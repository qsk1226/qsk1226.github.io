<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    代理模式 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            代理模式   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/04/28</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>#设计模式</a>
                                  
                                    <a class="tag is-link is-light" href='tag_%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>#结构型设计模式</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>

<p>在某些情况下，<strong><em>一个客户不想或者不能直接引用一个对象，又或者客户想要增强目标类的功能，但是又不能调整目标类的时候</em></strong>，可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p>

<p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p>

<p>代理模式可分为静态代理和动态代理，他们都提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>

<p>那么静态代理与动态代理的区别又是什么呢？</p>

<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是使用反射和字节码的技术，在运行期创建指定接口或类的子类以及其实力对象，并加载到JVM中</li>
</ul>

<h2 id="toc_0">静态代理</h2>

<h3 id="toc_1">静态态代理结构</h3>

<ul>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色
<figure><img src="media/15880844669175/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"/><figcaption>代理模式</figcaption></figure></li>
</ul>

<h3 id="toc_2">静态代理示例</h3>

<pre><code class="language-java">/**
 * 接口
 */
public interface IUserDao {

    void save();
}
/**
 * 接口实现
 * 目标对象
 */
public class UserDao implements IUserDao {
    public void save() {
        System.out.println(&quot;----已经保存数据!----&quot;);
    }
}
/**
 * 代理对象,静态代理
 */
public class UserDaoProxy implements IUserDao{
    //接收保存目标对象
    private IUserDao target;
    public UserDaoProxy(IUserDao target){
        this.target=target;
    }

    public void save() {
        System.out.println(&quot;开始事务...&quot;);
        target.save();//执行目标对象的方法
        System.out.println(&quot;提交事务...&quot;);
    }
}

/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        //目标对象
        UserDao target = new UserDao();

        //代理对象,把目标对象传给代理对象,建立代理关系
        UserDaoProxy proxy = new UserDaoProxy(target);

        proxy.save();//执行的是代理的方法
    }
}
</code></pre>

<h3 id="toc_3">静态代理总结:</h3>

<ul>
<li>可以做到在不修改目标对象的功能前提下,对目标功能扩展.</li>
<li>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</li>
</ul>

<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</p>

<h2 id="toc_4">动态代理技术实现主要方式</h2>

<h3 id="toc_5">JDK原生动态代理</h3>

<p>只能基于有接口代理对象进行代理</p>

<ul>
<li>Proxy: Proxy是所有动态代理的父类，它提供了一个静态方法来创建动态代理的class对象和实例。
<code>java
static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )
</code>
<ul>
<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入,每个动态代理实例都有一个关联的InvocationHandler。在代理实例上调用方法时，方法调用被转发到InvocationHandler的invoke方法。</li>
</ul></li>
</ul>

<pre><code class="language-java">public class DynamicProxyTest {

    interface IHello{
        void sayHello();
    }

    static class Hello implements IHello {
        @Override
        public void sayHello() {
            System.out.println(&quot;Hello world&quot;);
        }
    }

    static class DynamicProxy implements InvocationHandler {
        Object originalObj;
        Object bind(Object originalObj) {
            this.originalObj = originalObj;
            return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(&quot;welcom &quot;);
            return method.invoke(originalObj, args);
        }

    }


    public static void main(String[] args) {
        IHello iHello = (IHello) new DynamicProxy().bind(new Hello());
        iHello.sayHello();
    }
}
</code></pre>

<h3 id="toc_6">CGLIB动态代理</h3>

<p>CGLIB代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>

<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用CGLIB实现.</p>

<p>CGLIB是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)</p>

<p>CGLIB包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</p>

<ul>
<li>Enhancer: 来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor;</li>
<li>MethodInterceptor: 动态代理对象的方法调用都会转发到intercept方法进行增强。<br/>
MethodInterceptor实现了Callback接口，在 CGLIB 框架中 Callback 接口的实现可以理解为字节码的实现手段，共定义了 6 种实现方式，以适应不同场景的代理需求
<ul>
<li>MethodInterceptor</li>
<li>NoOp</li>
<li>LazyLoader</li>
<li>Dispatcher</li>
<li>InvocationHandler</li>
<li>FixedValue</li>
</ul></li>
</ul>

<h3 id="toc_7">CGLIB 代理示例</h3>

<pre><code class="language-java">public class ProxyFactory {
    /**
     * 产生代理对象
     *
     * @param targetClass       目标类
     * @param callbackFilter    回调增强方法的过滤器
     * @param methodInterceptor 回调增强方法
     * @return 代理对象
     */
    public static Object createProxy(Class&lt;?&gt; targetClass, CallbackFilter callbackFilter, MethodInterceptor... methodInterceptor) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(targetClass);
        enhancer.setUseCache(false);
        // 拦截器
        //enhancer.setCallbackFilter(callbackFilter);
        enhancer.setCallbacks(methodInterceptor);
        return enhancer.create();

    }
}

/**
 * 被代理对象
 */
public class HelloService {

    public void sayHello() {
        System.out.println(&quot;hello, Lily&quot;);
    }

    public void saySb(){
        System.out.println(&quot;Sb&quot;);
    }
    public void sayNinHao(){
        System.out.println(&quot;您好&quot;);
    }
}

/**
 * 抽象的增强的回调方法
 **/
public abstract class AbstractAdviceInterceptor implements MethodInterceptor {
    abstract void preExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    abstract void afterExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    public Object execute(MethodProxy proxy, Object object, Method method, Object[] args) {

        preExecute(proxy, object, method, args);
        Object result = null;
        try {
            result = proxy.invokeSuper(object, args);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        afterExecute(proxy, object, method, args);
        return result;
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        return execute(proxy, obj, method, args);
    }
}

/**
 * 代理对象的增强回调接口实现
 * MethodInterceptor可以作为类的回调增强，也能只增强当个方法
 */
public class HelloInterceptor extends AbstractAdviceInterceptor {

    @Override
    void preExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; pre operation:&quot;);
    }

    @Override
    void afterExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; after operation:&quot;);
        System.out.println(&quot;&quot;);
    }

}

public static void main(String[] args) {
    /*代理整个类*/
    HelloService proxy2 = (HelloService) ProxyFactory.createProxy(HelloService.class, null, new HelloInterceptor());
    proxy2.sayHello();
    proxy2.saySb();
    proxy2.sayNinHao();

}

</code></pre>

<h2 id="toc_8">使用场景</h2>

<p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p>

<ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
