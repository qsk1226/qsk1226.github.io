<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15882235745444.html">
                
                  <h1>CompletableFuture</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">概览</a>
</li>
<li>
<a href="#toc_1">创建CompletableFuture对象</a>
</li>
<li>
<a href="#toc_2">CompletableFuture 其它操作</a>
<ul>
<li>
<a href="#toc_3">whenComplete* 和 exceptionally 方法</a>
</li>
<li>
<a href="#toc_4">handle* 方法</a>
</li>
<li>
<a href="#toc_5">thenApply* 方法：连接</a>
</li>
<li>
<a href="#toc_6">thenAccept* 方法：纯消费一个CompletableFuture对象的结果</a>
</li>
<li>
<a href="#toc_7">thenAcceptBoth* 方法：在两个CompletableFuture对象的执行完后执行。</a>
</li>
<li>
<a href="#toc_8">thenRun* 方法：不消费CompletableFuture对象的结果，执行一个新任务。</a>
</li>
<li>
<a href="#toc_9">acceptEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它没有返回值。</a>
</li>
<li>
<a href="#toc_10">applyToEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它有返回值。</a>
</li>
<li>
<a href="#toc_11">辅助方法 ：allOf 和 anyOf</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">更进一步</a>
</li>
</ul>


<h2 id="toc_0">概览</h2>

<p>1、CompletableFuture是java8引入的新类，该类实现了 Future 接口和 CompletionStage 接口，封装了future、forkjoin相关类来执行异步，所以你还是可以像以前一样通过阻塞(get)或者轮询的方式获得结果，尽管这种方式不推荐使用。</p>

<p>2、CompletionStage 接口代表异步计算中的 不同阶段，以及如何 组合 这些计算阶段。</p>

<p>3、CompletableStage 接口中有 50 多个方法，可以对 CompletableStage 进行组合、计算，方法看似很多，但可以按功能对其分类，大多数方法都有 3 种变体：</p>

<ul>
<li>不带 Async 方法：同步方法</li>
<li>带 Async，只有一个参数：异步方法，使用默认的 ForkJoinPool.commonPool() 获取线程池</li>
<li>带 Async，有两个参数：异步方法，且使用第二个参数指定的 ExecutorService 线程池</li>
</ul>

<h2 id="toc_1">创建CompletableFuture对象</h2>

<pre><code class="language-text">//比较特殊，他入参就是返回值，也就是说他可以用来执行需要其他返回值的异步任务。
public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)

//无返回值，使用默认线程池
public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable)

//无返回值，使用自定义线程池
public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable, Executor executor)

//有返回值，使用默认线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier)

//有返回值，使用自定义线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)

//
public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)
</code></pre>

<p>举例：</p>

<pre><code class="language-text">//supplyAsync方法无入参，但是返回一个String对象。此方法使用了默认的线程池执行异步任务
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    //长时间的计算任务
    return &quot;·00&quot;;
});
</code></pre>

<h2 id="toc_2">CompletableFuture 其它操作</h2>

<p>下面将通过具体例子来展示各个方法的使用。</p>

<h3 id="toc_3">whenComplete* 和 exceptionally 方法</h3>

<p>当原始的CompletableFuture任务执行完后，不管是否成功计算出结果，还是抛出异常，都会会执行 whenComplete* 或 exceptionally 的方法中的任务。<br/>
该操作执行完毕后：</p>

<ul>
<li>会返回一个新的CompletableFuture对象！！！</li>
<li>使用whenComplete*方法时，返回的新的CompletableFuture对象的返回结果和原始的CompletableFuture对象计算结果相同</li>
<li>使用 exceptionally方法时，如果原始计算逻辑抛出异常，那么返回的 新的CompletableFuture对象 的返回结果由该方法的return值决定；如果原始计算逻辑没有抛出异常，那么返回的 新的CompletableFuture对象 的返回结果和原始计算逻辑返回的结果一致。有点绕，先不明白没关系，下面会有四个exceptionally实例解释这段话。</li>
</ul>

<pre><code class="language-text">BiConsumer&lt;T,U&gt; 函数接口有两个参数，无返回值。
Function&lt;T,R&gt; 函数接口有一个输入参数，返回一个结果。

//无Async，同步处理正常计算结果或异常，使用执行任务的那个线程来执行该方法，所以这个方法是同步的。
public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)
//有Async，异步处理正常计算结果或异常，使用执行任务的那个线程池中的线程来执行该方法！所以这个方法是异步的。
public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)
//有Async，异步处理正常计算结果或异常，使用自定义线程池来执行该方法，所以这个方法是异步的。
public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? superThrowable&gt; action, Executor executor)
//处理异常。
public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)
</code></pre>

<p>注意：当没有异常抛出来的时候，上面的Throwable参数为空！举例：</p>

<pre><code class="language-text">    private static Random random = new Random();
    private static long time = System.currentTimeMillis();

    public static int getMoreData(){
        System.out.println(&quot;begin to start compute&quot;);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(&quot;end to compute, passed:&quot; + System.currentTimeMillis());
        return random.nextInt(1000);
    }

    public static int throwException(){
        System.out.println(&quot;准备抛出异常&quot;);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(&quot;抛了&quot;);
        throw new RuntimeException(&quot;主动抛出异常&quot;);
    }
</code></pre>

<p>whenComplete：</p>

<pre><code class="language-text">    //如果使用这段代码，则会是和当前线程同步执行
    public static void main(String[] args) throws Exception{
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; getMoreData());

        CompletableFuture&lt;Integer&gt; future2 = future.whenComplete((result, excetion) -&gt; {
            System.out.println(&quot;执行到whenComplete了，result:&quot; + result);
            System.out.println(&quot;执行到whenComplete了，exception:&quot; + (excetion == null ? &quot;无异常&quot; : excetion.getClass()));
        });
        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    }

&gt; 打印执行结果：  
begin to start compute  
end to compute, passed:1551182552193  
执行到whenComplete了，result:625  
执行到whenComplete了，exception:无异常  
执行到最后一段代码了，future result：625  
执行到最后一段代码了，future2 result：625  

&gt;从打印结果可知，whenComplete使用原始的执行的任务的线程，所以可以看成是同步执行的，并且新的CompletableFuture对象的结果和原始的一致
</code></pre>

<p>whenCompleteAsync：</p>

<pre><code class="language-text">    //如果使用这段代码，则会是和当前线程同步执行
    public static void main(String[] args) throws Exception{
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; getMoreData());

        future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (excetion == null ? &quot;无异常&quot; : excetion.getClass()));
        });
        System.out.println(&quot;执行到最后一段代码了，result：&quot; + future.get());
    }

&gt; 打印执行结果：  
begin to start compute  
end to compute, passed:1551180611064  
执行到最后一段代码了，result：323  
执行到whenComplete了，result:323  
执行到whenComplete了，exception:无异常  

&gt;从打印结果可知，whenCompleteAsync是异步执行的
</code></pre>

<p>exceptionally比较复杂，需要通过4个实例才能真正明白：<br/>
exceptionally实例1：</p>

<pre><code class="language-text">    //这段代码，由于会抛出异常，会先走whenCompleteAsync，然后再走exceptionally，而且是无法获取到返回值的。
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        }).exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            return 0;
        });

       System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: 主动抛出异常
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
    at me.ele.ecs.eapp.service.impl.Main.main(Main.java:69)
Caused by: java.lang.RuntimeException: 主动抛出异常
    at me.ele.ecs.eapp.service.impl.Main.throwException(Main.java:37)
    at me.ele.ecs.eapp.service.impl.Main.lambda$main$0(Main.java:44)
</code></pre>

<p>exceptionally实例2：</p>

<pre><code class="language-text">    //这里的打印结果是和上面类似的，可是为什么这次要获取新的CompletableFuture对象呢？看下面的exceptionally实例3后，再回来对比吧
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        });

        CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            return 0;
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
       //因为上面的执行过程中，已经抛出了异常了，那么下面的这两段代码是无法执行到的，
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
        System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: 主动抛出异常
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
    at me.ele.ecs.eapp.service.impl.Main.main(Main.java:69)
Caused by: java.lang.RuntimeException: 主动抛出异常
    at me.ele.ecs.eapp.service.impl.Main.throwException(Main.java:37)
    at me.ele.ecs.eapp.service.impl.Main.lambda$main$0(Main.java:44)
</code></pre>

<p>exceptionally实例3：</p>

<pre><code class="language-text">    //
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        });

        CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            //这里的返回值实际其是没有用处的。因为如果抛出了异常，future的get方法是执行不到的；而如果没有抛出异常的话，还是会返回原始的CompletableFuture的值的
            //所以这个exceptionally就是仅仅用来处理异常的。
            return 0;
        });

        //System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        //System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
        //和上面实例2唯一的区别就是注释掉了上面两段代码，但是执行结果却不一样了，而且整个main方法都没有抛出来异常，原因就在于future和future2是异步执行的，所以是在别的线程抛了异常，而main方法是不会抛出来的。而且在获取future3的结果时，可以发现，返回了future3对象自定义的返回值
        System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
执行到最后一段代码了，future3 result：0
</code></pre>

<p>exceptionally实例4：</p>

<pre><code class="language-text">public static void main(String[] args) throws Exception{

    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

    CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
        System.out.println(&quot;计算已执行完毕，result:&quot; + result);
        System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
    });

    CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
        System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
        return 0;
    });

    System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
    System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    //原始的计算逻辑不变，exceptionally返回的新的CompletableFuture对象的结果和原始计算逻辑返回的结果一致。
    System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
}
</code></pre>

<blockquote>
<p>打印执行结果：<br/><br/>
begin to start compute<br/>
end to compute, passed:1551239497158<br/>
getMoreData: 679<br/>
执行到最后一段代码了，future result：679<br/>
计算已执行完毕，result:679<br/>
计算已执行完毕，exception:无异常<br/>
执行到最后一段代码了，future2 result：679<br/>
执行到最后一段代码了，future3 result：679</p>

<pre><code class="language-text"></code></pre>
</blockquote>

<h3 id="toc_4">handle* 方法</h3>

<p>和 whenComplete* 方法一样，都是在任务执行完后，执行该方法的逻辑，但是和 whenComplete* 不同的是：<br/>
该操作执行完毕后，它返回的新CompletableFuture对象的计算结果是handle*方法的返回值，并不是原始计算逻辑的返回值</p>

<pre><code class="language-java">//同步
public &lt;U&gt; CompletableFuture&lt;U&gt;     handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
//异步，使用原始CompletableFuture的线程
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
//异步，使用自定义线程池的线程
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)
</code></pre>

<p>代码实例：</p>

<pre><code class="language-java">    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Integer&gt; future2 = future.handleAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
            return result + 1;
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    }

&gt; 打印执行结果：  
begin to start compute
end to compute, passed:1551243326193
getMoreData: 395
执行到最后一段代码了，future result：395
计算已执行完毕，result:395
计算已执行完毕，exception:无异常
执行到最后一段代码了，future2 result：396
</code></pre>

<h3 id="toc_5">thenApply* 方法：连接</h3>

<p>thenApply* 可以连接多个CompletableFuture对象，相当于将一个一个的CompletableFuture串联起来了，第一个CompletableFuture对象的结果会传递到下一个对象中，并且下一个CompletableFuture对象的结算结果会作为上一个对象的CompletableFuture结果，依次类推，也就是说会改变原始CompletableFuture对象的结果。<br/>
注：它和 handle 方法有点类似，都会拿到上一个CompletableFuture对象的结果进行计算，但是区别就是thenApply 会改变原始对象的计算结果，而 handle* 并不会**。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApply(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)
复制代码public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        return 100;
        });
       //由于这里同时连接了多个thenApplyAsync，第一个是异步的，第二个是同步的，并且都没有处理异常，所以异常会直接在执行计算的线程上抛出来。
       CompletableFuture&lt;String&gt; f =  future.thenApplyAsync(i -&gt; i * 10).thenApply(i -&gt; i.toString());
       System.out.println(f.get()); //&quot;1000&quot;
}
</code></pre>

<h3 id="toc_6">thenAccept* 方法：纯消费一个CompletableFuture对象的结果</h3>

<p>thenAccept* 返回的新的CompletableFuture对象不返回结果，如果使用get方法，会返回一个null。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  thenAccept(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)
</code></pre>

<pre><code class="language-text">public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Void&gt; future2 = future.thenAccept(result -&gt; {
            System.out.println(&quot;执行到thenAccept了, result：&quot; + result);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result: &quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
end to compute, passed:1551341977684
getMoreData: 171
执行到thenAccept了, result：171
执行到最后一段代码了，future result：171
执行到最后一段代码了，future2 result: null
</code></pre>

<h3 id="toc_7">thenAcceptBoth* 方法：在两个CompletableFuture对象的执行完后执行。</h3>

<p>它和 thenAccept 一样，都是纯消费，但是thenAccept<em>只能消费一个CompletableFuture对象，而thenAcceptBoth</em> 能在两个不同的CompletableFuture对象执行完成后，消费他们两个的计算结果。<br/>
而且他仅仅在原始的两个CompletableFuture对象都计算成功之后，才开始执行。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)
public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)
public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)

//runAfterBoth和上面三个的区别就是它不消费原始的CompletableFuture结果
public     CompletableFuture&lt;Void&gt;  runAfterBoth(CompletionStage&lt;?&gt; other,  Runnable action)
</code></pre>

<pre><code class="language-java">
public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(Main::getMoreData);

        future.thenAcceptBothAsync(future2, (x, y) -&gt; {
            System.out.println(&quot;future1 和 future都执行完成了，结果分别是：&quot; + x + &quot;,&quot; + y);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result: &quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
begin to start compute
end to compute, passed:1551342475808
getMoreData: 920
执行到最后一段代码了，future result：920
end to compute, passed:1551342475811
getMoreData: 747
执行到最后一段代码了，future2 result: 747
future1 和 future都执行完成了，结果分别是：920,747
</code></pre>

<h3 id="toc_8">thenRun* 方法：不消费CompletableFuture对象的结果，执行一个新任务。</h3>

<p>在原始CompletableFuture执行任务结束后，而且执行指定的任务，不消费，也不产生结果。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  thenRun(Runnable action)
public CompletableFuture&lt;Void&gt;  thenRunAsync(Runnable action)
public CompletableFuture&lt;Void&gt;  thenRunAsync(Runnable action, Executor executor)
复制代码public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Void&gt; future2 = future.thenRunAsync(() -&gt; {
            System.out.println(&quot;future执行完成了&quot;);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
end to compute, passed:1551344347162
getMoreData: 688
执行到最后一段代码了，future result：688
future执行完成了
执行到最后一段代码了，future2 result：null
</code></pre>

<h3 id="toc_9">acceptEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它没有返回值。</h3>

<p>runAfterBoth是当两个CompletableFuture都计算完成后才执行。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)
</code></pre>

<h3 id="toc_10">applyToEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它有返回值。</h3>

<p>runAfterBoth是当两个CompletableFuture都计算完成后才执行。而 acceptEither* 没有返回值。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)
</code></pre>

<h3 id="toc_11">辅助方法 ：allOf 和 anyOf</h3>

<pre><code class="language-java">// allOf方法是当所有的CompletableFuture都执行完后执行计算。
public static CompletableFuture&lt;Void&gt;       allOf(CompletableFuture&lt;?&gt;... cfs)
//anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。
public static CompletableFuture&lt;Object&gt;     anyOf(CompletableFuture&lt;?&gt;... cfs)
</code></pre>

<p>示例：</p>

<pre><code class="language-java">Random rand = new Random();
CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {
    try {
        Thread.sleep(10000 + rand.nextInt(1000));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return 100;
});
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {
    try {
        Thread.sleep(10000 + rand.nextInt(1000));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return &quot;abc&quot;;
});
//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);
CompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);
System.out.println(f.get());
</code></pre>

<h2 id="toc_12">更进一步</h2>

<p>如果你用过Guava的Future类，你就会知道它的Futures辅助类提供了很多便利方法，用来处理多个Future，而不像Java的CompletableFuture，只提供了allOf、anyOf两个方法。 比如有这样一个需求，将多个CompletableFuture组合成一个CompletableFuture，这个组合后的CompletableFuture的计算结果是个List,它包含前面所有的CompletableFuture的计算结果，guava的Futures.allAsList可以实现这样的功能，但是对于java CompletableFuture，我们需要一些辅助方法：</p>

<pre><code class="language-java">   public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) {
       CompletableFuture&lt;Void&gt; allDoneFuture = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));
       return allDoneFuture.thenApply(v -&gt; futures.stream().map(CompletableFuture::join).collect(Collectors.&lt;T&gt;toList()));
   }
public static &lt;T&gt; CompletableFuture&lt;Stream&lt;T&gt;&gt; sequence(Stream&lt;CompletableFuture&lt;T&gt;&gt; futures) {
       List&lt;CompletableFuture&lt;T&gt;&gt; futureList = futures.filter(f -&gt; f != null).collect(Collectors.toList());
       return sequence(futureList);
   }
</code></pre>

<p>Java Future转CompletableFuture:</p>

<pre><code class="language-java">public static &lt;T&gt; CompletableFuture&lt;T&gt; toCompletable(Future&lt;T&gt; future, Executor executor) {
    return CompletableFuture.supplyAsync(() -&gt; {
        try {
            return future.get();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }, executor);
}
</code></pre>

<p>转载掘金文章: <a href="https://juejin.im/post/5c77b3ade51d456a045898c8">java8 CompletableFuture入门 使用教程 详解所有方法 附实例</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15880844669175.html">
                
                  <h1>代理模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>

<p>在某些情况下，<strong><em>一个客户不想或者不能直接引用一个对象，又或者客户想要增强目标类的功能，但是又不能调整目标类的时候</em></strong>，可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p>

<p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p>

<p>代理模式可分为静态代理和动态代理，他们都提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>

<p>那么静态代理与动态代理的区别又是什么呢？</p>

<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是使用反射和字节码的技术，在运行期创建指定接口或类的子类以及其实力对象，并加载到JVM中</li>
</ul>

<h2 id="toc_0">静态代理</h2>

<h3 id="toc_1">静态态代理结构</h3>

<ul>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色
<figure><img src="media/15880844669175/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"/><figcaption>代理模式</figcaption></figure></li>
</ul>

<h3 id="toc_2">静态代理示例</h3>

<pre><code class="language-java">/**
 * 接口
 */
public interface IUserDao {

    void save();
}
/**
 * 接口实现
 * 目标对象
 */
public class UserDao implements IUserDao {
    public void save() {
        System.out.println(&quot;----已经保存数据!----&quot;);
    }
}
/**
 * 代理对象,静态代理
 */
public class UserDaoProxy implements IUserDao{
    //接收保存目标对象
    private IUserDao target;
    public UserDaoProxy(IUserDao target){
        this.target=target;
    }

    public void save() {
        System.out.println(&quot;开始事务...&quot;);
        target.save();//执行目标对象的方法
        System.out.println(&quot;提交事务...&quot;);
    }
}

/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        //目标对象
        UserDao target = new UserDao();

        //代理对象,把目标对象传给代理对象,建立代理关系
        UserDaoProxy proxy = new UserDaoProxy(target);

        proxy.save();//执行的是代理的方法
    }
}
</code></pre>

<h3 id="toc_3">静态代理总结:</h3>

<ul>
<li>可以做到在不修改目标对象的功能前提下,对目标功能扩展.</li>
<li>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</li>
</ul>

<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</p>

<h2 id="toc_4">动态代理技术实现主要方式</h2>

<h3 id="toc_5">JDK原生动态代理</h3>

<p>只能基于有接口代理对象进行代理</p>

<ul>
<li>Proxy: Proxy是所有动态代理的父类，它提供了一个静态方法来创建动态代理的class对象和实例。
<code>java
static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )
</code>
<ul>
<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入,每个动态代理实例都有一个关联的InvocationHandler。在代理实例上调用方法时，方法调用被转发到InvocationHandler的invoke方法。</li>
</ul></li>
</ul>

<pre><code class="language-java">public class DynamicProxyTest {

    interface IHello{
        void sayHello();
    }

    static class Hello implements IHello {
        @Override
        public void sayHello() {
            System.out.println(&quot;Hello world&quot;);
        }
    }

    static class DynamicProxy implements InvocationHandler {
        Object originalObj;
        Object bind(Object originalObj) {
            this.originalObj = originalObj;
            return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(&quot;welcom &quot;);
            return method.invoke(originalObj, args);
        }

    }


    public static void main(String[] args) {
        IHello iHello = (IHello) new DynamicProxy().bind(new Hello());
        iHello.sayHello();
    }
}
</code></pre>

<h3 id="toc_6">CGLIB动态代理</h3>

<p>CGLIB代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>

<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用CGLIB实现.</p>

<p>CGLIB是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)</p>

<p>CGLIB包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</p>

<ul>
<li>Enhancer: 来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor;</li>
<li>MethodInterceptor: 动态代理对象的方法调用都会转发到intercept方法进行增强。</li>
</ul>

<pre><code class="language-java">public class ProxyFactory {
    /**
     * 产生代理对象
     *
     * @param targetClass       目标类
     * @param callbackFilter    回调增强方法的过滤器
     * @param methodInterceptor 回调增强方法
     * @return 代理对象
     */
    public static Object createProxy(Class&lt;?&gt; targetClass, CallbackFilter callbackFilter, MethodInterceptor... methodInterceptor) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(targetClass);
        enhancer.setUseCache(false);
        // 拦截器
        //enhancer.setCallbackFilter(callbackFilter);
        enhancer.setCallbacks(methodInterceptor);
        return enhancer.create();

    }
}

/**
 * 被代理对象
 */
public class HelloService {

    public void sayHello() {
        System.out.println(&quot;hello, Lily&quot;);
    }

    public void saySb(){
        System.out.println(&quot;Sb&quot;);
    }
    public void sayNinHao(){
        System.out.println(&quot;您好&quot;);
    }
}

/**
 * 抽象的增强的回调方法
 **/
public abstract class AbstractAdviceInterceptor implements MethodInterceptor {
    abstract void preExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    abstract void afterExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    public Object execute(MethodProxy proxy, Object object, Method method, Object[] args) {

        preExecute(proxy, object, method, args);
        Object result = null;
        try {
            result = proxy.invokeSuper(object, args);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        afterExecute(proxy, object, method, args);
        return result;
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        return execute(proxy, obj, method, args);
    }
}

/**
 * 代理对象的增强回调接口实现
 * MethodInterceptor可以作为类的回调增强，也能只增强当个方法
 */
public class HelloInterceptor extends AbstractAdviceInterceptor {

    @Override
    void preExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; pre operation:&quot;);
    }

    @Override
    void afterExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; after operation:&quot;);
        System.out.println(&quot;&quot;);
    }

}

public static void main(String[] args) {
    /*代理整个类*/
    HelloService proxy2 = (HelloService) ProxyFactory.createProxy(HelloService.class, null, new HelloInterceptor());
    proxy2.sayHello();
    proxy2.saySb();
    proxy2.sayNinHao();

}

</code></pre>

<h2 id="toc_7">使用场景</h2>

<p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p>

<ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15880496547017.html">
                
                  <h1>细说Reactor模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概念</h2>

<p>reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，其他框架都或多或少地用到了Reactor框架。 </p>

<p>在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 </p>

<p>reactor模式与外观模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>

<h2 id="toc_1">优点</h2>

<p>  1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的； <br/>
  2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； <br/>
  3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； <br/>
  4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>

<h2 id="toc_2">缺点</h2>

<p> 1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 <br/>
 2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 <br/>
 3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。<br/>
 </p>

<h2 id="toc_3">架构模式</h2>

<h3 id="toc_4">1、架构图</h3>

<p> <figure><img src="media/15586898110083/15590230630201.jpg" alt="" style="width:556px;"/></figure></p>

<h3 id="toc_5">2、构成</h3>

<p>Handles ：表示操作系统管理的资源，我们可以理解为fd。</p>

<p>Synchronous Event Demultiplexer ：同步事件分离器，阻塞等待Handles中的事件发生。</p>

<p>Initiation Dispatcher ：初始分派器，作用为添加Event handler（事件处理器）、删除Event handler以及分派事件给Event handler。也就是说，Synchronous Event Demultiplexer负责等待新事件发生，事件发生时通知Initiation Dispatcher，然后Initiation Dispatcher调用event handler处理事件。</p>

<p>Event Handler ：事件处理器的接口<br/>
Concrete Event Handler ：事件处理器的实际实现，而且绑定了一个Handle。因为在实际情况中，我们往往不止一种事件处理器，因此这里将事件处理器接口和实现分开，与C++、Java这些高级语言中的多态类似。</p>

<h3 id="toc_6">3、模块交互</h3>

<p> 1）我们注册Concrete Event Handler到Initiation Dispatcher中。 <br/>
 2）Initiation Dispatcher调用每个Event Handler的get_handle接口获取其绑定的Handle。 <br/>
 3）Initiation Dispatcher调用handle_events开始事件处理循环。在这里，Initiation Dispatcher会将步骤2获取的所有Handle都收集起来，使用Synchronous Event Demultiplexer来等待这些Handle的事件发生。 <br/>
 4）当某个（或某几个）Handle的事件发生时，Synchronous Event Demultiplexer通知Initiation Dispatcher。 <br/>
 5）Initiation Dispatcher根据发生事件的Handle找出所对应的Handler。 <br/>
 6）Initiation Dispatcher调用Handler的handle_event方法处理事件。</p>

<pre><code class="language-text">import java.io.IOException;  
import java.net.InetAddress;  
import java.net.InetSocketAddress;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.ServerSocketChannel;  
import java.util.Iterator;  
import java.util.Set;  

/** 
 * 反应器模式 
 * 用于解决多用户访问并发问题 
 *  
 * 举个例子：餐厅服务问题 
 *  
 * 传统线程池做法：来一个客人(请求)去一个服务员(线程) 
 * 反应器模式做法：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员” 
 *  
 * @author linxcool 
 */  
public class Reactor implements Runnable{  
    public final Selector selector;  
    public final ServerSocketChannel serverSocketChannel;  

    public Reactor(int port) throws IOException{  
        selector=Selector.open();  
        serverSocketChannel=ServerSocketChannel.open();  
        InetSocketAddress inetSocketAddress=new InetSocketAddress(InetAddress.getLocalHost(),port);  
        serverSocketChannel.socket().bind(inetSocketAddress);  
        serverSocketChannel.configureBlocking(false);  

        //向selector注册该channel    
        SelectionKey selectionKey=serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  

        //利用selectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor   
        selectionKey.attach(new Acceptor(this));  
    }  

    @Override  
    public void run() {  
        try {  
            while(!Thread.interrupted()){  
                selector.select();  
                Set&lt;SelectionKey&gt; selectionKeys= selector.selectedKeys();  
                Iterator&lt;SelectionKey&gt; it=selectionKeys.iterator();  
                //Selector如果发现channel有OP_ACCEPT或READ事件发生，下列遍历就会进行。  
                while(it.hasNext()){  
                    //来一个事件 第一次触发一个accepter线程    
                    //以后触发SocketReadHandler  
                    SelectionKey selectionKey=it.next();  
                    dispatch(selectionKey);  
                    selectionKeys.clear();  
                }  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 运行Acceptor或SocketReadHandler 
     * @param key 
     */  
    void dispatch(SelectionKey key) {  
        Runnable r = (Runnable)(key.attachment());    
        if (r != null){    
            r.run();  
        }    
    }    

} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.channels.SocketChannel;  

public class Acceptor implements Runnable{  
    private Reactor reactor;  
    public Acceptor(Reactor reactor){  
        this.reactor=reactor;  
    }  
    @Override  
    public void run() {  
        try {  
            SocketChannel socketChannel=reactor.serverSocketChannel.accept();  
            if(socketChannel!=null)//调用Handler来处理channel  
                new SocketReadHandler(reactor.selector, socketChannel);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.ByteBuffer;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.SocketChannel;  

public class SocketReadHandler implements Runnable{  
    private SocketChannel socketChannel;  
    public SocketReadHandler(Selector selector,SocketChannel socketChannel) throws IOException{  
        this.socketChannel=socketChannel;  
        socketChannel.configureBlocking(false);  

        SelectionKey selectionKey=socketChannel.register(selector, 0);  

        //将SelectionKey绑定为本Handler 下一步有事件触发时，将调用本类的run方法。    
        //参看dispatch(SelectionKey key)    
        selectionKey.attach(this);  

        //同时将SelectionKey标记为可读，以便读取。    
        selectionKey.interestOps(SelectionKey.OP_READ);    
        selector.wakeup();  
    }  

    /** 
     * 处理读取数据 
     */  
    @Override  
    public void run() {  
        ByteBuffer inputBuffer=ByteBuffer.allocate(1024);  
        inputBuffer.clear();  
        try {  
            socketChannel.read(inputBuffer);  
            //激活线程池 处理这些request  
            //requestHandle(new Request(socket,btt));   
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
</code></pre>

<h2 id="toc_7">总结</h2>

<p>reactor模式是javaNIO非堵塞技术的实现原理，我们不仅要知道其原理流程，还要知道其代码实现，当然这个reactor模式不仅仅在NIO中实现，而且在redies等其他地方也出现过，说明这个模式还是比较实用的，尤其是在多线程高并发的情况下使用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15878284668401.html">
                
                  <h1>线程池</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>为什么要用线程池?<br/>
Java 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行 任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来 3 个好处。</p>

<ul>
<li>第一:降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二:提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立 即执行。</li>
<li>第三:提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>

<h2 id="toc_0">线程池的简单实现</h2>

<pre><code class="language-java">public class MyThreadPool {
    // 任务队列
    private static BlockingQueue&lt;Runnable&gt; taskBlockingQueue;

    private Worker[] workers;

    public MyThreadPool(int taskCount, int workerCount) {
        if (taskCount &lt;=0 || workerCount &lt;=0)
            throw new IllegalArgumentException();
        taskBlockingQueue = new ArrayBlockingQueue&lt;&gt;(taskCount);
        initWorker(workerCount);
    }
    
    /*初始化线程池*/
    private void initWorker(int workerCount) {
        this.workers = new Worker[workerCount];
        for (int i = 0; i &lt; workerCount; i++) {
            Worker worker = new Worker();
            workers[i] = worker;
            workers[i].start();
        }
    }

    public void execute(Runnable task) {
        try {
            taskBlockingQueue.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    public void destroy() {
        for (Worker worker : workers) {
            worker.shutdown();
        }
        workers = null;
    }

    // 工作线程
    private final class Worker extends Thread {
        @Override
        public void run() {
            Runnable task = null;
            while (!isInterrupted()) {
                try {
                    task = taskBlockingQueue.take();
                } catch (InterruptedException e) {
                    // something
                }
                if (task != null) {
                    task.run();
                }
            }
        }

        public void shutdown() {
            interrupt();
        }
    }

}
</code></pre>

<h2 id="toc_1">jdk的线程池</h2>

<pre><code class="language-text">Executor
|----ThreadPerTaskExecutor in CompletableFuture
|----ExecutorService 
|--------AbstractExecutorService
|------------ThreadPoolExecutor
|----------------ScheduledThreadPoolExecutor
|------------ForkJoinPool (java.util.concurrent)
|------------DelegatedExecutorService in Executors 
|----------------FinalizableDelegatedExecutorService in Executors 
|----------------DelegatedScheduledExecutorService in Executors 
|--------ScheduledExecutorService
|------------ScheduledThreadPoolExecutor
|------------DelegatedScheduledExecutorService in Executors 
</code></pre>

<p>Executor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的<br/>
执行分离开来。</p>

<p>ExecutorService 接口继承了 Executor，在其上做了一些 shutdown()、submit() 的扩展，可以说是真正的线程池接口;</p>

<p>AbstractExecutorService 抽象类实现了 ExecutorService 接口中的大部分方法;</p>

<p>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。</p>

<p>ScheduledExecutorService 接口继承了 ExecutorService 接口，提供了带&quot;周期 执行&quot;功能 ExecutorService;</p>

<p>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令， 或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大</p>

<hr/>

<h3 id="toc_2">ThreadPoolExecutor类的构造函数</h3>

<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
</code></pre>

<p>参数说明：</p>

<ul>
<li><p>corePoolSize<br/>
线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize;<br/>
如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行;<br/>
如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p></li>
<li><p>maximumPoolSize<br/>
线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则 创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize</p></li>
<li><p>keepAliveTime<br/>
线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于 corePoolSize 时才有用</p></li>
<li><p>TimeUnit<br/>
keepAliveTime 的时间单位 workQueue</p></li>
<li><p>workQueue<br/>
workQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能。</p></li>
</ul>

<p>用于保存等待执行的任务的阻塞队列，一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：<br/>
    - 当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待， 因此线程池中的线程数不会超过 corePoolSize。<br/>
    - 使用无界队列时 maximumPoolSize 将是一个无效参数。<br/>
    - 使用无界队列时 keepAliveTime 将是一个无效参数。<br/>
    - 更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防 止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。<br/>
所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、 SynchronousQueue、PriorityBlockingQueue。</p>

<ul>
<li><p>ThreadFactory<br/>
新线程使用ThreadFactory创建。如果没有另外指定，则使用Executors.defaultThreadFactory()。通过提供不同的ThreadFactory，您可以更改线程的名称，线程组，优先级，守护进程状态等。</p></li>
<li><p>RejectedExecutionHandler<br/>
提供了四个预定义的处理程序策略：</p>
<ul>
<li>在默认ThreadPoolExecutor.AbortPolicy ，处理程序会引发运行RejectedExecutionException后排斥反应。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy中，调用execute本身的线程运行任务。 这提供了一个简单的反馈控制机制，将降低新任务提交的速度。</li>
<li>ThreadPoolExecutor.DiscardPolicy中 ，直接丢弃任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy中   丢弃阻塞队列中靠最前的任务，并执行当前任务。<br/>
可以定义和使用其他类型的RejectedExecutionHandler类。 这样做需要特别注意，特别是当策略被设计为仅在特定容量或排队策略下工作时。</li>
</ul></li>
</ul>

<hr/>

<h3 id="toc_3">扩展ThreadPoolExecutor</h3>

<p>该类提供了在每个任务执行之前和之后调用的protected可悲子类覆写的beforeExecute(Thread, Runnable)和afterExecute(Runnable, Throwable)方法。 这些可以用来操纵执行环境; 例如，重新初始化ThreadLocals，收集统计信息或添加日志条目。 另外，方法terminated()可以被覆盖，以执行执行程序完全终止后需要执行的任何特殊处理。</p>

<pre><code class="language-java">public class PausableThreadPoolExecutor extends ThreadPoolExecutor {
    private boolean isPaused;
    private ReentrantLock pauseLock = new ReentrantLock();

    private Condition unpaused = pauseLock.newCondition();

    public PausableThreadPoolExecutor(int corePoolSize,
                                      int maximumPoolSize,
                                      long keepAliveTime,
                                      TimeUnit unit,
                                      BlockingQueue&lt;Runnable&gt; workQueue,
                                      ThreadFactory threadFactory,
                                      RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        pauseLock.lock();
        try {
            while (isPaused) unpaused.await();
        } catch (InterruptedException ie) {
            t.interrupt();
        } finally {
            pauseLock.unlock();
        }
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        if (t != null) System.out.println(t);
    }


    public void pause() {
        pauseLock.lock();
        try {
            isPaused = true;
        } finally {
            pauseLock.unlock();
        }
    }

    public void resume() {
        pauseLock.lock();
        try {
            isPaused = false;
            unpaused.signalAll();
        } finally {
            pauseLock.unlock();
        }
    }

}
</code></pre>

<hr/>

<h2 id="toc_4">线程池的工作机制</h2>

<ol>
<li>如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务(注意， 执行这一步骤需要获取全局锁)。</li>
<li>如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。 </li>
<li>如果无法将任务加入 BlockingQueue(队列已满)，则创建新的线程来处理任务。</li>
<li>如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>

<h3 id="toc_5">提交任务</h3>

<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程 池执行成功。</p>

<p>submit()方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get (long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>

<h3 id="toc_6">关闭线程池</h3>

<p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池。它们 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断 线程，所以无法响应中断的任务可能永远无法终止。</p>

<p>但是它们存在一定的区别， shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行 或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的 状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程</p>

<h2 id="toc_7">如何合理使用线程池</h2>

<p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>

<ul>
<li>任务的性质:CPU 密集型任务、IO 密集型任务和混合型任务。 •任务的优先级:高、中和低。</li>
<li>任务的执行时间:长、中和短。 </li>
<li>任务的依赖性:是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。</li>
</ul>

<p>CPU 密集型任务应配置尽可能小的线程，如配置 Ncpu+1 个线程的线程池。 </p>

<p>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2*Ncpu。</p>

<p>混合型的任务，如果可以拆分，将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行 分解。</p>

<p>可以通过 Runtime.getRuntime().availableProcessors()方法获得当前设备的 CPU 个数。</p>

<p>对于 IO 型的任务的最佳线程数，有个公式可以计算 ：<br/>
Nthreads = NCPU * UCPU * (1 + W/C)</p>

<p>其中:<br/>
NCPU 是处理器的核的数目<br/>
UCPU 是期望的 CPU 利用率(该值应该介于 0 和 1 之间)<br/>
W/C 是等待时间与计算时间的比率</p>

<p>等待时间与计算时间我们在 Linux 下使用相关的 vmstat 命令或者 top 命令查看。</p>

<p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先执行。</p>

<p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果， 等待的时间越长，则 CPU 空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用 CPU。</p>

<p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设的大一点儿。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15878230274351.html">
                
                  <h1>阻塞队列</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>

<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。 因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能 最先从队列中删除，故队列又称为先进先出(FIFO—first in first out)线性表。</p>

<h2 id="toc_0">什么是阻塞队列</h2>

<p>1)支持阻塞的插入方法: 意思是当队列满时，队列会阻塞插入元素的线程， 直到队列不满。<br/>
2)支持阻塞的移除方法: 意思是在队列为空时，获取元素的线程会等待队 列变为非空。</p>

<p>BlockingQueue不接受null元素, 其实现被设计为主要用于生产者 - 消费者队列。消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用 来获取元素的容器。</p>

<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p>

<p>如下生产者消费模式：</p>

<pre><code class="language-java">class Producer implements Runnable {
    private final BlockingQueue queue;

    Producer(BlockingQueue q) {
        queue = q;
    }

    public void run() {
        try {
            while (true) {
                queue.put(produce());
            }
        } catch (InterruptedException ex) { 
            //...handle ...
        }
    }

    Object produce() { 
        // 生产...
    }
}

class Consumer implements Runnable {
    private final BlockingQueue queue;

    Consumer(BlockingQueue q) {
        queue = q;
    }

    public void run() {
        try {
            while (true) {
                consume(queue.take());
            }
        } catch (InterruptedException ex) { ...handle ...}
    }

    void consume(Object x) { 
        // do something...
    }
}
</code></pre>

<hr/>

<h2 id="toc_1">阻塞队列的操作</h2>

<p>BlockingQueue 方法有四种形式，具有不同的操作方式，不能立即满足，但可能在将来的某个时间点满足的方法:</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>

<tbody>
<tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>pull(time,unit)</td>
</tr>
<tr>
<td>检索方法</td>
<td>element()</td>
<td>peek()</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>

<ul>
<li><p>抛出异常<br/>
IllegalStateException - 如果由于容量限制，此时无法添加该元素<br/>
ClassCastException - 由于类型转换异常，无法添加元素<br/>
NullPointerException - 如果指定的元素为null<br/>
IllegalArgumentException - 如果指定元素的某些属性阻止将其添加到此队列中</p></li>
<li><p>返回特殊值:当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。</p></li>
<li><p>一直阻塞:当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会 一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费 者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。</p></li>
<li><p>超时退出:当阻塞队列满时，如果生产者线程往队列里插入元素，队列会 阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p></li>
</ul>

<hr/>

<p>BlockingQueue实现是线程安全的。 所有排队方法使用内部锁或其他形式的并发控制在原子上实现其效果.</p>

<h2 id="toc_2">常用阻塞队列</h2>

<ul>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。 </li>
<li>LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。 </li>
<li>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列。 </li>
<li>DelayQueue:一个使用优先级队列实现的无界阻塞队列。 </li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。 </li>
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。 </li>
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。 <br/>
以上的阻塞队列都实现了 BlockingQueue 接口，也都是线程安全的。</li>
</ul>

<h3 id="toc_3">Array 实现和 Linked 实现的区别</h3>

<ol>
<li>队列中锁的实现不同<br/>
ArrayBlockingQueue 实现的队列中的锁是没有分离的，即生产和消费用的是 同一个锁;<br/>
LinkedBlockingQueue 实现的队列中的锁是分离的，即生产用的是 putLock， 消费是 takeLock</li>
<li>在生产或消费时操作不同<br/>
ArrayBlockingQueue 实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的;<br/>
LinkedBlockingQueue 实现的队列中在生产和消费的时候，需要把枚举对象转换为 Node<E>进行插入或移除，会影响性能 </li>
<li>队列大小初始化方式不同<br/>
ArrayBlockingQueue 实现的队列中必须指定队列的大小; LinkedBlockingQueue 实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE<br/>
### DelayQueue<br/>
是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。 队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中 获取当前元素。只有在延迟期满时才能从队列中提取元素。</li>
</ol>

<p>可以将 DelayQueue 运用在以下应用场景:<br/>
缓存系统的设计:可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。还有订单到期，限时支付等等</p>

<h3 id="toc_4">SynchronousQueue</h3>

<p>本身不存储任何元素，每一个put操作必须等待一个take操作，将消息从生产者直接传递到消费者。</p>

<h3 id="toc_5">LinkedBlockingDeque</h3>

<p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列。所谓双向队列 指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入 口，在多线程同时入队时，也就减少了一半的竞争。多了 addFirst、addLast、offerFirst、offerLast、peekFirst 和 peekLast 等方法。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_8.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_10.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
