<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    Mysql 查询语句优化 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            Mysql 查询语句优化   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/09/14</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='mysql.html'>mysql</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>在分析如何优化 MySQL 查询语句之前，我们需要先了解一下查询语句优化的基本思路和原则。一般来说，查询语句的优化思路和原则主要提现在以下几个方面：</p>

<ul>
<li><p>优化更需要优化的查询；<br/>
一般来说，高并发低消耗的语句回避地并发高消耗的语句对系统的影响要大的多，因为优化高并发下的查询语句一旦有问题，可能使整个系统崩溃掉，而低并发的查询有问题的话，一般只会影响当前查询</p></li>
<li><p>定位优化对象的性能瓶颈；<br/>
在拿到一条需要优化的 Query 之后，我们首先要判断出这个 Query 的瓶颈到底是 IO 还是CPU。在MySQL中，我们可以通过系统自带的 PROFILING 功能很清楚的找出一个Query 的瓶颈所在</p>
<ul>
<li>通过慢查询日志定位那些执行效率较低的SL语向,用-SSL语句的日志文件--log-slow-queries[=file name] 选项启动时, mysqld写一个包含所有执行时间超过 long query time秒t 具体可以查看本书第26章中日志管理的相关部分。</li>
<li>慢查询日志在查询结東以后才记录,所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题,可以使用 show processlist f命今查看当前 MYSQL在进行的线程,包括线程的状态、是否锁表等,可以实时地查看SQL的执行情况,同时对一些锁表操作进行优化。</li>
</ul></li>
<li><p>明确的优化目标；<br/>
一般来说，我们首先需要清楚的了解数据库目前的整体状态，同时也要清楚的知道数据库中与该 Query 相关的数据库对象的各种信息，而且还要了解该 Query 在整个应用系统中所实现的功能。了解了数据库整体状态，我们就能知道数据库所能承受的最大压力，也就清楚了我们能够接受的最悲观情况。根据功能的重要性，确定 query 的优化目标。</p></li>
<li><p>从 Explain 入手；</p></li>
<li><p>多使用 profile；</p></li>
<li><p>永远用小结果集驱动大的结果集；</p></li>
<li><p>尽可能在索引中完成排序；</p></li>
<li><p>只取出自己需要的 Columns；</p></li>
<li><p>仅仅使用最有效的过滤条件；</p></li>
<li><p>尽可能避免复杂的 Join 和子查询；</p></li>
</ul>

<h2 id="toc_0">explain 的使用</h2>

<ul>
<li>ID：Query Optimizer 所选定的执行计划中查询的序列号；</li>
<li>Select_type：所使用的查询类型，主要有以下这几种查询类型
<ul>
<li>DEPENDENT SUBQUERY：子查询中内层的第一个 SELECT，依赖于外部查询的结果集；</li>
<li>DEPENDENT UNION：子查询中的 UNION，且为 UNION 中从第二个 SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集</li>
<li>PRIMARY：子查询中的最外层查询，注意并不是主键查询；</li>
<li>SIMPLE：除子查询或者 UNION 之外的其他查询；</li>
<li>SUBQUERY：子查询内层查询的第一个 SELECT，结果不依赖于外部查询结果集；</li>
<li>UNCACHEABLE SUBQUERY：结果集无法缓存的子查询；</li>
<li>UNION：UNION 语句中第二个 SELECT 开始的后面所有 SELECT，第一个 SELECT 为 PRIMARY</li>
<li>UNION RESULT：UNION 中的合并结果；</li>
</ul></li>
<li>Table：显示这一步所访问的数据库中的表的名称；</li>
<li><p>Type：告诉我们对表所使用的访问方式，主要包含如下集中类型：</p>
<ul>
<li>a11:全表扫描</li>
<li>index:全索引扫描; </li>
<li>index merge:查询中同时使用两个(或更多)索引,然后对索引结果进行 merge之后再读取表数据; </li>
<li>index subquery:子查询中的返回结果字段组合是一个索引(或索引组合),但不是一个主键或者唯一索引rang:索引范围扫描; </li>
<li>range: 索引范围扫描，常见于&lt;、&lt;=、&gt;、&gt;=、 between等操作符</li>
<li>ref:使用非唯一索引扫描或唯一索引的前缀扫描，最多只会有一条匹配结果,一般是通过主键或者唯一键索引来访问; </li>
<li>eq_ref: 使用唯一索引，每个索引键值，只有一条结果记录匹配</li>
<li>const:读常量,且最多只会有一条记录匹配,由于是常量,所以实际上只需要读一次eq </li>
<li>system:系统表,表中只有一行数据;</li>
<li></li>
<li><p>unique_ subquery:子查询中的返回结果字段组合是主键或者唯一约束;</p></li>
</ul></li>
<li><p>Possible_keys：该查询可以利用的索引. 如果没有任何索引可以使用，就会显示成 null，这一项内容对于优化时候索引的调整非常重要；</p></li>
<li><p>Key：MySQL Query Optimizer 从 possible_keys 中所选择使用的索引；</p></li>
<li><p>Key_len：被选中使用索引的索引键长度；</p></li>
<li><p>Ref：列出是通过常量（const），还是某个表的某个字段（如果是 join）来过滤（通过 key）的；</p></li>
<li><p>Rows：MySQL Query Optimizer 通过系统收集到的统计信息估算出来的结果集记录条数；</p></li>
<li><p>Extra：查询中每一步实现的额外细节信息，主要可能会是以下内容：</p>
<ul>
<li>Distinct：查找 distinct 值，所以当 mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询；</li>
<li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问 null 值的使用使用；</li>
<li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果；</li>
<li>No tables：Query语句中使用 FROM DUAL 或者不包含任何 FROM子句；</li>
<li>Not exists：在某些左连接中 MySQL Query Optimizer 所通过改变原有 Query 的组成而使用的优化方法，可以部分减少数据访问次数；</li>
<li>Range checked for each record (index map: N)：通过 MySQL 官方手册的描述，当MySQL Query Optimizer 没有发现好的可以使用的索引的时候，如果发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL 检查是否可以使用 range 或 index_merge 访问方法来索取行。</li>
<li>Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在 Query 中不能有 GROUP BY 操作。如使用 MIN()或者 MAX（）的时候；</li>
<li>Using filesort：当我们的 Query 中包含 ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。</li>
<li>Using index：所需要的数据只需要在 Index 即可全部获得而不需要再到表中取数据；</li>
<li>Using index for group-by：数据访问和 Using index 一样，所需数据只需要读取索引即可，而当 Query 中使用了 GROUP BY 或者 DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是 Using index for group-by；</li>
<li>Using temporary：当 MySQL 在某些操作中必须使用临时表的时候，在 Extra 信息中就会出现 Using temporary 。主要常见于 GROUP BY 和 ORDER BY 等操作中。</li>
<li>Using where：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现 Using where 信息；</li>
<li>Using where with pushed condition：这是一个仅仅在 NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开 Condition Pushdown 优化功能才可能会被使用。控制参数为 engine_condition_pushdown。</li>
</ul></li>
</ul>

<h2 id="toc_1">合理设计并利用索引</h2>

<h3 id="toc_2">索引设计原则</h3>

<ul>
<li>搜索的索引列,不一定是所要选择的列。换句话说,最适合索引的列是出现在 WHERE 子句中的列,或连接子向中指定的列,而不是出现在 SELECT关键字后的选择列表中的列。</li>
<li>使用唯一索引。考虑某列中值的分布。索引的列的基数越大,索引的效果越好。例如, 存放出生日期的列具有不同值,很容易区分各行。而用来记录性别的列,只含有“M”和“F”, 则对此列进行索引没有多大用处,因为不管搜索哪个值,都会得出大约一半的行。</li>
<li>使用短索引。如果对字符串列进行索引,应该指定一个前缀长度,只要有可能就应该这样做。例如,有一个CHAR(200列,如果在前10个或20个字符内,多数值是唯一的,那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间,也可能会使查询更快。较小的索引涉及的磁盘10较少,较短的值比较起来更快。更为重要的是,对于较短的健值,索引高速缓存中的块能容纳更多的键值,因此, MYSQL也可以在内存中容纳更多的值。这样就増加了找到行而不用读取索引中较多块的可能性</li>
<li><p>利用最左前级。在创建一个n列的索引时,实际是创建了 MYSQL可利用的n个索引多列索引可起几个索引的作用,因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。</p></li>
<li><p>不要过度索引。不要以为索引“越多越好”,什么东西都用索引是错误的。每个额外的索引都要占用额外的磁盘空间,并降低写操作的性能。在修改表的内容时,索引必须进行更新,有时可能需要重构,因此,索引越多,所花的时间越长。如果有一个索引很少利用或从不使用,那么会不必要地减缓表的修改速度。此外, MYSQL在生成一个执行计划时,要考虑各个索引,这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多,也可能会使 MYSQL选择不到所要使用的最好索引。只保持所需的索引有利于查询优化</p></li>
<li><p>对于 INNODB存储引擎的表,记录默认会按照一定的顺序保存,如果有明确定义的主键,则按照主键顺序保存。如果没有主键,但是有唯一索引,那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引,那么表中会自动生成一个内部列,按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的,所以 INNODB表尽量自己指定主键,当表中同时有几个列都是唯一的,都可以作为主键的时候,要选择最常作为访问条件的列作为主键,提高查询的效率。另外,还需要注意, INNODB表的普通索引都会保存主键的键值,所以主键要尽可能选择较短的数据类型,可以有效地减少索引的磁盘占用,提高索引的缓存效果。</p></li>
</ul>

<h3 id="toc_3">BTREE索引与HASH索引</h3>

<p>HASH索引有一些重要的特征需要在使用的时候特别注意：</p>

<ul>
<li>只用于使用 = 操作符的等式比较</li>
<li>优化器不能使用 HASH 索引来加速 ORDER BY操作。</li>
<li>MYSQL不能确定在两个值之间大约有多少行。如果将一个 MYISAM 表改为 HASH 索引的 MEMORY表,会影响一些查询的执行效率</li>
<li>只能使用整个关键字来搜索一行</li>
</ul>

<p>而对于 BTREE索引,当使用&gt;、&lt;、&gt;=、&lt;=、 BETWEEN、!=或者,或者 LIKE &#39; pattern (其中&#39;pattern&#39;不以通配符开始)操作符时,都可以使用相关列上的索引。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  















  
    




  </body>
</html>
