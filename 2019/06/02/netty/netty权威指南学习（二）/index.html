<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="大爷来玩儿啊">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://www.throne4j.com">
    <!--SEO-->

    <meta name="keywords" content="netty">


    <meta name="description" content="第二章 NIO 入门在本章中，我们会分别对JDK的BIO、NIO、NIO2.0的使用进行详细说明。本章主要内容包括：

传统的同步阻塞式IO编程
基于NIO的非阻塞编程
基于NIO2.0的异步非...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>netty权威指南学习（二） | 大爷来玩儿啊</title>


    <link rel="alternate" href="/atom.xml" title="大爷来玩儿啊" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="我跟人飙车来着">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 只要干不死，就往死里干 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://www.throne4j.com">大爷来玩儿啊</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa fa-home"></i>主页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/netty/"><i class="fa fa-book"></i>netty</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/java/"><i class="fa fa-book"></i>java</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/数据库/"><i class="fa fa-book"></i>数据库</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/spring/"><i class="fa fa-book"></i>spring</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/协议/"><i class="fa fa-book"></i>协议</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/设计模式/"><i class="fa fa-book"></i>设计模式</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/领域驱动/"><i class="fa fa-book"></i>领域驱动</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/redis/"><i class="fa fa-book"></i>redis</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/zookeeper/"><i class="fa fa-book"></i>zookepper</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa fa-archive"></i>时间机器</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about/"><i class="fa "></i>来首诗</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="netty权威指南学习（二）">
            
	            netty权威指南学习（二）
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/netty/">netty</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/netty/">netty</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/06/02</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="第二章-NIO-入门"><a href="#第二章-NIO-入门" class="headerlink" title="第二章 NIO 入门"></a>第二章 NIO 入门</h1><p>在本章中，我们会分别对JDK的BIO、NIO、NIO2.0的使用进行详细说明。本章主要内容包括：</p>
<ul>
<li>传统的同步阻塞式IO编程</li>
<li>基于NIO的非阻塞编程</li>
<li>基于NIO2.0的异步非阻塞(AIO)编程</li>
<li>为什么使用NIO编程</li>
<li>为什么使用Netty</li>
</ul>
<h2 id="2-1传统的BIO编程"><a href="#2-1传统的BIO编程" class="headerlink" title="2.1传统的BIO编程"></a>2.1传统的BIO编程</h2><p>　　网络编程的基本模型是client/server，也就是client进程与server进程通过3次握手之后建立连接，进而实现相互通信。</p>
<h3 id="2-1-1-BIO通信模型"><a href="#2-1-1-BIO通信模型" class="headerlink" title="2.1.1 BIO通信模型"></a>2.1.1 BIO通信模型</h3><p>　　BIO服务端通信模型（见下图）通常由一个Acceptor 负责接收客户端的请求，它接收到客户端请求之后，为每一个请求新建一个新的线程进行链路处理，处理完成之后，将处理结果数据，以流的方式发送给客户端，然后销毁线程。这就是典型的一请求一应答的通信模式。<br>　　该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量上来之后，服务端的线程和客户访问量呈1:1的关系增加，当服务端线程过多消耗java虚拟机的资源后，导致性能急剧下降，甚至将导致服务端宕机、僵死而无法提供服务。</p>
<p><img src="/2019/06/02/netty/netty权威指南学习（二）/BIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="BIO通信模型">　　</p>
<h3 id="2-1-2-同步阻塞式IO创建的TimeServer源码分析"><a href="#2-1-2-同步阻塞式IO创建的TimeServer源码分析" class="headerlink" title="2.1.2 同步阻塞式IO创建的TimeServer源码分析"></a>2.1.2 同步阻塞式IO创建的TimeServer源码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qinshengke</span><br><span class="line"> * @description TODO</span><br><span class="line"> * @date 2016-06-02 21:40</span><br><span class="line"> */</span><br><span class="line">public class TimeServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if (args != null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            port = Integer.valueOf(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        ServerSocket server = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;The server is started in port:&quot; + port);</span><br><span class="line">            // 获取server接待的socket</span><br><span class="line">            Socket socket = null;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                new Thread(new TimeServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (server != null) &#123;</span><br><span class="line">                System.out.println(&quot;The time server close&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qinshengke</span><br><span class="line"> * @description TODO</span><br><span class="line"> * @date 2016-06-02 22:03</span><br><span class="line"> */</span><br><span class="line">public class TimeServerHandler implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private Socket socket;</span><br><span class="line"></span><br><span class="line">    public TimeServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        // 获取socket 输入流</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(this.socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(this.socket.getOutputStream(), true);</span><br><span class="line">            String currentTime = null;</span><br><span class="line">            String body = null;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                body = in.readLine();</span><br><span class="line">                if (body == null) break;</span><br><span class="line">                System.out.println(&quot;The time server receive order :&quot; + body);</span><br><span class="line">                currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new Date(System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;;</span><br><span class="line">                out.println(currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            if (in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    this.socket.close();</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                this.socket = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qinshengke</span><br><span class="line"> * @description TODO</span><br><span class="line"> * @date 2019-06-02 22:19</span><br><span class="line"> */</span><br><span class="line">public class TimeClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if (args != null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            port = Integer.valueOf(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new Socket(&quot;127.0.0.1&quot;, port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">            out.println(&quot;QUERY TIME ORDER&quot;);</span><br><span class="line">            System.out.println(&quot;Send order 2 server succeed.&quot;);</span><br><span class="line">            String resp = in.readLine();</span><br><span class="line">            System.out.println(&quot;Now is :&quot; + resp);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (out != null) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　BIO主要问题在于每当有一个新的客户端请求接入时，服务端都必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接。试想一下，当成千上万甚至百万的客户端请求接入时，对服务器来说无异于灾难来临。
　　</p>
<h2 id="2-2-伪异步IO编程"><a href="#2-2-伪异步IO编程" class="headerlink" title="2.2  伪异步IO编程"></a>2.2  伪异步IO编程</h2><p>为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题，后来有人对他的线程模型进行了优化–后端通过线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N。</p>
<h3 id="2-2-1伪异步IO模型"><a href="#2-2-1伪异步IO模型" class="headerlink" title="2.2.1伪异步IO模型"></a>2.2.1伪异步IO模型</h3><p>　　采用线程池或者任务队列实现一种伪异步的IO通信框架，它的模型如下图所示:<br><img src="/2019/06/02/netty/netty权威指南学习（二）/%E4%BC%AA%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt><br>　　当有新的客户请求接入的时候，将客户端的socket封装为一个task投递到后端的线程池中进行处理,java线程池维护一个任务队列和N个活跃的线程，因此它消耗资源是可控的，不会造成资源的耗尽。由于伪异步通信模型底层实现依然使用BIO，无法从根本上解决同步阻塞IO的问题。</p>
<p>下面我们结合代码，了解一下伪异步通信模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.shengke.netty.bio.fake;</span><br><span class="line"></span><br><span class="line">import com.shengke.netty.bio.TimeServerHandler;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qinshengke</span><br><span class="line"> * @description TODO</span><br><span class="line"> * @date 2016-06-02 21:40</span><br><span class="line"> */</span><br><span class="line">public class TimeServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 8080;</span><br><span class="line">        if (args != null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            port = Integer.valueOf(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        ServerSocket server = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;The server is started in port:&quot; + port);</span><br><span class="line">            // 获取server接待的socket</span><br><span class="line">            Socket socket = null;</span><br><span class="line">            TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 10000);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                executePool.execute(new TimeServerHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (server != null) &#123;</span><br><span class="line">                System.out.println(&quot;The time server close&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.shengke.netty.bio.fake;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author qinshengke</span><br><span class="line"> * @description TODO</span><br><span class="line"> * @date 2016-06-02 22:03</span><br><span class="line"> */</span><br><span class="line">public class TimeServerHandlerExecutePool &#123;</span><br><span class="line"></span><br><span class="line">    private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123;</span><br><span class="line">        executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize,</span><br><span class="line">                120L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Runnable task) &#123;</span><br><span class="line">        executorService.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码没有什么变化，使用2.1.2章节中的 TimeClient。</p>
<h3 id="2-2-3-伪异步通信模型的弊端"><a href="#2-2-3-伪异步通信模型的弊端" class="headerlink" title="2.2.3 伪异步通信模型的弊端"></a>2.2.3 伪异步通信模型的弊端</h3><p>首先我们看下InputStream的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class InputStream implements Closeable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Reads some number of bytes from the input stream and stores them into</span><br><span class="line">     * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is</span><br><span class="line">     * returned as an integer.  This method blocks until input data is</span><br><span class="line">     * available, end of file is detected, or an exception is thrown.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and</span><br><span class="line">     * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span><br><span class="line">     * least one byte. If no byte is available because the stream is at the</span><br><span class="line">     * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at</span><br><span class="line">     * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span><br><span class="line">     * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,</span><br><span class="line">     * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the</span><br><span class="line">     * number of bytes actually read; these bytes will be stored in elements</span><br><span class="line">     * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span><br><span class="line">     * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span><br><span class="line">     * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;</span><br><span class="line">     * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param      b   the buffer into which the data is read.</span><br><span class="line">     * @return     the total number of bytes read into the buffer, or</span><br><span class="line">     *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span><br><span class="line">     *             the stream has been reached.</span><br><span class="line">     * @exception  IOException  If the first byte cannot be read for any reason</span><br><span class="line">     * other than the end of the file, if the input stream has been closed, or</span><br><span class="line">     * if some other I/O error occurs.</span><br><span class="line">     * @exception  NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">     * @see        java.io.InputStream#read(byte[], int, int)</span><br><span class="line">     */</span><br><span class="line">    public int read(byte b[]) throws IOException &#123;</span><br><span class="line">        return read(b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputStream的API中有一段是这样描述<br><strong><em>This method blocks until input data is available, end of file is detected, or an exception is thrown</em></strong><br>当对socket的输入流进行读取的时候，它会一直阻塞下去，知道发生以下三件事：</p>
<ul>
<li>有数据可读</li>
<li>可用数据已经读取完毕</li>
<li>发生空指针或者IO异常</li>
</ul>
<p>这意味着当对方发送请求或者响应比较慢，或者网络延迟，读取输入流的一方的通信线程将会一直阻塞，在此期间，其他接入消息只能在任务队列中排队等待</p>
<p>下面我们对输出流OutputStream进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class OutputStream implements Closeable, Flushable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array</span><br><span class="line">     * to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt;</span><br><span class="line">     * is that it should have exactly the same effect as the call</span><br><span class="line">     * &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @param      b   the data.</span><br><span class="line">     * @exception  IOException  if an I/O error occurs.</span><br><span class="line">     * @see        java.io.OutputStream#write(byte[], int, int)</span><br><span class="line">     */</span><br><span class="line">    public void write(byte b[]) throws IOException &#123;</span><br><span class="line">        write(b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用OutputStream的write方法写入输出流的时候，它将被阻塞，知道所有要发送的数据发送完毕，或发生异常。当数据的接收方数据处理能力低下时，将不能及时的从TCP缓冲区读取数据，这将会导致数据发送方的TCP windows size不断变小，直到为0，双方处于Keep-Alive状态，数据发送方将不能再向TCP缓冲区写入数据，这是如果采用同步阻塞IO，write操作将会被无限期阻塞，知道TCP windows size大于 0 或者发生异常为止。</p>
<p>下面我们就简单分析下通信对方返回应答时间过长引起的级联故障：<br>（1） 服务端处理缓慢，宴会应答消息消耗60s，平均只需要10ms<br>（2）采用伪异步IO的线程正在读取故障服务节点的响应，由于读取输入流是阻塞的，它将会被同步阻塞60s<br>（3）假设所有线程被阻塞在故障服务器，name后续所有的IO消息都将在任务队列中排队<br>（4）由于线程池采用阻塞队列实现，当队列积压满之后，后续如队列操作将被阻塞，进而acceptor将会拒绝接收客户端请求，导致大量的连接超时。</p>
<h2 id="2-3-NIO编程"><a href="#2-3-NIO编程" class="headerlink" title="2.3 NIO编程"></a>2.3 NIO编程</h2><p>在开始NIO之前我们首先需要弄明白NIO的概念，什么才是NIO？由于NIO的目标是使Java支持非阻塞IO，所以很多人喜欢称NIO为非阻塞IO（Non-block IO）</p>
<p>与Socket类和ServerSocket类相对应，NIO也童工了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。这两种新增加的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单但是性能和可靠性不好，非阻塞模式正好相反。</p>
<h3 id="2-3-1-NIO类库简介"><a href="#2-3-1-NIO类库简介" class="headerlink" title="2.3.1  NIO类库简介"></a>2.3.1  NIO类库简介</h3><p>NIO弥补了原来同步阻塞IO的不足，它在标准Java代码中提供了高速的、面向块的IO。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO不用使用本机代码就可以利用低级优化，这是原来IO锁无法做到的。下面我们对NIO的一些概念和功能坐下简单介绍，以便大家能够快速地了解NIO类库和相关概念。</p>
<h4 id="（1）缓冲区Buffer"><a href="#（1）缓冲区Buffer" class="headerlink" title="（1）缓冲区Buffer"></a>（1）缓冲区Buffer</h4><p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，踢向了新库与原IO的一个重要区别。在面向流的IO中，可以将数据直接写入或者将数据直接读到Stream对象中。</p>
<p>在NIO库中所有数据都是用缓冲区吃力的。在读取数据时，他是直接读到缓冲区中的，在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>缓冲区实质上一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置等信息。</p>
<p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区（每种Java基本类型都有对应的缓冲区 boolean除外）</p>
<ul>
<li>ByteBuffer 字节缓冲区</li>
<li>CharBuffer 字符缓冲区</li>
<li>ShortBuffer  短整型缓冲区</li>
<li>IntBuffer  整形缓冲区</li>
<li>LongBuffer 长整型缓冲区</li>
<li>FloatBuffer  浮点型缓冲区</li>
<li>DoubleBuffer 双精度浮点型缓冲区</li>
</ul>
<h4 id="（2）通道-Channel"><a href="#（2）通道-Channel" class="headerlink" title="（2）通道 Channel"></a>（2）通道 Channel</h4><p>Channel是一个通道，他就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动，而通道可以用于读、写或者两者同时进行。<br>因为Channel是全双工的，所以他可以比流更好的映射底层操作系统的API。</p>
<p>Channel的类图继承关系如下图所示：<br><img src="/2019/06/02/netty/netty权威指南学习（二）/Channel.jpg" alt="NIO channel接口继承图"></p>
<p>自顶向下看，前三层主要是channel接口，用于定义它的功能，后面是一些具体功能类（抽象类）。从类图可以看出，实际上Channel可以分为两大类：用于网络读写的SelectableChannel和用于文件操作的FileChannel</p>
<p>本文设计到的SocketChannel、ServerSocketChannel都是SelectableChannel的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ReadableByteChannel (java.nio.channels)</span><br><span class="line">    ReadableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">    ScatteringByteChannel (java.nio.channels)</span><br><span class="line">    ByteChannel (java.nio.channels)</span><br><span class="line">        SeekableByteChannel (java.nio.channels)</span><br><span class="line">        SocketChannel (java.nio.channels)</span><br><span class="line">        DatagramChannel (java.nio.channels)</span><br><span class="line">    SourceChannel in Pipe (java.nio.channels)</span><br><span class="line">InterruptibleChannel (java.nio.channels)</span><br><span class="line">    AbstractInterruptibleChannel (java.nio.channels.spi)</span><br><span class="line">        ReadableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">        SelectableChannel (java.nio.channels)</span><br><span class="line">        WritableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">        FileChannel (java.nio.channels)</span><br><span class="line">SelectableChannel (java.nio.channels)</span><br><span class="line">    AbstractSelectableChannel (java.nio.channels.spi)</span><br><span class="line">        SocketChannel (java.nio.channels)</span><br><span class="line">        SinkChannel in Pipe (java.nio.channels)</span><br><span class="line">        DatagramChannel (java.nio.channels)</span><br><span class="line">        SourceChannel in Pipe (java.nio.channels)</span><br><span class="line">        ServerSocketChannel (java.nio.channels)</span><br><span class="line">NetworkChannel (java.nio.channels)</span><br><span class="line">    AsynchronousServerSocketChannel (java.nio.channels)</span><br><span class="line">    SocketChannel (java.nio.channels)</span><br><span class="line">    MulticastChannel (java.nio.channels)</span><br><span class="line">    ServerSocketChannel (java.nio.channels)</span><br><span class="line">    AsynchronousSocketChannel (java.nio.channels)</span><br><span class="line">WritableByteChannel (java.nio.channels)</span><br><span class="line">    SinkChannel in Pipe (java.nio.channels)</span><br><span class="line">    WritableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">    ByteChannel (java.nio.channels)</span><br><span class="line">    GatheringByteChannel (java.nio.channels)</span><br><span class="line">AbstractInterruptibleChannel (java.nio.channels.spi)</span><br><span class="line">    ReadableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">    SelectableChannel (java.nio.channels)</span><br><span class="line">    WritableByteChannelImpl in Channels (java.nio.channels)</span><br><span class="line">    FileChannel (java.nio.channels)</span><br><span class="line">AsynchronousChannel (java.nio.channels)</span><br><span class="line">    AsynchronousServerSocketChannel (java.nio.channels)</span><br><span class="line">    AsynchronousFileChannel (java.nio.channels)</span><br><span class="line">    AsynchronousByteChannel (java.nio.channels)</span><br></pre></td></tr></table></figure>

<h4 id="（3）多路复用器Selector"><a href="#（3）多路复用器Selector" class="headerlink" title="（3）多路复用器Selector"></a>（3）多路复用器Selector</h4><p>我们探索下多路复用器Selector，它是Java NIO编程的基础，熟练地掌握Selector对NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单来说Selector会不断的轮询注册在其上的Channel，如果某个Chennel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的IO操作。<br>一个多路复用器Selector可以轮询多个Channel，由于JKD使用epoll代替传统的select，所以它并没有最大句柄 1024/2048的限制。也就是一个Selector就可以负责成千上万的客户端。</p>
<h3 id="2-3-2-NIO服务端通信序列图分析"><a href="#2-3-2-NIO服务端通信序列图分析" class="headerlink" title="2.3.2 NIO服务端通信序列图分析"></a>2.3.2 NIO服务端通信序列图分析</h3><p><img src="/2019/06/02/netty/netty权威指南学习（二）/NIO%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97%E5%9B%BE.png" alt="NIO服务端通信序列图"></p>
<p>下面，我们对NIO服务端的主要创建过程进行讲解和说明，作为NI的基础入门，这里忽略掉一些在生产环境部署所需的特性和功能。<br>步骤一： <strong>打开ServerSocketChannel</strong>，用于监听客户端的连接，它是所有客户端连接的父管道，伪代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel acceptor = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>

<p>步骤二： 绑定监听端口，设置连接为非阻塞模式，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acceptor.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port));</span><br><span class="line">acceptor.configureBlooking(false);</span><br></pre></td></tr></table></figure>

<p>步骤三： 创建Reactor线程，创建多路复用器并启动线程，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">new Thread(new ReactorTask()).start();</span><br></pre></td></tr></table></figure>

<p>步骤四： 将ServerSocketChannel 注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = acceptor.register(selector, SelectionKey.OP_ACCEPT, ioHandler);</span><br></pre></td></tr></table></figure>

<p>步骤五： 多路复用器在线程run方法的无限循环体内轮询准备就绪的Key，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = (SelectionKey) it.next();</span><br><span class="line">    // do with IO event</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤六： 多路复用器监听到有新的客接入，处理新的接入请求，完成TCP三次握手，建立物理链路，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel channel = acceptor.accept();</span><br></pre></td></tr></table></figure>

<p>步骤七： 设置客户端链路为非阻塞模式，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);</span><br><span class="line">channel.socket().setReuseAddress(true);</span><br></pre></td></tr></table></figure>

<p>步骤八： 将新接入的客户端连接注册到Reactor线程的多路复用器上，监听读操作，读取客户端发送的网络消息，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = socketChannel.register(selector, SelectionKey.OP_READ, ioOHandler);</span><br></pre></td></tr></table></figure>

<p>步骤九： 异步读取客户端请求消息到缓冲区，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int radNumber = channel.read(receivedBuffer);</span><br></pre></td></tr></table></figure>

<p>步骤十： 对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中，进行业务逻辑的编排，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Object message = null;</span><br><span class="line">while(buffer.hasRemain()) &#123;</span><br><span class="line">    byteBuffer.mark();</span><br><span class="line">    message = decode(byteBuffer);</span><br><span class="line">    if (message == null) &#123;</span><br><span class="line">        byteBuffer.reset();</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    messageList.add(message);</span><br><span class="line">&#125;</span><br><span class="line">if (!byteBuffer.hasRemain())</span><br><span class="line">    byteBuffer.clear()</span><br><span class="line">else</span><br><span class="line">    byteBuffer.compact();</span><br><span class="line">if (messageList !=null &amp;&amp; messageList.size()&gt;0) &#123;</span><br><span class="line">    for(Object msg : messageList) &#123;</span><br><span class="line">        handlerTask(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤十一： 将POJO对象encode成Buffer，调用SocketChannel 的异步write接口，将消息异步发送给客户端，伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(buffer);</span><br></pre></td></tr></table></figure>

<p>注意： 如果发送去TCP 缓冲区满，会导致写半包，此时，需要注册到监听写操作位，循环写，直到整包消息写入到TCP缓冲区，对于这些内容此处暂不赘述。</p>
<h3 id="2-3-3-NIO创建的TimeServer源码分析"><a href="#2-3-3-NIO创建的TimeServer源码分析" class="headerlink" title="2.3.3 NIO创建的TimeServer源码分析"></a>2.3.3 NIO创建的TimeServer源码分析</h3><p>我们将在TimeServer例程中给出完整的NIO创建的时间服务器源码</p>

    </div>
    
    <div class="post-footer">
        <div>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/06/03/java/集合/Collection集合大礼包/" class="pre-post btn btn-default" title="collection集合记录">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">collection集合记录</span>
        </a>
    
    
        <a href="/2019/06/02/spring/spring-core/(一) spring-core学习记录/" class="next-post btn btn-default" title="spring-core包阅读记录">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">spring-core包阅读记录</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'rs94TvqsO1CHWHQNk3Kx3jSg-gzGzoHsz',
            appKey: 'OnRH4bvLKckbcSHTx8EleVkw',
            placeholder: '骚年，发出你的10万个为什么',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-NIO-入门"><span class="toc-text">第二章 NIO 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1传统的BIO编程"><span class="toc-text">2.1传统的BIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-BIO通信模型"><span class="toc-text">2.1.1 BIO通信模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-同步阻塞式IO创建的TimeServer源码分析"><span class="toc-text">2.1.2 同步阻塞式IO创建的TimeServer源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-伪异步IO编程"><span class="toc-text">2.2  伪异步IO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1伪异步IO模型"><span class="toc-text">2.2.1伪异步IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-伪异步通信模型的弊端"><span class="toc-text">2.2.3 伪异步通信模型的弊端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-NIO编程"><span class="toc-text">2.3 NIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-NIO类库简介"><span class="toc-text">2.3.1  NIO类库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）缓冲区Buffer"><span class="toc-text">（1）缓冲区Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）通道-Channel"><span class="toc-text">（2）通道 Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）多路复用器Selector"><span class="toc-text">（3）多路复用器Selector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-NIO服务端通信序列图分析"><span class="toc-text">2.3.2 NIO服务端通信序列图分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-NIO创建的TimeServer源码分析"><span class="toc-text">2.3.3 NIO创建的TimeServer源码分析</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>






    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>