<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    NIO 入门 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            NIO 入门   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2021/03/01</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='Netty.html'>Netty</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2><a id="bio%E3%80%81nio%E5%92%8C-aio%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BIO、NIO 和 AIO 的区别?</h2>
<p>BIO 一个连接一个线程，客户端有连接请求时，服务器就需要启动一个线程进行处理。线程开销比较大。</p>
<p>NIO 一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮训到连接有 IO 请求时才会启动一个线程进行处理</p>
<p>AIO 一个有效请求一个线程，客户端的IO 请求都是由 os 先完成之后，再通知服务器应用去启动线程进行处理</p>
<p>BIO是面向流的，并且流都是单向的、阻塞的<br />
NIO是面向缓冲的，它事非阻塞的，它的channel 是双向的</p>
<p>NIO 特点：<br />
基于 Reactor 模型的事件驱动模型、单线程处理多任务、非阻塞 IO，基于 block的传输比基于流的传输更高效，它有更高效的 零拷贝技术、多路复用技术，大大提高了java网络应用的可伸缩性和实用性。</p>
<p>在 Reactor 模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发 器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>如在 Reactor 中实现读:注册读就绪事件和相应的事件处理器、事件分发器等待事 件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操 作，处理读到的数据，注册新的事件，然后返还控制权。</p>
<h2><a id="nio%E7%BB%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NIO 组成</h2>
<ul>
<li>
<p>Channel：通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道</p>
<ul>
<li>ServerSocketChannel(继承SelectableChannel)<br />
应用服务器程序的监听通道。只有通过这个通道，应用程序才能想操作系统注册支持多路复用IO的端口监听，同事支持 UDP和 TCP协议</li>
<li>SocketChannel(继承SelectableChannel)<br />
TCP Socket 套接字的监听通道，一个socket 套接字对应了一个客户端IP:端口 到服务器IO:端口 的通信连接</li>
</ul>
</li>
<li>
<p>Buffer：ByteBuffer、CharBuffer等等</p>
<ul>
<li>capacity 缓冲区的固定大小</li>
<li>limit 缓冲区最多可以读取或写入的大小限制</li>
<li>position 表示当前可以读取或写入的位置</li>
</ul>
</li>
<li>
<p>Selector ：多路复用选择器</p>
</li>
<li>
<p>SelectionKey<br />
表示SelectableChannel 在 Selector 中注册的标识，每个 Channel 想 Selector 注册时，都会创建一个 SelectionKey。<br />
SelectionKey 将Channel 与 Selector 建立了关系，并维护了 channel 事件。</p>
<ul>
<li>OP_READ : 当操作系统读缓冲区有数据可读时就绪。</li>
<li>OP_WRITE : 当操作系统写缓冲区有空闲空间时就绪</li>
<li>OP_CONNECT : 当 SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用</li>
<li>OP_ACCEPT : 当接收到一个客户端连接请求时就绪</li>
</ul>
</li>
</ul>
<p>服务器 ServerSocketChannel 对 OP_ACCEPT感兴趣。<br />
服务端 SocketChannel 对 OP_READ、OP_WRITE 感兴趣。<br />
客户端 SocketChannel 对 OP_CONNECT、OP_READ、OP_WRITE感兴趣。</p>
<h2><a id="nio%E5%AE%9E%E6%88%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NIO 实战</h2>
<p>服务端 NIO 伪代码</p>
<pre><code class="language-java">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

Selector selector = Selector.open();

serverSocketChannel.configureBlocking(false);
//绑定端口，并设置 backLog 限制请求队列的大小
serverSocketChannel.socket().bind(new InetSocketAddress(port), 1024);

serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

for(;;){
    // 阻塞 只有当至少一个注册的事件发生的时候才会继续，返回的 int 值表示有多少通道已经就绪
    selector.select();
    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; ite = selectionKeys.iterator();
    
    while(ite.hashNext()) {
        SelectionKey key = ite.next();
        // 由于此处是水平出发模式，如果不清除的话，将会一直通知这个事件
        ite.remove();
        
        try {
            // 此处可以置于线程池中进行异步处理，executor.submit(()-&gt;{处理key事件;})
            if (key.isValid()) {
                // while循环第一次进来处理 acceptable的事件，即处理新接入的请求事件
                if (key.isAcceptable()) {
                    // 获取key 绑定的服务端 channel
                    ServerSocketChannel sc = (ServerSocketChannel) key.channel();
                    // 从服务端 channel 中获取新近连接的客户端 channel
                    SocketChannel socketChannel = channel.accept();
                    socketChannel.configureBlocking(false);
                    
                    // 对连接进来的客户端注册感兴趣的事件,可以这样注册多个感兴趣的事件 SelectionKey.OP_READ|SelectionKey.OP_WRITE
                    socketChannel.register(selector, SelectionKey.OP_READ);
                }
                
                if (key.isReadable()) {
                    // while循环之后接收的客户端事件，上面注册的读事件
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    //创建ByteBuffer，并开辟一个1M的缓冲区
            				ByteBuffer buffer = ByteBuffer.allocate(1024);
            				// 读入到 buffer 缓冲区
                    int read = socketChannel.read(buffer);
                    if (read &gt; 0){
                        // 要想读 buffer 缓冲区，必须flip
                        buffer.flip();
                        
                        byte[] bytes = new byte[buffer.remaining()];
                        //将缓冲区可读字节数组复制到新建的数组中
                        buffer.get(bytes);
                        
                        System.out.println(new String(bytes, StandardCharssets.UTF_8));
                        
                        byte[] resp = &quot;服务器响应客户啦&quot;.getBytes();
                        ByteBuffer writeBuffer = ByteBuffer.allocate(resp.length);
                        writeBuffer.put(resp);
                        writeBuffer.flip();
                        socketChannel.write(writeBuffer);
                    } else if (read &lt;= 0) {
                        key.cancel();
                        socketChannel.close();
                    }
                }
            }    
        } cache(Exception e) {
        	if (key != null) {
        	   key.cancel();
        	   if (key.channel() != null) {
        	       try {
        	           key.channel().close();
        	       } catch (IOException ioException) {
        	           ioException.printStackTrace();
        	       }
        	   }
        	}
        }
    }
}
</code></pre>
<p>客户端伪代码</p>
<pre><code class="language-java">private Selector selector;
private SocketChannel socketChannel;
public void handle() {
	try {
		this.selector = Selector.open();
		socketChannel = SocketChannel.open();
		socketChannel.configureBlocking(false);
	} catch (IOException e) {
		e.printStackTrace();
	}

	try {
		doConnect();
	} catch (IOException e) {
		e.printStackTrace();
		System.exit(-1);
	}

	for (; ; ) {
		try {
			// 阻塞方法，当至少一个注册的额时间发生的时候就会继续
			selector.select();

			Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
			Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();

			SelectionKey key = null;
			while (iterator.hasNext()) {
				key = iterator.next();
				iterator.remove();

				try {
					if (key.isValid()) {
						SocketChannel sc = (SocketChannel) key.channel();
						if (key.isConnectable()) {
							// 如果确实完成了连接，注册读事件
							if (sc.finishConnect()) {
								socketChannel.register(selector, SelectionKey.OP_READ);
							}
						} else {
							System.exit(-1);
						}
						// 有可读的事件之后
						if (key.isReadable()) {
							ByteBuffer buffer = ByteBuffer.allocate(1024);
							int readBytes = sc.read(buffer);
							if (readBytes &gt; 0) {
								buffer.flip();
								byte[] bytes = new byte[buffer.remaining()];

								buffer.get(bytes);
								System.out.println(&quot;客户端受到消息&quot; + new String(bytes, StandardCharsets.UTF_8));
							}/*链路已经关闭，释放资源*/ else if (readBytes &lt; 0) {
								key.cancel();
								sc.close();
							}
						}
					}
				} catch (Exception e) {
					if (key != null) {
						key.cancel();
						if (key.channel() != null) {
							key.channel().close();
						}
					}
				}
			}


		} catch (IOException e) {
			e.printStackTrace();
			System.exit(-1);
		}
	}

	if (selector != null) {
		try {
			selector.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

// 内部方法，连接服务器
private void doConnect() throws IOException {
	if (socketChannel.connect(new InetSocketAddress(host, port))) {
		socketChannel.register(selector, SelectionKey.OP_READ);
	} else {
		/*如果此通道处于非阻塞模式，则调用此方法将启动非阻塞连接操作。
		 如果连接马上建立成功，则此方法返回true。
		 否则，此方法返回false，
		 因此我们必须关注连接就绪事件，
		 并通过调用finishConnect方法完成连接操作。*/
		socketChannel.register(selector, SelectionKey.OP_CONNECT);
	}

}

private void doWrite(SocketChannel sc, String request) throws IOException {
	byte[] bytes = request.getBytes();
	ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
	writeBuffer.put(bytes);
	writeBuffer.flip();
	sc.write(writeBuffer);
}
</code></pre>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
