<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  java并发编程 - 大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15867933931035.html">
                
                  <h1>细说java 显式锁 Lock</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>锁是用于通过多个线程控制对共享资源的访问工具。通常锁提供对共享资源的独占访问，但是一些锁可能允许并发的访问共享资源，例如ReadWriteLock的读锁。</p>

<p>问:java中有了synchronized，为什么又会出现java显式锁呢？<br/>
答：Lock实现提供比使用synchronized方法可以获得更灵活、更广泛的锁定操作。</p>

<p>使用synchronized方法或语句提供对每个对象相关联的隐式监视器锁访问，但是强制所有锁获取和释放以块的结构方式发生，当获取多个锁的时候，他们必须以相反的顺序被释放，并且所有的锁都必须被释放在与他们相同的词汇范围内。</p>

<p>lock的使用应使用如下的惯用写法:</p>

<pre><code class="language-java">Lock l = ...;
l.lock();
try{
    // 访问被此锁保护起来的相关资源
} finally{
    l.unlock();
}
</code></pre>

<pre><code class="language-text">public interface Lock {
    // 获得锁资源
    void lock();
    // 尝试获得锁，如果当前线程被调用了interrupted则中断，并抛出异常，否则就获得锁
    void lockInterruptibly() throws InterruptedException;
    // 判断能否获得锁，如果能获得，则获得锁，并返回true(此时已经获得了锁)
    boolean tryLock();
    // 保持给定的等待时间，如果期间能拿到锁，则获得锁，同样如果期间被中断，则抛异常
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    // 释放锁
    void unlock();
    // 返回与此Lock对象绑定Condition实例
    Condition newCondition();
}
</code></pre>

<hr/>

<h2 id="toc_0">ReentrantLock重入锁，内部实现有公平锁和非公平锁。</h2>

<h3 id="toc_1">可重入</h3>

<p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞， 该特性的实现需要解决以下两个问题。<br/>
1)线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程， 如果是，则再次成功获取。<br/>
2)锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放该锁后，其 他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示 当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于 0 时表示锁已 经成功释放。</p>

<p>nonfairTryAcquire 方法增加了再次获取同步状态的处理逻辑:通过判断当前 线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请 求，则将同步状态值进行增加并返回 true，表示获取同步状态成功。同步状态表 示锁被一个线程重复获取的次数。<br/>
如果该锁被获取了 n 次，那么前(n-1)次 tryRelease(int releases)方法必须返回 false，而只有同步状态完全释放了，才能返回 true。可以看到，该方法将同步状 态是否为 0 作为最终释放的条件，当同步状态为 0 时，将占有线程设置为 null， 并返回 true，表示释放成功。</p>

<h3 id="toc_2">公平和非公平锁</h3>

<pre><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>

<p>ReentrantLock 的构造函数中，默认的无参构造函数将会把 Sync 对象创建为NonfairSync 对象，这是一个“非公平锁”;</p>

<p>而另一个构造函数 ReentrantLock(boolean fair)传入参数为 true 时将会把 Sync 对象创建为“公平锁” FairSync。</p>

<p>nonfairTryAcquire(int acquires)方法，对于非公平锁，只要 CAS 设置同步状态 成功，则表示当前线程获取了锁，而公平锁则不同。</p>

<p>tryAcquire 方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 <strong>hasQueuedPredecessors()</strong>方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此 需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>

<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>

<hr/>

<h3 id="toc_3">condition接口</h3>

<p>Condition与Lock要结合使用，使用Condition可以用来实现wait()和notify()/notifyAll()类似的等待/通知模式。与Object对象里不同的是，Condition更加灵活，可以在一个Lock对象里创建多个Condition实例，有选择的进行线程通知，在线程调度上更加灵活。<br/>
Condition接口的通过<br/>
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject <br/>
<a href="15867863097702.html">细说AbstractQueuedSynchronizer(AQS)</a><br/>
来实现。</p>

<p>使用Condition注释上的栗子：</p>

<pre><code class="language-java">/**
 * 阻塞的有界队列
 */
public class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition(); 
    final Condition notEmpty = lock.newCondition(); 

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            // 当count等于数组的大小时，当前线程等待，直到notFull通知，再进行生产
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            // 当count为0，进入等待，直到notEmpty通知，进行消费。
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>

<p>可以通过多个线程来调用put和take方法，来模拟生产者和消费者。<br/>
我们来换成常规的wait/notify的实现方式：</p>

<pre><code class="language-java">public class BoundedBuffer {
    private final Object lock;
    
    public BoundedBuffer(Object lock) {
        this.lock = lock;
    }
    public void put(Object x) {
        try {
            synchronized (items) {
                while (count == items.length) {
                    items.wait();
                }
                items[putptr] = x;
                if (++putptr == items.length) putptr = 0;
                ++count;
                // items.notify();
                items.notifyAll();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public Object take() {
        try {
            synchronized (items) {
                while (count == 0) {
                    items.wait();
                }
                Object x = items[takeptr];
                if (++takeptr == items.length) takeptr = 0;
                --count;
                // items.notify();
                items.notifyAll();
                return x;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>如果将items.notifyAll()换成items.notify()，在多生产者和多消费者模式情况下，可能出现take唤醒了take的情况，导致生产者在等待消费者消费，而消费者等待生产者生产，最终导致程序无限等待，而用notifyAll()，则唤醒所有的生产者和消费者，不像Condition可以选择性的通知。下面我们来看一下它的源码：</p>

<pre><code class="language-java">public interface Condition {
    // 让当前线程等待，直到被通知或者被中断
    void await() throws InterruptedException;
    // 与前者的区别是，当等待过程中被中断时，仍会继续等待，直到被唤醒，才会设置中断状态
    void awaitUninterruptibly();
    // 让当前线程等待，直到它被告知或中断，或指定的等待时间已经过。
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    // 与上面的类似，让当前线程等待，不过时间单位是纳秒
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    // 让当前线程等待到确切的指定时间，而不是时长
    boolean awaitUntil(Date deadline) throws InterruptedException;
    // 唤醒一个等待当前condition的线程，有多个则随机选一个
    void signal();
    // 唤醒所有等待当前condition的线程
    void signalAll();
}
</code></pre>

<hr/>

<h2 id="toc_4">ReadWriteLock</h2>

<p>读写锁接口只定义了两个获取读锁和写锁的接口方法，需要具体实现类ReentrantReadWriteLock实现</p>

<pre><code class="language-java">public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
</code></pre>

<h3 id="toc_5">ReentrantReadWriteLock</h3>

<h4 id="toc_6">读写状态的设计</h4>

<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的 同步状态。<br/>
回想 ReentrantLock 中自定义同步器的实现，同步状态表示锁被一个线程重 复获取的次数，而读写锁的自定义同步器需要在同步状态(一个整型变量)上维 护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br/>
如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变 量，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写，读写锁 是如何迅速确定读和写各自的状态呢?<br/>
答案是通过位运算。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF (将高 16 位全部抹去)，读状态等于 S&gt;&gt;&gt;16(无符号补 0 右移 16 位)。当写 状态增加 1 时，等于 S+1，当读状态增加 1 时，等于 S+(1&lt;<16)，也就是 S+0x00010000。 根据状态的划分能得出一个推论:S 不等于 0 时，当写状态(S&0x0000FFFF)等 于 0 时，则读状态(S>&gt;&gt;16)大于 0，即读锁已被获取。</p>

<h4 id="toc_7">写锁的获取与释放</h4>

<p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写 状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为 0)或者该线 程不是已经获取写锁的线程，则当前线程进入等待状态。</p>

<p>该方法除了重入条件(当前线程为获取了写锁的线程)之外，增加了一个读 锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于:读写锁要确 保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他 读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读 写线程的后续访问均被阻塞。</p>

<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态， 当写状态为 0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁， 同时前次写线程的修改对后续读写线程可见</p>

<h4 id="toc_8">读锁的获取与释放</h4>

<p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他 写线程访问(或者写状态为 0)时，读锁总会被成功地获取，而所做的也只是(线 程安全的)增加读状态。如果当前线程已经获取了读锁，则增加读状态。</p>

<p>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读 状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择 保存在 ThreadLocal 中，由线程自身维护。在 tryAcquireShared(int unused)方法中， 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果 当前线程获取了写锁或者写锁未被获取，则当前线程(线程安全，依靠 CAS 保证) 增加读状态，成功获取读锁。读锁的每次释放(线程安全的，可能有多个读线程 同时释放读锁)均减少读状态。</p>

<h4 id="toc_9">锁的升降级</h4>

<p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放， 最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p>

<p>锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p>

<p>RentrantReadWriteLock 不支持锁升级(把持读锁、获取写锁，最后释放读锁 的过程)。目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程 成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。<br/>
ReadLock<br/>
WriteLock </p>

<h3 id="toc_10">StampedLock</h3>

<p>JDK1.8增加的一种新的锁实现</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15867876320249.html">
                
                  <h1>JUC辅助同步类之CountDownLatch、CyclicBarrier、Semaphore</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CountDownLatch 号令枪</h2>

<p>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行操作。<br/>
CountDownLatch 是通过一个计数器来实现的，计数器的初始值为初始任务 的数量。每当完成了一个任务后，计数器的值就会减 1 (CountDownLatch.countDown()方法)。当计数器值到达 0 时，它表示所有的已 经完成了任务，然后在闭锁上等待 CountDownLatch.await()方法的线程就可以恢 复执行任务。</p>

<pre><code class="language-java">public class MichaelShow {
    private static final AtomicInteger COUNT = new AtomicInteger(0);
    static class Customer extends Thread {
        private final CountDownLatch beQuiet;
        private final CountDownLatch beBoom;

        public Customer(CountDownLatch beQuiet, CountDownLatch beBoom) {
            this.beQuiet = beQuiet;
            this.beBoom = beBoom;
        }

        @Override
        public void run() {
            try {
                beQuiet.await();
                System.out.println(&quot;观众大喊：Michael Jackson， 我爱你！！！晕厥~~~&quot;);
                COUNT.getAndAdd(1);
                beBoom.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch startShow = new CountDownLatch(1);
        CountDownLatch beBoom = new CountDownLatch(100);
        for (int i = 0; i &lt; 100; i++) {
            new Customer(startShow,beBoom).start();
        }

        System.out.println(&quot;Michael号令，演唱会马上开始&quot;);
        startShow.countDown(); // 开始演唱会
        beBoom.await();// 等待晕厥到一定人数，将人送往医院
        System.out.println(&quot;观众晕厥&quot;+COUNT.get()+&quot;个，都被送往医院&quot;);
    }
}
</code></pre>

<h2 id="toc_1">CyclicBarrier</h2>

<p>CyclicBarrier 的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做 的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一 个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 </p>

<p>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截 的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然 后当前线程被阻塞。<br/>
CyclicBarrier还提供一个更高级的构造函数CyclicBarrie(r intparties，Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复 杂的业务场景。</p>

<pre><code class="language-java">public class HomeWorkCyclicBarrier {

    private static CyclicBarrier barrier
            = new CyclicBarrier(4, new Treacher());

    //存放子线程工作结果的容器
    private static ConcurrentHashMap&lt;String, Long&gt; resultMap
            = new ConcurrentHashMap&lt;&gt;();

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            Thread thread = new Thread(new Student());
            thread.start();
        }

    }

    /*汇总作业*/
    private static class Treacher implements Runnable {

        @Override
        public void run() {
            StringBuilder result = new StringBuilder();
            for (Map.Entry&lt;String, Long&gt; workResult : resultMap.entrySet()) {
                result.append( workResult.getValue()+&quot;、&quot;);
            }
            System.out.println(&quot;王老师批阅学生&quot; + result+&quot;的作业&quot;);
            System.out.println(&quot;王老师看学生搞对象&quot;);
        }
    }

    /*相互等待的子线程*/
    private static class Student implements Runnable {

        @Override
        public void run() {
            long id = Thread.currentThread().getId();
            resultMap.put(&quot;作业&quot;+Thread.currentThread().getId() + &quot;&quot;, id);
            try {
                Thread.sleep(1000 + id);
                System.out.println(&quot;学生&quot; + id + &quot;写作业&quot;);
                barrier.await();
                Thread.sleep(1000 + id);
                System.out.println(&quot;学生&quot; + id + &quot;搞对象&quot;);
                //barrier.await();
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
</code></pre>

<h3 id="toc_2">Semaphore</h3>

<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p>

<h4 id="toc_3">应用场景</h4>

<p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下：</p>

<pre><code class="language-java">public class DBPoolSemaphore {
    
    private final static int POOL_SIZE = 10;
    //两个指示器，分别表示池子还有可用连接和已用连接
    private final Semaphore useful,useless;
    //存放数据库连接的容器
    private static final LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();
    //初始化池
    static {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            pool.addLast(makeConnection());
        }
    }
    public DBPoolSemaphore() {
        this.useful = new Semaphore(10);
        this.useless = new Semaphore(0);
    }
    
    /*归还连接*/
    public void returnConnect(Connection connection) throws InterruptedException {
        if(connection!=null) {
            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;
                    +&quot;可用连接数：&quot;+useful.availablePermits());
            useless.acquire();
            synchronized (pool) {
                pool.addLast(connection);
            }
            useful.release();
        }
    }
    
    /*从池子拿连接*/
    public Connection takeConnect() throws InterruptedException {
        useful.acquire();
        Connection connection;
        synchronized (pool) {
            connection = pool.removeFirst();
        }
        useless.release();
        return connection;
    }
    
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15867863097702.html">
                
                  <h1>AbstractQueuedSynchronizer(AQS)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">了解 LockSupport</a>
</li>
<li>
<a href="#toc_1">AQS 使用方式</a>
</li>
<li>
<a href="#toc_2">AQS 源码解读</a>
<ul>
<li>
<a href="#toc_3">AQS 中的数据结构</a>
<ul>
<li>
<a href="#toc_4">Node节点</a>
</li>
<li>
<a href="#toc_5">head 和 tail</a>
</li>
<li>
<a href="#toc_6">state</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">节点在同步队列中的增加</a>
</li>
<li>
<a href="#toc_8">独占式同步状态获取与释放</a>
<ul>
<li>
<a href="#toc_9">获取同步状态</a>
</li>
<li>
<a href="#toc_10">释放同步状态</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">共享式同步状态获取与释放</a>
</li>
<li>
<a href="#toc_12">下面实现一个共享锁，代码如下：</a>
</li>
<li>
<a href="#toc_13">ConditionObject</a>
<ul>
<li>
<a href="#toc_14">ConditionObject的数据结构</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>AQS提供一个框架来实现基于先进先出(FIFO)同步队列的阻塞锁和相关同步器(信号量、事件等)。它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p>

<p>AQS同步器是实现锁(也可以是任意同步组件)的关键，在锁的实现中聚合同步器。</p>

<p>锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线 程并行访问)，隐藏了实现细节;</p>

<p>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、 线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者 所需关注的领域。</p>

<h2 id="toc_0">了解 LockSupport</h2>

<p>LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。</p>

<p>LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>

<p>LockSupport 增加了 park(Object blocker)、parkNanos(Object blocker,long nanos)和 parkUntil(Object blocker,long deadline)3 个方法，用于实现阻塞当前线程的功能，其中参数 blocker 是用来标识当前线程在等待的对象(以下称为阻塞对象)，线程被阻塞时记录此对象，以允许监视和诊断工具识别线程被阻塞的原因。<br/>
关于LockSupport给出一个样例</p>

<pre><code class="language-java">/**
 * 先入先出的不可重入锁
 */
public class FiFOMutex {

    private final AtomicBoolean locked = new AtomicBoolean(false);
    private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;&gt;();

    public void lock() {
        boolean wasInterrupted = false;
        Thread current = Thread.currentThread();
        waiters.add(current);

        // Block while not first in queue or cannot acquire lock
        while (waiters.peek() != current ||
                !locked.compareAndSet(false, true)) {
            LockSupport.park(this);
            if (Thread.interrupted()) // ignore interrupts while waiting
                wasInterrupted = true;
        }

        waiters.remove();
        if (wasInterrupted)          // reassert interrupt status on exit
            current.interrupt();
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
    
}
</code></pre>

<hr/>

<h2 id="toc_1">AQS 使用方式</h2>

<p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管 理同步状态，在 AQS 里由一个 int 型的 state 来代表这个状态，在抽象方法的实 现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的 3 个方法 (getState()、setState(int newState)和 compareAndSetState(int expect,int update)) 来进行操作，因为它们能够保证状态的改变是安全的。</p>

<p>AQS支持默认独占模式和共享模式来获取同步状态，子类应被定义为自定义同步组件的非公共静态内部类，AQS 自身不实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，这样就可以方便实现不同类型的同步组件(ReentrantLock、 ReentrantReadWriteLock、CountDownLatch、Semaphore、CyclicBarrier 等)。</p>

<p>AQS的设计者采用模板模式，提供一系列模板方法供不同类型的同步组件使用，如下所示：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>void acquire(int arg)</td>
<td>以独占木事获取同步状态，忽略中断，如果获取同步状态成功，直接返回true，否则将会进入同步队列中等待，该方法会调用重写的tryAcquire(int arg)方法</td>
</tr>
<tr>
<td>void acquireInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>以共享模式获取同步状态，忽略中断，当前线程未获取到同步状态，则进入同步队列等待，与acquire(int arg)不同的是，同一时刻可以有多个线程获取同步状态</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>以独占方式释放同步状态，在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
</tbody>
</table>

<p>AQS提供的支持类型的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Collection<Thread> getExclusiveQueuedThreads()</td>
<td>返回同步队列中以独占模式获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Thread getFirstQueuedThread()</td>
<td>返回同步队列中第一个（等待时间最长的）线程，或 null如果没有线程正在排队。</td>
</tr>
<tr>
<td>Collection<Thread> getQueuedThreads()</td>
<td>返回同步队列中的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getSharedQueuedThreads()</td>
<td>返回同步队列中以共享模式下获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getWaitingThreads(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>返回包含可能正在等待与此同步器关联的给定条件的线程。</td>
</tr>
<tr>
<td>boolean isQueued(Thread thread)</td>
<td>给定的线程当前在排队，则返回true。</td>
</tr>
<tr>
<td>boolean hasQueuedPredecessors()</td>
<td>是否有比当前线程更早排队的线程。该方法被设计为由一个公平的同步器使用</td>
</tr>
<tr>
<td>boolean hasWaiters(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>查询任何线程是否等待与此同步器相关联的给定条件。 请注意，由于超时和中断可能随时发生， true返回不能保证未来的signal将唤醒任何线程。 该方法主要用于监视系统状态。</td>
</tr>
<tr>
<td>isQueued(Thread thread)</td>
<td>如果给定的线程当前在排队，则返回true。</td>
</tr>
</tbody>
</table>

<p>需要子类重写的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>boolean tryAcquire(int arg)</td>
<td>以独占模式获取同步状态，需要查询当前状态，并判断同步状态是否符合预期，然后进行CAS设置同步状态</td>
</tr>
<tr>
<td>boolean tryAcquireShared(int arg)</td>
<td>以共享模式获取。 返回大于等于0的值，表示获取成功，否则，获取失败</td>
</tr>
<tr>
<td>boolean tryRelease(int arg)</td>
<td>独占模式下释放同步状态，等待获取同步状态的线程将有机会获取同步状态成功</td>
</tr>
<tr>
<td>boolean tryReleaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>当前同步器是否被当前线程所独占，此方法仅在AbstractQueuedSynchronizer.ConditionObject方法内部调用，因此如果不使用条件，则不需要定义该方法</td>
</tr>
</tbody>
</table>

<p>访问或修改同步状态的方法<br/>
重写同步器指定的方法时，需要使用同步器提供的如下 3 个方法来访问或修 改同步状态。<br/>
•getState():获取当前同步状态。<br/>
•setState(int newState):设置当前同步状态。<br/>
•compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<p>开发者可以自定义同步器，例如：</p>

<pre><code class="language-java">/**
 * 门闩锁
 */
class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() != 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled() ? 1 : -1;
     }

     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
 }
</code></pre>

<hr/>

<h2 id="toc_2">AQS 源码解读</h2>

<h3 id="toc_3">AQS 中的数据结构</h3>

<p><figure><img src="media/15867863097702/15874785413013.jpg" alt=""/></figure></p>

<h4 id="toc_4">Node节点</h4>

<p>Node节点是同步队列节点类。同步队列（由Node实现）是“CLH”(Craig、Landin和Hagersten)锁队列的变体，CLH锁通常用于自旋锁。<br/>
Node节点会存1、储线程信息；2、当前线程&quot;获取锁&quot;请求的状态（取消、通知下一节点）；3、当前节点的前驱和后驱节点等信息。</p>

<p>Node节点设计如下：</p>

<pre><code class="language-java">static final class Node {
        // 初始 共享模式节点
        static final Node SHARED = new Node();
        // 独占模式节点
        static final Node EXCLUSIVE = null;
        //表示由于超时或中断线程，已取消的等待状态值
        static final int CANCELLED = 1; 
        //表示当前节点在释放或取消的占用状态的时候需要将其后继节点的线程唤醒
        static final int SIGNAL = -1;
        //表示线程正在等待某个条件
        static final int CONDITION = -2;
        //表示一个被释放的节点应该被传播到其他节点。这是在doReleaseShared中设置的(仅针对head节点)，以确保传播能够继续，即使其他操作已经介入。
        static final int PROPAGATE = -3;
        // 线程”获取锁“ 的请求等待状态 0、CANCELLED、SIGNAL、PROPAGATE、CONDITION
        volatile int waitStatus;
        // 表示该节点的前一个 Node 节点(前驱)
        volatile Node prev;
        //表示该节点的后一个 Node 节点(后继)
        volatile Node next;
        // 表示该节点的代表的线程
        volatile Thread thread;
        // 表示等待 condition 条件的 Node 节点
        Node nextWaiter;
        // 是否共享模式
        final boolean isShared() {
            return nextWaiter == SHARED;
        }
        // 当前节点的前驱节点
        final Node predecessor() throws NullPointerException {
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }
        //用于建立初始标头或共享标头
        Node() {}
        
        Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }

        Node(Thread thread, int waitStatus) { // Used by Condition
            this.waitStatus = waitStatus;
            this.thread = thread;
        }
    }
</code></pre>

<h4 id="toc_5">head 和 tail</h4>

<p>head是指向Node同步队列的头结点，tail是指向Node同步队列的尾结点。</p>

<h4 id="toc_6">state</h4>

<p>同步器当前的的同步状态，通过下面3个方法进行访问：<br/>
•getState():获取当前同步状态。<br/>
•setState(int newState):设置当前同步状态。<br/>
•compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<hr/>

<h3 id="toc_7">节点在同步队列中的增加</h3>

<p>当一个线程成功地获取了同步状态(或者锁)，其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS 会将这个线程以及等待状态等信息构造成 为一个节点(Node)并将其加入同步队列的尾部。</p>

<p>而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于 CAS 的设置尾节点的方法: compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾 节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>

<p>首节点的变化<br/>
首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设 置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功 获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只需要将 首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。</p>

<h3 id="toc_8">独占式同步状态获取与释放</h3>

<p>首先看一下度展示同步状态获取与释放的流程图：<br/>
<figure><img src="media/15867863097702/15874795148241.jpg" alt=""/></figure></p>

<h4 id="toc_9">获取同步状态</h4>

<p>获取同步状态通过调用同步器的 acquire(int arg)方法可以获取同步状态，主要完成了同步 状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是:</p>

<p><strong>首先</strong>调用自定义同步器实现的 tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。<br/>
<strong>其次</strong>如果同步状态获取失败(tryAcquire 返回 false)，则构造同步节点(独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态)并通过 addWaiter(Node node)方法将该节点加入到同步队列的尾部，<br/>
<strong>最后</strong>调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环” 的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒 主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>

<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>

<p>从源码中可以看到获取同步状态代码只有3行代码，其中最重要的就是下面的三个方法：</p>

<ul>
<li>tryAcquire(int arg)</li>
</ul>

<p>尝试以独占模式获取。该方法应该查询对象的状态是否允许以独占模式获取它，如果允许，则应该获取它。需要我们自定义实现</p>

<pre><code class="language-java">protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
</code></pre>

<ul>
<li>addWaiter(Node node)</li>
</ul>

<p>将当前线程包装成 Node 后，队列不为空的情况下，先尝试把当前节点加入 队列并成为尾节点，如果不成功或者队列为空进入 enq(final Node node)方法</p>

<p>在 enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new 出一个空节点，并让首节点(head)和尾节点(tail)两个引用都指向这个空节点; 第二件事，把当前节点加入队列。<br/>
在“死循环”中只有通过 CAS 将节点设置成为尾节点之后，当前线程才能从 该方法返回，否则，当前线程不断地尝试设置。</p>

<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 尝试一次快速排队操作，失败的话，enq来补位。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        //保证线程安全的原子操作
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}

// 将节点插入队列，必要时进行初始化.
private Node enq(final Node node) {
    for (; ; ) {
        Node t = tail;
        if (t == null) { 
            // 对head节点进行初始化赋值，并头尾指向同一个节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // head和tail节点初始化之后，将node加到队列尾部
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>

<ul>
<li>acquireQueued(Node node, arg)</li>
</ul>

<p>其实就是一个自旋的过程，每个节点(或者说每个线程)都在自省地观察， 当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中(并会阻塞节点的线程)。<br/>
在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中 尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么?原因有两个。<br/>
第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br/>
第二，维护同步队列的 FIFO 原则。<br/>
当前线程获取到同步状态后，让首节点(head)这个引用指向自己所在节点。 当同步状态获取成功后，当前线程就从 acquire 方法返回了。如果同步器实现的 是锁，那就代表当前线程获得了锁。</p>

<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            //获取节点的前驱结点
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //是否要阻塞线程并判断是否被中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 如果
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h4 id="toc_10">释放同步状态</h4>

<p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的 release(int arg)方法可以释 放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节 点重新尝试获取同步状态)。</p>

<pre><code class="language-java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>

<p>该方法执行时，会唤醒首节点(head)所指向节点的后继节点线程， unparkSuccessor(Node node)方法使用 LockSupport 来唤醒处于等待状态的线程。</p>

<pre><code class="language-java">private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>

<p>这段代码的意思，一般情况下，被唤醒的是 head 指向节点的后继节点线程， 如果这个后继节点处于被 cancel 状态， 会转而从尾开始遍历，找到最前面且没有被 cancel 的节点。</p>

<hr/>

<h3 id="toc_11">共享式同步状态获取与释放</h3>

<p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时 获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p>

<p>因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于 等于 0。可以看到，在 doAcquireShared(int arg)方法的自旋过程中，如果当前节<br/>
  点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于 0，表示该次获 取同步状态成功并从自旋过程中退出。</p>

<pre><code class="language-java">public final void acquireShared(int arg) {
    // tryAcquireShared共享方式尝试获取资源。负数表示失败；0表示成功获得同步状态，但没有剩余可用资源；正数表示成功，且有剩余资源。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>

<p>我们看下doAcquireShared(int arg)方法的实现</p>

<pre><code class="language-java">// 以共享不可中断模式获取。
private void doAcquireShared(int arg) {
    // 构建当前线程的共享节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            // 获取当前节点的前驱节点，前驱节点如果是头结点的话，当前线程会尝试获取同步状态
            final Node p = node.predecessor();
            if (p == head) {
                // tryAcquireShared(int arg)方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    // 此处是与独占同步器的最大不同点
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果当前线程无法获取到同步状态，则在此处阻塞，等待被唤醒
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

// 设置新的头结点，并将获取的同步状态释放，通知后续节点共享锁资源
private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head;
        // 将node节点设置为头结点
        setHead(node);
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
                (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            //下个节点是共享模式的，则释放当前线程的
            if (s == null || s.isShared())
                // 当前线程释放锁，通知下一个节点
                doReleaseShared();
        }
    }
</code></pre>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够 支持多个线程同时访问的并发组件(比如 Semaphore)，它和独占式主要区别在 于 tryReleaseShared(int arg)方法必须确保同步状态(或者资源数)线程安全释放， 一般是通过循环和 CAS 来保证的，因为释放同步状态的操作会同时来自多个线程。</p>

<pre><code class="language-java">private void doReleaseShared() {
        
        for (; ; ) {
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    // 释放同步状态不成功的话，继续执行释放
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            
                    // 唤醒后续节点
                    unparkSuccessor(h);
                } else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))//确保传播能够继续
                    continue;
            }
            if (h == head) 
                break;
        }
    }
</code></pre>

<hr/>

<h3 id="toc_12">下面实现一个共享锁，代码如下：</h3>

<pre><code class="language-java">/**
 * 共享锁简单实现
 **/
public class SimpleShareLock implements Lock {

    private static final int OFFSET = 1;
    //为n表示允许n个线程同时获得锁
    private final Sync sync = new Sync(4 * OFFSET);

    private static final class Sync extends AbstractQueuedSynchronizer {

        Sync(int count) {
            if (count &lt;= 0) {
                throw new IllegalArgumentException(&quot;允许共享同步状态的线程数不能小于1&quot;);
            }
            setState(count);
        }

        /**
         * @param reduceCount 扣减个数
         * @return 返回小于0，表示当前线程获得同步状态失败，大于0表示当前线程获得同步状态成功
         */
        public int tryAcquireShared(int reduceCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current - reduceCount;
                // 需要保证线程安全使用CAS操作
                if (newCount &lt; 0 || compareAndSetState(current, newCount)) {
                    return newCount;
                }
            }
        }

        /**
         * @param returnCount 归还个数
         * @return
         */
        public boolean tryReleaseShared(int returnCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current + returnCount;
                if (compareAndSetState(current, newCount)) {
                    return true;
                }
            }
        }

        ConditionObject newCondition() {
            return new ConditionObject();
        }
    }

    public void lock() {
        sync.acquireShared(OFFSET);
    }

    public void unlock() {
        sync.releaseShared(OFFSET);
    }

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireSharedInterruptibly(OFFSET);
    }

    public boolean tryLock() {
        return sync.tryAcquireShared(OFFSET) &gt;= 0;
    }

    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(OFFSET, unit.toNanos(time));
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
</code></pre>

<hr/>

<h3 id="toc_13">ConditionObject</h3>

<p><figure><img src="media/15867863097702/15875725837865.jpg" alt=""/></figure></p>

<h4 id="toc_14">ConditionObject的数据结构</h4>

<p>等待队列是一个 FIFO 的队列，在队列中的每个节点都包含了一个线程引用， 该线程就是在 Condition 对象上等待的线程，如果一个线程调用了 Condition.await() 方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。</p>

<p>ConditionObject中的节点定义复用了同步器中节点的定义Node（但是node.waitStatus = Node.CONDITION）</p>

<p>一个 Condition 包含一个等待队列，Condition 拥有首节点(firstWaiter)和尾节点(lastWaiter)。</p>

<p>当前线程调用 Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition 拥有首尾节点的引用，而新增节点只需要将原有的尾节点 nextWaiter 指向它，并且更新尾节点即可。</p>

<p>上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是 获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br/>
<figure><img src="media/15867863097702/15875726221437.jpg" alt=""/></figure></p>

<p>调用 Condition 的 await()方法(或者以 await 开头的方法)，会使当前线程 进入等待队列并释放锁，同时线程状态变为等待状态。当从 await()方法返回时， 当前线程一定获取了 Condition 相关联的锁。</p>

<p>如果从队列(同步队列和等待队列)的角度看 await()方法，当调用 await() 方法时，相当于同步队列的首节点(获取了锁的节点)移动到 Condition 的等待 队列中。调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点， 该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同 步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤 醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用 Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。<br/>
<figure><img src="media/15867863097702/15875726951805.jpg" alt=""/></figure><br/>
如图所示，同步队列的首节点并不会直接加入等待队列，而是通过 addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。<br/>
<figure><img src="media/15867863097702/15875727427827.jpg" alt=""/></figure><br/>
调用 Condition 的 signal()方法，将会唤醒在等待队列中等待时间最长的节点 (首节点)，在唤醒节点之前，会将节点移到同步队列中。</p>

<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程。</p>

<p>通过调用同步器的 enq(Node node)方法，等待队列中的头节点线程安全地移 动到同步队列。当节点移动到同步队列后，当前线程再使用 LockSupport 唤醒该 节点的线程。</p>

<p>被唤醒后的线程，将从 await()方法中的 while 循环中退出 (isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中)，进而调 用同步器的 acquireQueued()方法加入到获取同步状态的竞争中。</p>

<p>成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的 await() 方法返回，此时该线程已经成功地获取了锁。</p>

<p>Condition 的 signalAll()方法，相当于对等待队列中的每个节点均执行一次 signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每 个节点的线程</p>

<p>ConditionObject 是同步器的条件实现。</p>

<pre><code class="language-java">/**
 * 条件等待
 */
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    // 释放当前线程持有的同步状态，并返回释放之前的同步状态
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // 当前节点是否被移到同步队列, 如果在等待队列，则进行阻塞
    while (!isOnSyncQueue(node)) {
        // 阻塞condition上的当前线程，等待signal信号唤醒
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //此时进入阻塞队列，自旋获取锁
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}

/**
 * 唤醒条件Condition上的阻塞线程
 */
 public final void signal() {
    // 非当前线程持有同步状态 抛出异常
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

// 删除和传输节点，直到命中不可取消的一个或null。
private void doSignal(Node first) {
    do {
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
            (first = firstWaiter) != null);
}

final boolean transferForSignal(Node node) {
    // 释放当前节点同步状态
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    // 将节点存入同步队列列尾
    Node p = enq(node);
    int ws = p.waitStatus;
    // 同步状态已取消 或 设置同步状态失败，则唤醒节点线程并重新同步。
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="ThreadLocal.html">
                
                  <h1>ThreadLocal源码分析以及使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">ThreadLocal结构分析</a>
</li>
<li>
<a href="#toc_1">ThreadLocal的源码解析</a>
</li>
<li>
<a href="#toc_2">ThreadLocalMap解析</a>
<ul>
<li>
<a href="#toc_3">ThreadLocalMap源码分析</a>
</li>
<li>
<a href="#toc_4">ThreadLocal的引用关系</a>
<ul>
<li>
<a href="#toc_5">内存泄漏问题及解决办法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Hash冲突怎么解决</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">线程不安全问题</a>
</li>
</ul>


<p>ThreadLocal该类提供线程局部变量，起到线程隔离的作用。</p>

<h2 id="toc_0">ThreadLocal结构分析</h2>

<ul>
<li>首先我们看下ThreadLocal和Thread的它们之间的关系，如下图所示：</li>
</ul>

<p><figure><img src="media/15864440934982/15865132297584.jpg" alt=""/></figure></p>

<p><strong>Thread类内部声明了一个ThreadLocal.ThreadLocalMap类型的变量 threadLocals</strong>，ThreadLocal类负责维护ThreadLocal与Thread 之间关系的 ThreadLocalMap散列映射。</p>

<h2 id="toc_1">ThreadLocal的源码解析</h2>

<p><figure><img src="media/15864440934982/15865038471517.jpg" alt=""/></figure></p>

<p>我们一起来看下ThreadLocal 内部代码</p>

<pre><code class="language-java">// 创建线程和ThreadLocal的关联映射
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// 获取线程 t 的threadLocalMap
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// 设置当前线程的局部变量值
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

//获取当前线程的局部变量值
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

// 设置初始值
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

// 移除此线程局部变量的当前线程值。
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
</code></pre>

<h2 id="toc_2">ThreadLocalMap解析</h2>

<h3 id="toc_3">ThreadLocalMap源码分析</h3>

<p><figure><img src="media/15864440934982/15865034564443.jpg" alt=""/></figure></p>

<pre><code class="language-java">
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        // k已经过时，被垃圾回收啦
        if (k == null) 
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}

private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    
    // 发生了hash碰撞问题，采用线性探测法，按照一定步长查找下一个位置，直到找到空余的位置存放value值为止,如果遇到过时的局部变量值，则将过时的value值替换为新的value值
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key) {
            e.value = value;
            return;
        }
        // 遇到过时的线程局部变量
        if (k == null) {
            // 用指定键的项替换set操作期间遇到的过时项。
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    // entry 条目个数大于表的扩容阈值的时候
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        // 重新调整table的大小。首先扫描整个表，删除陈旧的条目。如果这还不足以缩小表的大小，则将表的大小加倍。
        rehash();
}


private void remove(ThreadLocal&lt;?&gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear(); // 清除ThreadLocal引用
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
            return;
        }
    }
}

private void rehash() {
    // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
    expungeStaleEntries();

    // 使用较低的阈值加倍，以避免扩容滞后
    if (size &gt;= threshold - threshold / 4)
        resize();
}
</code></pre>

<h3 id="toc_4">ThreadLocal的引用关系</h3>

<p>ThreadLocal的引用关系 如下图所示：</p>

<p><figure><img src="media/15864440934982/15865783936571.jpg" alt="" style="width:708px;"/></figure></p>

<h4 id="toc_5">内存泄漏问题及解决办法</h4>

<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么下次gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链： <br/>
current thread 引用 -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value <br/>
永远无法回收，造成内存泄露。</p>

<p>针对这种情况ThreadLocalMap提供了一些防护措施：</p>

<ul>
<li><p>1、 getEntry(ThreadLocal&lt;?&gt; key)、set(ThreadLocal&lt;?&gt; key, Object value)提供了针对key为null的entry的擦除操作expungeStaleEntry(i)</p></li>
<li><p>2、 remove(ThreadLocal&lt;?&gt; key)方法内部提供了针对ThreadLocal的擦除操作</p></li>
</ul>

<p>如下代码所示：</p>

<pre><code class="language-java">public class ThreadLocalContext {

    private static final ThreadLocal&lt;Object&gt; UNKNOWN_THREAD_LOCAL = new ThreadLocal&lt;&gt;();

    public static Object get() {
        return UNKNOWN_THREAD_LOCAL.get();
    }

    public static void set(Object value) {
        UNKNOWN_THREAD_LOCAL.set(value);
    }

    public static void remove(){
        UNKNOWN_THREAD_LOCAL.remove();
    }
}

/**
 * ThreadLocal内存泄漏的风险演示
 * -XX:+PrintGCDetails -Xmx50m
 * @author goddess
 * @since 2020/4/8 23:16
 **/
public class ThreadOOM {

    static class UseData {
        private byte[] element = new byte[1024 * 1024 * 10];// 10M
    }

    static class UseThreadOOM implements Runnable {
        @Override
        public void run() {
            ThreadLocalContext.set(new UseData());
            //ThreadLocalContext.remove();
        }
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 3000; i++) {
                executorService.execute(new UseThreadOOM());
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }
}
</code></pre>

<p>放开ThreadLocalContext.remove的gc信息<br/>
<figure><img src="media/15864440934982/15865803964880.jpg" alt="" style="width:1569px;"/></figure></p>

<p>注释掉ThreadLocalContext.remove的部分gc信息：<br/>
<figure><img src="media/15864440934982/15865798232002.jpg" alt="" style="width:1570px;"/></figure></p>

<p><strong>方式1 的前提条件是当key为null的时候咱得去调用getEntry、set方法，单这并不是任何时候都会执行的操作，所以保险的做法就是手动调用ThreadLocal的remove函数，删除不再需要的ThreadLocal，防止内存泄露。</strong></p>

<h3 id="toc_6">Hash冲突怎么解决</h3>

<p>ThreadLocalMap当执行set(Object value)的时候可能会发生hash冲突，当发生了hash碰撞的时候，map采用了一种<strong>线性探测法(就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用,按照一定步长查找下一个位置，直到找到空余的位置存放value值为止)</strong></p>

<p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置，如下代码：</p>

<pre><code class="language-text">private static int nextIndex(int i, int len) {
    return ((i + 1 &lt; len) ? i + 1 : 0);
}
private static int prevIndex(int i, int len) {
    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);
}
</code></pre>

<p>如果有大量不同的ThreadLocal对象放入ThreadLocalMap中时发一次或多次hash冲突，就要多次执行线性探测法，则效率很低。</p>

<p><strong>建议：</strong> 由于存在hash冲突问题，每个线程只存一个ThreadLocal变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，可以避免hash碰撞引起效率低下的问题。</p>

<h2 id="toc_7">线程不安全问题</h2>

<p>记住一点，本次线程任务使用完ThreadLocal之后要调用threadLocal.remove()方法。当使用线程池的时候，线程执行完任务之后，线程并不会消亡，而是重新回到了线程池中，等待下次任务的分派。可能产生的问题：<strong>造成线程不安全的问题，访问threadLocal.get()获取的值可能不是自己预期的变量值</strong><br/>
看如下代码：</p>

<pre><code class="language-java">public class ThreadUnsafe {

    static class UseThreadUnsafe implements Runnable {
        private int value;

        UseThreadUnsafe(int value) {
            this.value = value;
        }

        @Override
        public void run() {
            Object o = ThreadLocalContext.get();
            if (o == null) {
                ThreadLocalContext.set(value+1);
            }
            System.out.println(Thread.currentThread().getName()+&quot; 线程局部变量表：&quot; + ThreadLocalContext.get());
            // tips：开启和注释的情况下完全不一样
            ThreadLocalContext.remove();
        }
    }


    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 6; i++) {
                executorService.execute(new UseThreadUnsafe(i));
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }

}
</code></pre>

<p>开启的情况下：<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：5<br/>
pool-1-thread-3 线程局部变量表：4<br/>
pool-1-thread-1 线程局部变量表：6</p>

<p>注释的情况下：<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3</p>

<hr/>

<p><strong>综上所述 ThreadLocal使用完变量之后，千万要记着调用ThreadLocal的remove()完成擦除操作</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15853612430664.html">
                
                  <h1>java线程基础</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">基础概念</h2>

<ul>
<li><p>什么是进程和线程</p>
<ul>
<li>进程是程序运行资源分配的最小单位。其中资源包括：cpu、内存空间、磁盘IO等，同一个进程中的多条线程共享该进程中的全部系统资源。</li>
<li>线程是cpu调度的最小单位，必须依赖于进程存在。<br/>
cpu通过轮转机制会公平的把 cpu 时间分配给各个线程，在线程的切换的过程中，会产生线程上下文开销，也称为 RR 调度</li>
</ul></li>
<li><p>什么是并行和并发<br/>
并行：同一时刻，可以处理事情的能力。<br/>
并发：单位时间内，处理事情的能力。例如：1秒内，一个应用内可以处理10个提交任务，</p></li>
<li><p>高并发编程的意义和注意事项<br/>
操作系统会限制线程数量，以防线程耗尽系统资源，Linux：1000个；windows：2000个</p>
<ul>
<li>优点：
<ul>
<li>可以充分利用系统资源</li>
<li>加快系统对用户的响应速度</li>
</ul></li>
<li>弊端： 
<ul>
<li>存在资源竞争关系</li>
<li>可能会产生死锁</li>
<li>消耗系统资源</li>
</ul></li>
</ul></li>
</ul>

<hr/>

<h2 id="toc_1">java 语言的线程</h2>

<h3 id="toc_2">构建线程的方式</h3>

<p>Thread类、Runnable接口，Thread类是对线程的抽象，Runnable是对任务的抽象</p>

<h3 id="toc_3">线程终止的方式：</h3>

<ul>
<li>自然终止<br/>
run方法执行完毕或者跑出一个未处理的异常导致线程提前结束</li>
<li>中断
<ul>
<li>interrupt()<br/>
中断线程通知，非强制打断，中断标志位设置为true(已中断)</li>
<li>isInterrupted()<br/>
线程通过此方法判断是否被中断</li>
<li>static interrupted()<br/>
线程通过此方法判断是否被中断，中断标志位会进行重置为false</li>
</ul></li>
</ul>

<p>*** 注意：***</p>

<ul>
<li>stop()、destroy()、suspend()、resume()官方已作为废弃API处理</li>
<li>处于死锁状态的线程不会被中断</li>
</ul>

<h3 id="toc_4">run()和 start()区别</h3>

<ul>
<li>run() 不会新启线程，可以视为普通的业务方法，执行run()方法，当前线程是主线程</li>
<li>start() 启动新线程</li>
</ul>

<h3 id="toc_5">join()</h3>

<p>ThreadA.join() 是先等待ThreadA运行至死亡</p>

<h3 id="toc_6">yield()</h3>

<p>将线程从运行态转到就绪态,是当前线程让出cup占有权,让出的时间不可设定。不会释放锁资源。<br/>
当执行yield()之后进入就绪态的线程，有可能立即又被cpu捡起来去执行了</p>

<h3 id="toc_7">线程优先级</h3>

<p>1~10，缺省 5<br/>
thread.setPriority(int xx); 优先级不是特别靠谱的东西</p>

<h3 id="toc_8">守护线程</h3>

<p>守护线程是一种支持型线程，因为它主要被用作程序中 后台调度以及支持性工作。<br/>
通过Thread.setDaemon(true)将线程设置为守护线程。</p>

<p>线程的状态切换<br/>
<figure><img src="media/15853612430664/15862720985637.jpg" alt="" style="width:937px;"/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="java并发编程.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
