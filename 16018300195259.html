<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    Netty 面试题 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            Netty 面试题   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/10/05</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='%E9%9D%A2%E8%AF%95%E9%A2%98.html'>面试题</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2 id="toc_0">Netty 的特点</h2>

<p>一个高性能、异步事件驱动的NIO框架，它提供了 TCP、UDP和文件传输的支持</p>

<p>使用更高效的 socket 底层，对 epoll 空轮询引起的 cpu 占用率飙升在内部进行了处理，避免了直接使用 NIO 的陷阱，简化了 NIO 的处理方式。</p>

<p>使用多种 decoder/encoder支持，对 TCP 粘包/分包进行自动化处理</p>

<p>可使用接收/处理线程池，提高连接效率，对重连、心跳检测的简单支持</p>

<p>可配置 IO 线程数，TCP 参数， TCP接收和发送缓冲区使用直接内存代替堆内存，哦通过内存池的方式循环利用 ByteBuf，通过引用计数器以及申请释放不再引用的对象，降低了 GC 频率。</p>

<p>使用单线程串行化的方式，高效的 Reactor 线程模型</p>

<p>大量使用了 volatile、使用了 CAS 和原子类、线程安全类的使用、读写锁的使用。</p>

<h2 id="toc_1">Netty 的线程模型</h2>

<p>Netty 通过 Reactor 模型给予多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss线程池的线程负责处理请求的 accept事件，当接受到 accept 事件的请求时，把对应的socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 handler 处理。</p>

<p>单线程模型： 所有 IO 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求，向服务端发起连接，又要读取请求或响应消息。一个 NIO 线程同时处理成败上千的链路，性能上无法支撑，数度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不适合。</p>

<p>多线程模型：有一个 NIO 线程(Acceptor) 只负责监听服务端，接收客户端的 TCP 连接请求； NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送;一个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个acceptor 线程可能会存在性能不足的问题而成为瓶颈。</p>

<p>主从多线程模型： Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 IO 的读写等操作，从而保证 mainReactor 只负责介入认证、握手等操作。</p>

<h2 id="toc_2">Netty 中有哪些重要组件?</h2>

<ul>
<li>Channel: Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。</li>
<li>EventLoop:主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。</li>
<li>ChannelFuture: Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功 或者失败时，监听就会自动触发返回结果。</li>
<li>ChannelHandler: 充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用 来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li>
<li>ChannelPipeline: 为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动 分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>

<h2 id="toc_3">TCP 粘包/拆包的原因及解决方法</h2>

<p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p>

<p>TCP 粘包/分包的原因:<br/>
应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序 写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘 包现象;</p>

<p>进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度&gt;MSS 的时候将发生拆包</p>

<p>以太网帧的 payload(净荷)大于 MTU(1500 字节)进行 ip 分片</p>

<p>解决方法<br/>
消息定长:FixedLengthFrameDecoder 类<br/>
包尾增加特殊字符分割:行分隔符类:LineBasedFrameDecoder 或自定义分隔符类 : DelimiterBasedFrameDecoder<br/>
将消息分为消息头和消息体:LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p>

<h2 id="toc_4">请概要介绍下序列化</h2>

<p>序列化(编码)是将对象序列化为二进制形式(字节数组)，主要用于网络传输、数据 持久化等;而反序列化(解码)则是将从网络、磁盘等读取的字节数组还原成原始对象，主 要用于网络传输对象的解码，以便完成远程调用。</p>

<p>影响序列化性能的关键因素:序列化后的码流大小(网络带宽的占用)、序列化的性能 (CPU 资源占用);是否支持跨语言(异构系统的对接和开发语言切换)。</p>

<ul>
<li><p>Java 默认提供的序列化:无法跨语言、序列化后的码流太大、序列化的性能差</p></li>
<li><p>XML，优点:人机可读性好，可指定元素或特性的名称。缺点:序列化数据只包含数据 本身以及类的结构，不包括类型标识和程序集信息;只能序列化公共属性和字段;不能序列 化方法;文件庞大，文件格式复杂，传输占带宽。适用场景:当做配置文件存储数据，实时 数据转换。</p></li>
<li><p>JSON，是一种轻量级的数据交换格式，优点:兼容性高、数据格式比较简单，易于读 写、序列化后数据较小，可扩展性好，兼容性好、与 XML 相比，其协议比较简单，解析速 度比较快。缺点:数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开 销比较大。适用场景(可替代XML):跨防火墙访问、可调式性要求高、基于 Web browser 的 Ajax 请求、传输数据量相对小，实时性要求相对低(例如秒级别)的服务。</p></li>
<li><p>Thrift，不仅是序列化协议，还是一个 RPC 框架。优点:序列化后的体积小, 速度快、 支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩 编码。缺点:使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、 不能与其他传输层协议共同使用(例如 HTTP)、无法支持向持久层直接读写数据，即不适 合做数据持久化序列化协议。适用场景:分布式系统的 RPC 解决方案</p></li>
<li><p>Protobuf，将数据结构以.proto 文件进行描述，通过代码生成工具可以生成对应数据结 构的 POJO 对象和 Protobuf 相关的方法和属性。优点:序列化后码流小，性能高、结构化数 据存储格式(XML JSON 等)、通过标识字段的顺序，可以实现协议的前向兼容、结构化的 文档更容易管理和维护。缺点:需要依赖于工具生成代码、支持的语言相对较少，官方只支持 Java 、C++ 、python。适用场景:对性能要求高的 RPC 调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</p></li>
</ul>

<p>其它</p>

<ul>
<li>protostuff 基于 protobuf 协议，但不需要配置 proto 文件，直接导包即可</li>
<li>Jboss marshaling 可以直接序列化 java 类， 无须实java.io.Serializable 接口</li>
<li>Message pack 一个高效的二进制序列化格式</li>
<li>Hessian 采用二进制协议的轻量级 remoting onhttp 工具</li>
<li>kryo 基于 protobuf 协议，只支持 java 语言,需要注册(Registration)，然后序列化(Output)， 反序列化(Input)</li>
</ul>

<h2 id="toc_5">Netty 是如何解决 JDK 中的 Selector BUG 的</h2>

<p>Selector BUG:JDK NIO 的 BUG，例如臭名昭著的 epoll bug，它会导致 Selector 空轮询， 最终导致 CPU 100%。官方声称在 JDK1.6 版本的 update18 修复了该问题，但是直到 JDK1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有被根本解决。</p>

<p>这个问题的具体原因是:在部分 Linux 的 2.6 的 kernel 中，poll 和 epoll 对于突然中断的 连接 socket 会对返回的 eventSet 事件集合置为 POLLHUP，也可能是 POLLERR，eventSet 事件 集合发生了变化，这就可能导致 Selector 会被唤醒。这个时候 selector 的 select 方法，返回 numKeys 是 0，所以下面本应该对 key 值进行遍历的事件处理根本执行不了，又回到最上面的 while(true)循环，循环往复，不断的轮询，直到 linux 系统出现 100%的 CPU 情况，最终导 致程序崩溃。</p>

<p>修复的办法有两个:</p>

<ul>
<li>将 SelectKey 去除掉，然后“刷新”一下 Selector，刷新的方式也就是调用<br/>
Selector.selectNow 方法，这种修改仍然不是可靠的，一共有两点:
<ul>
<li>多个线程中的 SelectionKey 的 key 的 cancel，很可能和下面的 Selector.selectNow 同时并发，如果是导致 key 的 cancel 后运行很可能没有效果</li>
<li>与其说第一点使得 NIO 空转出现的几率大大降低，经过 Jetty 服务器的测试报告发现，这种重复利用 Selector 并清空 SelectionKey 的改法很可能没有任何的效果。</li>
</ul></li>
<li>创建一个新的 Selector，这种处理方法要保险的多，基本上不会有任何的问题。<br/>
Netty 采用就是这种解决办法: 对 Selector 的 select 操作周期进行统计，每完成一次空 的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则触发了 epoll 死循环 bug。重建 Selector，判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从 旧的 Selector 上去除注册，重新注册到新的 Selector 上，并将原来的 Selector 关闭。</li>
</ul>

<h2 id="toc_6">Netty 的优势有哪些?</h2>

<p>使用简单:封装了 NIO 的很多细节，使用更简单。<br/>
功能强大:预置了多种编解码功能，支持多种主流协议。<br/>
定制能力强:可以通过 ChannelHandler 对通信框架进行灵活地扩展。<br/>
性能高:通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。<br/>
稳定:Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身。 <br/>
社区活跃:Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。</p>

<h2 id="toc_7">Netty 高性能表现在哪些方面?</h2>

<ul>
<li>IO 线程模型:同步非阻塞，用最少的资源做更多的事。</li>
<li>内存零拷贝:尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li>内存池设计:申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管 理内存分配情况。</li>
<li>串形化处理读写:避免使用锁带来的性能开销。即消息的处理尽可能在同一个线程内完 成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多 个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模 型性能更优。</li>
<li>高性能序列化协议:支持 protobuf 等高性能序列化协议。</li>
<li>高效并发编程的体现:volatile 的大量、正确使用; CAS 和原子类的广泛使用;线程安全容器的使用;通过读写锁提升并发性能。</li>
</ul>

<h2 id="toc_8">Netty 发送消息有几种方式?</h2>

<p>Netty 有两种发送消息的方式:</p>

<ul>
<li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动;</li>
<li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。</li>
</ul>

<h2 id="toc_9">Netty 的内存管理机制是什么</h2>

<p>首先会预申请一大块内存 Arena，Arena 由许多 Chunk 组成，而每个 Chunk 默认由 2048 个 page 组成。</p>

<p>Chunk 通过 AVL 树的形式组织 Page，每个叶子节点表示一个 Page，而中间节点表示内 存区域，节点自己记录它在整个 Arena 中的偏移地址。</p>

<p>当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的 所有节点都已被分配了。</p>

<p>大于 8k 的内存分配在 poolChunkList 中，而 PoolSubpage 用于分配小于 8k 的内存，它会 把一个 page 分割成多段，进行内存分配。</p>

<h2 id="toc_10">ByteBuf 的特点</h2>

<p>支持自动扩容(4M)，保证 put 方法不会抛出异常、通过内置的复合缓冲类型，实现<br/>
零拷贝(zero-copy);</p>

<p>不需要调用 flip()来切换读/写模式，读取和写入索引分开;</p>

<p>引用计数基于原子变量 AtomicIntegerFieldUpdater 用于内存回收;</p>

<p>PooledByteBuf 采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次 使用都新建一个缓冲区对象。UnpooledHeapByteBuf 每次都会新建一个缓冲区对象</p>

<h2 id="toc_11">select、poll、epoll的区别，以及如何选择</h2>

<p>select，poll，epoll 都是 操作系统实现 IO 多路复用的机制。 我们知道，I/O 多路复用 就通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)， 能够通知程序进行相应的读写操作，那么select、poll、epoll 的区别有哪些呢？</p>

<table>
<thead>
<tr>
<th>操作</th>
<th>描述符限制</th>
<th>IO效率</th>
<th>消息传递方式</th>
</tr>
</thead>

<tbody>
<tr>
<td>select</td>
<td>单个进程所能打开的最大连接数有 FD_SETSIZE 宏定义，其大小是 32 个整数的大小(在 32 位的机器上，大小就是 1024，同理 64 位机器上 FD_SETSIZE 为 2048)，当然我们可以对进行修改，然后重新编译内核， 但是性能可能会受到影响。</td>
<td>因为每次调用时都会对连接进行线性遍历，所以随着 FD 的增加会造 成遍历速度慢的“线性下降性能问题”</td>
<td>内核需要将消息传递到用户空间，都需要内核考贝动作</td>
</tr>
<tr>
<td>poll</td>
<td>poll 本质上和 select 没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td>
<td>同上</td>
<td>同上</td>
</tr>
<tr>
<td>epoll</td>
<td>它所支持的FD上限是操作系统的最大文件句柄数，远远大于1024，可通过 cat/proc/sys/fs/file -max 查看，这个数可系统内存关系比较大</td>
<td>epoll 只会对活跃的socket进行操作，epoll会根据每个fd上的回调函数实现。如果所有的socket处于活跃状态，则epoll的效率并不比select/poll效率高多少，在活跃socket比较少的情况下，epoll效率不成为题</td>
<td>epoll 通过内核和用户空间共享一块内存 mmap 来实现</td>
</tr>
</tbody>
</table>

<p>无论是 select、poll还是epol都需要内核把FD消息通知给用户空间,如何避免不必要的内存复制就显得非常重要，epoll 通过内核和用户空间共享一块内存mmap来避免不必要的内存复制。</p>

<p>在选择 select，poll，epoll 时要根据具体的使用场合以及这三种方式的自身特点。</p>

<ul>
<li><p>表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。</p></li>
<li><p>select 低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</p></li>
</ul>

<h2 id="toc_12">什么是水平触发(LT)和边缘触发(ET)?</h2>

<p>Level_triggered(水平触发):当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么 下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果 你一直不去读写，它会一直通知你!!!如果系统中有大量你不需要读写的就绪文件描述符， 而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率!!!</p>

<p>Edge_triggered(边缘触发):当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调 用 epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第 二次可读写事件才会通知你!!!这种模式比水平触发效率高，系统不会充斥大量你不关心 的就绪文件描述符!!</p>

<p>select(),poll()模型都是水平触发模式，信号驱动 IO 是边缘触发模式，epoll()模型即支持 水平触发，也支持边缘触发，默认是水平触发。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  















  
    




  </body>
</html>
