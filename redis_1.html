<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  redis - 大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15938782048225.html">
                
                  <h1>六、Redis 数据流 stream</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1、stream 实现</h2>

<p>消息队列是分布式系统中不可缺少的组件之一，主要有异步处理、应用解耦、限流削峰的功能。目前应用较为广泛的消息队列有RabbitMQ、RocketMQ、Kafka等。Redis在最新的5.0.0版本中也加入了消息队列的功能，这就是Stream。</p>

<p>Redis Stream 它主要由消息、生产者、消费者、消费组4部分组成。可以通过如下指令创建一个消息流并项其中加入一条消息<br/>
<figure><img src="media/15938782048225/15939414214436.jpg" alt="" style="width:800px;"/></figure></p>

<pre><code class="language-text">xadd mystream * name zhangsan age 10
</code></pre>

<p>上面的命令中</p>

<ul>
<li>mystream 为 Stream 的名称；</li>
<li>* 代表由Redis自行生成消息ID；</li>
<li>name、age为该消息的field；hb、20则为对应的field的值。</li>
</ul>

<p>每个消息都由以下两部分组成:</p>

<ul>
<li>每个消息有唯一的消息ID，消息ID严格递增。</li>
<li>消息内容由多个field-value对组成。</li>
</ul>

<p>生产者负责向消息队列中生产消息，消费者消费某个消息流。消费者可以归属某个消费组，也可以不归属任何消费组。当消费者不归属于任何消费组时，该消费者可以消费消息队列中的任何消息。</p>

<p>消费组是Stream 具有如下特点</p>

<ul>
<li>每个消费组通过组名称唯一标识，每个消费组都可以消费该消息队列的全部消息，多个消费组之间相互独立。</li>
<li>每个消费组可以有多个消费者，消费者通过名称唯一标识，消费者之间的关系是竞争关系，也就是说一个消息只能由该组的一个成员消费。</li>
<li>组内成员消费消息后需要确认，每个消息组都有一个待确认消息队列（pending entry list，pel），用以维护该消费组已经消费但没有确认的消息。</li>
<li>消费组中的每个成员也有一个待确认消息队列，维护着该消费者已经消费尚未确认的消息。</li>
</ul>

<p>Redis Stream的底层实现主要使用了listpack以及Rax树</p>

<h3 id="toc_1">1.1、stream 底层结构 listpack</h3>

<p>listpack 是一个字符串列表的序列化格式，也就是将一个字符串列表进行序列化存储。Redis listpack可用于存储字符串或者整型。</p>

<p><figure><img src="media/15938782048225/15938831394252.jpg" alt="listpack结构图"/><figcaption>listpack结构图</figcaption></figure></p>

<p>listpack由4部分组成：</p>

<ul>
<li>Total Bytes：整个listpack的空间大小，占用4个字节，每个listpack最多占用4294967295Bytes。</li>
<li>Num Elem：listpack中的元素个数，即Entry的个数，占用2个字节<br/>
虽然占用2个字节，但是并不意味着listpack最多只能存放65535个Entry，当Entry个数大于等于65535时，Num Elem被设置为65535，此时如果需要获取元素个数，需要遍历整个listpack</li>
<li>End：listpack结束标志，占用1个字节，内容为0xFF。</li>
<li>Entry： 每个具体的元素，其内容可以为字符串或者整型。
<ul>
<li>encode： 该entry元素的编码，占用1个字节</li>
<li>content：entry元素内容</li>
<li>backlen： 记录了这个Entry的长度（Encode+content）</li>
</ul></li>
</ul>

<h3 id="toc_2">1.2、Stream底层结构Rax</h3>

<p>前缀树是字符串查找时，经常使用的一种数据结构，能够在一个字符串集合中快速查找到某个字符串, 但是由于前缀树中每个节点只存储字符串中的一个字符，故而有时会造成空间的浪费。Rax的出现就是为了解决这一问题，Rax中不仅可以存储字符串，同时还可以为这个字符串设置一个值，也就是key-value。</p>

<p><figure><img src="media/15938782048225/15939279706367.jpg" alt="含有两个压缩节点的rax"/><figcaption>含有两个压缩节点的rax</figcaption></figure></p>

<p><figure><img src="media/15938782048225/15939288033339.jpg" alt="含有foobar,footer两个key的Rax"/><figcaption>含有foobar,footer两个key的Rax</figcaption></figure></p>

<pre><code class="language-c">typedef struct rax {    
     raxNode *head;     //指向头节点的指针
     uint64_t numele;     //key的个数
     uint64_t numnodes; //节点个数
} rax;

typedef struct raxNode {     
    uint32_t iskey:1;   /* 当前节点是否包含一个key，占用1bit*/     
    uint32_t isnull:1;  /* 当前key对应的value是否为空，占用1bit */     
    uint32_t iscompr:1; /* 当前节点是否为压缩节点，占用1bit */     
    uint32_t size:29;   /* 压缩节点压缩的字符串长度或者非压缩节点的子节点个数，占用29bit */
    unsigned char data[];  /*包含填充字段，同时存储了当前节点包含的字符串以及子节点的指针、key对应的value指针。*/
} raxNode;
</code></pre>

<p>raxNode分为2类，压缩节点和非压缩节点</p>

<ul>
<li>压缩节点 。我们假设该节点存储的内容为字符串ABC
<figure><img src="media/15938782048225/15939314326955.jpg" alt=""/></figure>
<ul>
<li>·iskey为1且isnull为0时，value-ptr存在，否则value-ptr不存在；</li>
<li>·iscompr为1代表当前节点是压缩节点，size为3代表存储了3个字符；</li>
<li>紧随size的是该节点存储的字符串，根据字符串的长度确定是否需要填充字段（填充必要的字节，使得后面的指针地址放到合适的位置上）；</li>
<li>由于是压缩字段，故而只有最后一个字符有子节点。</li>
</ul></li>
<li>非压缩节点 。我们假设其内容为XY
<figure><img src="media/15938782048225/15939394205610.jpg" alt=""/></figure>
每个字符都有一个子节点，值得一提的是，字符个数小于2时，都是非压缩节点。</li>
</ul>

<h2 id="toc_3">2、stream 结构</h2>

<p>Redis Stream的实现依赖于Rax结构以及listpack结构，每个消息的具体信息存储在这个listpack中。Rax用于快速索引；listpack用于存储具体的消息</p>

<p>每个listpack都有一个master entry，该结构中存储了创建这个listpack时待插入消息的所有field，这主要是考虑同一个消息流，消息内容通常具有相似性，如果后续消息的field与master entry内容相同，则不需要再存储其field。</p>

<p>每个listpack中可能存储多条消息</p>

<p><figure><img src="media/15938782048225/15939395823945.jpg" alt="Stream结构"/><figcaption>Stream结构</figcaption></figure></p>

<p>Stream结构如下</p>

<pre><code class="language-c">/*
*每个Stream会有多个消费组，每个消费组通过组名称进行唯一标识，
*同时关联一个streamCG结构，
*/
typedef struct stream {     
   /*
   存储消息生产者生产的具体消息，每个消息有唯一的ID。
   以消息ID为键，消息内容为值存储在rax中，
   值得注意的是，rax中的一个节点可能存储多个消息， 
   */     
    rax *rax;             
    /*当前stream中的消息个数（不包括已经删除的消息）*/
    uint64_t length;     
    /*当前stream中最后插入的消息的ID，stream为空时，设置为0*/   
    streamID last_id;
    /*存储了当前stream相关的消费组，以消费组的组名为键，streamCG为值存储在rax中*/
    rax *cgroups;
} stream;

/*消费组结构定义*/
typedef struct streamCG {
    /*last_id为该消费组已经确认的最后一个消息的ID*/
    streamID last_id; 
    /*该消费组尚未确认的消息，并以消息ID为键，streamNACK（代表一个尚未确认的消息）为值*/
    rax *pel;
    /*为该消费组中所有的消费者，并以消费者的名称为键，streamConsumer（代表一个消费者）为值。*/
    rax *consumers; 
} streamCG;

/*消费者，每个消费者通过streamConsumer唯一标识*/
typedef struct streamConsumer {     
    mstime_t seen_time;     //该消费者最后一次活跃的时间
    sds name;     //消费者的名称
    rax *pel;   //该消费者尚未确认的消息，以消息ID为键，streamNACK 为值。
} streamConsumer;


/*未确认消息，维护了消费组或者消费者尚未确认的消息，
值得注意的是，消费组中的pel的元素与每个消费者的pel中的元素是共享的，
即该消费组消费了某个消息，这个消息会同时放到消费组以及该消费者的pel队列中，并且二者是同一个streamNACK结构。*/
typedef struct streamNACK {     
    mstime_t delivery_time;     //该消息最后发送给消费方的时间
    uint64_t delivery_count;     //该消息已经发送的次数
    streamConsumer *consumer;  //该消息当前归属的消费者。
} streamNACK;
</code></pre>

<hr/>

<h2 id="toc_4">3、Stream 命令</h2>

<h3 id="toc_5">xadd 命令</h3>

<p>将指定消息数据追加到指定的Stream队列中或裁减列中数据长度。</p>

<pre><code class="language-bash">xadd key [MAXLEN [~|=] &lt;count&gt;] &lt;ID or *&gt; [field value] [field value] ...
</code></pre>

<p>每条消息由一或多个阈值对组成，消息插入Stream队列中后会返回唯一的消息ID。xadd是唯一可以向Stream队列添加数据的命令</p>

<ul>
<li>MAXLEN<br/>
当Stream中数据量过大时，可通过此关键字来裁剪长度，删除stream中旧数据至指定的值；当数据量小于等于指定值时，不进行剪切。其中裁剪模式有两种。
<ul>
<li>~：模糊裁剪，优化精确裁剪，一般用此模式，效率更高。</li>
<li>=：精确裁剪，我们知道，在数据存储的listpack结构体中，裁剪长度的所有阈值是依照数据从老到新的方式，依次把listpack释放掉，但在此模式下，删除最后一个listpack中的数据比较费时，所以推荐用模糊裁剪。</li>
</ul></li>
<li>ID：添加消息可指定具体值或用 <code>*</code>代替，<strong>指定的值必须大于当前Stream队列中最大的消息ID</strong>，为<code>*</code>时则默认生成一个最新的ID，ID值取的是当前时间+序列号。</li>
</ul>

<pre><code class="language-shell"># 添加一条数据，使用系统生成的最新ID
&gt; xadd mystream * name doubi age 18
1593943429128-0
# 如果发现添加新元素后的Stream有超过100W+条消息，则删除旧消息，使长度大约缩减至100W个元素
&gt; xadd mystream MAXLEN ~ 1000000 * name tim age 29
</code></pre>

<h3 id="toc_6">xrange命令</h3>

<p>读取给定ID范围内的消息数据，并可以设置返回数据的条数。</p>

<pre><code class="language-shell">&gt; xrange key start end [COUNT count]
</code></pre>

<p>范围起始值分别由start和end字段指定，将返回两个ID之间（闭区间）的所有消息，消息排序为ID递增排序。</p>

<ul>
<li>start: 开始消息ID，指定具体值或通过“-”特殊符号来表示最小ID。</li>
<li>end：结束消息ID，指定具体值或通过“+”特殊符号来表示最大ID。</li>
<li>COUNT：设定返回的消息数量</li>
</ul>

<pre><code class="language-text">127.0.0.1:6379&gt; xrange mystream - + count 2
1) 1) &quot;1593943573938-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;doubi&quot;
      3) &quot;age&quot;
      4) &quot;18&quot;
2) 1) &quot;1593957391373-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;doubi1&quot;
      3) &quot;age&quot;
      4) &quot;19&quot;
</code></pre>

<h3 id="toc_7">xrevrange命令</h3>

<p>xrevrange命令与xrange用法完全一致，唯一区别是返回数据的顺序为消息ID的递减序，正好与xrange返回的数据顺序相反。</p>

<h3 id="toc_8">xdel 命令</h3>

<p>用于删除Stream队列中指定的一或多个消息ID对应的数据。</p>

<pre><code class="language-text">xdel key ID [ID ...]
</code></pre>

<p>key 类型必须为OBJ_STREAM，否则报错。</p>

<h3 id="toc_9">xgroup 命令</h3>

<p>用于队列的消费组管理，包含对消费组的创建、删除、修改等操作。</p>

<pre><code class="language-text">xgroup [CREATE key groupname id-or-$]  [SETID key id-or-$]        [DESTROY key groupname]  [DELCONSUMER key groupname consumername] [HELP]
</code></pre>

<ul>
<li>CREATE：创建一个新消费组。</li>
<li>SETID：修改某个消费组消费的消息last_id。</li>
<li>DESTROY：删除指定消费组。</li>
<li>DELCONSUMER：删除指定消费组中某个消费者。</li>
<li>HELP：查看使用帮助。</li>
</ul>

<pre><code class="language-shell"># 创建一个消费组mmp，从消息id为1593943573938-0的消息开始消费
127.0.0.1:6379&gt; xgroup CREATE mystream mmp 1593943573938-0
OK
</code></pre>

<p>最后一个参数是指定该消费组开始消费的消息ID，其中“0”或“0- 0”，表示从头开始消费，如果使用特殊符“$”，则表示队列中最后一项ID，只读取消息队列中新到的消息。</p>

<h3 id="toc_10">xreadgroup 命令</h3>

<p>用于从消费组中可靠地消费n条消息，如果指定的消费者不存在，则创建之。</p>

<pre><code class="language-text">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
</code></pre>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称。</li>
<li>COUNT：消费多少条数据。</li>
<li>BLOCK：是否为阻塞模式，milliseconds为阻塞多少毫秒</li>
<li>STREAMS：Stream队列名称，可指定多个。若指定多个，则ID 也要对应指定相同个数。</li>
<li>ID：读取只大于指定消息ID后未确认的消息；特殊符号“&gt;”，读取未传递给其他任何消费者的消息，也就是新消息。</li>
<li>NOACK：该消息不需要确认。</li>
</ul>

<p>客户端必须使用XACK确认消息处理，以便从待处理条目列表中删除待处理条目。可以使用XPENDING命令检查待处理条目列表。</p>

<h3 id="toc_11">xread 命令</h3>

<p>用于从Stream队列中读取N条消息，一般用作遍历队列中的消息。</p>

<p>从一个或者多个流中读取数据，仅返回ID大于调用者报告的最后接收ID的条目。此命令有一个阻塞选项，用于等待可用的项目，类似于BRPOP或者BZPOPMIN等等。</p>

<pre><code class="language-text">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
</code></pre>

<ul>
<li>COUNT: 读取多少条数据</li>
<li>BLOCK：是否为阻塞模式，milliseconds为阻塞多少毫秒</li>
<li>STREAMS：Stream队列名称</li>
<li>ID：指定从哪个消息ID开始读取，也就是消息ID大于指定的ID 的消息，可为“$”特殊符号，代表从最后一条开始读取。</li>
</ul>

<p>此命令读取消息后无须通过XACK确认，也不需要强制指定消费组名称与消费者名称</p>

<h3 id="toc_12">xacx 命令</h3>

<p>xack命令用于确认一或多个指定ID的消息，使其从待确认列表中删除。</p>

<pre><code class="language-text">xack key groupName ID [ID ...]
</code></pre>

<ul>
<li>group：消费组名称；</li>
<li>ID：确认的消息ID。</li>
</ul>

<pre><code class="language-shell">127.0.0.1:6379&gt; xack mystream mmp 1593957391373-0 1593943573938-0
(integer) 1
</code></pre>

<h3 id="toc_13">xpending 命令</h3>

<p>xpending命令用于读取某消费组或者某个消费者的未确认消息，返回未确认的消息ID、空闲时间、被读取次数。</p>

<pre><code class="language-text">xpending key group [start end count] [consumer]
</code></pre>

<p>group：指定的消费组；·start：范围开始ID，可以为特殊符“-”表示开始或指定ID；·end：范围结束ID，可以为特殊符“+”标识结尾或指定ID；·count：读取条数；·consumer：指定的消费者。</p>

<p>读取消费组cg1中消费者c1的所有待确认消息。</p>

<pre><code class="language-shell">127.0.0.1:6379&gt; xadd mystream * name doubi1 age 19
&quot;1593962280326-0&quot;
127.0.0.1:6379&gt; XREADGROUP GROUP mmp c1 COUNT 2 STREAMS mystream &gt;
1) 1) &quot;mystream&quot;
   2) 1) 1) &quot;1593962280326-0&quot;
         2) 1) &quot;name&quot;
            2) &quot;doubi1&quot;
            3) &quot;age&quot;
            4) &quot;19&quot;
127.0.0.1:6379&gt; xpending mystream mmp - + 2 c1
1) 1) &quot;1593962280326-0&quot;
   2) &quot;c1&quot;
   3) (integer) 3616  # 间隔多长时间没有确认
   4) (integer) 1
</code></pre>

<h3 id="toc_14">xinfo命令</h3>

<p>用于读取消息队列、消费组、消费者等的信息。</p>

<pre><code class="language-text">xinfo [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]
</code></pre>

<p>CONSUMERS：用于查看某个消费组下的消费者信息；·GROUPS：用于查看某个Stream队列下的消费组信息；·STREAM：用于查看某个Stream队列的整体组信息</p>

<pre><code class="language-shell"># 查看消费组c1中消费者消费信息：
127.0.0.1:6379&gt; xinfo consumers mystream mmp
1) 1) &quot;name&quot;
   2) &quot;c1&quot;
   3) &quot;pending&quot;
   4) (integer) 0
   5) &quot;idle&quot;
   6) (integer) 238485
   
   
   # 查看Stream队列信息
   127.0.0.1:6379&gt; xinfo stream mystream
 1) &quot;length&quot;
 2) (integer) 3
 3) &quot;radix-tree-keys&quot;
 4) (integer) 1
 5) &quot;radix-tree-nodes&quot;
 6) (integer) 2
 7) &quot;groups&quot;
 8) (integer) 1
 9) &quot;last-generated-id&quot;
10) &quot;1593962280326-0&quot;
11) &quot;first-entry&quot;
12) 1) &quot;1593961742431-0&quot;
    2) 1) &quot;name&quot;
       2) &quot;doubi&quot;
       3) &quot;age&quot;
       4) &quot;18&quot;
13) &quot;last-entry&quot;
14) 1) &quot;1593962280326-0&quot;
    2) 1) &quot;name&quot;
       2) &quot;doubi1&quot;
       3) &quot;age&quot;
       4) &quot;19&quot;
</code></pre>

<h3 id="toc_15">xlen 命令</h3>

<p>用于获取Stream队列的数据长度</p>

<pre><code class="language-text">xlen key ID [ID ...]
</code></pre>

<pre><code class="language-text">127.0.0.1:6379&gt; xlen mystream
(integer) 3
</code></pre>

<h3 id="toc_16">xtrim 命令</h3>

<p>缩减消息队列。</p>

<pre><code class="language-text">xtrim key MAXLEN [~] count
</code></pre>

<p>参照  xadd 命令</p>

<h3 id="toc_17">xclaim命令</h3>

<p>改变一或多个未确认消息的所有权，新的所有者是在命令参数中指定。</p>

<pre><code class="language-text">XCLAIM  key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]
</code></pre>

<ul>
<li>consumer：指定新的消费者</li>
<li>min-idle-time：指定消息最小空闲数；</li>
<li>ID：指定消息ID；</li>
<li>IDLE <ms>: 设置消息的空闲时间（自最后一次交付到目前的时间）。如果没有指定IDLE，则假设IDLE值为0，即时间计数被重置，因为消息现在有新的所有者来尝试处理它。</li>
<li>TIME <ms-unix-time>: 这个命令与IDLE相同，但它不是设置相对的毫秒数，而是将空闲时间设置为一个指定的Unix时间（以毫秒为单位）。这对于重写生成XCLAIM命令的AOF文件很有用。</li>
<li>RETRYCOUNT <count>: 将重试计数器设置为指定的值。这个计数器在每一次消息被交付的时候递增。通常，XCLAIM不会更改这个计数器，它只在调用XPENDING命令时提供给客户端：这样客户端可以检测到异常，例如在大量传递尝试后由于某种原因从未处理过的消息。</li>
<li>FORCE: 在待处理条目列表（PEL）中创建待处理消息条目，即使某些指定的ID尚未在分配给不同客户端的待处理条目列表（PEL）中。但是消息必须存在于流中，否则不存在的消息ID将会被忽略。</li>
<li>JUSTID: 只返回成功认领的消息ID数组，不返回实际的消息。</li>
</ul>

<p>在流的消费者组上下文中，此命令改变待处理消息的所有权， 因此新的所有者是在命令参数中指定的消费者。通常是这样的：</p>

<ul>
<li>假设有一个具有关联消费者组的流。</li>
<li>某个消费者A在消费者组的上下文中通过XREADGROUP从流中读取一条消息。</li>
<li>作为读取消息的副作用，消费者组的待处理条目列表（PEL）中创建了一个待处理消息条目：这意味着这条消息已传递给给定的消费者，但是尚未通过XACK确认。</li>
<li>突然这个消费者出现故障，且永远无法恢复。</li>
<li>其他消费者可以使用XPENDING检查已经过时很长时间的待处理消息列表，为了继续处理这些消息，他们使用XCLAIM来获得消息的所有权，并继续处理。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/07/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='redis.html'>redis</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15937003019170.html">
                
                  <h1>五、Redis 基本数据类型与其命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Redis 支持多种类型的数据结构，如 字符串（string）， 散列（hashe）， 列表（list）， 集合（sets）， 有序集合（zset） 与范围查询， bitmap， hyperloglogs 和 地理空间（geospatial） 索引半径查询，stream消息队列。</p>

<p>Redis命令十分丰富，包括的命令组有Cluster、Connection、Geo、Hashes、HyperLogLog、Keys、Lists、Pub/Sub、Scripting、Server、Sets、Sorted Sets、Strings、Transactions一共14个redis命令组两百多个redis命令。</p>

<h2 id="toc_0">1、Redis基本数据类型</h2>

<p>Redis可以存储键与 5 种不同数据结构类型之间映射的数据，这 5 种数据结构类型分别为 string(字符串)、list(列表)、set(集合)、zset(有序集合)、hash(散列)。</p>

<table>
<thead>
<tr>
<th>结构类型</th>
<th>编码类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>

<tbody>
<tr>
<td>string</td>
<td>raw、int、embstr</td>
<td>可以使字符串、整数或者浮点数</td>
<td>对整个字符串或字符串的一部分执行操作；对证书和浮点数执行自增、自减操作</td>
</tr>
<tr>
<td>list</td>
<td>quicklist</td>
<td>底层由链表实现，每个节点都包含一个字符串</td>
<td>从列表的两端推入或者弹出元素；根据偏移量对列表进行修改；读取单个或多个元素；根据值查询或者移除元素</td>
</tr>
<tr>
<td>set</td>
<td>intset、dict</td>
<td>不重复的无序集合，但当底层实现是intset的时候则是有序的</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>zset</td>
<td>ziplist、skiplist+dict</td>
<td>不可重复的有序集合，字符串成员(member)于浮点数分支(score)之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、移除单个元素；根据分值范围(range)或者成员来获取元素</td>
</tr>
<tr>
<td>hash</td>
<td>dict、ziplist</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所有键值对</td>
</tr>
</tbody>
</table>

<p><strong>关于key的几条建议</strong></p>

<ul>
<li>不建议太长的键值，原因：1、消耗内存；2、这类键值计算成本很高</li>
<li>不建议太短的键值，设计键值要有良好的可读性，太短的话，看不懂就有点尴尬了</li>
<li>最好有一个相对固定的键值模式，比如这样的模式： 业务名:对象名:id:[属性] ，业务有销售订单、采购订单，销售订单的键值可以是： sale:order:100:orderId这样的</li>
</ul>

<h2 id="toc_1">Redis 中的 string 字符串</h2>

<p>字符串在Redis中是以key-value形式存储在redisDb的dict中的。</p>

<p>字符串的key经过Hash 之后作为dict的键，只能是string类型，字符串的value是dict的值，用结构体robj来表示。</p>

<p>字符串值robj 的 type 值为 OBJ_STRING 。当字符串值是string类型时，encoding的值根据字符串的长度(NCODING_EMBSTR_SIZE_LIMIT = 44)分别为OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR(字符串长度&lt;=44)；当字符串值是long类型时，encoding的值为OBJ_ENCODING_INT。</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>设置</td>
<td>SET key value [NX] [XX] [EX seconds] [PX milliseconds]</td>
<td>设置存储在给定键中的值</td>
<td>set mykey  myvalue</td>
<td>·NX： 当数据库中key不存在时，可以将key-value添加到数据库。·XX： 当数据库中key存在时，可以将key-value设置到数据库，与NX参数互斥。·EX： key的超时秒数。·PX： key的超时毫秒数，与EX参数互斥。</td>
</tr>
<tr>
<td>设置</td>
<td>mset key value [key value ...]</td>
<td>设置多个key-value，如果key之前存在，则使用新的value进行覆盖</td>
<td>mset idear1 eat idear2 play</td>
<td>设置键值对 idear1 : ear 、 idear2  : play</td>
</tr>
<tr>
<td>设置</td>
<td>setex key second value</td>
<td>设置key-value并设置过期时间(单位：秒)</td>
<td>setex mykey 10  hungry</td>
<td>设置的mykey : hungry 10秒钟后过期，10秒后get mykey 返回 nil；</td>
</tr>
<tr>
<td>设置</td>
<td>psetex　key　milliseconds　value</td>
<td>设置key-value并设置过期时间(单位：毫秒)</td>
<td>setex mykey 10  hungry</td>
<td>设置的mykey : hungry 10毫秒钟后过期，10毫秒后get mykey 返回 nil；</td>
</tr>
<tr>
<td>设置</td>
<td>setnx key value</td>
<td>只有key不存在时才会设置key-value</td>
<td>setnx mykey myvalue</td>
<td>如果mykey不存在则设置，如果存在不执行覆盖操作</td>
</tr>
<tr>
<td>设置</td>
<td>msetnx key value [key value ...]</td>
<td>当所有的key都不存在时才会设置这些key-value</td>
<td>msetnx mykey1 myvalue1 mykey2 myvalue2</td>
<td>所有的key都不存在设置这些个key-value</td>
</tr>
<tr>
<td>获取</td>
<td>get key</td>
<td>获取存储在给定键中的值</td>
<td>get mykey</td>
<td>返回myvalue</td>
</tr>
<tr>
<td>获取</td>
<td>getset key value</td>
<td>将给定keuy的值设置为value，并返回key的旧值</td>
<td>getset mykey newValue</td>
<td>返回mykey的旧值myvalue，并设置mykey为新值 newValue</td>
</tr>
<tr>
<td>获取</td>
<td>mget key [key...]</td>
<td>获取多个key</td>
<td>mget mykey1 mykey2</td>
<td>获取mykey1、mykey2的值</td>
</tr>
<tr>
<td>获取</td>
<td>getrange key start end</td>
<td>获取存储在给定键中的值的某一段</td>
<td>get mykey 0 -2</td>
<td>返回myvalue 值递第一位置至倒数第二位置的value 值</td>
</tr>
<tr>
<td>获取</td>
<td>strlen</td>
<td>获取指定key的长度</td>
<td>strlen mykey</td>
<td>复杂度为O(1)</td>
</tr>
<tr>
<td>修改</td>
<td>append key value</td>
<td>追加一个值到key上</td>
<td>append mykey tony</td>
<td>添加完tony之后运行get mykey 得到结果 myvalue tony</td>
</tr>
<tr>
<td>计数</td>
<td>decr key</td>
<td>整数原子减 1</td>
<td>decr mykey</td>
<td>如果mykey原先不存在，在减1之前，age会被置为0</td>
</tr>
<tr>
<td>计数</td>
<td>decrby key decrement</td>
<td>整数原子减指定整数</td>
<td>decrby mykey</td>
<td>如果mykey原先不存在，在减decrement之前，mykey会被置为0</td>
</tr>
<tr>
<td>计数</td>
<td>incr key</td>
<td>整数原子加1</td>
<td>incr mykey</td>
<td>如果mykey原先不存在，在加1之前mykey会被置为0</td>
</tr>
<tr>
<td>计数</td>
<td>incrby key increment</td>
<td>整数原子加指定整数</td>
<td>incrby mykey 10</td>
<td>如果mykey原先不存在，在加increment之前mykey会被置为0</td>
</tr>
<tr>
<td>修改</td>
<td>setrange key offset value</td>
<td>覆盖key的value的offset之后的字符串</td>
<td>setrange mykey 2 qu</td>
<td>mykey之前的值是woca，执行此命令之后的结果就是woqu</td>
</tr>
<tr>
<td>通用</td>
<td>del key</td>
<td>删除存储在给定键中的值</td>
<td>del mykey</td>
<td>删除 mykey 键</td>
</tr>
</tbody>
</table>

<p>此外还有一种字符串的位操作：<br/>
位操作是高级语言的基础，Redis提供了位设置、操作、统计等命令，这些命令主要包括setbit、getbit、bitpos、bitcount、bittop 和 bitfield。抽空在补这部分内容  TODO。</p>

<p>Q：追加字符串时，需要判断追加后的字符串长度必须小于512MB，否则会报错，那么在set命令时为什么没有限制最大长度呢？<br/>
A:在服务端接收到命令的时候，就已经判断了命令的最大长度不能大于512 MB，所以set命令不需要再次判断了</p>

<p>字符串追加会修改原字符串的值，所以必须保证字符串是非共享的。如果字符串是共享的，则需要解除共享，新创建一个值对象。</p>

<h2 id="toc_2">Redis 中的 list 列表</h2>

<p>在 Redis 引入 quicklist之前，Redis采用压缩链表（ziplist）以及双向链表（adlist）作为List的底层实现。当元素个数比较少并且元素长度比较小时，Redis 采用 ziplist 作为其底层存储；当任意一个条件不满足时，Redis采用adlist作为底层存储结构。这么做的主要原因是，当元素长度较小时，采用ziplist可以有效节省存储空间，但ziplist的存储空间是连续的，当元素个数比较多时，修改元素时，必须重新分配存储空间，这无疑会影响Redis的执行效率，故而采用一般的双向链表。</p>

<p>Redis3.2版本之后，列表底层使用快速链表（quicklist）数据结构存储，而快速链表是双向链表与压缩列表 ziplist 的组合。</p>

<p>链表广泛应用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>blpop key [key ...] timeout</td>
<td>lpop的阻塞版本</td>
<td>blpop myList 0</td>
<td>调用返回key和左边第一个元素的组合 myList、list3</td>
</tr>
<tr>
<td>brpop key [key ...] timeout</td>
<td>rpop的阻塞版本</td>
<td>brpop myList</td>
<td>没元素的话阻塞在key的列表上</td>
</tr>
<tr>
<td>lindex key index</td>
<td>通过列表索引获取key列表的value值, index  0：表示第一个元素； -1：表示最后一个元素；-2 ：表示倒数第二个原始</td>
<td>lindex myList 0</td>
<td>返回list3</td>
</tr>
<tr>
<td>linsert key before/after pivot value</td>
<td>把value插入myList 列表中在元素的的前面或后面</td>
<td>linsert myList before  list2 beauty</td>
<td>返回[list3,beauty,list2,list1]</td>
</tr>
<tr>
<td>llen key</td>
<td>获得列表的长度</td>
<td>llen myList</td>
<td>返回3</td>
</tr>
<tr>
<td>lpop key</td>
<td>从队列的左边出队并返回一个元素，列表为空时返回nil</td>
<td>lpop myList</td>
<td>返回并删除了第一个元素list3</td>
</tr>
<tr>
<td>lpush key value [value ...]</td>
<td>从队列的左边入队一个或多个元素</td>
<td>lpush myList list4 list 5</td>
<td>value按照先后顺序插入到列表头，最后列表元素[list5,list4,list3,beauty,list2,list1]</td>
</tr>
<tr>
<td>lpushx key vlaue</td>
<td>当列表存在时，从列表左边入队一个元素</td>
<td>lpushx myList1  hello</td>
<td>myList1 不存在 元素插入不成功</td>
</tr>
<tr>
<td>lrange key startIndex stopIndex</td>
<td>从列表中获取指定位置范围内的元素</td>
<td>lrange myList 0 1</td>
<td>结果[list3,list2]</td>
</tr>
<tr>
<td>lrem key count value</td>
<td>从存于key的列表中移除前count个的值为value的元素，count&gt;0 :从头向尾移除置为value的元素；count&lt;0: 从尾向头移除置为value的元素；count=0： 移除所有值为value的元素</td>
<td>lrem myList 1 list2</td>
<td>[list3,list1]</td>
</tr>
<tr>
<td>lset key index value</td>
<td>设置列表里面的index位置的元素值</td>
<td>lset myList 2 ghost</td>
<td>列表更新为[list3,list2,ghost]</td>
</tr>
<tr>
<td>ltrim key start stop</td>
<td>修剪并保留指定范围内的元素</td>
<td>ltrim myList 1 2</td>
<td>列表被编辑为 [list2,list1]</td>
</tr>
<tr>
<td>rpop key</td>
<td>从列表右边出队并返回一个元素，列表为空时返回nil</td>
<td>rpop myList</td>
<td>列表被编辑为 [list3,list2]</td>
</tr>
<tr>
<td>rpush key value [value ...]</td>
<td>从列表右边入队一个或多个元素</td>
<td>rpush myList niu</td>
<td>列表被编辑为 [list3,list2,list1,niu]</td>
</tr>
<tr>
<td>rpushx key value</td>
<td>列表如果存在，则从列表右边入队一个元素</td>
<td>rpushx myList leng</td>
<td>列表被编辑为 [list3,list2,list1,leng]，如果myList不存在，啥都不干</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">栈和队列命令列表</h3>

<p>栈与队列是操作受限制的线性表</p>

<p>栈只允许在线性表的同一侧执行插入或删除操作，具有先进后出的特性；</p>

<p>队列只允许在一侧插入另一侧删除，具有先进先出的特性。</p>

<table>
<thead>
<tr>
<th>命令类型</th>
<th>左侧</th>
<th>右侧</th>
<th>左侧阻塞</th>
<th>右侧阻塞</th>
<th>左侧必须键存在</th>
<th>右侧必须键存在</th>
</tr>
</thead>

<tbody>
<tr>
<td>push类</td>
<td>lpush</td>
<td>rpush</td>
<td>无</td>
<td>无</td>
<td>lpushx</td>
<td>rpushx</td>
</tr>
<tr>
<td>pop类</td>
<td>lpop</td>
<td>rpop</td>
<td>blpop</td>
<td>brpop</td>
<td>无</td>
<td>无</td>
</tr>
</tbody>
</table>

<h2 id="toc_4">Redis 中的 set 集合</h2>

<p>在Redis中，集合元素为字符串和数字，分别用dict和intset存储。对于单个集合，Redis 实现了元素的新增、删除、遍历等操作；对于多个集合，Redis实现了集合间求交集、并集和差集等操作。</p>

<p>set集合中添加元素的时候分两种情况：</p>

<ul>
<li><p>当encoding方式为OBJ_ENCODING_HT时，set的底层用的是字典，将key直接添加进dict。需要注意的是，用dict存储集合元素时，元素值存储于字典的key中，字典的value值为null。</p></li>
<li><p>当encoding方式为OBJ_ENCODING_INTSET时，又有两种情况：</p>
<ul>
<li>若新增的元素本身非数字（value转long long失败），需要通过setTypeConvert转化后再存储；</li>
<li>若新增的元素本身是数字，则用intsetAdd新增元素。且当新增成功，但intset的元素个数过多（个数大于server.set_max_intset_entries时。该参数可配置，默认为512），同样会触发setTypeConvert，将OBJ_ENCODING_INTSET转化为OBJ_ENCODING_HT，为避免转化过程中发生字典的rehash操作，代码中用 dictExpand主动扩容。</li>
</ul></li>
</ul>

<p>移除元素的时候同样分两种情况进行处理：</p>

<ul>
<li>若encoding为OBJ_ENCODING_HT时，则调用dictDelete处理删除元素时，会检查字典容量，字典容量不足也会触发扩容操作。</li>
<li>当encoding为OBJ_ENCODING_INTSET时，调用intsetRemove处理</li>
</ul>

<p>Set集合相关命令如下表：</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>sadd key member [member ...]</td>
<td>添加一个或多个指定的member元素到集合key中.</td>
<td>sadd myset &quot;hello&quot;</td>
<td>返回新成功添加到集合里元素的数量，不包括已经存在于集合中的元素.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中。如果key 的类型不是集合则返回错误。</td>
</tr>
<tr>
<td>scard key</td>
<td>返回集合存储的key的基数 (集合元素的数量).</td>
<td>SCARD myset</td>
<td>集合的基数(元素的数量),如果key不存在,则返回 0.</td>
</tr>
<tr>
<td>sdiff key [key ...]</td>
<td>返回一个集合与给定集合的差集的元素.</td>
<td>sdiff  myset1 myset2</td>
<td>返回myset1和myset2的差集元素，不存在的key认为是空集.</td>
</tr>
<tr>
<td>sdiffstore destination key [key ...]</td>
<td>返回一个集合与给定集合的差集元素的个数，并将结果放入destination中</td>
<td>sdiffstore myset myset1 myset2</td>
<td>将myset1和myset2的差集存储在myset中</td>
</tr>
<tr>
<td>sinter key [key ...]</td>
<td>返回所有集合的元素交集列表</td>
<td>sinter myset1 myset2</td>
<td>如果key不存在则被认为是一个空的集合,当给定的集合为空的时候,结果也为空.(一个集合为空，结果一直为空).</td>
</tr>
<tr>
<td>sinterstore destination key [key ...]</td>
<td>返回所有集合的元素交集的元素数目，并存储到 destination中</td>
<td>sinterstore myset myset1 myset2</td>
<td>myset1和myset2的交集存储到 myset集合中，并返回集合元素的数目，如果destination 集合存在, 则会被重写.</td>
</tr>
<tr>
<td>sismember key member</td>
<td>判断member是否存在于key集合中，存在返回1，不存在返回0</td>
<td>sismember myset &quot;121&quot;</td>
<td>判断121是否存在于myset集合中，myset不存在或121不是myset集合元素返回0，否则返回 1</td>
</tr>
<tr>
<td>smembers key</td>
<td>返回集合所有元素</td>
<td>smembers myset</td>
<td>该命令的作用与使用一个参数的 sinter 命令作用相同.</td>
</tr>
<tr>
<td>smove source destination member</td>
<td>将member 从source集合移动到destination集合中</td>
<td>smove myset1 myset2 &quot;sb&quot;</td>
<td>将sb元素从 myset1 集合 移动到 myset2 集合中</td>
</tr>
<tr>
<td>spop key [count]</td>
<td>从存储在key的集合中移除并返回一个或多个随机元素</td>
<td>spop myset 3</td>
<td>从myset中删除并返回3个元素，被删除的元素，或者当key不存在时返回nil。</td>
</tr>
<tr>
<td>srandmember key [count]</td>
<td>随机返回集合key中count个数元素</td>
<td>srandmember myset 3</td>
<td>随机返回myset集合中的3个元素</td>
</tr>
<tr>
<td>srem key member [member ...]</td>
<td>移除key 集合中指定的元素</td>
<td>srem myset &quot;sb1&quot; &quot;sb2&quot;</td>
<td>从myset中删除sb1 和 sb2，如果集合中不存在 sb1则忽略，myset集合不存在则被视为一个空集合，返回 0</td>
</tr>
<tr>
<td>sscan key cursor [match pattern] [count count]</td>
<td>遍历集合中所有的元素</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sunion key [key ...]</td>
<td>返回给定的多个集合的并集中的所有成员</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sunionstore destination key [key ...]</td>
<td>将多个集合的并集存储到destination集合中</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="toc_5">Redis 中的 zset  有序集合</h2>

<p>有序集合中，用到的关键数据结构是ziplist以及dict和skiplist，当服务器属性server.zset_max_ziplist_entries的值大于0且元素的member 长度小于服务器属性server.zset_max_ziplist_value的值（默认为64）时，使用的是ziplist，否则使用的是dict和skiplist。</p>

<p>有序集合里面的成员是不能重复的都是唯一的，但是，不同成员间有可能有相同的分数。当多个成员有相同的分数时，相同分数的成员按照字典规则相对排序，字典顺序排序用的是二进制，它比较的是字符串的字节数组。</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>zadd key [nx|xx] [ch] [incr] score member [score member]</td>
<td>将一个或多个member元素及其分值score加入到有序集合对应的key当中。其中，分值score可以是整数值或双精度浮点数。XX：只更新已经存在的元素，不添加元素。NX：不更新已经存在的元素，总是添加新的元素。CH：将返回值从添加的新元素数量修改为更改的元素总数。INCR：对成员的分数进行递增操作。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrem key member [member]</td>
<td>删除有序集合 key中的一个或者多个member</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zcard key</td>
<td>获取有序集合key中的技基数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zcount key min max</td>
<td>返回有序集合 key 中 scroe 值在 [min,max]区间的成员数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zincrby key increment member</td>
<td>在有序集合 key 的 member 的分值上增加 increment</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrank key member</td>
<td>按照分值从小到大返回有序集合成员member的排名，其中排名从0开始计算</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrevrank key member</td>
<td>按照分值从大到小返回有序集合成员member的排名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zscore key member</td>
<td>获取有序集合key中成员member的分值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zscan key cursor [match parttern] [count count]</td>
<td>迭代有序集合中的元素和分值，match可以通过正则匹配元素，count 是返回的元素数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrange key start stop [withscores]</td>
<td>获取有序集合key中指定区间的成员，成员按照分值递增排序，如果分值相同，成员按照字典序排序</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrevrange key start stop [withscores]</td>
<td>获取有序集合key中指定区间的成员，成员按照分值递减排序，如果分值相同，成员按照字典序排序</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrangebyscore key min max [withscores] [limit offset count]</td>
<td>返回有序集key中，所有score值介于min和max之间（包括等于min或max）的成员。有序集成员按score值递增（从小到大）次序排列。具有相同score值的成员按字典序排列。limit 表示分页，offset(起始位置)和count(结果数量)必须输入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrevrangebyscore key min max [withscores] [limit offset count]</td>
<td>除了有序集合按score值递减之外，跟zrangebyscore完全一样。limit 表示分页，offset(起始位置)和count(结果数量)必须输入</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zrangebylex key min max [limit offset count]</td>
<td>分数必须相同，返回给定的有序集合键key中值介于min和max之间的成员，根据成员的字典序排序。limit 表示分页，offset(起始位置)和count(结果数量)必须输入</td>
<td></td>
<td>合法的min和max参数必须包含“(”或者“[”，其中“(”表示开区间，“[”表示闭区间；可以使用 “-“ 和 “+” 表示得分最小值和最大值；成员字符串作为二进制数组的字节数进行比较；</td>
</tr>
<tr>
<td>zlexcount key min max</td>
<td>返回给定的有序集合键key中值介于min和max之间的成员数量。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zremrangebyrank key start stop</td>
<td>移除有序集合key 中指定排名区间的所有成员</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zremrangebyscore key min max</td>
<td>移除有序集合key中所有score值介于[min,max]之间的成员</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zremrangebylex key min max</td>
<td>移除该集合中成员字典序介于min和max范围的所有元素</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zunionstore destination numkeys key [key ...] [weights weight] [sumiminimax]</td>
<td>计算给定的numkeys个有序集合的并集，并且把结果放到destination中。WEIGHTS选项可以在使用聚合函数时为每个有序集分别指定一个乘法因子</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zinterstore destination numkeys key [key ...] [WEIGHTS weight] [SUMIMINIMAX]</td>
<td>计算给定的numkeys个有序集合的交集，并且把结果放到destination中。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zpopmax key [count]</td>
<td>删除并返回有序集合key中的最多count个具有最高得分的成员。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>zpopmin key [count]</td>
<td>删除并返回有序集合key中的最多count个具有最少得分的成员。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bzpopmax key [key ...] timeout</td>
<td>删除并返回 有序集合 key 中分值最高的成员，在参数中的所有有序集合均为空的情况下，阻塞连接</td>
<td>bzpopmax zset2 zset1 0</td>
<td>按照zset的key前后顺序，删除并返回zset2的分值最高的成员</td>
</tr>
<tr>
<td>bzpopmin key [key ..] timeout</td>
<td>删除并返回 有序集合 key 中分值最低的成员，在参数中的所有有序集合均为空的情况下，阻塞连接</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="toc_6">Redis 中的 hash 散列表</h2>

<p>Redis散列存储有 ziplist 和 散列表(hashtable) 2种，有时我们需要从ziplist编码转换为散列表编码。值得注意的是，即使后期满足条件，也不会从散列表编码转换为ziplist编码。</p>

<p>当需要存储的key-value结构同时满足下面两个条件时，采用ziplist作为底层存储：</p>

<ul>
<li>key-value结构的所有键值对的字符串长度都小于hash-max- ziplist-value（默认值64），该值可以通过配置文件配置</li>
<li>散列对象保存的键值对的个数（一个键值对记为1个）小于hash-max-ziplist-entries（默认值512），该值也可以通过配置文件配置。</li>
</ul>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>hset key field value</td>
<td>设置 key 指定的哈希集中指定字段的值</td>
<td></td>
<td>如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段在哈希集中存在，它将被重写。</td>
</tr>
<tr>
<td>hmset key field value [field value]</td>
<td>设置 key 指定的哈希集中指定字段的值</td>
<td></td>
<td>设置 key 指定的哈希集中指定字段的值</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值</td>
<td></td>
<td>如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。</td>
</tr>
<tr>
<td>hexists key field</td>
<td>查看某个field是否存在，可以用于标识某个操作之前是否已经执行过</td>
<td>xxx</td>
<td>查看field是否存在，存在返回1，key不存在或者field不存在返回0。</td>
</tr>
<tr>
<td>hget key field</td>
<td>获取单个field对应的value值</td>
<td></td>
<td>该字段所关联的值。当字段不存在或者 key 不存在时返回nil。</td>
</tr>
<tr>
<td>hmget key field [field...]</td>
<td>获取多个field对应的value值</td>
<td></td>
<td>当字段不存在或者 key 不存在时返回nil</td>
</tr>
<tr>
<td>hkeys key</td>
<td>获取某个key下的所有field信息</td>
<td></td>
<td>当 key 指定的哈希集不存在时返回空列表</td>
</tr>
<tr>
<td>hvals key</td>
<td>获取某个key下的所有value信息</td>
<td></td>
<td>哈希集中的值的列表，当 key 指定的哈希集不存在时返回空列表</td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取某个key下的所有key-field信息</td>
<td></td>
<td>哈希集中字段和值的列表。当 key 指定的哈希集不存在时返回空列表。</td>
</tr>
<tr>
<td>hlen key</td>
<td>获取散列表中field的个数，主要用于数据统计。</td>
<td></td>
<td>哈希集中字段的数量，当 key 指定的哈希集不存在时返回 0</td>
</tr>
<tr>
<td>hscan key cursor [match pattern] [COUNT count]</td>
<td>遍历散列表中所有的field-value对</td>
<td></td>
<td>cursor指向当前的位置，0代表新一轮的迭代，返回0代表本轮迭代结束；count是需要返回的field 个数，默认值是10，当底层编码为ziplist时，该值无效，Redis会将ziplist中所有field-value返回，当编码为散列表时，返回的元素个数不一定，可能大于，也可能小于或等于此值；pattern是需要匹配的模式，这一步是读取完数据之后，发送数据之前执行的</td>
</tr>
<tr>
<td>hdel key field [field ...]</td>
<td>将key对应的散列表中的field删除，key为空时返回0，key 不为空时返回成功删除的field个数</td>
<td></td>
<td>直接调用ziplist或者散列表的接口将数据删除。散列表中field全部被删除时，key也会被删除。</td>
</tr>
<tr>
<td>hincrby key field increment</td>
<td>将field对应的value增加increment</td>
<td></td>
<td>如果key不存在则直接新建key，field不存在则直接新建field，设置其值为0，命令返回增加后的新值</td>
</tr>
<tr>
<td>hincrbyfloat key field increment</td>
<td>将field对应的value增加increment</td>
<td></td>
<td>如果key不存在则直接新建key，field不存在则直接新建field，设置其值为0，命令返回增加后的新值</td>
</tr>
<tr>
<td>hstrlen key field</td>
<td>返回hash指定field的value的字符串长度</td>
<td></td>
<td>如果hash或field不存在，返回0</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/07/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='redis.html'>redis</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15936158582613.html">
                
                  <h1>四、Redis  通用命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>redis 是一个键值对数据库服务器，服务器中的每个数据库都有 redisDB 结构表示( 在<a href="15934396305281.html">redis命令处理生命周期</a> 文章中查找)， redisDb 结构的dict字典保存了数据库中的所有的键值对。</p>

<p>所有针对数据库的操作，比如本章节的键相关命令还是基本数据类型相关的命令，实际上都是通过对键空间字典进行操作来实现的。</p>

<p>在读写键空间的时候，redis会进行一些维护操作</p>

<ul>
<li>读写一个键之后，服务器会根据键是否存在来更新服务器的键空间命中 (hit) 次数或键空间未命中(miss)次数，这两个值可以在 info stats 命令的keyspace_hits和keyspace_misses 属性中查看</li>
<li>在读取一个键之后，服务器会更新键的 LRU （最后一次使用）时间，这个值可以用于计算键的空闲时间，以方便对象内存的释放与回收</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其它操作</li>
<li>如果游客户端使用watch 命令见识了某个键，那么服务器在对被监视的键进行更新之后，会将这个件标记为 dirty ，从而让食物程序注意到这个件已经被修改过</li>
<li>服务器每次修改一个键之后，会对dirty键计数器的值 增 1，这个计数器会触发服务器的持久化以及复制操作</li>
<li>服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按照配置发送相应的数据库通知，用于Redis的发布订阅功能。</li>
</ul>

<h2 id="toc_0">1、Redis 键相关命令</h2>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>del key [key ...]</td>
<td>同步方式删除键 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>exists key</td>
<td>查看key是否存在</td>
<td></td>
<td></td>
</tr>
<tr>
<td>expire key seconds</td>
<td>设置键的过期时间</td>
<td>expire mykey 10</td>
<td>mykey键值对 10秒后过期</td>
</tr>
<tr>
<td>pexpire key milliseconds</td>
<td>设置key的过期时间，时间单位是毫秒</td>
<td></td>
<td></td>
</tr>
<tr>
<td>expireat key timestamp</td>
<td>设置key的生存时间，接收的时间参数以秒为单位的unix时间戳</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pexpireat key milliseconds-timestamp</td>
<td>设置key的生存时间，接收的时间参数为毫秒为单位时间戳</td>
<td></td>
<td></td>
</tr>
<tr>
<td>keys parttern</td>
<td>查看所有键</td>
<td>keys *</td>
<td>Redis存在大量键时，禁止使用此命令</td>
</tr>
<tr>
<td>hscan</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>migrate host post key destination-db timeout [COPY] [REPLACE]</td>
<td>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</td>
<td></td>
<td>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。</td>
</tr>
<tr>
<td>dump key</td>
<td>序列化key并返回序列化后的数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>restore key ttl serialized-value [replace]</td>
<td>反序列化serialized-value，并与key关联</td>
<td></td>
<td></td>
</tr>
<tr>
<td>move key dbIndex</td>
<td>将key移动到另一个数据库</td>
<td>move mykey 3</td>
<td>移动mykey到3号数据库</td>
</tr>
<tr>
<td>OBJECT  help/refcount/encoding/idletime/freq key</td>
<td>查看数据库的值对象编码</td>
<td>object e</td>
<td>help ：帮助命令，object命令使用手册。refcount ：获得指定键关联的值的引用数，即redisObject对象refcount属性。encoding ：获得指定键关联的值的内部存储使用的编码，即redisObject对象encoding属性的字符串表达。idletime ：返回键的空闲时间，即自上次读写键以来经过的近似秒数。freq ：返回键的对数访问频率计数器。当maxmemory-policy设置为LFU策略时，此子命令可用。</td>
</tr>
<tr>
<td>persist key</td>
<td>删除key的过期时间，使key长期有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ttl [key]</td>
<td>查看键所剩的过期时间(时间单位：秒)</td>
<td>ttl mykey</td>
<td>查看设置过期时间的键所剩过期时间还有几秒</td>
</tr>
<tr>
<td>pttl [key]</td>
<td>查看键所剩的过期时间(时间单位：毫秒)</td>
<td>pttl mykey</td>
<td>查看设置过期时间的键所剩过期时间还有几毫秒</td>
</tr>
<tr>
<td>randomkey</td>
<td>从当前数据库随机返回一个key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename key newkey</td>
<td>将key重命名为newkey，如果newkey已存在，则值将被覆盖</td>
<td></td>
<td></td>
</tr>
<tr>
<td>renamenx key newkey</td>
<td>重命名后的key不存在时才能执行成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td>scan cursor [MATCH parttern] [COUNT count]</td>
<td></td>
<td></td>
<td>scan命令和hscan、sscan、zscan命令都用于增量迭代，每次只返回少量数据，不会有像keys命令堵塞服务器的隐患</td>
</tr>
<tr>
<td>sort key key [BY pattern] [LIMIT offset count] [GET pattern] [ASC/DESC] [ALPHA] destination</td>
<td>对列表、集合或有序集合中的元素进行排序，返回或保存List、Set、Zset类型的key中排序后的元素</td>
<td></td>
<td>·BY： 使用其他键的值作为权重进行排序，如果其他键不存在则跳过排序。·LIMIT： 限定排序返回的元素。·GET： 跟BY作用相反，将排序结果作为权重来排序匹配的其他键，可多次使用。·ASC/DESC： 正序/倒序排序。·ALPHA： 对字符串进行排序，默认使用数字排序。·STORE： 将排序后的结果保存到指定的键。</td>
</tr>
<tr>
<td>touch key [key]</td>
<td>修改指定key(s) 最后访问时间 若key不存在，不做操作</td>
<td></td>
<td></td>
</tr>
<tr>
<td>type [key]</td>
<td>查看键的数据结构类型</td>
<td>type mykey</td>
<td>键不存在返回 nil</td>
</tr>
<tr>
<td>unlink key [key ...]</td>
<td>根据删除的工作量决定使用同步方式还是异步方式删除键 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wait numslaves timeout</td>
<td>阻塞当前客户端，直到所有以前的写命令都成功的传输和指定的slaves确认。如果指定以毫秒为单位，请求超时，即使指定的slaves还没有到达，命令任然返回。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_1">过期键的删除策略</h3>

<p>过期键的删除策略</p>

<ul>
<li><p>惰性删除策略，访问数据库键时，校验该键是否过期，如果过期则删除<br/>
对于cpu时间来说最友好，程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在费做不可的情况下进行，并且删除的木啊比偶仅限当前处理的键，但是此种策略又非常占用内存，已过期的键不会立马删除，占着内存直到下次访问时才会释放内存空间</p></li>
<li><p>定时删除策略，设置键过期时间的同时，创建定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作<br/>
可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存，但是会占用一定的cpu时间，影响服务器的响应时间和吞吐量，除此之外，创建定时器需要用到 redis 服务器的时间事件，而当前时间事件的实现方式是无序链表，查找一个时间的时间复杂度为 O(N)，并不能高效的处理大量的时间事件。</p></li>
<li><p>定期删除策略，周期性删除过期键，redisServer启动过程最后一步(开启事件循环，会触发Redis的定时任务的时间事件，查看 <a href="15934396305281.html">三、redis命令处理生命周期</a>) </p>
<ul>
<li>每个一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响</li>
<li>通过定期删除过期键，有效的减少了过期键带来的内存损耗。</li>
</ul></li>
</ul>

<h3 id="toc_2">redis过期键删除策略</h3>

<p>Redis 服务器采用惰性删除策略和定期删除两种策略，通过分配使用这两种删除策略，redis服务器可以很好的利用cpu时间和避免内存浪费之间取得一个较好的平衡</p>

<h2 id="toc_3">2、Redis服务器相关命令</h2>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>dbsize</td>
<td>查看当前数据库里面的 keys 总数</td>
<td>dbsize</td>
<td>Redis存在大量键时，禁止使用此命令</td>
</tr>
<tr>
<td>flushall</td>
<td>清除所有库的数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>flushdb dbIndex</td>
<td>清除指定index的库</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>save</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bgsave</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/07/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='redis.html'>redis</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15934396305281.html">
                
                  <h1>三、redis命令处理生命周期</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>服务器处理客户端命令请求的整个流程，包括服务器启动监听，接收命令请求并解析，执行命令请求，返回命令回复等。</p>

<p>Redis服务器是典型的事件驱动程序，因此事件处理显得尤为重要，而Redis将事件分为两大类：文件事件与时间事件。文件事件即socket的读写事件，时间事件用于处理一些需要周期性执行的定时任务。</p>

<h2 id="toc_0">1、基本知识</h2>

<h3 id="toc_1">1.1、Redis 对象</h3>

<p>Redis 是一个 key-value 型数据库， key只能是字符串， vlaue可以是 字符串、列表、集合、有序集合、散列表， 这5中数据类型用结构体 robj表示，robj被称为 Redis 对象。<br/>
robj结构体如下所示：</p>

<pre><code class="language-c">typedef struct redisObject {     
    unsigned type:4;    // 对象类型
    unsigned encoding:4;    // 对象编码
    unsigned lru:LRU_BITS;  //缓存淘汰使用, 占24比特
    int refcount;   //存储当前对象的引用次数，用于实现对象的共享    
    void *ptr;  //指向实际存储的某一种数据结构
} robj;
</code></pre>

<ul>
<li>结构体robj的type字段表示对象类型，由 encoding 字段决定。</li>
</ul>

<pre><code class="language-c">#define OBJ_STRING 0
#define OBJ_LIST 1
#define OBJ_SET 2
#define OBJ_ZSET 3
#define OBJ_HASH 4
</code></pre>

<ul>
<li><p>结构体 robj 的ptr<br/>
ptr是void* 类型的指针，指向实际存储的某一种数据结构的地址。</p></li>
<li><p>结构体 robj 的 refcount <br/>
refcount 存储当前对象的引用次数，用于实现对象的共享。共享时 refcount加1；删除对象时，refcount减1；当refcount值为0时，释放对象空间。<br/>
只有当对象robj存储的是0～10000的整数时，对象robj才会被共享，且这些共享整数对象的引用计数初始化为INT_MAX，保证不会被释放。</p></li>
<li><p>结构体 robj 的 lru<br/>
用于实现缓存淘汰策略，可以在配置文件中使用maxmemory-policy配置已用内存达到最大内存限制时的缓存淘汰策略。lru根据用户配置的缓存淘汰策略存储不同数据，常用的策略就是LRU与LFU。</p>
<ul>
<li>LRU的核心思想是，如果数据最近被访问过，那么将来被访问的几率也更高，此时lru字段存储的是对象访问时间；</li>
<li>LFU的核心思想是，如果数据过去被访问多次，那么将来被访问的频率也更高，此时lru字段存储的是上次访问时间与访问次数，lru的低8比特存储的是对象的访问次数，高16比特存储的是对象的上次访问时间。</li>
</ul></li>
<li><p>结构体 robj 的 encoding <br/>
结构体 robj 的 encoding 表示当前对象的底层存储采用的数据结构，即对象的编码。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th>可存储对象类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_Quicklist</td>
<td>快速列表</td>
<td>列表</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典</td>
<td>集合、散列表、有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td>散列表、有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合</td>
<td>集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
<td>有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_STREAM</td>
<td>stream</td>
<td>stream</td>
</tr>
<tr>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表(不再使用)</td>
<td>不再使用</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>未使用</td>
<td>未使用</td>
</tr>
</tbody>
</table></li>
</ul>

<h4 id="toc_2">对象内存回收</h4>

<p>由于C语言不具备自动回收内存的功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制。程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>

<p>redisObject 结构中的引用计数器refcount会随着对象的使用状态而不断变化：</p>

<ul>
<li>在创建一个新对象是，引用计数的值会被初始化为 1</li>
<li>当对象被一个新程序使用的时候，它的引用计数值会被增加 1</li>
<li>当对象不再被一个新程序使用的时候，它的引用计数值会被减少 1</li>
<li>当对象的引用计数值变为0的时候，对象所占用的内存会被释放</li>
</ul>

<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>

<p>为了节约内存空间，Redis 会共享 值为 0 ~ 9999 的字符串对象，但是为啥只是共享 0 ~ 9999的整数字符串呢？</p>

<p>当服务器考虑讲一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而共享一个对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗cpu时间也会越多。</p>

<h4 id="toc_3">对象的空闲时长</h4>

<p>redisObject 对象结构的最后一个属性 lru记录了对象最后一次被命令程序访问的时间。<br/>
命令 object idletime 可以打印出给定键的空闲时间，这一空闲时长是通过将当前时间减去键的值对象 lru 时间计算得出的。</p>

<p>键的空闲时间有一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为 volatile-lru或者 allkeys-lru，那么当服务器占用的内存数超过了maxmemory现象所设置的上限值，空闲时长较高的那部分键优先被服务器释放，从而回收内存。</p>

<h3 id="toc_4">1.2、服务端结构体redisServer</h3>

<p>结构体redisServer存储Redis服务器的所有信息，包括但不限于数据库、配置参数、命令表、监听端口与地址、客户端列表、若干统计信息、RDB与AOF持久化相关信息、主从复制相关信息、集群相关信息等。</p>

<p>一个redisDb就代表了一个数据库，而redisServer 中则保存了它所设计到的所有数据库的数组。</p>

<pre><code class="language-c">struct redisServer {     
    // 配置文件绝对路径
    char *configfile;     
    // 数据库的数目,默认16，可通过参数databases配置
    int dbnum;     
    // 数据库数组，数组的每个元素都是redisDb类型
    redisDb *db;     
    //命令字典，redis支持的所有命令都存储在这个字典中，value值为struct redisCommand对象
    dict *commands;     
    // redis的事件循环，类型为aeEventLoop
    aeEventLoop *el;
    // 服务器监听端口号，默认端口号 6379
    int port;     
    //绑定的所有IP地址，可以通过参数bind配置多个
    char *bindaddr[CONFIG_BINDADDR_MAX];     
    // 用户配置的IP地址数目
    int bindaddr_count;     
    //针对bindaddr字段的所有IP地址创建的socket文件描述符
    int ipfd[CONFIG_BINDADDR_MAX];     
    //创建的socket文件描述符数目
    int ipfd_count;    
    //当前连接到Redis服务器的所有客户端
    list *clients;     
    //最大空闲时间，可通过参数timeout配置
    int maxidletime; 
}
</code></pre>

<p>默认情况下，redis客户端的目标数据库为0号数据库，但客户端可以通过执行 select 命令来切换目标数据库。而客户端 client 结构中db属性则记录了它当前的目标数据库</p>

<h3 id="toc_5">1.3、客户端结构体 client</h3>

<p>Redis是典型的客户端服务器结构，客户端通过socket与服务端建立网络连接并发送命令请求，服务端处理命令请求并回复。Redis使用结构体client存储客户端连接的所有信息，包括但不限于客户端的名称、客户端连接的套接字描述符、客户端当前选择的数据库ID、客户端的输入缓冲区与输出缓冲区等。</p>

<pre><code class="language-c">typedef struct client {     
    uint64_t id;     
    int fd;     
    redisDb *db;     
    robj *name;      
    time_t lastinteraction                   
    sds querybuf;     
    int argc;     
    robj **argv;     
    struct redisCommand *cmd;          
    list *reply;     
    unsigned long long reply_bytes;     
    size_t sentlen;     
    char buf[PROTO_REPLY_CHUNK_BYTES];     
    int bufpos; 
} client;

// 用来管理数据库相关数据和实现相关操作
typedef struct redisDb {     
    int id;     // id为数据库序号，默认情况下Redis有16个数据库，id序号为0～15。
    long long avg_ttl;         //avg_ttl存储数据库对象的平均TTL，用于统计
    dict *dict;     //键空间散列表，存储数据库所有键值对。
    dict *expires;     //过期时间散列表，存放键的过期时间，注意dict和expires中的键都指向同一个键的sds。
    dict *blocking_keys;     // 处于阻塞状态的键和对应的client，比如blpop命令阻塞键和对应客户端，而解除客户端的阻塞状态有两种 1：进行push操作；2：阻塞超时
    dict *ready_keys;     //解除阻塞状态的键和对应的client
    list *defrag_later;         // 逐渐尝试逐个碎片整理的key列表
    dict *watched_keys;     //watch的键和对应的client，主要用于事务
} redisDb;
</code></pre>

<p>各字段含义如下:</p>

<ul>
<li>id为客户端唯一ID，通过全局变量server.next_client_id实现</li>
<li>fd为客户端socket的文件描述符</li>
<li>db为客户端使用select命令选择的数据库对象</li>
<li>name 客户端名称，可以使用命令 client setname 设置</li>
<li>lastinteraction 客户端上次与服务器交互的时间，以次实现客户端的超时处理。</li>
<li>querybuf：输入缓冲区，recv函数接收到的客户端命令请求会暂时缓存在此缓冲区</li>
<li>argc：输入缓冲区的命令请求时按照Redis协议格式编码字符串，需要解析出命令请求的所有参数，参数个数存储在argc字段，参数内容被解析为robj对象，存储在argv数组</li>
<li>cmd：待执行的客户端命令</li>
<li>reply：输出链表，存储待返回给客户端的命令回复数据。链表节点存储的值类型为 clientReplyBlock，定义为如下：</li>
</ul>

<pre><code class="language-c">typedef struct clientReplyBlock {     
    size_t size, used;     
    char buf[]; 
} clientReplyBlock;
</code></pre>

<ul>
<li>reply_bytes：表示输出链表中所有节点的存储空间的总和</li>
<li>sentlen：表示已返回给客户端的字节数</li>
<li>buf：输出缓冲区，存储待返回给客户端的命令回复数据，bufpos表示输出缓冲区中数据的最大字节位置，sentlen~bufpos区间的数据都是需要返回给客户端的。</li>
</ul>

<h3 id="toc_6">1.4、命令结构体 redisCommond</h3>

<p>Redis支持的所有命令初始都存储在全局变量redisCommandTable，类型为redisCommand，结构体redisCommand相对简单，主要定义了命令的名称、命令处理函数以及命令标志等</p>

<pre><code class="language-c">struct redisCommand {     
    //命令名称
    char *name;     
    //命令处理函数
    redisCommandProc *proc;    
    //命令参数数目,用于校验命令请求格式是否正确
    int arity;     
    //命令标志，例如标识命令时读命令还是写命令
    char *sflags;     
    //命令的二进制标志，服务器启动时解析sflags字段生成。
    int flags;            
    // calls :从服务器启动至今命令执行的次数，用于统计。
    // 从服务器启动至今命令总的执行时间，microseconds/calls即可计算出该命令的平均处理时间，用于统计
    long long microseconds, calls; 
};
</code></pre>

<h3 id="toc_7">1.5、事件处理</h3>

<p>Redis服务器是典型的事件驱动程序，而事件又分为 <strong><em>文件事件（socket的可读可写事件）</em></strong> 与 <strong><em>时间事件（定时任务）</em></strong> 两大类。无论是文件事件还是时间事件都封装在结构体aeEventLoop中：</p>

<pre><code class="language-c">typedef struct aeEventLoop {     
    //事件循环是否结束
    int stop;         
    //为文件事件数组，存储已经注册的文件事件
    aeFileEvent *events;     
    //存储被触发的文件事件
    aeFiredEvent *fired;     
    //多个时间事件形成链表，timeEventHead即为时间事件链表头节点
    aeTimeEvent *timeEventHead;
    // Redis底层可以使用4种 I/O 多路复用模型（kqueue、epoll等），apidata是对这4种模型的进一步封装。             
    void *apidata     
    //Redis服务器需要阻塞等待文件事件的发生，进程阻塞之前会调用beforesleep函数，
    //进程因为某种原因被唤醒之后会调用aftersleep函数
    aeBeforeSleepProc *beforesleep;     
    aeBeforeSleepProc *aftersleep; 
} aeEventLoop;
</code></pre>

<p>Redis有多个定时任务，因此理论上应该有多个时间事件，多个时间事件形成链表，timeEventHead即为时间事件链表头节点；</p>

<p>Redis服务器需要阻塞等待文件事件的发生，进程阻塞之前会调用beforesleep函数，进程因为某种原因被唤醒之后会调用aftersleep函数。</p>

<p>函数beforesleep会执行一些不是很费时的操作，如：集群相关操作、过期键删除操作（这里可称为快速过期键删除）、向客户端返回命令回复等。</p>

<p>事件驱动程序通常在server 启动过程的最后一步开启事件循环，之后只需等待事件发生处理文件事件和时间事件即可。</p>

<h4 id="toc_8">1.5.1、文件事件</h4>

<p>Redis客户端通过TCP socket与服务端交互，文件事件指的就是socket的可读可写事件。socket读写操作有阻塞与非阻塞之分。</p>

<p>采用阻塞模式时，一个进程只能处理一条网络连接的读写事件，为了同时处理多条网络连接，通常会采用多线程或者多进程，效率低下；非阻塞模式下，可以使用目前比较成熟的I/O多路复用模型，如select/epoll/kqueue等，视不同操作系统而定。</p>

<p>epoll是Linux内核为处理大量并发网络连接而提出的解决方案，能显著提升系统CPU利用率。</p>

<p>Redis并没有直接使用epoll提供的API，而是同时支持4种I/O多路复用模型，并将这些模型的API进一步统一封装。</p>

<p>Redis在编译阶段，会检查操作系统支持的I/O多路复用模型，并按照一定规则决定使用哪种模型。</p>

<h4 id="toc_9">1.5.2、时间事件</h4>

<p>通过文件事件一节可以知道，事件循环执行函数aeProcessEvents的主要逻辑：①查找最早会发生的时间事件，计算超时时间；②阻塞等待文件事件的产生；③处理文件事件；④处理时间事件。时间事件的执行函数为processTimeEvents。</p>

<p>Redis服务器内部有很多定时任务需要执行，定时任务被封装为时间事件aeTimeEvent对象，多个时间事件形成链表，存储在aeEventLoop结构体的timeEventHead字段，它指向链表首节点。</p>

<pre><code class="language-c">typedef struct aeTimeEvent {     
    //时间事件唯一ID，通过字段eventLoop-&gt;timeEventNextId实现
    long long id;     
    //时间事件触发的秒数与毫秒数
    long when_sec;     
    long when_ms;    
    //函数指针，指向时间事件处理函数 
    aeTimeProc *timeProc;
    //函数指针，删除时间事件节点之前会调用此函数     
    aeEventFinalizerProc *finalizerProc;     
    //指向对应的客户端对象
    void *clientData;     
    //指向下一个时间事件节点
    struct aeTimeEvent *next; 
} aeTimeEvent;
</code></pre>

<p>函数serverCron实现了Redis服务器所有定时任务的周期执行。serverCron函数的执行时间不能过长，否则会导致服务器不能及时响应客户端的命令请求。</p>

<h2 id="toc_10">2、server启动过程</h2>

<p>Redis服务器的启动过程，主要分为server初始化，监听端口以及等待命令3节。</p>

<p>服务器初始化主流程可以简要分为7个步骤：<br/>
①初始化配置，给配置参数赋初始值，包括用户可配置的参数，以及命令表的初始化；<br/>
②加载并解析配置文件；<br/>
③初始化服务端内部变量，比如客户端链表、数据库、全局变量和共享对象等；<br/>
④创建事件循环eventLoop，即分配结构体所需内存，并初始化结构体各字段；epoll就是在此时创建的；<br/>
⑤创建socket并启动监听，所有创建的socket都会设置为非阻塞模式，原因在于Redis 使用了IO多路复用模式，其要求socket读写必须是非阻塞的，用户可通过指令port配置socket绑定端口号，指令bind配置socket 绑定IP地址；；<br/>
⑥创建文件事件与时间事件；<br/>
⑦开启事件循环，等待文件时间和时间事件发生即可。</p>

<pre><code class="language-c">void aeMain(aeEventLoop *eventLoop) {     
    eventLoop-&gt;stop = 0;     //开始事件循环    
    while (!eventLoop-&gt;stop) {         
        if (eventLoop-&gt;beforesleep != NULL)             
            eventLoop-&gt;beforesleep(eventLoop);         //事件处理主函数  
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);     
    }
}
</code></pre>

<pre><code class="language-c">int aeProcessEvents(aeEventLoop *eventLoop, int flags) {
    shortest = aeSearchNearestTimer(eventLoop);     
    long long ms = shortest-&gt;when_sec - now_sec)*1000 + shortest-&gt;when_ms - now_ms;     
    …………    
    //阻塞等待文件事件发生
    numevents = aeApiPoll(eventLoop, tvp);     
    for (j = 0; j &lt; numevents; j++) {         
        aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];         
        //处理文件事件，即根据类型执行rfileProc或wfileProc     
    }     
    //处理时间事件    
    processed += processTimeEvents(eventLoop); 
}
</code></pre>

<p>TCP是基于字节流的可靠传输层协议，为了提升网络利用率，一般默认都会开启Nagle。当应用层调用write函数发送数据时，TCP并不一定会立刻将数据发送出去，根据Nagle算法，还必须满足一定条件才行。</p>

<p>Nagle是这样规定的：如果数据包长度大于一定门限时，则立即发送；如果数据包中含有FIN（表示断开TCP链接）字段，则立即发送；如果当前设置了TCP_NODELAY选项，则立即发送；如果以上所有条件都不满足，则默认需要等待200毫秒超时后才会发送。</p>

<p>TCP是可靠的传输层协议，但每次都需要经历“三次握手”与“四次挥手”，为了提升效率，可以设置SO_KEEPALIVE，即TCP长连接，这样TCP传输层会定时发送心跳包确认该连接的可靠性。</p>

<h2 id="toc_11">3、命令处理过程</h2>

<p>命令的处理过程，此过程分为3个阶段：解析命令请求、调用命令和返回结果给客户端。</p>

<h3 id="toc_12">3.1、命令解析</h3>

<p>TCP是一种基于字节流的传输层通信协议，因此接收到的TCP数据不一定是一个完整的数据包，其有可能是多个数据包的组合，也有可能是某一个数据包的部分，这种现象被称为半包与粘包。</p>

<p>为了区分一个完整的数据包，通常有如下3种方法：①数据包长度固定；②通过特定的分隔符区分，比如HTTP协议就是通过换行符区分的；③通过在数据包头部设置长度字段区分数据包长度，比如FastCGI协议。</p>

<pre><code class="language-text">SET redis-key value1
被翻译为如下结构
*3\r\n$3\r\nSET\r\n$9\r\nredis-key\r\n$6\r\nvalue1\r\n
</code></pre>

<p><strong>Redis 使用自定义格式区分不同的命令，客户端会对命令请求转换为如下的协议格式，其中换行符 <code>\r\n</code> 用于区分命令请求的若干参数，<code>“*3”</code>表示该命令请求有3个参数，<code>“$3”</code>表示第一个参数长度为3，顺序读取三个字符SET ， <code>“$9”</code>表示第二个参数的长度，读取为redis-key ， <code>“$6”</code> 表示第三个参数长度为，读取为value1</strong></p>

<p>Redis服务器接收到的命令请求首先存储在客户端对象的querybuf 输入缓冲区，然后解析命令请求各个参数，并存储在客户端对象的argv（参数对象数组）和argc（参数数目）字段。</p>

<p>客户端命令请求的入口函数为readQueryFromClient，会读取socket数据存储到客户端对象的输入缓冲区，并调用函数processInputBuffer解析命令请求。<br/>
<figure><img src="media/15934396305281/15936857634402.jpg" alt="processInputBuffer解析流程"/><figcaption>processInputBuffer解析流程</figcaption></figure></p>

<h3 id="toc_13">3.2、命令调用</h3>

<p>解析完命令请求之后，会调用函数 processCommand 处理该命令请求，而处理命令请求之前还有很多校验逻辑，比如1、客户端是否已经完成认证，2、命令请求参数是否合法，3、如果是quit命令直接返回并关闭客户端，4、执行函数 lookupCommand 查找命令后，如果命令不存在返回错误等，所有的校验规则通过后，才会调用命令处理函数执行命令。</p>

<p>命令执行完之后，如果有必要，还需要更新统计信息，记录慢查询日志，AOF 持久化该命令请求，传播命令请求给所有的从服务器等。</p>

<pre><code class="language-text">    int processCommand(client *c) {
        ...
            if (c-&gt;flags &amp; CLIENT_MULTI 
                &amp;&amp; c-&gt;cmd-&gt;proc != execCommand 
                &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand 
                &amp;&amp;  c-&gt;cmd-&gt;proc != multiCommand 
                &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand) {
                //如果client有CLIENT_MULTI标志并且不是exec，discard，                                          multi和watch命令，则将该命令放入队列            
                queueMultiCommand(c);        //放入队列            
                addReply(c,shared.queued);         
            } else {                        
                //否则调用call命令            
                call(c,CMD_CALL_FULL);         
                ...
            } 
     ...
    }
    ```

### 3.3、返回结果
Redis服务器返回结果类型不同，协议格式不同，而客户端可以根据返回结果的第一个字符判断返回类型。

Redis的返回结果可以分为5类：
- 状态回复，第一个字符是`“+”`；例如，SET命令执行完毕会向客户端返回`“+OK\r\n”`。
- 错误回复，第一个字符是“-”。例如，当客户端请求命令不存在时，会向客户端返回`“-ERR unknown command&#39;testcmd&#39;”`。
- 整数回复，第一个字符是 “:”。例如，INCR命令执行完毕向客户端返回 `“:100\r\n”`。
- 批量回复，第一个字符是` &quot;$&quot;`。例如，GET命令查找键向客户端返回结果`&quot;$5\r\nhello\r\n&quot;`，其中`$5`表示返回字符串长度
- 多条批量回复，第一个字符是`“*”`。例如，LRANGE命令可能会返回多个值，格式为`“*3\r\n$6\r\nvalue1\r\n$6\r\nvalue2\r\n$6\r\nvalue3\r\n”`，与命令请求协议格式相同，`“*3”`表示返回值数目，`“$6”`表示当前返回值字符串长度。
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/06/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='redis.html'>redis</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15930711977940.html">
                
                  <h1>二、Redis 底层基本数据结构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Redis  自己实现了底层的数据结构，简单动态字符串、跳跃表、压缩列表、字典、整数集合、quicklist、stream</p>

<table>
<thead>
<tr>
<th>底层数据结构</th>
<th>可存储对象类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>quickList</td>
<td>列表</td>
</tr>
<tr>
<td>字典</td>
<td>集合、散列表、有序集合</td>
</tr>
<tr>
<td>压缩列表</td>
<td>列表、散列表、有序集合</td>
</tr>
<tr>
<td>整数集合</td>
<td>集合</td>
</tr>
<tr>
<td>跳跃表</td>
<td>有序集合</td>
</tr>
<tr>
<td>stream</td>
<td>stream</td>
</tr>
</tbody>
</table>

<h3 id="toc_0">简单动态字符串 SDS</h3>

<p>简单动态字符串（Simple Dynamic Strings，SDS）是Redis的基本数据结构之一，用于存储字符串和整型数据。SDS兼容C语言标准字符串处理函数，且在此基础上保证了二进制安全。</p>

<pre><code class="language-c">struct __attribute__ ((__packed__))sdshdr5 {     
    unsigned char flags; /* 低3位存储类型, 高5位存储长度 */
    char buf[];/*柔性数组，存放实际内容*/ 
};
struct __attribute__((__packed__))sdshdr8 {     
    uint8_t len; /* 已使用长度，用1字节存储 */    
     uint8_t alloc; /* 总长度，用1字节存储*/     
     unsigned char flags; /* 低3位存储类型, 高5位预留 */    
      char buf[];/*柔性数组，存放实际内容*/ 
};
 struct __attribute__((__packed__))sdshdr16 {    
    uint16_t len; /*已使用长度，用2字节存储*/     
    uint16_t alloc; /* 总长度，用2字节存储*/     
    unsigned char flags; /* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
}; 
struct __attribute__((__packed__))sdshdr32 {     
    uint32_t len; /*已使用长度，用4字节存储*/     
    uint32_t alloc; /* 总长度，用4字节存储*/    
    unsigned char flags;/* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
};
struct __attribute__((__packed__))sdshdr64 {     
    uint64_t len; /*已使用长度，用8字节存储*/     
    uint64_t alloc; /* 总长度，用8字节存储*/     
    unsigned char flags; /* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
};
</code></pre>

<p>(1) SDS如何兼容C语言字符串？如何保证二进制安全？SDS对象中的buf是一个柔性数组，上层调用时，SDS直接返回了buf。由于buf是直接指向内容的指针，故兼容C语言函数。而当真正读取内容时，SDS会通过len来限制读取长度，而非“\0”，保证了二进制安全。<br/>
(2) sdshdr5的特殊之处是什么？sdshdr5只负责存储小于32字节的字符串。一般情况下，小字符串的存储更普遍，故Redis进一步压缩了sdshdr5的数据结构，将sdshdr5的类型和长度放入了同一个属性中，用flags的低3位存储类型，高5位存储长度。创建空字符串时，sdshdr5会被sdshdr8替代。<br/>
(3) SDS是如何扩容的？SDS在涉及字符串修改处会调用sdsMakeroomFor函数进行检查，根据不同情况动态扩容，该操作对上层透明。</p>

<h3 id="toc_1">跳跃表 zskiplist</h3>

<p>通过将有序集合的部分节点分层，由最上层开始依次向后查找，如果本层的next节点大于要查找的值或next节点为NULL，则从本节点开始，降低一层继续向后查找，依次类推，如果找到则返回节点；否则返回NULL。采用该原理查找节点，在节点数量比较多时，可以跳过一些节点，查询效率大大提升，这就是跳跃表的基本思想。</p>

<p>跳跃表存储结构如下图所示：<br/>
<figure><img src="media/15930711977940/15932648695005.jpg" alt="跳跃表存储结构"/><figcaption>跳跃表存储结构</figcaption></figure></p>

<p>接下来看下跳跃表的数据结构 </p>

<pre><code class="language-c">// 定义了skiplist的节点结构
typedef struct zskiplistNode {    
    sds ele;    //用于存储字符串类型的数据
    double score;   //用于存储排序的分支
    struct zskiplistNode *backward;     //后退指针，只能执行当前节点最底层的前一个节点，头节点和第一个节点的backward指向NULL，从后向前遍历跳跃表时使用
    struct zskiplistLevel {
        struct zskiplistNode *forward;      //指向本层下一个节点，尾结点的forward指向null
        unsigned int span;      //forward 指向的节点与本节点之间的元素个数，span越大，跳过的节点个数越多。
    } level[];      // 柔性数组，每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个 1~64 的值，值越大出现的概率越低
} zskiplistNode;

// 定义了真正的skiplist结构
typedef struct zskiplist {     
    struct zskiplistNode *header, *tail;    // 头指针header和尾指针tail
    unsigned long length;   // 链表长度length，即链表包含的节点总数。创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中
    int level;  //skiplist的总层数，即所有节点层数的最大值
} zskiplist;
</code></pre>

<p>所有节点是按照分值 score 从小到大的方式排序的，当有序集合的 score 相同时，节点会按照 ele 的字典序进行排序。</p>

<h3 id="toc_2">压缩列表 ziplist</h3>

<p>压缩列表ziplist本质上就是一个字节数组(一块连续的内存空间)，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。ziplist 的存储顺序与插入顺序一致，而散列表的存储则不一致。</p>

<h4 id="toc_3">压缩列表 ziplist 存储结构</h4>

<p>压缩列表 结构示意图如下：<br/>
<figure><img src="media/15930711977940/15932748544287.jpg" alt="" style="width:856px;"/></figure></p>

<ul>
<li>zlbytes： 占4个字节，压缩列表的字节长度，因此压缩列表最多有232 -1个字节。</li>
<li>zltail： 占4个字节,压缩列表尾元素相对于压缩列表起始地址的偏移量。</li>
<li>zllen： 占2个字节,压缩列表的元素个数。zllen无法存储元素个数超过65535（216 -1）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。</li>
<li>entryX： 压缩列表存储的元素，可以是字节数组或者整数，长度不限。</li>
<li>zlend： 占1个字节，压缩列表的结尾，恒为0xFF。</li>
</ul>

<p>查看一个压缩列表示例：</p>

<p><figure><img src="media/15930711977940/15932741442146.jpg" alt="" style="width:888px;"/></figure></p>

<p>了解了压缩列表的基本结构，我们可以很容易地获得压缩列表的字节长度、元素个数等，那么如何遍历压缩列表呢？对于任意一个元素，我们如何判断其存储的是什么类型呢？我们又如何获取字节数组的长度呢？</p>

<p><strong>压缩列表元素</strong>的结构示意图如下所示：<br/>
<figure><img src="media/15930711977940/15932749731815.jpg" alt="" style="width:900px;"/></figure></p>

<p>previous_entry_length 字段表示前一个元素的字节长度，占1个或者5个字节，</p>

<ul>
<li>当前一个元素的长度小于254字节时，用1个字节表示；</li>
<li>当前一个元素的长度大于或等于254字节时，用5个字节来表示。而此时previous_entry_length字段的第1个字节是固定的0xFE，后面4个字节才真正表示前一个元素的长度。<br/>
假设已知当前元素的首地址为p，那么p - previous_entry_length就是前一个元素的首地址，从而实现压缩列表从尾到头的遍历。</li>
</ul>

<p>encoding字段表示当前元素的编码，即content字段存储的数据类型（整数或者字节数组），数据内容存储在content字段。为了节约内存，encoding字段同样长度可变。</p>

<p>压缩列表元素的编码如下表所示：</p>

<table>
<thead>
<tr>
<th>encoding编码</th>
<th>encoding 长度</th>
<th>content类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>00 bbbbbb (6 比特表示content长度)</td>
<td>1字节</td>
<td>最大长度为63的字节数组</td>
</tr>
<tr>
<td>01 bbbbbb xxxxxxxx (14比特表示content 长度)</td>
<td>2字节</td>
<td>最大长度为2<sup>14</sup> -1 的字节数组</td>
</tr>
<tr>
<td>10 aaaaaaaa bbbbbbbb cccccccc dddddddd (32比特表示 content长度)</td>
<td>5字节</td>
<td>最大长度为2<sup>32</sup> -1 的字节数组</td>
</tr>
<tr>
<td>11 00 0000</td>
<td>1字节</td>
<td>int 16整数</td>
</tr>
<tr>
<td>11 01 0000</td>
<td>1字节</td>
<td>int 32整数</td>
</tr>
<tr>
<td>11 10 0000</td>
<td>1字节</td>
<td>int 64整数</td>
</tr>
<tr>
<td>11 11 0000</td>
<td>1字节</td>
<td>24位整数</td>
</tr>
<tr>
<td>11 11 1110</td>
<td>1字节</td>
<td>8位 整数</td>
</tr>
<tr>
<td>11 11 xxxx</td>
<td>1字节</td>
<td>没有 content 字段 xxxx 表示 0~12的整数，数据直接存储在encoding字段的最后4位</td>
</tr>
</tbody>
</table>

<p>Redis 定义的 encoding 字段的各个编码类型：</p>

<pre><code class="language-c">#define ZIP_STR_06B (0 &lt;&lt; 6) 
#define ZIP_STR_14B (1 &lt;&lt; 6) 
#define ZIP_STR_32B (2 &lt;&lt; 6) 
#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4) 
#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4) 
#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4) 
#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4) 
#define ZIP_INT_8B 0xfe
</code></pre>

<p>由于previous_entry_length存储前一个元素的字节长度，长度占1个或5个字节，为了能存储前一个元素的字节长度，在更新压缩列表过程中可能会出现一种被称为“连锁更新”的现象，Redis 在删除和插入元素操作的末尾检查是需要更新后续元素的 previous_entry_length字段，不过其造成性能问题的几率很低</p>

<h4 id="toc_4">压缩列表 ziplist 的结构体</h4>

<p>我们发现对于压缩列表的任意元素，获取前一个元素的长度、判断存储的数据类型、获取数据内容都需要经过复杂的解码运算。解码后的结果应该被缓存起来，为此定义了结构体zlentry，用于表示解码后的压缩列表元素。</p>

<pre><code class="language-c">typedef struct zlentry {
    unsigned int prevrawlensize;    //previous_entry_length 字段的长度
    unsigned int prevrawlen;    //previous_entry_length 字段存储的内容
    unsigned int lensize;   //encoding 字段的长度
    unsigned int len;   //encoding 元素数据内容的长度
    unsigned char encoding;     //encoding中 数据类型
    unsigned int headersize;    // 表示当前元素的首部长度，即previous_entry_lengh字段长度与encoding字段长度之和
    unsigned char *p;   //当前元素首地址
} zlentry;
</code></pre>

<h3 id="toc_5">字典 Dict</h3>

<p>字典又称为散列表，是用来存储键值 (key-value) 对的一种数据结构，Redis 是K-V 型数据库，任何的增删改查操作实际上都是对字典中的数据进行增删改查操作。</p>

<p>Redis 字典实现依赖的数据结构主要包含了三部分：字典、Hash表、Hash表节点。字典中嵌入了两个 Hash 表，Hash 表中的table字段存放 Hash 表节点，Hash 表节点对应存储的是键值对。</p>

<ul>
<li>Hash表的数据结构如下：</li>
</ul>

<pre><code class="language-c">typedef struct dictht {     
    dictEntry **table;                /* 指针数组，用于存储键值对*/     
    unsigned long size;                /* table数组的总大小*/     
    unsigned long sizemask;        /* 掩码 = size - 1 ，用来计算键的索引值*/     
    unsigned long used;                /* table数组已存元素个数，包含next单链表的数据*/ 
} dictht;
</code></pre>

<ul>
<li>Hash 表节点的数据结构如下：</li>
</ul>

<pre><code class="language-c">typedef struct dictEntry {     
    void *key;                        /*存储键*/     
    union {         
        void *val;                        /*redisDb.dict 中的val*/         
        uint64_t u64;         
        int64_t s64;                /*redisDb.expires 中存储过期时间*/         
        double d;     
    } v;
    struct dictEntry *next;        /*当Hash冲突时，指向冲突的元素，形成单链表*/ 
} dictEntry;
</code></pre>

<ul>
<li>最外层的 字典 Dict 数据结构 如下：</li>
</ul>

<pre><code class="language-c">typedef struct dict {     
    dictType *type;           /*该字典对应的一组特定操作抽象函数*/     
    void *privdata;           /*该字典依赖的数据，配合type字段指向的函数一起使用*/     
    dictht ht[2];               /*  Hash 表的数组，键值对存储在这里，一般情况下只会使用ht[0]，只有当盖子点扩容、缩容需要进行rehash ，才会使用到ht[1]*/     
    long rehashidx;            /*rehash标识。默认值为-1，代表没进行rehash操作；不为-1时，代表正进行rehash操作，存储的值表示Hash表ht[0]的rehash操作进行到了哪个索引值*/     
    unsigned long iterators; /* 当前运行的迭代器数*/ 
} dict;
</code></pre>

<p>Redis字典这个数据结构，除了主数据库的K-V数据存储外，还有很多其他地方会用到。例如，Redis的哨兵模式，就用字典存储管理所有的Master节点及Slave节点；再如，数据库中键值对的值为Hash类型时，存储这个Hash类型的值也是用的字典。在不同的应用中，字典中的键值对形态都可能不同，而dictType结构体，则是为了实现各种形态的字典而抽象出来的一组操作函数。</p>

<p>Redis 字典结构的完整版<br/>
<figure><img src="media/15930711977940/15933377033789.jpg" alt=""/></figure></p>

<p><strong><em>在Hash 表扩容或者收缩的时候，程序需要将现有的哈希表中的所有键值对rehash 到新的 Hash表里面，此rehash 过程不是一次性完成的，而是渐进式的完成。</em></strong></p>

<h3 id="toc_6">整数集合</h3>

<p>整数集合 intset 的底层实现为数组， 是一个有序的、无重复数据的、存储整形数据的结构。</p>

<p>在两种情况下，set 集合 底层编码会发生转换：</p>

<ul>
<li>当元素个数超过一定数量(默认值512)之后，即使元素类型仍然是整型，也会将编码转换为 hashtable。由配置项 set-max-intset-entries 512 决定。</li>
<li>当增加非整型变量是，例如集合中增加元素 &#39;a&#39; ，集合编码从 intset 转换为 hashtable。</li>
</ul>

<p>整数集合在Redis 中可以保存 int16_t、int32_t、int64_t类型的整型数据，并且可以保证集合中<strong>不会出现重复数据</strong>。每个整数集合使用一个 intset 类型的数据结构表示。<br/>
intset 数据结构如下：<br/>
<figure><img src="media/15930711977940/15934343810923.jpg" alt=""/></figure></p>

<pre><code class="language-c">typedef struct intset {     
    uint32_t encoding;//编码类型    
    uint32_t length;//元素个数    
    int8_t contents[];//柔性数组,根据encoding字段决定几个字节表示一个元素
} intset
</code></pre>

<ul>
<li>encoding<br/>
编码类型，决定每个元素占用几个字节
<ul>
<li>INTSET_ENC_INT16：当元素值都位于INT16_MIN和INT16_MAX之间时使用。该编码方式为每个元素占用2个字节。</li>
<li>INTSET_ENC_INT32：当元素值位于INT16_MAX到INT32_MAX或者INT32_MIN到INT16_MIN之间时使用。该编码方式为每个元素占用4个字节。</li>
<li>INTSET_ENC_INT64：当元素值位于INT32_MAX到INT64_MAX或者INT64_MIN到INT32_MIN之间时使用。该编码方式为每个元素占用8个字节。</li>
</ul></li>
</ul>

<p>当 存放新元素到 整数集合中的时候，如果新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进性升级，然后才能将新元素添加到整数集合里面。</p>

<p>整数集合的升级操作提升了它的灵活性又尽可能的节约了内存空间。</p>

<h3 id="toc_7">quicklist</h3>

<h4 id="toc_8">quicklist 存储数据结构</h4>

<p>quicklist是Redis底层最重要的数据结构之一，它是Redis对外提供的6种基本数据结构中List的底层实现。</p>

<ul>
<li><p>list<br/>
链表是这样一种数据结构，其中的各对象按线性顺序排列。<br/>
链表与数组的不同点在于，数组的顺序由下标决定，链表的顺序由对象中的指针决定。<br/>
List是链型数据存储常用的数据结构，可以是单向链表、双向链表，可以是排序链表、无序链表，可以是循环链表、非循环链表。<br/>
链表具有可快速插入、删除的优点。<br/>
由于List查找复杂度为O(n)，n为元素个数，所以不适用于快速查找的场合。<br/>
双向非循环链表结构图：<br/>
<figure><img src="media/15930711977940/15937659545835.jpg" alt=""/></figure></p></li>
<li><p>quicklist<br/>
quicklist是Redis 3.2中新引入的数据结构，能够在时间效率和空间效率间实现较好的折中。<br/>
<strong>quicklist是一个由 ziplist 充当节点的双向链表</strong>。quicklist是一个双向链表，链表中的每个节点是一个 ziplist 结构。<br/>
quicklist可以看成是用双向链表将若干小型的ziplist连接到一起组成的一种数据结构。<br/>
当ziplist节点个数过多，quicklist退化为双向链表，一个极端的情况就是每个ziplist节点只包含一个entry，即只有一个元素。当ziplist元素个数过少时，quicklist可退化为ziplist，一种极端的情况就是quicklist中只有一个ziplist节点。</p></li>
</ul>

<p><figure><img src="media/15930711977940/15934465912385.jpg" alt=""/></figure></p>

<p>quicklist核心结构如下：</p>

<pre><code class="language-c">typedef struct quicklist {     
    quicklistNode *head;     // 头节点
    quicklistNode *tail;     // 尾节点
    unsigned long count;        //quicklist中元素总数 
    unsigned long len;          // quicklistNode节点个数   
    //指明每个quickListNade 中ziplist长度
    //当fill为正数时，表明每个ziplist最多含有的数据项数。
    //当fill为负数时，fill == -1 ：ziplist节点最大为 4KB；
    //fill == -2 ：ziplist节点最大为8KB； 
    //fill == -3 ：ziplist节点最大为16KB；
    //fill == -4 ：ziplist节点最大为32KB；
    //fill == -5 ：ziplist节点最大为64KB
    int fill : 16;        
     //Redis允许对中间的quicklistNode节点进行压缩，
     //通过修改参数list-compress-depth进行配置，即设置compress参数
     //该项的具体含义是两端各有compress个节点不压缩 ,  
     //通过修改参数list-compress-depth进行配置，0=off          
    unsigned int compress : 16; 
} quicklist;

typedef struct quicklistNode {     
    struct quicklistNode *prev;     // 指向该节点的前节点
    struct quicklistNode *next;     // 指向该节点的后节点
    unsigned char *zl;      //指向该节点对应的 ziplist 结构
    unsigned int sz;        //代表整个 ziplist 结构的大小
    unsigned int count : 16;        // ziplist 中元素个数
    unsigned int encoding : 2;      //代表采用的编码，1：原生结构；2：使用 LZF 进行压缩    
    unsigned int container : 2;     //为quicklistNode节点 zl 指向的容器类型，1: none；2: 使用 ziplist 存储数据    
    unsigned int recompress : 1;    // 这个节点之前是否是压缩节点，若是，则在使用压缩节点前新进行解压缩，使用后需要重新压缩；1的时候代表是压缩节点。
    unsigned int attempted_compress : 1;        // 测试时使用，   
    unsigned int extra : 10;     //预留字段 
} quicklistNode;

/* 当对 ziplist 利用 LZF 算法进行压缩时，quicklistNode 节点指向的结构为 quicklistLZF*/
typedef struct quicklistLZF {     
    unsigned int sz;    // compressed 所占用的 字节大小     
    char compressed[]; 
} quicklistLZF;

/* 当使用quicklistNode中ziplist中的一个节点时，Redis提供了quicklistEntry结构以便于使用 */
typedef struct quicklistEntry {     
    const quicklist *quicklist;     // 指向当前元素所在的quicklist
    quicklistNode *node;     // 指向当前元素所在的quicklistNode结构
    unsigned char *zi;     // 指向当前元素所在的ziplist
    unsigned char *value;    // 指向该节点的字符串内容
    long long longval;     // longval为该节点的整型值
    unsigned int sz;     // sz代表该节点的大小，与value配合使用
    int offset;     // 表明该节点相对于整个ziplist的偏移量，即该节点是ziplist第多少个entry
} quicklistEntry;

// quicklistIter是quicklist中用于遍历的迭代器
typedef struct quicklistIter {     
    const quicklist *quicklist;     //指向当前元素所处的quicklist
    quicklistNode *current;     // 指向元素所在quicklistNode
    unsigned char *zi;     // 指向元素所在的ziplist
    long offset;    // 表明节点在所在的ziplist中的偏移量     
    int direction;  //direction表明迭代器的方向
} quicklistIter;
</code></pre>

<h4 id="toc_9">数据压缩</h4>

<p>quicklist每个节点的实际数据存储结构为ziplist，这种结构的主要优势在于节省存储空间。</p>

<p>为了进一步降低ziplist所占用的空间，Redis 允许对ziplist进一步压缩，Redis采用的压缩算法是LZF，压缩过后的数据可以分成多个片段，每个片段有2部分：一部分是解释字段，另一部分是存放具体的数据字段。解释字段可以占用1～3个字节，数据字段可能不存在。</p>

<p>LZF压缩后的数据结构图如下所示：<br/>
<figure><img src="media/15930711977940/15935992099183.jpg" alt="LZF压缩后的数据结构"/><figcaption>LZF压缩后的数据结构</figcaption></figure></p>

<p>LZF压缩的数据格式有3种，即解释字段有3种：</p>

<ul>
<li><p>字面型，解释字段占用1个字节，数据字段长度由解释字段后5位决定。<br/>
<figure><img src="media/15930711977940/15937674478317.jpg" alt=""/></figure></p></li>
<li><p>简短重复型，解释字段占用2个字节，没有数据字段，数据内容与前面数据内容重复，重复长度小于8，图中L 是长度字段，数据长度为长度字段的字面值加2，o是偏移量字段，位置偏移量是偏移字段组成的字面值加1。<br/>
<figure><img src="media/15930711977940/15937678687562.jpg" alt=""/></figure></p></li>
<li><p>批量重复型，解释字段占3个字节，没有数据字段，数据内容与前面内容重复。图中L是长度字段，数据长度为长度字段的字面值加9，o是偏移量字段，位置偏移量是偏移字段组成的字面值加1。<br/>
<figure><img src="media/15930711977940/15937679218472.jpg" alt=""/></figure></p></li>
</ul>

<h4 id="toc_10">压缩</h4>

<p>LZF数据压缩的基本思想是：数据与前面重复的，记录重复位置以及重复长度，否则直接记录原始数据内容。</p>

<p>压缩算法的流程如下：遍历输入字符串，对当前字符及其后面2个字符进行散列运算，如果在Hash表中找到曾经出现的记录，则计算重复字节的长度以及位置，反之直接输出数据。</p>

<h4 id="toc_11">解压缩</h4>

<p>根据LZF压缩后的数据格式，我们可以较为容易地实现LZF的解压缩。值得注意的是，可能存在重复数据与当前位置重叠的情况，此时需要按位逐个进行复制。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/06/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='redis.html'>redis</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="redis.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="redis_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
