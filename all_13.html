<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15867863097702.html">
                
                  <h1>AbstractQueuedSynchronizer(AQS)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">了解 LockSupport</a>
</li>
<li>
<a href="#toc_1">AQS 使用方式</a>
</li>
<li>
<a href="#toc_2">AQS 源码解读</a>
<ul>
<li>
<a href="#toc_3">AQS 中的数据结构</a>
<ul>
<li>
<a href="#toc_4">Node节点</a>
</li>
<li>
<a href="#toc_5">head 和 tail</a>
</li>
<li>
<a href="#toc_6">state</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">节点在同步队列中的增加</a>
</li>
<li>
<a href="#toc_8">独占式同步状态获取与释放</a>
<ul>
<li>
<a href="#toc_9">获取同步状态</a>
</li>
<li>
<a href="#toc_10">释放同步状态</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">共享式同步状态获取与释放</a>
</li>
<li>
<a href="#toc_12">下面实现一个共享锁，代码如下：</a>
</li>
<li>
<a href="#toc_13">ConditionObject</a>
<ul>
<li>
<a href="#toc_14">ConditionObject的数据结构</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>AQS提供一个框架来实现基于先进先出(FIFO)同步队列的阻塞锁和相关同步器(信号量、事件等)。它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p>

<p>AQS同步器是实现锁(也可以是任意同步组件)的关键，在锁的实现中聚合同步器。</p>

<p>锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线 程并行访问)，隐藏了实现细节;</p>

<p>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、 线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者 所需关注的领域。</p>

<h2 id="toc_0">了解 LockSupport</h2>

<p>LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。</p>

<p>LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>

<p>LockSupport 增加了 park(Object blocker)、parkNanos(Object blocker,long nanos)和 parkUntil(Object blocker,long deadline)3 个方法，用于实现阻塞当前线程的功能，其中参数 blocker 是用来标识当前线程在等待的对象(以下称为阻塞对象)，线程被阻塞时记录此对象，以允许监视和诊断工具识别线程被阻塞的原因。<br/>
关于LockSupport给出一个样例</p>

<pre><code class="language-java">/**
 * 先入先出的不可重入锁
 */
public class FiFOMutex {

    private final AtomicBoolean locked = new AtomicBoolean(false);
    private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;&gt;();

    public void lock() {
        boolean wasInterrupted = false;
        Thread current = Thread.currentThread();
        waiters.add(current);

        // Block while not first in queue or cannot acquire lock
        while (waiters.peek() != current ||
                !locked.compareAndSet(false, true)) {
            LockSupport.park(this);
            if (Thread.interrupted()) // ignore interrupts while waiting
                wasInterrupted = true;
        }

        waiters.remove();
        if (wasInterrupted)          // reassert interrupt status on exit
            current.interrupt();
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
    
}
</code></pre>

<hr/>

<h2 id="toc_1">AQS 使用方式</h2>

<p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管 理同步状态，在 AQS 里由一个 int 型的 state 来代表这个状态，在抽象方法的实 现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的 3 个方法 (getState()、setState(int newState)和 compareAndSetState(int expect,int update)) 来进行操作，因为它们能够保证状态的改变是安全的。</p>

<p>AQS支持默认独占模式和共享模式来获取同步状态，子类应被定义为自定义同步组件的非公共静态内部类，AQS 自身不实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，这样就可以方便实现不同类型的同步组件(ReentrantLock、 ReentrantReadWriteLock、CountDownLatch、Semaphore、CyclicBarrier 等)。</p>

<p>AQS的设计者采用模板模式，提供一系列模板方法供不同类型的同步组件使用，如下所示：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>void acquire(int arg)</td>
<td>以独占木事获取同步状态，忽略中断，如果获取同步状态成功，直接返回true，否则将会进入同步队列中等待，该方法会调用重写的tryAcquire(int arg)方法</td>
</tr>
<tr>
<td>void acquireInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>以共享模式获取同步状态，忽略中断，当前线程未获取到同步状态，则进入同步队列等待，与acquire(int arg)不同的是，同一时刻可以有多个线程获取同步状态</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>以独占方式释放同步状态，在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
</tbody>
</table>

<p>AQS提供的支持类型的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Collection<Thread> getExclusiveQueuedThreads()</td>
<td>返回同步队列中以独占模式获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Thread getFirstQueuedThread()</td>
<td>返回同步队列中第一个（等待时间最长的）线程，或 null如果没有线程正在排队。</td>
</tr>
<tr>
<td>Collection<Thread> getQueuedThreads()</td>
<td>返回同步队列中的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getSharedQueuedThreads()</td>
<td>返回同步队列中以共享模式下获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getWaitingThreads(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>返回包含可能正在等待与此同步器关联的给定条件的线程。</td>
</tr>
<tr>
<td>boolean isQueued(Thread thread)</td>
<td>给定的线程当前在排队，则返回true。</td>
</tr>
<tr>
<td>boolean hasQueuedPredecessors()</td>
<td>是否有比当前线程更早排队的线程。该方法被设计为由一个公平的同步器使用</td>
</tr>
<tr>
<td>boolean hasWaiters(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>查询任何线程是否等待与此同步器相关联的给定条件。 请注意，由于超时和中断可能随时发生， true返回不能保证未来的signal将唤醒任何线程。 该方法主要用于监视系统状态。</td>
</tr>
<tr>
<td>isQueued(Thread thread)</td>
<td>如果给定的线程当前在排队，则返回true。</td>
</tr>
</tbody>
</table>

<p>需要子类重写的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>boolean tryAcquire(int arg)</td>
<td>以独占模式获取同步状态，需要查询当前状态，并判断同步状态是否符合预期，然后进行CAS设置同步状态</td>
</tr>
<tr>
<td>boolean tryAcquireShared(int arg)</td>
<td>以共享模式获取。 返回大于等于0的值，表示获取成功，否则，获取失败</td>
</tr>
<tr>
<td>boolean tryRelease(int arg)</td>
<td>独占模式下释放同步状态，等待获取同步状态的线程将有机会获取同步状态成功</td>
</tr>
<tr>
<td>boolean tryReleaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>当前同步器是否被当前线程所独占，此方法仅在AbstractQueuedSynchronizer.ConditionObject方法内部调用，因此如果不使用条件，则不需要定义该方法</td>
</tr>
</tbody>
</table>

<p>访问或修改同步状态的方法<br/>
重写同步器指定的方法时，需要使用同步器提供的如下 3 个方法来访问或修 改同步状态。<br/>
•getState():获取当前同步状态。<br/>
•setState(int newState):设置当前同步状态。<br/>
•compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<p>开发者可以自定义同步器，例如：</p>

<pre><code class="language-java">/**
 * 门闩锁
 */
class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() != 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled() ? 1 : -1;
     }

     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
 }
</code></pre>

<hr/>

<h2 id="toc_2">AQS 源码解读</h2>

<h3 id="toc_3">AQS 中的数据结构</h3>

<p><figure><img src="media/15867863097702/15874785413013.jpg" alt=""/></figure></p>

<h4 id="toc_4">Node节点</h4>

<p>Node节点是同步队列节点类。同步队列（由Node实现）是“CLH”(Craig、Landin和Hagersten)锁队列的变体，CLH锁通常用于自旋锁。<br/>
Node节点会存1、储线程信息；2、当前线程&quot;获取锁&quot;请求的状态（取消、通知下一节点）；3、当前节点的前驱和后驱节点等信息。</p>

<p>Node节点设计如下：</p>

<pre><code class="language-java">static final class Node {
        // 初始 共享模式节点
        static final Node SHARED = new Node();
        // 独占模式节点
        static final Node EXCLUSIVE = null;
        //表示由于超时或中断线程，已取消的等待状态值
        static final int CANCELLED = 1; 
        //表示当前节点在释放或取消的占用状态的时候需要将其后继节点的线程唤醒
        static final int SIGNAL = -1;
        //表示线程正在等待某个条件
        static final int CONDITION = -2;
        //表示一个被释放的节点应该被传播到其他节点。这是在doReleaseShared中设置的(仅针对head节点)，以确保传播能够继续，即使其他操作已经介入。
        static final int PROPAGATE = -3;
        // 线程”获取锁“ 的请求等待状态 0、CANCELLED、SIGNAL、PROPAGATE、CONDITION
        volatile int waitStatus;
        // 表示该节点的前一个 Node 节点(前驱)
        volatile Node prev;
        //表示该节点的后一个 Node 节点(后继)
        volatile Node next;
        // 表示该节点的代表的线程
        volatile Thread thread;
        // 表示等待 condition 条件的 Node 节点
        Node nextWaiter;
        // 是否共享模式
        final boolean isShared() {
            return nextWaiter == SHARED;
        }
        // 当前节点的前驱节点
        final Node predecessor() throws NullPointerException {
            Node p = prev;
            if (p == null)
                throw new NullPointerException();
            else
                return p;
        }
        //用于建立初始标头或共享标头
        Node() {}
        
        Node(Thread thread, Node mode) {     // Used by addWaiter
            this.nextWaiter = mode;
            this.thread = thread;
        }

        Node(Thread thread, int waitStatus) { // Used by Condition
            this.waitStatus = waitStatus;
            this.thread = thread;
        }
    }
</code></pre>

<h4 id="toc_5">head 和 tail</h4>

<p>head是指向Node同步队列的头结点，tail是指向Node同步队列的尾结点。</p>

<h4 id="toc_6">state</h4>

<p>同步器当前的的同步状态，通过下面3个方法进行访问：<br/>
•getState():获取当前同步状态。<br/>
•setState(int newState):设置当前同步状态。<br/>
•compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<hr/>

<h3 id="toc_7">节点在同步队列中的增加</h3>

<p>当一个线程成功地获取了同步状态(或者锁)，其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS 会将这个线程以及等待状态等信息构造成 为一个节点(Node)并将其加入同步队列的尾部。</p>

<p>而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于 CAS 的设置尾节点的方法: compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾 节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>

<p>首节点的变化<br/>
首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设 置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功 获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只需要将 首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。</p>

<h3 id="toc_8">独占式同步状态获取与释放</h3>

<p>首先看一下度展示同步状态获取与释放的流程图：<br/>
<figure><img src="media/15867863097702/15874795148241.jpg" alt=""/></figure></p>

<h4 id="toc_9">获取同步状态</h4>

<p>获取同步状态通过调用同步器的 acquire(int arg)方法可以获取同步状态，主要完成了同步 状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是:</p>

<p><strong>首先</strong>调用自定义同步器实现的 tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。<br/>
<strong>其次</strong>如果同步状态获取失败(tryAcquire 返回 false)，则构造同步节点(独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态)并通过 addWaiter(Node node)方法将该节点加入到同步队列的尾部，<br/>
<strong>最后</strong>调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环” 的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒 主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>

<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>

<p>从源码中可以看到获取同步状态代码只有3行代码，其中最重要的就是下面的三个方法：</p>

<ul>
<li>tryAcquire(int arg)</li>
</ul>

<p>尝试以独占模式获取。该方法应该查询对象的状态是否允许以独占模式获取它，如果允许，则应该获取它。需要我们自定义实现</p>

<pre><code class="language-java">protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
</code></pre>

<ul>
<li>addWaiter(Node node)</li>
</ul>

<p>将当前线程包装成 Node 后，队列不为空的情况下，先尝试把当前节点加入 队列并成为尾节点，如果不成功或者队列为空进入 enq(final Node node)方法</p>

<p>在 enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new 出一个空节点，并让首节点(head)和尾节点(tail)两个引用都指向这个空节点; 第二件事，把当前节点加入队列。<br/>
在“死循环”中只有通过 CAS 将节点设置成为尾节点之后，当前线程才能从 该方法返回，否则，当前线程不断地尝试设置。</p>

<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 尝试一次快速排队操作，失败的话，enq来补位。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        //保证线程安全的原子操作
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}

// 将节点插入队列，必要时进行初始化.
private Node enq(final Node node) {
    for (; ; ) {
        Node t = tail;
        if (t == null) { 
            // 对head节点进行初始化赋值，并头尾指向同一个节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // head和tail节点初始化之后，将node加到队列尾部
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>

<ul>
<li>acquireQueued(Node node, arg)</li>
</ul>

<p>其实就是一个自旋的过程，每个节点(或者说每个线程)都在自省地观察， 当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中(并会阻塞节点的线程)。<br/>
在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中 尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么?原因有两个。<br/>
第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br/>
第二，维护同步队列的 FIFO 原则。<br/>
当前线程获取到同步状态后，让首节点(head)这个引用指向自己所在节点。 当同步状态获取成功后，当前线程就从 acquire 方法返回了。如果同步器实现的 是锁，那就代表当前线程获得了锁。</p>

<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            //获取节点的前驱结点
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //是否要阻塞线程并判断是否被中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 如果
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h4 id="toc_10">释放同步状态</h4>

<p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的 release(int arg)方法可以释 放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节 点重新尝试获取同步状态)。</p>

<pre><code class="language-java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>

<p>该方法执行时，会唤醒首节点(head)所指向节点的后继节点线程， unparkSuccessor(Node node)方法使用 LockSupport 来唤醒处于等待状态的线程。</p>

<pre><code class="language-java">private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>

<p>这段代码的意思，一般情况下，被唤醒的是 head 指向节点的后继节点线程， 如果这个后继节点处于被 cancel 状态， 会转而从尾开始遍历，找到最前面且没有被 cancel 的节点。</p>

<hr/>

<h3 id="toc_11">共享式同步状态获取与释放</h3>

<p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时 获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p>

<p>因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于 等于 0。可以看到，在 doAcquireShared(int arg)方法的自旋过程中，如果当前节<br/>
  点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于 0，表示该次获 取同步状态成功并从自旋过程中退出。</p>

<pre><code class="language-java">public final void acquireShared(int arg) {
    // tryAcquireShared共享方式尝试获取资源。负数表示失败；0表示成功获得同步状态，但没有剩余可用资源；正数表示成功，且有剩余资源。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>

<p>我们看下doAcquireShared(int arg)方法的实现</p>

<pre><code class="language-java">// 以共享不可中断模式获取。
private void doAcquireShared(int arg) {
    // 构建当前线程的共享节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            // 获取当前节点的前驱节点，前驱节点如果是头结点的话，当前线程会尝试获取同步状态
            final Node p = node.predecessor();
            if (p == head) {
                // tryAcquireShared(int arg)方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    // 此处是与独占同步器的最大不同点
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果当前线程无法获取到同步状态，则在此处阻塞，等待被唤醒
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

// 设置新的头结点，并将获取的同步状态释放，通知后续节点共享锁资源
private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head;
        // 将node节点设置为头结点
        setHead(node);
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
                (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            //下个节点是共享模式的，则释放当前线程的
            if (s == null || s.isShared())
                // 当前线程释放锁，通知下一个节点
                doReleaseShared();
        }
    }
</code></pre>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够 支持多个线程同时访问的并发组件(比如 Semaphore)，它和独占式主要区别在 于 tryReleaseShared(int arg)方法必须确保同步状态(或者资源数)线程安全释放， 一般是通过循环和 CAS 来保证的，因为释放同步状态的操作会同时来自多个线程。</p>

<pre><code class="language-java">private void doReleaseShared() {
        
        for (; ; ) {
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    // 释放同步状态不成功的话，继续执行释放
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            
                    // 唤醒后续节点
                    unparkSuccessor(h);
                } else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))//确保传播能够继续
                    continue;
            }
            if (h == head) 
                break;
        }
    }
</code></pre>

<hr/>

<h3 id="toc_12">下面实现一个共享锁，代码如下：</h3>

<pre><code class="language-java">/**
 * 共享锁简单实现
 **/
public class SimpleShareLock implements Lock {

    private static final int OFFSET = 1;
    //为n表示允许n个线程同时获得锁
    private final Sync sync = new Sync(4 * OFFSET);

    private static final class Sync extends AbstractQueuedSynchronizer {

        Sync(int count) {
            if (count &lt;= 0) {
                throw new IllegalArgumentException(&quot;允许共享同步状态的线程数不能小于1&quot;);
            }
            setState(count);
        }

        /**
         * @param reduceCount 扣减个数
         * @return 返回小于0，表示当前线程获得同步状态失败，大于0表示当前线程获得同步状态成功
         */
        public int tryAcquireShared(int reduceCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current - reduceCount;
                // 需要保证线程安全使用CAS操作
                if (newCount &lt; 0 || compareAndSetState(current, newCount)) {
                    return newCount;
                }
            }
        }

        /**
         * @param returnCount 归还个数
         * @return
         */
        public boolean tryReleaseShared(int returnCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current + returnCount;
                if (compareAndSetState(current, newCount)) {
                    return true;
                }
            }
        }

        ConditionObject newCondition() {
            return new ConditionObject();
        }
    }

    public void lock() {
        sync.acquireShared(OFFSET);
    }

    public void unlock() {
        sync.releaseShared(OFFSET);
    }

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireSharedInterruptibly(OFFSET);
    }

    public boolean tryLock() {
        return sync.tryAcquireShared(OFFSET) &gt;= 0;
    }

    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(OFFSET, unit.toNanos(time));
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
</code></pre>

<hr/>

<h3 id="toc_13">ConditionObject</h3>

<p><figure><img src="media/15867863097702/15875725837865.jpg" alt=""/></figure></p>

<h4 id="toc_14">ConditionObject的数据结构</h4>

<p>等待队列是一个 FIFO 的队列，在队列中的每个节点都包含了一个线程引用， 该线程就是在 Condition 对象上等待的线程，如果一个线程调用了 Condition.await() 方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。</p>

<p>ConditionObject中的节点定义复用了同步器中节点的定义Node（但是node.waitStatus = Node.CONDITION）</p>

<p>一个 Condition 包含一个等待队列，Condition 拥有首节点(firstWaiter)和尾节点(lastWaiter)。</p>

<p>当前线程调用 Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition 拥有首尾节点的引用，而新增节点只需要将原有的尾节点 nextWaiter 指向它，并且更新尾节点即可。</p>

<p>上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是 获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br/>
<figure><img src="media/15867863097702/15875726221437.jpg" alt=""/></figure></p>

<p>调用 Condition 的 await()方法(或者以 await 开头的方法)，会使当前线程 进入等待队列并释放锁，同时线程状态变为等待状态。当从 await()方法返回时， 当前线程一定获取了 Condition 相关联的锁。</p>

<p>如果从队列(同步队列和等待队列)的角度看 await()方法，当调用 await() 方法时，相当于同步队列的首节点(获取了锁的节点)移动到 Condition 的等待 队列中。调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点， 该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同 步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤 醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用 Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。<br/>
<figure><img src="media/15867863097702/15875726951805.jpg" alt=""/></figure><br/>
如图所示，同步队列的首节点并不会直接加入等待队列，而是通过 addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。<br/>
<figure><img src="media/15867863097702/15875727427827.jpg" alt=""/></figure><br/>
调用 Condition 的 signal()方法，将会唤醒在等待队列中等待时间最长的节点 (首节点)，在唤醒节点之前，会将节点移到同步队列中。</p>

<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程。</p>

<p>通过调用同步器的 enq(Node node)方法，等待队列中的头节点线程安全地移 动到同步队列。当节点移动到同步队列后，当前线程再使用 LockSupport 唤醒该 节点的线程。</p>

<p>被唤醒后的线程，将从 await()方法中的 while 循环中退出 (isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中)，进而调 用同步器的 acquireQueued()方法加入到获取同步状态的竞争中。</p>

<p>成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的 await() 方法返回，此时该线程已经成功地获取了锁。</p>

<p>Condition 的 signalAll()方法，相当于对等待队列中的每个节点均执行一次 signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每 个节点的线程</p>

<p>ConditionObject 是同步器的条件实现。</p>

<pre><code class="language-java">/**
 * 条件等待
 */
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    // 释放当前线程持有的同步状态，并返回释放之前的同步状态
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // 当前节点是否被移到同步队列, 如果在等待队列，则进行阻塞
    while (!isOnSyncQueue(node)) {
        // 阻塞condition上的当前线程，等待signal信号唤醒
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //此时进入阻塞队列，自旋获取锁
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}

/**
 * 唤醒条件Condition上的阻塞线程
 */
 public final void signal() {
    // 非当前线程持有同步状态 抛出异常
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

// 删除和传输节点，直到命中不可取消的一个或null。
private void doSignal(Node first) {
    do {
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
            (first = firstWaiter) != null);
}

final boolean transferForSignal(Node node) {
    // 释放当前节点同步状态
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    // 将节点存入同步队列列尾
    Node p = enq(node);
    int ws = p.waitStatus;
    // 同步状态已取消 或 设置同步状态失败，则唤醒节点线程并重新同步。
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15857296160676.html">
                
                  <h1>查看远程mysql 主机的 binlog 日志</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>show master status;</p>

<p>show binary logs;</p>

<p>show binlog events in &#39;mysql-bin.000030&#39;;</p>

<p>c查看<br/>
show global variables like &quot;%binlog_format%&quot;;</p>

<pre><code class="language-text">mysqlbinlog -u temp_admin  -h psi.mysql.test.tcit.cc -P 3306 --read-from-remote-server -p  --base64-output=&quot;decode-rows&quot; -v  --start-datetime=&#39;2020-04-01 14:00:00&#39; --stop-datetime=&#39;2020-04-01 16:00:00&#39;  mysql-bin.000030 &gt; xxx.txt
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='mysql.html'>mysql</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="ThreadLocal.html">
                
                  <h1>ThreadLocal源码分析以及使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">ThreadLocal结构分析</a>
</li>
<li>
<a href="#toc_1">ThreadLocal的源码解析</a>
</li>
<li>
<a href="#toc_2">ThreadLocalMap解析</a>
<ul>
<li>
<a href="#toc_3">ThreadLocalMap源码分析</a>
</li>
<li>
<a href="#toc_4">ThreadLocal的引用关系</a>
<ul>
<li>
<a href="#toc_5">内存泄漏问题及解决办法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Hash冲突怎么解决</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">线程不安全问题</a>
</li>
</ul>


<p>ThreadLocal该类提供线程局部变量，起到线程隔离的作用。</p>

<h2 id="toc_0">ThreadLocal结构分析</h2>

<ul>
<li>首先我们看下ThreadLocal和Thread的它们之间的关系，如下图所示：</li>
</ul>

<p><figure><img src="media/15864440934982/15865132297584.jpg" alt=""/></figure></p>

<p><strong>Thread类内部声明了一个ThreadLocal.ThreadLocalMap类型的变量 threadLocals</strong>，ThreadLocal类负责维护ThreadLocal与Thread 之间关系的 ThreadLocalMap散列映射。</p>

<h2 id="toc_1">ThreadLocal的源码解析</h2>

<p><figure><img src="media/15864440934982/15865038471517.jpg" alt=""/></figure></p>

<p>我们一起来看下ThreadLocal 内部代码</p>

<pre><code class="language-java">// 创建线程和ThreadLocal的关联映射
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// 获取线程 t 的threadLocalMap
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// 设置当前线程的局部变量值
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

//获取当前线程的局部变量值
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

// 设置初始值
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

// 移除此线程局部变量的当前线程值。
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
</code></pre>

<h2 id="toc_2">ThreadLocalMap解析</h2>

<h3 id="toc_3">ThreadLocalMap源码分析</h3>

<p><figure><img src="media/15864440934982/15865034564443.jpg" alt=""/></figure></p>

<pre><code class="language-java">
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        // k已经过时，被垃圾回收啦
        if (k == null) 
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}

private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    
    // 发生了hash碰撞问题，采用线性探测法，按照一定步长查找下一个位置，直到找到空余的位置存放value值为止,如果遇到过时的局部变量值，则将过时的value值替换为新的value值
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key) {
            e.value = value;
            return;
        }
        // 遇到过时的线程局部变量
        if (k == null) {
            // 用指定键的项替换set操作期间遇到的过时项。
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    // entry 条目个数大于表的扩容阈值的时候
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        // 重新调整table的大小。首先扫描整个表，删除陈旧的条目。如果这还不足以缩小表的大小，则将表的大小加倍。
        rehash();
}


private void remove(ThreadLocal&lt;?&gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear(); // 清除ThreadLocal引用
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
            return;
        }
    }
}

private void rehash() {
    // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
    expungeStaleEntries();

    // 使用较低的阈值加倍，以避免扩容滞后
    if (size &gt;= threshold - threshold / 4)
        resize();
}
</code></pre>

<h3 id="toc_4">ThreadLocal的引用关系</h3>

<p>ThreadLocal的引用关系 如下图所示：</p>

<p><figure><img src="media/15864440934982/15865783936571.jpg" alt="" style="width:708px;"/></figure></p>

<h4 id="toc_5">内存泄漏问题及解决办法</h4>

<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么下次gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链： <br/>
current thread 引用 -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value <br/>
永远无法回收，造成内存泄露。</p>

<p>针对这种情况ThreadLocalMap提供了一些防护措施：</p>

<ul>
<li><p>1、 getEntry(ThreadLocal&lt;?&gt; key)、set(ThreadLocal&lt;?&gt; key, Object value)提供了针对key为null的entry的擦除操作expungeStaleEntry(i)</p></li>
<li><p>2、 remove(ThreadLocal&lt;?&gt; key)方法内部提供了针对ThreadLocal的擦除操作</p></li>
</ul>

<p>如下代码所示：</p>

<pre><code class="language-java">public class ThreadLocalContext {

    private static final ThreadLocal&lt;Object&gt; UNKNOWN_THREAD_LOCAL = new ThreadLocal&lt;&gt;();

    public static Object get() {
        return UNKNOWN_THREAD_LOCAL.get();
    }

    public static void set(Object value) {
        UNKNOWN_THREAD_LOCAL.set(value);
    }

    public static void remove(){
        UNKNOWN_THREAD_LOCAL.remove();
    }
}

/**
 * ThreadLocal内存泄漏的风险演示
 * -XX:+PrintGCDetails -Xmx50m
 * @author goddess
 * @since 2020/4/8 23:16
 **/
public class ThreadOOM {

    static class UseData {
        private byte[] element = new byte[1024 * 1024 * 10];// 10M
    }

    static class UseThreadOOM implements Runnable {
        @Override
        public void run() {
            ThreadLocalContext.set(new UseData());
            //ThreadLocalContext.remove();
        }
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 3000; i++) {
                executorService.execute(new UseThreadOOM());
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }
}
</code></pre>

<p>放开ThreadLocalContext.remove的gc信息<br/>
<figure><img src="media/15864440934982/15865803964880.jpg" alt="" style="width:1569px;"/></figure></p>

<p>注释掉ThreadLocalContext.remove的部分gc信息：<br/>
<figure><img src="media/15864440934982/15865798232002.jpg" alt="" style="width:1570px;"/></figure></p>

<p><strong>方式1 的前提条件是当key为null的时候咱得去调用getEntry、set方法，单这并不是任何时候都会执行的操作，所以保险的做法就是手动调用ThreadLocal的remove函数，删除不再需要的ThreadLocal，防止内存泄露。</strong></p>

<h3 id="toc_6">Hash冲突怎么解决</h3>

<p>ThreadLocalMap当执行set(Object value)的时候可能会发生hash冲突，当发生了hash碰撞的时候，map采用了一种<strong>线性探测法(就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用,按照一定步长查找下一个位置，直到找到空余的位置存放value值为止)</strong></p>

<p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置，如下代码：</p>

<pre><code class="language-text">private static int nextIndex(int i, int len) {
    return ((i + 1 &lt; len) ? i + 1 : 0);
}
private static int prevIndex(int i, int len) {
    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);
}
</code></pre>

<p>如果有大量不同的ThreadLocal对象放入ThreadLocalMap中时发一次或多次hash冲突，就要多次执行线性探测法，则效率很低。</p>

<p><strong>建议：</strong> 由于存在hash冲突问题，每个线程只存一个ThreadLocal变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，可以避免hash碰撞引起效率低下的问题。</p>

<h2 id="toc_7">线程不安全问题</h2>

<p>记住一点，本次线程任务使用完ThreadLocal之后要调用threadLocal.remove()方法。当使用线程池的时候，线程执行完任务之后，线程并不会消亡，而是重新回到了线程池中，等待下次任务的分派。可能产生的问题：<strong>造成线程不安全的问题，访问threadLocal.get()获取的值可能不是自己预期的变量值</strong><br/>
看如下代码：</p>

<pre><code class="language-java">public class ThreadUnsafe {

    static class UseThreadUnsafe implements Runnable {
        private int value;

        UseThreadUnsafe(int value) {
            this.value = value;
        }

        @Override
        public void run() {
            Object o = ThreadLocalContext.get();
            if (o == null) {
                ThreadLocalContext.set(value+1);
            }
            System.out.println(Thread.currentThread().getName()+&quot; 线程局部变量表：&quot; + ThreadLocalContext.get());
            // tips：开启和注释的情况下完全不一样
            ThreadLocalContext.remove();
        }
    }


    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 6; i++) {
                executorService.execute(new UseThreadUnsafe(i));
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }

}
</code></pre>

<p>开启的情况下：<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：5<br/>
pool-1-thread-3 线程局部变量表：4<br/>
pool-1-thread-1 线程局部变量表：6</p>

<p>注释的情况下：<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3</p>

<hr/>

<p><strong>综上所述 ThreadLocal使用完变量之后，千万要记着调用ThreadLocal的remove()完成擦除操作</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15865981620428.html">
                
                  <h1>软引用（SoftReference）和引用队列（ReferenceQueue）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>软引用可用来实现内存敏感的高速缓存。</p>

<h2 id="toc_0">软引用（SoftReference）</h2>

<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p>

<p>SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p>

<pre><code class="language-java">MyObject aRef = new MyObject();
SoftReference aSoftRef=new SoftReference(aRef);
</code></pre>

<p>此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。<br/>
随即，我们可以结束aReference对这个MyObject实例的强引用: aRef = null;</p>

<p>此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:</p>

<pre><code class="language-java">MyObject anotherRef=(MyObject)aSoftRef.get();
</code></pre>

<p>重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。</p>

<h2 id="toc_1">ReferenceQueue工作机制</h2>

<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。使用ReferenceQueue清除失去了软引用对象的SoftReference。</p>

<p>作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p>

<pre><code class="language-java">ReferenceQueue queue = new ReferenceQueue();
SoftReference ref=new SoftReference(aMyObject, queue);
</code></pre>

<p>那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。<br/>
在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:</p>

<pre><code class="language-java">SoftReference ref = null;
while ((ref = (EmployeeRef) q.poll()) != null) {
    // 清除ref
}
</code></pre>

<h2 id="toc_2">使用软引用构建敏感数据的缓存</h2>

<h3 id="toc_3">为什么需要使用软引用</h3>

<p>首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。</p>

<h2 id="toc_4">通过软可及对象重获方法实现Java对象的高速缓存</h2>

<p>利用Java平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类:</p>

<pre><code class="language-java">@Data
public class Employee {
    private String id;// 雇员的标识号码
    private String name;// 雇员姓名
    private String department;// 该雇员所在部门
    private String Phone;// 该雇员联系电话
    private int salary;// 该雇员薪资
    private String origin;// 该雇员信息的来源
}
</code></pre>

<p>这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义:</p>

<pre><code class="language-java">import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.HashTable;

public class EmployeeCache {
    // 一个Cache实例
    private static EmployeeCache cache;
    // 用于Chche内容的存储
    private HashTable&lt;String,EmployeeRef&gt; employeeRefs;
    private ReferenceQueue&lt;Employee&gt; q;// 垃圾Reference的队列
    // 继承SoftReference，使得每一个实例都具有可识别的标识。并且该标识与其在HashMap内的key相同。
    private class EmployeeRef extends SoftReference&lt;Employee&gt; {
        private String _key = &quot;&quot;;
        public EmployeeRef(Employee em, ReferenceQueue&lt;Employee&gt; q) {
            super(em, q);
            _key = em.getID();
        }
    }
    // 构建一个缓存器实例
    private EmployeeCache() {
        employeeRefs = new HashTable&lt;String,EmployeeRef&gt;();
        q = new ReferenceQueue&lt;Employee&gt;();
    }
    // 取得缓存器实例
    public static EmployeeCache getInstance() {
        if (cache == null) {
            cache = new EmployeeCache();
        }
        return cache;
    }
    // 以软引用的方式对一个Employee对象的实例进行引用并保存该引用
    private void cacheEmployee(Employee em) {
        cleanCache();// 清除垃圾引用
        EmployeeRef ref = new EmployeeRef(em, q);
        employeeRefs.put(em.getID(), ref);
    }
    // 依据所指定的ID号，重新获取相应Employee对象的实例
    public Employee getEmployee(String ID) {
        Employee em = null;
        // 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。
        if (employeeRefs.containsKey(ID)) {
            EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);
            em = (Employee) ref.get();
        }
        // 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，
        // 并保存对这个新建实例的软引用
        if (em == null) {
            em = new Employee(ID);
            System.out.println(&quot;Retrieve From EmployeeInfoCenter. ID=&quot; + ID);
            this.cacheEmployee(em);
        }
        return em;
    }
    // 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象
    private void cleanCache() {
        EmployeeRef ref = null;
        while ((ref = (EmployeeRef) q.poll()) != null) {
            employeeRefs.remove(ref._key);
        }
    }
    // 清除Cache内的全部内容
    public void clearCache() {
        cleanCache();
        employeeRefs.clear();
        System.gc();
        System.runFinalization();
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15853612430664.html">
                
                  <h1>java线程基础</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">基础概念</h2>

<ul>
<li><p>什么是进程和线程</p>
<ul>
<li>进程是程序运行资源分配的最小单位。其中资源包括：cpu、内存空间、磁盘IO等，同一个进程中的多条线程共享该进程中的全部系统资源。</li>
<li>线程是cpu调度的最小单位，必须依赖于进程存在。<br/>
cpu通过轮转机制会公平的把 cpu 时间分配给各个线程，在线程的切换的过程中，会产生线程上下文开销，也称为 RR 调度</li>
</ul></li>
<li><p>什么是并行和并发<br/>
并行：同一时刻，可以处理事情的能力。<br/>
并发：单位时间内，处理事情的能力。例如：1秒内，一个应用内可以处理10个提交任务，</p></li>
<li><p>高并发编程的意义和注意事项<br/>
操作系统会限制线程数量，以防线程耗尽系统资源，Linux：1000个；windows：2000个</p>
<ul>
<li>优点：
<ul>
<li>可以充分利用系统资源</li>
<li>加快系统对用户的响应速度</li>
</ul></li>
<li>弊端： 
<ul>
<li>存在资源竞争关系</li>
<li>可能会产生死锁</li>
<li>消耗系统资源</li>
</ul></li>
</ul></li>
</ul>

<hr/>

<h2 id="toc_1">java 语言的线程</h2>

<h3 id="toc_2">构建线程的方式</h3>

<p>Thread类、Runnable接口，Thread类是对线程的抽象，Runnable是对任务的抽象</p>

<h3 id="toc_3">线程终止的方式：</h3>

<ul>
<li>自然终止<br/>
run方法执行完毕或者跑出一个未处理的异常导致线程提前结束</li>
<li>中断
<ul>
<li>interrupt()<br/>
中断线程通知，非强制打断，中断标志位设置为true(已中断)</li>
<li>isInterrupted()<br/>
线程通过此方法判断是否被中断</li>
<li>static interrupted()<br/>
线程通过此方法判断是否被中断，中断标志位会进行重置为false</li>
</ul></li>
</ul>

<p>*** 注意：***</p>

<ul>
<li>stop()、destroy()、suspend()、resume()官方已作为废弃API处理</li>
<li>处于死锁状态的线程不会被中断</li>
</ul>

<h3 id="toc_4">run()和 start()区别</h3>

<ul>
<li>run() 不会新启线程，可以视为普通的业务方法，执行run()方法，当前线程是主线程</li>
<li>start() 启动新线程</li>
</ul>

<h3 id="toc_5">join()</h3>

<p>ThreadA.join() 是先等待ThreadA运行至死亡</p>

<h3 id="toc_6">yield()</h3>

<p>将线程从运行态转到就绪态,是当前线程让出cup占有权,让出的时间不可设定。不会释放锁资源。<br/>
当执行yield()之后进入就绪态的线程，有可能立即又被cpu捡起来去执行了</p>

<h3 id="toc_7">线程优先级</h3>

<p>1~10，缺省 5<br/>
thread.setPriority(int xx); 优先级不是特别靠谱的东西</p>

<h3 id="toc_8">守护线程</h3>

<p>守护线程是一种支持型线程，因为它主要被用作程序中 后台调度以及支持性工作。<br/>
通过Thread.setDaemon(true)将线程设置为守护线程。</p>

<p>线程的状态切换<br/>
<figure><img src="media/15853612430664/15862720985637.jpg" alt="" style="width:937px;"/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_12.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_14.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
