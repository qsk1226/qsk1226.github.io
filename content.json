[{"title":"","date":"2019-12-04T14:34:00.277Z","path":"qsk/uncategorized/undefined.html","text":"netty 内存使用技巧 堆外内存更广阔的的空间减少冗余细节 内存池技巧 抽象类不能实例化 为什么使用对象池 创建对象开销大 对象高频率创建切可复用 支持并发又能保护系统 维护、共享有限资源 开源实现 commons poolnetty 轻量级对象池实现 RecyclerRecycler 使用场景 内存池/ ObjectPoolRecycler 主线 ourthread 创建selector 创建 server socket channel 初始化 server socket channel 给server socket channel 从boss group 中选择一个NioEventLoop","tags":[]},{"title":"golang安装配置","date":"2019-06-03T13:38:43.000Z","path":"qsk/golang/golang_install_config.html","text":"go语言在mac osx系统上安装go语言非常简单，直接在官网上下载mac os版的安装包一路next即可安装成功。另外可使用HomeBrew来实现go语言的安装，brew install go GOPATH配置 GOPATH 设置go项目的工作目录，在go项目的工作目录中至少存在三个目录： src 用于以代码包的形式组织并保存go源文件，这里的代码包与src下的子目录一一对应。 pkg 编译后生成的文件（.a文件）。非main函数的文件在go install后生成。 用于存放通过go install命令安装后的代码包的归档文件。前提是代码包中必须包含go库源码文件。 bin 存放编译后生成的可执行文件,通过go install命令完成安装后，保存由go命令源码文件生成的可执行文件。 GOBINGOBIN是 GOPATH 下的bin目录 GOROOT go语言的安装路径源码文件1) 命令源码文件 &gt; 如果一个源码文件被声明属于main代码包，且该文件代码中包含无参数声明和结果声明的main函数，则他就是命令源码文件。命令源码文件可以直接通过go run 命令直接启动运行。2) 库源码文件 &gt;通常，库源码文件声明的包名 会 与它直接所属的代码包名一致，且库源码文件中不包含无参数声明和无结果声明的main函数3) 测试源码文件 &gt; 测试源码文件是一种特殊的库文件，可以通过执行 go test 命令运行当前代码包下的所有测试源码文件。","tags":[{"name":"golang","slug":"golang","permalink":"http://www.throne4j.com/tags/golang/"}]},{"title":"spring-core包阅读记录","date":"2019-06-02T13:38:43.000Z","path":"qsk/spring/undefined.html","text":"spring-core 学习记录org.springframework.util类作用记录 AutoPopulatingList 对list的一个简单包装 DigestUtils 计算摘要的各种方法工具 Base64Utils 一个用于Base64编码和解码的简单实用程序类 ErrorHandler(函数接口) 处理异常的策略接口 InstanceFilter 一个简单的实例过滤器，它根据包含和排除元素的集合检查给定的实例是否匹配。 ClassUtils ReflectionUtils CollectionUtils ConcurrentReferenceHashMap CustomizableThreadCreator 用于创建新的{@link Thread}实例的简单可自定义助手类。提供各种bean属性:线程名称前缀、线程优先级等。 PropertiesPersister 用于持久化{@code java.util的策略接口。属性}，允许可插入的解析策略。 实现有 DefaultPropertiesPersister FastByteArrayOutputStream FileCopyUtils 用于文件和流复制的简单实用程序方法 FileSystemUtils 处理文件系统的实用方法。 InstanceFilter 一个简单的实例过滤器，它根据包含和排除元素的集合检查给定的实例是否匹配。ExceptionTypeFilter LinkedCaseInsensitiveMap LinkedMultiValueMap PatternMatchUtils 用于简单模式匹配的实用方法，特别是对于Spring的典型“xxx”、“xxx”和“xxx”模式样式。 PropertyPlaceholderHelper 用于处理具有占位符值的字符串的实用程序类 SystemPropertyUtils 用于解析文本中的占位符的Helper类。通常应用于文件路径。 MethodInvoker Helper类，它允许指定以声明方式调用的方法，无论是静态的还是非静态的。 NumberUtils ObjectUtils ResourceUtils 可处理jar包内的路径资源 SerializationUtils SocketUtils 处理网络套接字的简单实用方法，例如：用于查找{@code localhost}上的可用端口。 StreamUtils 处理流的实用程序 StringUtils 字符串的实用方法 StringValueResolver(函数接口) 用于解析字符串值的简单策略接口。 TypeUtils 用于处理Java 5泛型类型参数的实用程序。 org.springframework.util.concurrent 并发包类说明 ListenableFuture (接口) 扩展{@link Future}，使其能够接受完成回调。如果在添加回调时未来已完成，则立即触发回调。 CompletableToListenableFutureAdapter 将{@link CompletableFuture}或{@link CompletionStage}调整为Spring {@link ListenableFuture}。 DelegatingCompletableFuture 扩展的{@link CompletableFuture}，允许取消委托 连同{@link CompletableFuture}本身。 FailureCallback (函数接口) Failure callback for a {@link ListenableFuture}. SuccessCallback(函数接口) Success callback for a {@link ListenableFuture}. FutureAdapter 一个抽象类，它将在S上参数化的{@link Future}调整为在T上参数化的{@code Future}。所有方法都委托给适配器，其中{@link #get()}和{@link #get(long, TimeUnit)}对适配器的结果调用{@link #adapt(Object)}。 ListenableFutureAdapter extends FutureAdapter implements ListenableFuture ListenableFutureCallback (接口) 结果(成功或失败)的回调机制，来自{@link ListenableFuture}。 extends SuccessCallback， FailureCallback ListenableFutureCallbackRegistry 用于维护成功和失败回调并帮助通知它们的{@link ListenableFuture}实现的Helper类。 ListenableFutureTask 实现{@link ListenableFuture}的{@link FutureTask}的扩展。 ListenableFutureTask extends FutureTask implements ListenableFuture 其实现类有 SettableTask org.springframework.core.task 任务执行 TaskExecutor 简单的任务执行器接口，抽象了{@link Runnable}的执行。 继承自java.util.concurrent.Executor执行已提交的{@link Runnable}任务的对象。 在java中Executor的实现类 均实现了{@link ExecutorService}这个更加广泛的接口，具体实现类可由Executors类生产。 AsyncTaskExecutor 继承自TaskExecutor，实现了异步扩展功能。 SimpleAsyncTaskExecutor 为每个任务触发一个新线程的实现，异步地执行。 SyncTaskExecutor TaskDecorator(函数接口) 一个回调接口，用于将装饰器应用于将要执行的任何{@link Runnable}。 ExecutorServiceAdapter 适配器，它接受一个Spring {@link org.springframework.core.TaskExecutor}, 并公开一个完整的{@code java.util.concurrent。ExecutorService} TaskExecutorAdapter 适配器，它接受JDK {@code java.util.concurrent。并公开一个Spring {@link org.springframework.core.task。TaskExecutor}。 org.springframework.core 包类解析 AliasRegistry 用于管理别名的通用接口。作为超级接口 SimpleAliasRegistry BeanDefinitionRegistry","tags":[{"name":"spring-core","slug":"spring-core","permalink":"http://www.throne4j.com/tags/spring-core/"}]},{"title":"桥接模式","date":"2018-07-01T13:38:43.000Z","path":"qsk/design-pattern/bridge-pattern.html","text":"桥接模式桥接模式的定义桥接模式（Bridge Pattern），将抽象部分与它的实现部分分离，使它们都可以独立地变化。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 模式结构桥接模式包含如下角色： Abstraction：抽象类 （Shape）RefinedAbstraction：扩充抽象类(Circle)Implementor：实现类接口 (DrawAPI)ConcreteImplementor：具体实现类 (RedCircle、GreenCircle) uml图解 桥接模式使用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 代码实现123public interface DrawAPI &#123; void drawCircle(int radius, int x, int y);&#125; 1234567891011121314public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(\"Drawing Circle[ color: red, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); &#125;&#125;public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(\"Drawing Circle[ color: green, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); &#125;&#125; 使用 DrawAPI 接口创建抽象类 Shape。 1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125; 1234567891011121314public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125; 123456789public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125;","tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"http://www.throne4j.com/tags/结构型模式/"}]},{"title":"Queue详解","date":"2016-07-19T13:30:08.000Z","path":"qsk/java/queue.html","text":"Collection集合 List集合 继承Collection接口，集合有序、允许重复值、可插入null。 Set集合 集合无序，不允许重复值， Queue队列","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]},{"title":"Set详解","date":"2016-07-15T06:23:08.000Z","path":"qsk/java/set.html","text":"Collection集合 List集合 继承Collection接口，集合有序、允许重复值、可插入null。 Set集合 集合无序，不允许重复值， Queue队列 Set 详解Set继承自Collection接口,内部实现由HashMap实现,并维护了双向链表。 Set集合中每个元素都是独一无二的，它不包含重复元素(元素equals相等),可包含至多一个null元素。 Set集合不保证元素的有序性，实现SortedSet接口的集合除外。UML图解 HashSetHashSet实现了Set接口，内部由一个哈希表（HashMap）支持实现相关set功能。我们看下它的构造器和add方法 1234567891011private transient HashMap&lt;E, Object&gt; map;private static final Object PRESENT = new Object();public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT) == null;&#125; 从源码中看到Set的元素是存储在map集合中的，set自述: map之心，昭昭可鉴。 TreeSetTreeSet是有序的Set集合，基于TreeMap实现。 集合使用元素的 Comparable进行自然排序，或者使用在排序集创建时提供的Comparator进行排序。插入排序集的所有元素必须实现Comparable接口(或指定比较器Comparator) 构造器 1234567891011121314// TreeSet的存储容器private transient NavigableMap&lt;E, Object&gt; m;// 构造存指定储存储容器的TreeSet实例TreeSet(NavigableMap&lt;E, Object&gt; m) &#123; this.m = m;&#125;// 默认构造TreeMap的TreeSet实例public TreeSet() &#123; this(new TreeMap&lt;E, Object&gt;());&#125;//指定比较器的TreeSet实例public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator));&#125; iterator() 遍历TreeSet的迭代方法 123public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator();&#125; descendingIterator() 遍历TreeSet的逆向迭代方法 123public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator();&#125; descendingSet() 返回此集合中包含的元素的逆序视图。 123public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet&lt;&gt;(m.descendingMap());&#125; subSet 12345public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive));&#125; headSet 123public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;&gt;(m.headMap(toElement, inclusive));&#125; tailSet 123public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));&#125; comparator() 获取元素的比较器 123public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator();&#125; first() 123public E first() &#123; return m.firstKey();&#125; last() 123public E last() &#123; return m.lastKey();&#125; E lower(E e) 返回比e小的最大元素，如果没有返回null 123public E lower(E e) &#123; return m.lowerKey(e);&#125; E floor(E e) 返回小于等于e的最大元素 123public E floor(E e) &#123; return m.floorKey(e);&#125; E ceiling(E e) 返回会大于等于e的最小元素 123public E ceiling(E e) &#123; return m.ceilingKey(e);&#125; higher(E e) 返回大于e的最小元素 123public E higher(E e) &#123; return m.higherKey(e);&#125; pollFirst() 检索并删除第一个元素，Set为空则返回null 1234public E pollFirst() &#123; Map.Entry&lt;E, ?&gt; e = m.pollFirstEntry(); return (e == null) ? null : e.getKey();&#125; pollLast() 检索并删除最后一个元素，Set为空则返回null1234public E pollLast() &#123; Map.Entry&lt;E, ?&gt; e = m.pollLastEntry(); return (e == null) ? null : e.getKey();&#125;","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]},{"title":"list详解","date":"2016-07-13T19:23:08.000Z","path":"qsk/java/list.html","text":"Collection集合 List集合 继承Collection接口，集合有序、允许重复值、可插入null。 Set集合 集合无序，不允许重复值，内部实现通过HashMap实现 Queue队列 鸟瞰 List接口List继承了Collection接口，它用某种特定的插入顺序来维护元素顺序，集合有序、允许重复值、可插入null。下面我们看下List的UML图： ArrayList基于动态数组实现，可以动态的扩容，用户拥有对元素精确插入的控制权。当集合中对插入元素数据的速度要求不高，但是要求快速访问元素数据，则使用此集合 LinkedList基于链表实现，是一个双向循环列表，可以被当做堆栈使用。当集合中对访问元素数据速度不做要求不高，但是对插入和删除元素数据速度要求高的情况，则使用LinkedList Vector同样基于数组实现，并且满足多线程环境下的安全操作。Collections.synchronizedList(list)或者并发包下面的CopyOnWriteArrayList来实现线程安全的集合。 Stack基于数组实现，是栈，它继承与Vector，特性是FILO（先进后出）。当集合中有需求是希望后保存的数据先读取出来，则使用Stack AbstractList抽象类方法Itr 内部类 ,iterator迭代器 ListItr 内部类,listIterator迭代器 add get set add remove indexOf(int index) lastIndexOf clear addAll iterator() listIterator() 集合全部元素的双向迭代器 listIterator(int index) 从index位置开始的迭代器 subList(int from, int to) 截取子集合 equals hashCode removeRange rangeCheckForAdd(int) 范围检查 outOfBoundsMsg(int) 是否超出界限 modCount 集合被修改了多少次迭代器123456789public ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0);&#125;public ListIterator&lt;E&gt; listIterator(final int index) &#123; rangeCheckForAdd(index); return new ListItr(index);&#125; SubList 子集合类，從如下代碼中看到，子集合內部依然保留了父集合中的全部元素，只是子集合的長度發生變化以及各元素會取偏移之後的元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162class SubList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; //父集合 private final AbstractList&lt;E&gt; l; //子集合元素偏移量 private final int offset; //子集合長度 private int size; SubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex); if (toIndex &gt; list.size()) throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;); l = list; offset = fromIndex; size = toIndex - fromIndex; this.modCount = l.modCount; &#125; public E set(int index, E element) &#123; rangeCheck(index); checkForComodification(); return l.set(index + offset, element); &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return l.get(index + offset); &#125; public int size() &#123; checkForComodification(); return size; &#125; public void add(int index, E element) &#123; rangeCheckForAdd(index); checkForComodification(); l.add(index + offset, element); this.modCount = l.modCount; size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = l.remove(index + offset); this.modCount = l.modCount; size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); l.removeRange(fromIndex + offset, toIndex + offset); this.modCount = l.modCount; size -= (toIndex - fromIndex); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize == 0) return false; checkForComodification(); l.addAll(offset + index, c); this.modCount = l.modCount; size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); return new ListIterator&lt;E&gt;() &#123; private final ListIterator&lt;E&gt; i = l.listIterator(index + offset); public boolean hasNext() &#123; return nextIndex() &lt; size; &#125; public E next() &#123; if (hasNext()) return i.next(); else throw new NoSuchElementException(); &#125; public boolean hasPrevious() &#123; return previousIndex() &gt;= 0; &#125; public E previous() &#123; if (hasPrevious()) return i.previous(); else throw new NoSuchElementException(); &#125; public int nextIndex() &#123; return i.nextIndex() - offset; &#125; public int previousIndex() &#123; return i.previousIndex() - offset; &#125; public void remove() &#123; i.remove(); SubList.this.modCount = l.modCount; size--; &#125; public void set(E e) &#123; i.set(e); &#125; public void add(E e) &#123; i.add(e); SubList.this.modCount = l.modCount; size++; &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return new SubList&lt;&gt;(this, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot; + index + &quot;, Size: &quot; + size; &#125; private void checkForComodification() &#123; if (this.modCount != l.modCount) throw new ConcurrentModificationException(); &#125;&#125; RandomAccessSubList随机访问子集合AbstractList私有內部類：Itr迭代器：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private class Itr implements Iterator&lt;E&gt; &#123; /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; AbstractList私有內部類ListItr: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public E previous() &#123; checkForComodification(); try &#123; int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.set(lastRet, e); expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125; ArrayListArrayList由于是由数组实现，可实现自动扩容操作，默认初始容量：10，随着ArrayList中元素的增加，它的容量会不断的自动增长。 ArrayList 序列化通过源码，我们知道用于存储元素的数组elementData被transient关键字修饰，我们知道被transient修饰的对象不被应用在序列化，那么ArrayList是将元素序列化的呢？源码中有如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; transient Object[] elementData; //将ArrayList实例的状态保存到流中(即序列化它)。 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 从流(即反序列化)中重新构造ArrayList实例。 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125;&#125; 为什么要这样实现呢？原因在于elementData作为存储元素的缓存数组，它会预留一些容量用于添加元素，这些预留的空间并不存储任何元素，为了保证序列化时拿到的是用户的实际大小的数组数据。java序列化查看此篇章【深入理解java序列化】 list迭代器我们知道在遍历List集合的时候不允许对集合进行修改操作，否则会抛出ConcurrentModifiedException异常信息，为了解决这个问题，可以使用List提供给我们的特殊迭代器ListIterator，此迭代器除了提供集合操作之外还允许双向访问。 123456789101112131415161718192021public class ListDemo &#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"李磊\"); list.add(\"韩梅梅\"); list.add(\"Lucy\"); System.out.println(list); ListIterator&lt;String&gt; iterator = list.listIterator(); while(iterator.hasNext())&#123; String element = iterator.next(); if(element.equals(\"李磊\"))&#123; iterator.set(\"韩梅梅她老公\"); &#125; if (element.equals(\"Lucy\")) &#123; iterator.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 输出结果 :[李磊, 韩梅梅, Lucy][韩梅梅她老公, 韩梅梅] ArrayList的常用操作1. add(E element) 在末尾添加指定类型的元素12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean add(E e) &#123; // 进行扩容操作，并增加modCounnnt ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;//进行扩容操作private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //列表被修改的次数 modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //将容量扩到1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 将老集合元素复制到新长度的集合中 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 2. add(int index, E element) 在下标为index的位置插入element元素，后面的元素后移一位123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // 对源数组进行复制处理（位移），从index + 1到size-index。主要目的就是空出index位置供数据插入 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 3. E remove(int index) 移除下标为index的元素12345678910111213public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 4. get(int index) 获取下标为index的元素123456public E get(int index) &#123; rangeCheck(index); //检查集合是否被修改 checkForComodification(); return ArrayList.this.elementData(offset + index);&#125; 5. set(int index, E element) 将下标为index的元素设置为element123456public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; retur 6. trimToSize() 将”elementData[]”的大小设置为集合的当前大小(size)LinkedListLinkedList实现了 List 和Deque，实现所有可选列表操作，并允许所有元素(包括{@code null})。 Deque : 支持在两端插入和删除元素的线性集合。 源码分析LinkedList的基础属性及实现数据的结构12345678910111213141516171819202122// 集合的长度transient int size = 0;// 头结点transient Node&lt;E&gt; first;// 为节点transient Node&lt;E&gt; last;//此数据结构 实现了LinkedList双向链表功能private static class Node&lt;E&gt; &#123; // 节点保存的数据 E item; //指向下一个元素 Node&lt;E&gt; next; // 指向前一个元素 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; LinkedList提供的List接口相关方法1. node(int index) 返回指定元素索引处的(非空)节点。1234567891011121314Node&lt;E&gt; node(int index) &#123; // index 小于集合长度的1/2，从头部开始定位元素；反之，从尾部开始定位元素。 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 2. Add(E e)添加指定类型的元素1234567891011121314151617181920212223public boolean add(E e) &#123; linkLast(e); return true;&#125;// 末尾设置为元素evoid linkLast(E e) &#123; // 记录当前的末尾节点 final Node&lt;E&gt; l = last; // 构建元素为E的节点newNode final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 将last节点设置为newNode last = newNode; // 如果尾结点为null，添加元素设置为头结点，否则，将原尾结点的next指向新节点newNode if (l == null) first = newNode; else l.next = newNode; // 集合长度加1 size++; // 集合已被修改 modCount++;&#125; 3. add(int index, E element)123456789101112131415161718192021222324252627282930313233public void add(int index, E element) &#123; checkPositionIndex(index); // index为集合长度的时候，添加末尾元素，否则在index之前添加元素 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 4. E get(int index) 获取下标为index的元素 1234public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 5. remove(int index) 删除指定索引元素123456789101112131415161718192021222324252627282930public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; // 头节点头结点为null if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; // 尾节点next指向为null if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 6. contain(Object o) 是否包含元素o123456789101112131415161718192021public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 7. clear()123456789101112public void clear() &#123; for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; 8. set(index, E element) 将index索引的元素设置为element1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; LinkedList提供的Deque接口常用方法1. E getFirst() 获取头节点123456public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; 2. E getLast() 获取尾节点123456public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; 3. removeFirst()12345678910111213141516171819202122public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; 4. removeLast()12345678910111213141516171819202122public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; 5. addFirst(E e) 将指定的元素追加到队头。1234567891011121314151617public void addFirst(E e) &#123; linkFirst(e);&#125;/** * Links e as first element. */private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 6. addLast(E e) 将指定的元素追加到此列表的末尾。123456789101112131415161718public void addLast(E e) &#123; linkLast(e);&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 7. E peek() 检索但不删除此列表的头(第一个元素)。1234public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; 8. poll() 检索并删除此列表的头部(第一个元素)。1234public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; 9. boolean offer(E e) 将指定的元素添加为列表的尾部(最后一个元素)。123public boolean offer(E e) &#123; return add(e);&#125; 10. boolean offerFirst(E e) 将指定的元素插入到此列表的前面。1234public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; 11. E pop() 从这个列表表示的堆栈中弹出一个元素。123public E pop() &#123; return removeFirst();&#125; 12. push(E e) 将元素推入此列表所表示的堆栈。123public void push(E e) &#123; addFirst(e);&#125; Vector由于Vector和ArrayList大体不差多少，另在多线程环境下，不推荐使用的原因，此处不作详解。唯一需要注意的地方，如使用的情况下，别乱复合使用。 Stack堆栈Stack继承自Vector，内部实现也是Vector，实现先进后出的特性。栈最主要的意义就在于：入栈和出栈的对称性。 push 将项推到堆栈顶部。pop 删除堆栈顶部的对象，并将该对象作为该函数的值返回。peek 查看堆栈顶部的对象，而不将其从堆栈中删除emptysearch 返回的是距离栈顶的距离","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]},{"title":"红黑树详解","date":"2016-07-03T06:20:14.000Z","path":"qsk/structure/red-black.html","text":"","tags":[{"name":"树","slug":"树","permalink":"http://www.throne4j.com/tags/树/"}]},{"title":"collection集合记录","date":"2016-07-03T06:20:14.000Z","path":"qsk/java/collection_record.html","text":"Collection集合 List集合 继承Collection接口，集合有序、允许重复值、可插入null。 Set集合 集合无序，不允许重复值， Queue队列 Collection集合集合表示了一组对象，而Collection是集合层次结构的根接口。一些集合可以存在重复的元素，而有些则不允许，一些是有序的，而又有一些是无序的。jdk并没有提供此接口的直接实现，并且又通过具体的子接口分别来定义不同的实现，例如List、Set接口来定义集合的实现。 collection接口快速预览我们看下Collection的UML 我们在看下Collection所定义的集合的基本行为 下面我們看下Collection接口中的默認實現： 1234567891011public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; //省略其它方法 default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; @Override default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0); &#125;&#125; List 和 Set 的异同点 相同点： 同样继承自Collection接口，都实现了Collection规定的行为增删改以及迭代iterator功能。 不同点： List允许重复元素，set不允许重复元素 List底层实现是基于数组或链表，允许存放重复元素，set底层是现实HashMap，HashMap的Key均匀分布在hash桶中，且必须是唯一的，所以Set元素也是唯一的。 List是有序的，而set不保证元素的存放顺序的有序性 List集合中元素按照元素的存放顺序进行遍历，而Set则保证不了元素的有序性，但是Set提供了一个SortSet实现(见TreeSet集合)，也提供了元素的有序性 List可以通过O(1)复杂度进行元素的存取，但是Set必须遍历所有数据来获取指定元素。","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]},{"title":"Map详解","date":"2016-07-03T06:20:14.000Z","path":"qsk/java/map详解.html","text":"Map详解HashMap 是我们开发过程中使用频率及其高又及其重要的集合类。它是将键映射到值的对象。Map不能包含重复的键,每个键最多可以映射到一个值。一些map实现，比如TreeMap类，对它们的顺序做出了特定的保证;其他类，如HashMap类，则没有。 UML Map默认方法说明Map接口除了定义此类集合应该具有的行为模式之外，还定义了Map的集合视图Entry内部类。 default V getOrDefault(Object key, V defaultValue) 返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue。 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) 为映射中的每个条目执行给定的操作，直到处理完所有条目或操作引发异常为止。 default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) 将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或函数抛出异常。 default V putIfAbsent(K key, V value) 如果指定的键尚未与值关联(或映射到 null)，则将其与给定值关联并返回null，否则将返回当前值。 default boolean remove(Object key, Object value) 仅当当前映射到指定值时，才删除指定键的项。 default boolean replace(K key, V oldValue, V newValue) 仅当当前映射到指定值时，才替换指定键的项。 default V replace(K key, V value) 仅当指定键的项当前映射到某个值时，才替换该项。 default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) 如果指定的键尚未与值关联(或映射到null)，则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非null。 default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) 如果指定键的值为present且非null，则尝试计算给定键及其当前映射值的新映射。 default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) 尝试为指定的键及其当前映射值计算映射(如果没有当前映射，则为null)。 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 如果指定的键尚未与值关联或与null关联，则将其与给定的非null值关联。否则，将关联值替换为给定映射函数的结果，如果结果是null，则删除关联值。 HashMap数据结构图HashMap继承自AbstractMap、Map、Cloneable、Serializable HashMap内部属性123456789101112131415161718192021222324252627282930313233//默认初始容量—必须是2的幂。(16)static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//最大容量，如果较高的值由带参数的任何构造函数隐式指定，则使用该值。static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 构造函数中没有指定时使用的负载因子。static final float DEFAULT_LOAD_FACTOR = 0.75f;// 桶的树化阈值，当桶的大小大于这个阈值时，普通Node链表结构转化为TreeNode红黑树结构。// 树化的链表长度须是2的且最小得大于8static final int TREEIFY_THRESHOLD = 8;//桶的链表化阈值,当在resize()时，treeNode红黑树的映射数量小于这个阈值时，TreeNode红黑树结构将转化为Node链表结构static final int UNTREEIFY_THRESHOLD = 6;//哈希表允许转化为TreeNode红黑树的最小容量值(为了避免在扩容还是树化的冲突，这个值必须至少是4 * TREEIFY_THRESHOLD)。在哈希表的容量没达到这个阈值的时候，桶会直接扩容。static final int MIN_TREEIFY_CAPACITY = 64;//表，第一次使用时初始化，并根据需要调整大小。 当分配时，长度总是2的幂。transient Node&lt;K, V&gt;[] table;//保存缓存entrySet ()。注意AbstractMap字段用于keySet()和values()。transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;//此映射中包含的键值映射的数目。transient int size;//这个HashMap在结构上被修改的次,数结构修改是指改变HashMap中映射的数量或修改其内部结构的次数(例如，rehash)。transient int modCount;// 扩容临界值 这个值为 大于cap的且距离最近的2的n次幂数，用于扩容判断int threshold; HashMap部分内部类Node 内部类: 链表数据结构123456789static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; // 记录位于哪个桶中 final int hash; final K key; V value; // 指向下一个元素 Node&lt;K, V&gt; next; ........&#125; TreeNode 内部类: 红黑树数据结构，LinkedHashMap.Entry 继承自HashMap.Node。关于红黑树会单独抽出一篇幅去分析。红黑树见：红黑树 1234567891011static final class TreeNode&lt;K, V&gt; extends LinkedHashMap.Entry&lt;K, V&gt; &#123; // 记录父节点 TreeNode&lt;K, V&gt; parent; // red-black tree links // 左孩子 TreeNode&lt;K, V&gt; left; // 右孩子 TreeNode&lt;K, V&gt; right; //删除后需要断开next链接 TreeNode&lt;K, V&gt; prev; // needed to unlink next upon deletion // 红黑颜色标记 boolean red; 从源码中可以发现TreeNode继承自LinkedHashMap.Entry&lt;K, V&gt;，在LinkedHashMap中的Entry实现如下： 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; HashMap构造器1234567891011121314151617181920212223242526/*** 默认16长度，负载因子0.75*/public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; HashMap方法static final int hash(Object key) 计算 获取key的hashCode值 获取key的hashCode值的高16位 高16位和hashCode进行异或操作获取新的hash值 计算hash桶的索引公式：(table.length - 1) &amp; hash 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; int tableSizeFor(int cap) 计算table扩容临界值入参cap 大于0 且小于最大容量，如果cap是2次幂则返回cap，否则将cap转为大于cap且距离最小的2次幂 12345678910111213static final int tableSizeFor(int cap) &#123; //cap = 16 二进制: 00010000 int n = cap - 1; n= 00001111 (15) n |= n &gt;&gt;&gt; 1; // n = n |(n &gt;&gt;&gt; 1) 含义是n= n或等 n&gt;&gt;&gt;1 00001111 n= | 00000111 ----------- n= 00001111 (15) n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; // 返回16&#125; putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) 以 m 为基础构造新的映射，或者在已有映射基础上添加映射 m123456789101112131415161718192021final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 1、判断table是否已初始化 if (table == null) &#123; // pre-size float ft = ((float) s / loadFactor) + 1.0F; int t = ((ft &lt; (float) MAXIMUM_CAPACITY) ? (int) ft : MAXIMUM_CAPACITY); if (t &gt; threshold) // 1.1、设置扩容临界值 threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) // 2、如果s已经超出了扩容临界值，则进行扩容操作 resize(); // 3、执行存入映射操作 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; V put(K key, V value) 存放映射123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)存放映射 key-value onlyIfAbsent 如果为true，不修改已存在映射， evict 如果为false，则处于创建模式(从源码上看的话，是为LinkedHashMap服务的) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 存放映射final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; // table未初始化或者长度为0，则进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //计算index，并对null做处理 ,(n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123;//发生碰撞的时候,桶中已经存在元素 Node&lt;K, V&gt; e; K k; //节点key存在，直接覆盖value,比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断该链为红黑树,hash值不相等，即key不相等；为红黑树结点,并放入树当中 else if (p instanceof TreeNode) e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value); //该链为链表 else &#123; //在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; //到达链表的尾部,在尾部插入新结点 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; //在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // existing mapping for key // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或旧值为null,用新值替换旧值 if (!onlyIfAbsent || oldValue == null) e.value = value; //访问后回调 afterNodeAccess(e); return oldValue; &#125; &#125; //结构性修改,modCount加1 ++modCount; //超过扩容临界值，就扩容 if (++size &gt; threshold) resize(); // 此方法被LinkedHashMap实现 afterNodeInsertion(evict); return null;&#125; final Node&lt;K, V&gt;[] resize() 扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596final Node&lt;K, V&gt;[] resize() &#123; Node&lt;K, V&gt;[] oldTab = table; // 源table的容量大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 源扩容临界值 int oldThr = threshold; // 定义新table的容量大小和扩容临界值 int newCap, newThr = 0; // 源容量大于0时 if (oldCap &gt; 0) &#123; // 达到最大容量，不能在扩容了，直接返回 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // newCap 是源容量左移一位 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) &#123; // 初始容量设置为阈值 newCap = oldThr; &#125; else &#123; // 初始阈值为零表示使用默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float) newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ? (int) ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\", \"unchecked\"&#125;) //新建hash桶数组 Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap]; //将新数组的值复制给旧的hash桶数组 table = newTab; //进行扩容操作，复制Node对象值到新的hash桶数组 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K, V&gt; e; //如果旧的hash桶数组在j结点处不为空，复制给e if ((e = oldTab[j]) != null) &#123; //将旧的hash桶数组在j结点处设置为空，方便gc oldTab[j] = null; //如果e的后面没有node节点，直接对e的hash值对新的数组长度求模获得存储位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果e是红黑树的类型，那么添加到红黑树中 else if (e instanceof TreeNode) //将树仓中的节点拆分为上下树，如果太小，则取消树。仅从resize调用; ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap); else &#123; // preserve order // 如果是普通的链表节点，则进行普通的hash分布 // 存储索引位置为 原索引位置的 节点 Node&lt;K, V&gt; loHead = null, loTail = null; // 索引位置为 原索引位置+oldCap位置的节点 Node&lt;K, V&gt; hiHead = null, hiTail = null; Node&lt;K, V&gt; next; do &#123; //将Node结点的next赋值给next next = e.next; //如果结点e的hash值与原hash桶数组的长度作与运算为0，则扩容后的索引位置跟老表的索引位置相同 if ((e.hash &amp; oldCap) == 0) &#123; // loTail为空，代表该节点为第一个节点 if (loTail == null) // 将节点e 赋值给loHead loHead = e; else loTail.next = e; // loTail不为空，则将节点添加到loTail后面 loTail = e; // 将此次循环的新节点赋值给loTail &#125; else &#123;//如果结点e的hash值与原hash桶数组的长度作与运算不为0，则扩容后索引位置为老表的索引位置+oldCap // 如果hiTail为空，代表该节点为第一个节点 if (hiTail == null) hiHead = e; //将节点e赋值给hiHead else hiTail.next = e; // 将节点添加到hiTail后面 hiTail = e; // 将此次循环的新节点赋值给hiTail &#125; &#125; while ((e = next) != null); // 如果loTail不为空（扩容后，有老表的数据分布在新表的原索引位置），则将最后一个节点的next设为空，并将新表上对应`原索引位置`的节点设置为相应的头结点 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 如果hiTail不为空，（扩容后，有老表的数据分布在新表的原索引位置+oldCap的位置上），将最后一个节点的next设置为空，并将新表的 `原索引+oldCap` 的节点设置为对应的头结点hiHead if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; V get(Object key)1234public V get(Object key) &#123; Node&lt;K, V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; final Node&lt;K, V&gt; getNode(int hash, Object key)获取key所在的Node节点 123456789101112131415161718192021222324252627final Node&lt;K, V&gt; getNode(int hash, Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; first, e; int n; K k; // 1、table不为空、table长度大于0、hash计算所得桶索引的第一个映射不为空，则继续查找，否则直接返回null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 2、如果第一个映射的hash和参数hash相等并且key和value都相等的时候返回第一条，否则去链表或者红黑树中查询 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 3、在链表或者红黑树中获取key对应的映射 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) // 从红黑树中获取key映射 return ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key); // 遍历Node链表，获取key映射 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; treeIfbBin(Node&lt;K, V&gt;[] tab, int hash) 将链表树形化1234567891011121314151617181920212223final void treeifyBin(Node&lt;K, V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K, V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K, V&gt; hd = null, tl = null; do &#123; // 将Node节点转化为TreeNode节点 TreeNode&lt;K, V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125; V remove(Object key)12345public V remove(Object key) &#123; Node&lt;K, V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) matchValue 如果为真，则仅在值相等时删除 movable 如果为false，删除时不要移动其他节点 12345678910111213141516171819202122232425262728293031323334353637383940414243final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K, V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; final void split(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int index, int bit)将树中的节点拆分为上下树，如果太小，则取消树。仅从resize调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445final void split(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K, V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K, V&gt; loHead = null, loTail = null; TreeNode&lt;K, V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K, V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K, V&gt;) e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125;&#125; HashMap注意事项 当桶转变为红黑树的时候，树的root节点不一定是桶的索引位置的头节点。 在TreeNode结构中有一个方法moveRootToFront(Node&lt;K,V&gt; tab, TreeNode&lt;K,V&gt; root),此方法确保在树形化时，树的root节点设置为桶的索引位置。 在链表转变为红黑树之后，链表依然会通过TreeNode的next属性维持。 由于红黑树依然通过next维护这链表结构,所以红黑树的叶子节点可能存在next节点。 树化发生在putVal方法中，去树化发生在扩容resize() HashMap总结 HashMap 由 Node 数组（Node&lt;K,V&gt;[] table）实现，当hash冲突的时候(数组的索引位置相同的时候)，则可能是以链表或红黑树的形式存在。 增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步： 拿到 key 的 hashCode 值； 将 hashCode 的高位参与运算，重新计算 hash 值； 将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。 HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。 threshold 的值计算规则是比capacity大但离capacity最近的2的n次方值 导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是： table的长度始终为 2 的 n 次方； 索引位置的计算方法为 “(table.length - 1) &amp; hash”。 HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。 HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。 当同一个索引位置的节点数增加到至少8个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。 当同一个索引位置的节点数量在移除后达到至多 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。 HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。 TreeMapTreeMap 可自然排序或通过comparator进行排序 LinkedHashMapLinkedHashMap继承自HashMa,所以它具有HashMap的所有特性,它的扩展了HashMap节点结构来作为自己的节点结构;LinkedHashMap通过head、tail维护了双向链表 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; HashMap 和 HashTable 的区别 HashMap 允许 key 和 value 为 null，Hashtable 不允许。 HashMap 的默认初始容量为 16，Hashtable 为 11。 HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。 HashMap 是非线程安全的，Hashtable是线程安全的。 HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。 HashMap 去掉了 Hashtable 中的 contains 方法。 HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]},{"title":"深入理解java序列化","date":"2016-06-18T11:38:43.000Z","path":"qsk/java/understand_java_serial.html","text":"深入理解java序列化如果你只知道实现Serializable接口的对象，可以序列化为本地文件。那你最好再阅读该篇文章，文章对序列化进行了更深一步的讨论，用实际的例子代码讲述了序列化的高级认识，包括父类序列化的问题、静态变量问题、transient关键字的影响、序列化ID问题。在笔者实际开发过程中，就多次遇到序列化的问题，在该文章中也会与读者分享。 引言将Java对象序列化为二进制文件的Java序列化技术是Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与Java序列化相关，通过分析情境出现的原因，使读者轻松牢记Java 序列化中的一些高级认识。 序列化 ID 问题 情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C序列化为二进制数据再传给 B，B 反序列化得到 C。 问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable接口，但是反序列化时总是提示不成功。 解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。 12345678910111213141516171819202122232425package com.inout; import java.io.Serializable; public class A implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;package com.inout;import java.io.Serializable;public class A implements Serializable &#123; private static final long serialVersionUID = 2L; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 序列化ID在Eclipse下提供了两种生成策略，一个是固定的1L，一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。 特性使用案例 读者应该听过Façade模式，它是为应用程序提供统一的访问接口，案例程序中的Client客户端使用了该模式，案例程序结构图如图1所示。 Client端通过FaçadeObject才可以与业务逻辑对象进行交互。而客户端的FaçadeObject不能直接由Client生成，而是需要Server端生成，然后序列化后通过网络将二进制对象数据传给Client，Client负责反序列化得到Façade对象。该模式可以使得Client端程序的使用需要服务器端的许可,同时Client端和服务器端的FaçadeObject类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的FaçadeObject类的序列化ID再次生成，当Client端反序列化FaçadeObject就会失败，也就是强制Client端从服务器端获取最新程序。 静态变量序列化 情境：查看清单 2 的代码。 清单 2. 静态变量序列化问题代码 12345678910111213141516171819202122232425262728293031public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 清单2中的main方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单2，这个System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？最后的输出是10，对于无法理解的读者认为，打印的 staticVar是从读取的对象里获得的，应该是保存时的状态才对。之所以打印10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。 父类的序列化与 Transient 关键字 情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。 解决：要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int 型的是 0，对象型的是 null。 特性使用案例 我们熟悉使用Transient关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。 上图中可以看出，attr1、attr2、attr3、attr5都不会被序列化，放在父类中的好处在于当有另外一个Child类时，attr1、attr2、attr3依然不会被序列化，不用重复抒写transient，代码简洁。 对敏感字段加密 情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 解决：在序列化过程中，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单3展示了这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static final long serialVersionUID = 1L;private String password = &quot;pass&quot;;public String getPassword() &#123; return password;&#125;public void setPassword(String password) &#123; this.password = password;&#125;private void writeObject(ObjectOutputStream out) &#123; try &#123; PutField putFields = out.putFields(); System.out.println(&quot;原密码:&quot; + password); password = &quot;encryption&quot;;//模拟加密 putFields.put(&quot;password&quot;, password); System.out.println(&quot;加密后的密码&quot; + password); out.writeFields(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void readObject(ObjectInputStream in) &#123; try &#123; GetField readFields = in.readFields(); Object object = readFields.get(&quot;password&quot;, &quot;&quot;); System.out.println(&quot;要解密的字符串:&quot; + object.toString()); password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;public static void main(String[] args) &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); System.out.println(&quot;解密后的字符串:&quot; + t.getPassword()); oin.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对password进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单3后控制台输出如图 3 所示: 特性使用案例 RMI 技术是完全基于 Java序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及RMI的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。 序列化存储规则1234567891011121314151617181920ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); Test test = new Test(); //试图将对象两次写入文件 out.writeObject(test); out.flush(); System.out.println(new File(&quot;result.obj&quot;).length()); out.writeObject(test); out.close(); System.out.println(new File(&quot;result.obj&quot;).length()); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); //从文件依次读出两个文件 Test t1 = (Test) oin.readObject(); Test t2 = (Test) oin.readObject(); oin.close(); //判断两个引用是否指向同一个对象 System.out.println(t1 == t2); 清单 3中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入false 才对，但是最后结果输出如图 4 所示。 我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？ 解答：Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 特性案例分析123456789101112131415ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));Test test = new Test();test.i = 1;out.writeObject(test);out.flush();test.i = 2;out.writeObject(test);out.close();ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;));Test t1 = (Test) oin.readObject();Test t2 = (Test) oin.readObject();System.out.println(t1.i);System.out.println(t2.i); 清单 4 的目的是希望将 test 对象两次保存到result.obj文件中，写入一次以后修改对象属性值再次保存第二次，然后从result.obj中再依次读出两个对象，输出这两个对象的i属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。结果两个输出的都是 1，原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次writeObject 需要特别注意这个问题。 小结本文通过几个具体的情景，介绍了Java序列化的一些高级知识，虽说高级，并不是说读者们都不了解，希望用笔者介绍的情景让读者加深印象，能够更加合理的利用Java序列化技术，在未来开发之路上遇到序列化问题时，可以及时的解决。由于本人知识水平有限，文章中倘若有错误的地方，欢迎联系我批评指正。 转载自 读书使人进步","tags":[{"name":"序列化","slug":"序列化","permalink":"http://www.throne4j.com/tags/序列化/"}]},{"title":"深入理解java反射(一)","date":"2016-06-13T13:38:43.000Z","path":"qsk/java/understand_java_reflect.html","text":"深入理解java反射机制反射(Reflection)是 Java程序开发语言的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。 首先 我们看下java.lang.reflect包下面几个主要类的关系图 AnnotatedElement该接口的实现类代表程序中可以接受注解的程序元素，这个接口提供了获取注解相关的功能，该接口主要有一下几个实现类： Class 类定义 Constructor 构造器定义 Field 属性成员定义 Method 方法定义 Package 包定义 123456789public interface AnnotatedElement &#123; default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass); default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass); default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass); default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass); &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass); Annotation[] getAnnotations(); Annotation[] getDeclaredAnnotations();&#125; 实现用户自定义注解元注解GenericDeclaration提供了获取泛型相关的功能，只有方法和构造方法上支持泛型，所以只有Method，Constructor实现了该接口 Member作为一个对象内部方法和属性的声明的抽象，包含了名称，修饰符，所在的类,其中修饰符包含了 static final public private volatile 等，通过一个整数表示，每一个类型在二进制中占一个位. AccessibleObject这是一个类，提供了权限管理的功能，例如是否允许在反射中在外部调用一个private方法，获取一个private属性的值，所以method，constructor,field都继承该类，下面这段代码展示了如何在反射中访问一个私有的成员变量，class对象的构造方法不允许对外。 123456789101112131415161718private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException&#123; if (obj instanceof Constructor &amp;&amp; flag == true) &#123; Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj; if (c.getDeclaringClass() == Class.class) &#123; throw new SecurityException(&quot;Cannot make a java.lang.Class&quot; + &quot; constructor accessible&quot;); &#125; &#125; obj.override = flag;&#125;boolean override;public boolean isAccessible() &#123; return override;&#125; 以下为 Field里面通过field.get(原始对象)获取属性值得实现,先通过override做校验，如果没有重载该权限，则需要校验访问权限 1234567891011public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; return getFieldAccessor(obj).get(obj);&#125;","tags":[{"name":"反射","slug":"反射","permalink":"http://www.throne4j.com/tags/反射/"}]},{"title":"反射Type详解","date":"2016-06-03T13:38:43.000Z","path":"qsk/java/reflect_type_detail.html","text":"Type 来历来历我们知道，Type 是 JDK5 开始引入的，其引入主要是为了泛型，没有泛型的之前， 只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类 Class 类进行抽象。 Class 类的一个具体对象就代表一个指定的原始类型。 泛型出现之后，也就扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、泛型数组类型，也就是 Type 的子接口。 那为什么没有统一到 Class 下，而是增加一个 Type 呢？（Class 也是种类的意思，Type 是类型的意思）? 是为了程序的扩展性，最终引入了 Type 接口作为 Class，ParameterizedType，GenericArrayType，TypeVariable 和 WildcardType 这几种类型的总的父接口。 这样实现了 Type 类型参数接受以上五种子类的实参或者返回值类型就是 Type 类型的参数。 Type应用有很多场景下我们可以获得Type，比如： 当我们拿到一个Class，用Class. getGenericInterfaces()方法得到Type[]，也就是这个类实现接口的Type类型列表。 当我们拿到一个Class，用Class.getDeclaredFields()方法得到Field[]，也就是类的属性列表，然后用Field. getGenericType()方法得到这个属性的Type类型。 当我们拿到一个Method，用Method. getGenericParameterTypes()方法获得Type[]，也就是方法的参数类型列表。 Java 类型分类Java 的所有类型包括： raw type：原始类型，对应 Class parameterized types：参数化类型，对应 ParameterizedType array types：数组类型，对应 GenericArrayType type variables：类型变量，对应 TypeVariable primitive types：基本类型，仍然对应 Class 1 中的 Class，不仅仅指平常所指的类，还包括数组、接口、注解、枚举等结构。3 中的数组类型 GenericArrayType，应该指的是 2、4 类型数组，而不是一般我们说的数组，我们一般所说的数组是指 1、5 类型数组，他们还是 1，也就是 Class 类型。 TypeVariable类型参数，描述类型，表示泛指任意或相关一类类型，泛型声明所声明的类型参数，仅仅用作参数占位符的标识符。 1234567891011121314public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type, AnnotatedElement &#123; // AnnotatedType[] getAnnotatedBounds(); //返回表示此类型变量的上限的 Type对象的数组 Type[] getBounds(); //获取声明该类型变量实体(即获得类、方法或构造器名) D getGenericDeclaration(); //返回此类型变量的名称，表示占位符 String getName();&#125; 123456789101112public class CustomTypeVariable&lt;T&gt; &#123; public static void main(String[] args) &#123; Type[] types = CustomTypeVariable.class.getTypeParameters(); TypeVariable typeVariable = (TypeVariable) types[0]; //Output: T typeVariable.getName(); //Output: Object typeVariable.getBounds()[0]; //Output: com.aspire.search.test.CustomTypeVariable typeVariable.getGenericDeclaration(); &#125;&#125; ParameterizedType参数化类型，形如：Object&lt;T, K&gt;，即常说的泛型，是 Type 的子接口。 1234567891011public interface ParameterizedType extends Type &#123; //返回类型参数数组 Type[] getActualTypeArguments(); //返回此类型Type对象 Type getRawType(); //返回一个 Type对象，表示此类型为其成员的类型 Type getOwnerType();&#125; 123456789101112131415161718public class CustomParameterizedType &#123; static List&lt;String&gt; contains = new ArrayList&lt;&gt;(); public Map.Entry&lt;String,String&gt; mapEntry; public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException &#123; //字段 Field field = CustomParameterizedType.class.getDeclaredField(\"mapEntry\"); ParameterizedType paramterTypes = (ParameterizedType) field.getGenericType(); Type[] types = paramterTypes.getActualTypeArguments(); //Output: java.util.Map$Entry String rawType = paramterTypes.getRawType().getTypeName(); //Output: java.util.Map Type ownerType = paramterTypes.getOwnerType(); //Output: [java.lang.String, java.lang.String] Type[] typeArgs = paramterTypes.getActualTypeArguments(); &#125;&#125; GenericArrayType泛型数组，描述的是形如：A[] 或 T[] 类型 12345public interface GenericArrayType extends Type &#123; // 返回泛型数组类型 Type getGenericComponentType();&#125; 12345678910public class CustomGenericArrayType&lt;T&gt; &#123; private T[] var; public static void main(String[] args) throws NoSuchFieldException &#123; //GenericArrayType实例对象 Type fruitType = CustomGenericArrayType.class.getDeclaredField(\"var\").getGenericType(); //泛型类型T Type var1 = ((GenericArrayType)fruitType).getGenericComponentType(); &#125;&#125; WildcardType通配符表达式，泛型表达式，也可以说是，限定性的泛型，形如：? extends classA、？super classB。 12345678public interface WildcardType extends Type &#123; //返回类型变量下限 Type[] getLowerBounds(); //返回类型变量上限 Type[] getUpperBounds();&#125; 1234567891011121314151617public class CustomWildcardType &#123; private List&lt;? extends Fruit&gt; ft1; private List&lt;? super Apple&gt; ft2; public static void main(String[] args) throws NoSuchFieldException &#123; //读取参数化类型(ParameterizedType): List&lt;? extends Fruit&gt; Type var1 = CustomWildcardType.class.getDeclaredField(\"ft1\").getGenericType(); Type var2 = CustomWildcardType.class.getDeclaredField(\"ft2\").getGenericType(); WildcardType w1 = (WildcardType) ((ParameterizedType) var1).getActualTypeArguments()[0]; WildcardType w2 = (WildcardType) ((ParameterizedType) var2).getActualTypeArguments()[0]; //Output: com.aspire.search.test.Fruit Type type1 = w1.getUpperBounds()[0]; //Output: com.aspire.search.test.Apple Type type2 = w2.getLowerBounds()[0]; &#125;&#125; spring-core中 SerializableTypeWrapper类Type 类型的包装类从上面可知，Type 包括：原始类型，而泛型又可以衍生出：类型参数以及通配符表达式。获取类型信息不仅仅是局限于原始类型信息，如果是泛型，还需要知道它的类型参数或通配符参数等信息，那如何提供获取这些信息的工具？这里用到了 SerializableTypeWrapper 包装类，其内部通过不同的 Type 类型实现不同接口的代理类实现。client - &gt;TypeWriter -&gt; Proxy：先看类型包装器接口，TypeProvider 是字段类型、方法入参类型、方法返回类型的包装类，高层模块通过该实例获取类型的相关信息，包括泛型的原始类型、类型参数等等： 1234567891011121314151617@SuppressWarnings(\"serial\")interface TypeProvider extends Serializable &#123; /** * 返回类型 */ @Nullable Type getType(); /** * 返回类型源 */ @Nullable default Object getSource() &#123; return null; &#125;&#125; 字段 Field 对象包装器仅仅对字段的封装，可以理解为字段的代理类： 12345678910111213141516171819202122232425262728293031323334353637@SuppressWarnings(\"serial\")static class FieldTypeProvider implements TypeProvider &#123; private final String fieldName; // 得到目标属性所在类对应的Class对象 private final Class&lt;?&gt; declaringClass; private transient Field field; public FieldTypeProvider(Field field) &#123; this.fieldName = field.getName(); this.declaringClass = field.getDeclaringClass(); this.field = field; &#125; @Override public Type getType() &#123; // 返回字段的声明类型 return this.field.getGenericType(); &#125; @Override public Object getSource() &#123; return this.field; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); try &#123; this.field = this.declaringClass.getDeclaredField(this.fieldName); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Could not find original class structure\", ex); &#125; &#125;&#125; 方法参数包装器其实就是对方法参数类型的代理类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@SuppressWarnings(\"serial\")static class MethodParameterTypeProvider implements TypeProvider &#123; // 方法名 @Nullable private final String methodName; // 参数类型 private final Class&lt;?&gt;[] parameterTypes; // 得到目标属性所在类对应的Class对象 private final Class&lt;?&gt; declaringClass; // 参数索引 private final int parameterIndex; private transient MethodParameter methodParameter; public MethodParameterTypeProvider(MethodParameter methodParameter) &#123; this.methodName = (methodParameter.getMethod() != null ? methodParameter.getMethod().getName() : null); this.parameterTypes = methodParameter.getExecutable().getParameterTypes(); this.declaringClass = methodParameter.getDeclaringClass(); this.parameterIndex = methodParameter.getParameterIndex(); this.methodParameter = methodParameter; &#125; @Override public Type getType() &#123; return this.methodParameter.getGenericParameterType(); &#125; @Override public Object getSource() &#123; return this.methodParameter; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); try &#123; if (this.methodName != null) &#123; this.methodParameter = new MethodParameter( this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex); &#125; else &#123; this.methodParameter = new MethodParameter( this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex); &#125; &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Could not find original class structure\", ex); &#125; &#125;&#125; 返回参数包装器方法返回类型代理类，注意这里的 provider 属性，它指向泛型实例对象。例如，获取 List 字段的原始类型，即调用代理类的 getRawType() 方法，即最终调用 MethodInvokeTypeProvider.getType()，此时 provider 执行 List 的包装类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SuppressWarnings(\"serial\")static class MethodInvokeTypeProvider implements TypeProvider &#123; private final TypeProvider provider; private final String methodName; //方法名 private final Class&lt;?&gt; declaringClass; // 所在类对应的Class对象 private final int index; private transient Method method; @Nullable private transient volatile Object result; public MethodInvokeTypeProvider(TypeProvider provider, Method method, int index) &#123; this.provider = provider; this.methodName = method.getName(); this.declaringClass = method.getDeclaringClass(); this.index = index; this.method = method; &#125; @Override @Nullable public Type getType() &#123; Object result = this.result; if (result == null) &#123; // 延迟调用目标方法 result = ReflectionUtils.invokeMethod(this.method, this.provider.getType()); // 缓存结果 this.result = result; &#125; return (result instanceof Type[] ? ((Type[]) result)[this.index] : (Type) result); &#125; @Override @Nullable public Object getSource() &#123; return null; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName); if (method == null) &#123; throw new IllegalStateException(\"Cannot find method on deserialization: \" + this.methodName); &#125; if (method.getReturnType() != Type.class &amp;&amp; method.getReturnType() != Type[].class) &#123; throw new IllegalStateException( \"Invalid return type on deserialized method - needs to be Type or Type[]: \" + method); &#125; this.method = method; &#125;&#125; 看下 SerializableTypeWrapper 类的类属性常量： 1234private static final Class&lt;?&gt;[] SUPPORTED_SERIALIZABLE_TYPES = &#123; GenericArrayType.class, ParameterizedType.class, TypeVariable.class, WildcardType.class&#125;;static final ConcurrentReferenceHashMap&lt;Type, Type&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(256); 从上面的代码可以看出： 定义了一个 Class 类型的数组，其元素分别为 GenericArrayType、ParameterizedType、TypeVariable、WildcardType，也就是为不同的泛型代理实现的接口。使用 cache 缓存已创建的代理 获取类型对外暴露的静态方法，该方法在类型的代理类中也会被调用，在代理类中调用是为了获取泛型的相关类型信息： 12345678910111213141516171819202122232425262728293031323334@Nullablestatic Type forTypeProvider(TypeProvider provider) &#123; Type providedType = provider.getType(); if (providedType == null || providedType instanceof Serializable) &#123; /** * 作为获取原始类型还是与泛型相关的信息(泛型原始类型、参数类型)入口 * 注意： * 1、原始类型，对应 Class，Class实现Serializable接口，直接返回 * 2、泛型类型如List&lt;String&gt;，返回其代理类 */ return providedType; &#125; if (GraalDetector.inImageCode() || !Serializable.class.isAssignableFrom(Class.class)) &#123; // 如果类型在当前运行时环境中通常不可序列化，那么跳过任何包装尝试 return providedType; &#125; // 获取给定提供者的可序列化类型代理 Type cached = cache.get(providedType); if (cached != null) &#123; return cached; &#125; for (Class&lt;?&gt; type : SUPPORTED_SERIALIZABLE_TYPES) &#123; if (type.isInstance(providedType)) &#123; ClassLoader classLoader = provider.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[] &#123;type, SerializableTypeProxy.class, Serializable.class&#125;; InvocationHandler handler = new TypeProxyInvocationHandler(provider); cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler); cache.put(providedType, cached); return cached; &#125; &#125; throw new IllegalArgumentException(&quot;Unsupported Type class: &quot; + providedType.getClass().getName());&#125; 泛型代理类实现的接口定义获取类型包装器 TypeProvider 对象协议： 123456interface SerializableTypeProxy &#123; /** * 返回基础类型 */ TypeProvider getTypeProvider();&#125; 关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@SuppressWarnings(\"serial\")private static class TypeProxyInvocationHandler implements InvocationHandler, Serializable &#123; //类型包装类，例如List&lt;String&gt;的包装类 private final TypeProvider provider; public TypeProxyInvocationHandler(TypeProvider provider) &#123; this.provider = provider; &#125; @Override @Nullable public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; /** * 重写equals方法 */ if (method.getName().equals(\"equals\") &amp;&amp; args != null) &#123; Object other = args[0]; // Unwrap proxies for speed if (other instanceof Type) &#123; other = unwrap((Type) other); &#125; // 确定给定的对象是否相等 return ObjectUtils.nullSafeEquals(this.provider.getType(), other); &#125; /** * 重写hashCode方法 */ else if (method.getName().equals(\"hashCode\")) &#123; // 返回给定对象的哈希码 return ObjectUtils.nullSafeHashCode(this.provider.getType()); &#125; /** * 实现SerializableTypeProxy.getTypeProvider()方法 */ else if (method.getName().equals(\"getTypeProvider\")) &#123; // 执行getTypeProvider方法 return this.provider; &#125; /** * 实现Type子接口返回Type类型的方法： * GenericArrayType.getGenericComponentType() * ParameterizedType.getRawType()/getOwnerType() */ if (Type.class == method.getReturnType() &amp;&amp; args == null) &#123; return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1)); &#125; /** * 实现Type子接口返回Type[]类型的方法： * ParameterizedType.getActualTypeArguments() * TypeVariable.getBounds() * WildcardType.getUpperBounds()/getLowerBounds() */ else if (Type[].class == method.getReturnType() &amp;&amp; args == null) &#123; /** * 1: ParameterizedType.getActualTypeArguments() * 返回一个表示此类型的实际类型参数的Type数组,eg: Hash&lt;String, String&gt;返回[class java.lang.String, class java.lang.String] */ Type[] result = new Type[((Type[]) method.invoke(this.provider.getType())).length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i)); &#125; return result; &#125; try &#123; return method.invoke(this.provider.getType(), args); &#125; catch (InvocationTargetException ex) &#123; throw ex.getTargetException(); &#125; &#125;&#125; 接下来看下 SerializableTypeWrapper 对外暴露的其他方法： 123456789101112131415161718192021// 返回泛型类型的可序列化变体@Nullablepublic static Type forField(Field field) &#123; return forTypeProvider(new FieldTypeProvider(field));&#125;// 返回方法参数泛型类型的可序列化变体@Nullablepublic static Type forMethodParameter(MethodParameter methodParameter) &#123; return forTypeProvider(new MethodParameterTypeProvider(methodParameter));&#125;// 返回原始类型@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T extends Type&gt; T unwrap(T type) &#123; Type unwrapped = type; while (unwrapped instanceof SerializableTypeProxy) &#123; unwrapped = ((SerializableTypeProxy) type).getTypeProvider().getType(); &#125; return (unwrapped != null ? (T) unwrapped : type);&#125; 获取 Type 实例的调用过程： 总结：通过使用代理类的方式来获取具体的类型信息，特别是想要获取泛型相关的信息时，很直观。 接下来看下参数化类型 ParameterizedType 代理类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public final class $Proxy0 extends Proxy implements ParameterizedType, SerializableTypeProxy, Serializable &#123; private static Method m1; private static Method m6; private static Method m5; private static Method m2; private static Method m7; private static Method m3; private static Method m4; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; // public final boolean equals(Object var1) &#123;...&#125; // public final String toString() &#123;...&#125; // public final int hashCode() &#123;...&#125; public final String getTypeName() throws &#123; try &#123; return (String)super.h.invoke(this, m6, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type getOwnerType() throws &#123; try &#123; return (Type)super.h.invoke(this, m5, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final TypeProvider getTypeProvider() throws &#123; try &#123; return (TypeProvider)super.h.invoke(this, m7, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type[] getActualTypeArguments() throws &#123; try &#123; return (Type[])super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type getRawType() throws &#123; try &#123; return (Type)super.h.invoke(this, m4, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m6 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getTypeName\"); m5 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getOwnerType\"); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m7 = Class.forName(\"com.wiket.proxy.Client$SerializableTypeProxy\").getMethod(\"getTypeProvider\"); m3 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getActualTypeArguments\"); m4 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getRawType\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;","tags":[{"name":"反射","slug":"反射","permalink":"http://www.throne4j.com/tags/反射/"}]},{"title":"Object详解","date":"2016-05-27T08:30:14.000Z","path":"qsk/java/Object.html","text":"java基础之Object走上java开发之路伊始，我们知道java是面向对象程序设计语言。 java中的Object是所有类的超级父类(基本类型不是对象，不做考虑)，如果没有显示指出类所实现的超类，Object类就被认为是这个类的超类。 Object所描述的属性和方法抽象出了所有对象所共有的属性和方法。 private static native void registerNatives()注册本地方法 public final native Class&lt;?&gt; getClass()不可被子类重写的native方法，getClass() 返回的实例对象的真实class类型 public native int hashCode()可被子类重写的本地方法。默认情况下，对象的哈希码是通过将该对象的内部地址转换成一个整数来实现的。哈希码的通用约定如下： 在java程序执行过程中，在一个对象没有被改变的前提下，无论这个对象被调用多少次，hashCode方法都会返回相同的整数值。对象的哈希码没有必要在不同的程序中保持相同的值。 如果2个对象使用equals方法进行比较并且相同的话，那么这2个对象的hashCode方法的值也必须相等。 现存在两个对象，obj1 和 obj2,如果违反这个约定的话，obj1.equals(obj2),但是hashCode不相等，在哈希表中会存入obj1和obj2，但是这两个元素是重复的，对于拥有不可重复元素特性的的Set集合来说，就会失去这一重要特性，而产生不可预期的后果。 如果根据equals方法，得到两个对象不相等，那么这2个对象的hashCode值不需要必须不相同。但是，不相等的对象的hashCode值不同的话可以提高哈希表的性能。 public boolean equals(Object obj)比较对象的内存地址equals方法在非空对象引用上的特性： reflexive，自反性。任何非空引用值x，对于x.equals(x)必须返回true symmetric，对称性。任何非空引用值x和y，如果x.equals(y)为true，那么y.equals(x)也必须为true transitive，传递性。任何非空引用值x、y和z，如果x.equals(y)为true并且y.equals(z)为true，那么x.equals(z)也必定为true consistent，一致性。任何非空引用值x和y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改 对于任何非空引用值 x，x.equals(null) 都应返回 false protected native Object clone() throws CloneNotSupportedException创建并返回对象的一份浅拷贝，一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 也为true。 由于Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常 public String toString()Object对象的默认实现，即输出类的名字@实例的哈希码的16进制： public final native void notify()唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程。选择是任意性的，并在对实现做出决定时发生。一个线程在对象监视器上等待可以调用wait方法。 直到当前线程放弃对象上的锁之后，被唤醒的线程才可以继续处理。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。 notify方法只能被作为此对象监视器的所有者的线程来调用。一个线程要想成为对象监视器的所有者，可以使用以下3种方法： 执行对象的同步实例方法 使用synchronized内置锁 对于Class类型的对象，执行同步静态方法 一次只能有一个线程拥有对象的监视器。 如果当前线程不是此对象监视器的所有者的话会抛出IllegalMonitorStateException异常 注意点： 因为notify只能在拥有对象监视器的所有者线程中调用，否则会抛出IllegalMonitorStateException异常 public final native void notifyAll()同notify(),唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 public final native void wait(long timeout) throws InterruptedExceptionwait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。 跟notify和notifyAll方法一样，当前线程必须是此对象的监视器所有者，否则还是会发生IllegalMonitorStateException异常。 wait方法会让当前线程(我们先叫做线程T)将其自身放置在对象的等待集中，并且放弃该对象上的所有同步要求。出于线程调度目的，线程T是不可用并处于休眠状态，直到发生以下四件事中的任意一件： 其他某个线程调用此对象的notify方法，并且线程T碰巧被任选为被唤醒的线程 其他某个线程调用此对象的notifyAll方法 其他某个线程调用Thread.interrupt方法中断线程T 时间到了参数设置的超时时间。如果timeout参数为0，则不会超时，会一直进行等待 所以可以理解wait方法相当于放弃了当前线程对对象监视器的所有者(也就是说释放了对象的锁) 之后，线程T会被等待集中被移除，并且重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用wait方法时的情况。然后，线程T从wait方法的调用中返回。所以，从wait方法返回时，该对象和线程T的同步状态与调用wait方法时的情况完全相同。 在没有被通知、中断或超时的情况下，线程还可以唤醒一个所谓的虚假唤醒 (spurious wakeup)。虽然这种情况在实践中很少发生，但是应用程序必须通过以下方式防止其发生，即对应该导致该线程被提醒的条件进行测试，如果不满足该条件，则继续等待。换句话说，等待应总是发生在循环中，如下面的示例： 12345synchronized (obj) &#123; while (&lt;condition does not hold&gt;) obj.wait(timeout); ... // Perform action appropriate to condition&#125; 如果当前线程在等待之前或在等待时被任何线程中断，则会抛出InterruptedException异常。在按上述形式恢复此对象的锁定状态时才会抛出此异常。 wait(long timeout, int nanos) throws InterruptedException方法跟wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。 需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。 public final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable在对象实例被垃圾回收系统回收时触发。","tags":[{"name":"基础","slug":"基础","permalink":"http://www.throne4j.com/tags/基础/"}]}]