[{"title":"golang安装配置","date":"2019-06-03T13:38:43.000Z","path":"golang/go/go语言配置说明/","text":"go语言在mac osx系统上安装go语言非常简单，直接在官网上下载mac os版的安装包一路next即可安装成功。另外可使用HomeBrew来实现go语言的安装，brew install go GOPATH配置 GOPATH 设置go项目的工作目录，在go项目的工作目录中至少存在三个目录： src 用于以代码包的形式组织并保存go源文件，这里的代码包与src下的子目录一一对应。 pkg 编译后生成的文件（.a文件）。非main函数的文件在go install后生成。 用于存放通过go install命令安装后的代码包的归档文件。前提是代码包中必须包含go库源码文件。 bin 存放编译后生成的可执行文件,通过go install命令完成安装后，保存由go命令源码文件生成的可执行文件。 GOBINGOBIN是 GOPATH 下的bin目录 GOROOT go语言的安装路径源码文件1) 命令源码文件 &gt; 如果一个源码文件被声明属于main代码包，且该文件代码中包含无参数声明和结果声明的main函数，则他就是命令源码文件。命令源码文件可以直接通过go run 命令直接启动运行。2) 库源码文件 &gt;通常，库源码文件声明的包名 会 与它直接所属的代码包名一致，且库源码文件中不包含无参数声明和无结果声明的main函数3) 测试源码文件 &gt; 测试源码文件是一种特殊的库文件，可以通过执行 go test 命令运行当前代码包下的所有测试源码文件。","tags":[{"name":"golang","slug":"golang","permalink":"http://www.throne4j.com/tags/golang/"}]},{"title":"反射Type详解","date":"2019-06-03T13:38:43.000Z","path":"java/java/反射/反射Type学习记录/","text":"Type 来历来历我们知道，Type 是 JDK5 开始引入的，其引入主要是为了泛型，没有泛型的之前， 只有所谓的原始类型。此时，所有的原始类型都通过字节码文件类 Class 类进行抽象。 Class 类的一个具体对象就代表一个指定的原始类型。 泛型出现之后，也就扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、泛型数组类型，也就是 Type 的子接口。 那为什么没有统一到 Class 下，而是增加一个 Type 呢？（Class 也是种类的意思，Type 是类型的意思）? 是为了程序的扩展性，最终引入了 Type 接口作为 Class，ParameterizedType，GenericArrayType，TypeVariable 和 WildcardType 这几种类型的总的父接口。 这样实现了 Type 类型参数接受以上五种子类的实参或者返回值类型就是 Type 类型的参数。 Type应用有很多场景下我们可以获得Type，比如： 当我们拿到一个Class，用Class. getGenericInterfaces()方法得到Type[]，也就是这个类实现接口的Type类型列表。 当我们拿到一个Class，用Class.getDeclaredFields()方法得到Field[]，也就是类的属性列表，然后用Field. getGenericType()方法得到这个属性的Type类型。 当我们拿到一个Method，用Method. getGenericParameterTypes()方法获得Type[]，也就是方法的参数类型列表。 Java 类型分类Java 的所有类型包括： raw type：原始类型，对应 Class parameterized types：参数化类型，对应 ParameterizedType array types：数组类型，对应 GenericArrayType type variables：类型变量，对应 TypeVariable primitive types：基本类型，仍然对应 Class 1 中的 Class，不仅仅指平常所指的类，还包括数组、接口、注解、枚举等结构。3 中的数组类型 GenericArrayType，应该指的是 2、4 类型数组，而不是一般我们说的数组，我们一般所说的数组是指 1、5 类型数组，他们还是 1，也就是 Class 类型。 TypeVariable类型参数，描述类型，表示泛指任意或相关一类类型，泛型声明所声明的类型参数，仅仅用作参数占位符的标识符。 1234567891011121314public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type, AnnotatedElement &#123; // AnnotatedType[] getAnnotatedBounds(); //返回表示此类型变量的上限的 Type对象的数组 Type[] getBounds(); //获取声明该类型变量实体(即获得类、方法或构造器名) D getGenericDeclaration(); //返回此类型变量的名称，表示占位符 String getName();&#125; 123456789101112public class CustomTypeVariable&lt;T&gt; &#123; public static void main(String[] args) &#123; Type[] types = CustomTypeVariable.class.getTypeParameters(); TypeVariable typeVariable = (TypeVariable) types[0]; //Output: T typeVariable.getName(); //Output: Object typeVariable.getBounds()[0]; //Output: com.aspire.search.test.CustomTypeVariable typeVariable.getGenericDeclaration(); &#125;&#125; ParameterizedType参数化类型，形如：Object&lt;T, K&gt;，即常说的泛型，是 Type 的子接口。 1234567891011public interface ParameterizedType extends Type &#123; //返回类型参数数组 Type[] getActualTypeArguments(); //返回此类型Type对象 Type getRawType(); //返回一个 Type对象，表示此类型为其成员的类型 Type getOwnerType();&#125; 123456789101112131415161718public class CustomParameterizedType &#123; static List&lt;String&gt; contains = new ArrayList&lt;&gt;(); public Map.Entry&lt;String,String&gt; mapEntry; public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException &#123; //字段 Field field = CustomParameterizedType.class.getDeclaredField(\"mapEntry\"); ParameterizedType paramterTypes = (ParameterizedType) field.getGenericType(); Type[] types = paramterTypes.getActualTypeArguments(); //Output: java.util.Map$Entry String rawType = paramterTypes.getRawType().getTypeName(); //Output: java.util.Map Type ownerType = paramterTypes.getOwnerType(); //Output: [java.lang.String, java.lang.String] Type[] typeArgs = paramterTypes.getActualTypeArguments(); &#125;&#125; GenericArrayType泛型数组，描述的是形如：A[] 或 T[] 类型 12345public interface GenericArrayType extends Type &#123; // 返回泛型数组类型 Type getGenericComponentType();&#125; 12345678910public class CustomGenericArrayType&lt;T&gt; &#123; private T[] var; public static void main(String[] args) throws NoSuchFieldException &#123; //GenericArrayType实例对象 Type fruitType = CustomGenericArrayType.class.getDeclaredField(\"var\").getGenericType(); //泛型类型T Type var1 = ((GenericArrayType)fruitType).getGenericComponentType(); &#125;&#125; WildcardType通配符表达式，泛型表达式，也可以说是，限定性的泛型，形如：? extends classA、？super classB。 12345678public interface WildcardType extends Type &#123; //返回类型变量下限 Type[] getLowerBounds(); //返回类型变量上限 Type[] getUpperBounds();&#125; 1234567891011121314151617public class CustomWildcardType &#123; private List&lt;? extends Fruit&gt; ft1; private List&lt;? super Apple&gt; ft2; public static void main(String[] args) throws NoSuchFieldException &#123; //读取参数化类型(ParameterizedType): List&lt;? extends Fruit&gt; Type var1 = CustomWildcardType.class.getDeclaredField(\"ft1\").getGenericType(); Type var2 = CustomWildcardType.class.getDeclaredField(\"ft2\").getGenericType(); WildcardType w1 = (WildcardType) ((ParameterizedType) var1).getActualTypeArguments()[0]; WildcardType w2 = (WildcardType) ((ParameterizedType) var2).getActualTypeArguments()[0]; //Output: com.aspire.search.test.Fruit Type type1 = w1.getUpperBounds()[0]; //Output: com.aspire.search.test.Apple Type type2 = w2.getLowerBounds()[0]; &#125;&#125; spring-core中 SerializableTypeWrapper类Type 类型的包装类从上面可知，Type 包括：原始类型，而泛型又可以衍生出：类型参数以及通配符表达式。获取类型信息不仅仅是局限于原始类型信息，如果是泛型，还需要知道它的类型参数或通配符参数等信息，那如何提供获取这些信息的工具？这里用到了 SerializableTypeWrapper 包装类，其内部通过不同的 Type 类型实现不同接口的代理类实现。client - &gt;TypeWriter -&gt; Proxy：先看类型包装器接口，TypeProvider 是字段类型、方法入参类型、方法返回类型的包装类，高层模块通过该实例获取类型的相关信息，包括泛型的原始类型、类型参数等等： 1234567891011121314151617@SuppressWarnings(\"serial\")interface TypeProvider extends Serializable &#123; /** * 返回类型 */ @Nullable Type getType(); /** * 返回类型源 */ @Nullable default Object getSource() &#123; return null; &#125;&#125; 字段 Field 对象包装器仅仅对字段的封装，可以理解为字段的代理类： 12345678910111213141516171819202122232425262728293031323334353637@SuppressWarnings(\"serial\")static class FieldTypeProvider implements TypeProvider &#123; private final String fieldName; // 得到目标属性所在类对应的Class对象 private final Class&lt;?&gt; declaringClass; private transient Field field; public FieldTypeProvider(Field field) &#123; this.fieldName = field.getName(); this.declaringClass = field.getDeclaringClass(); this.field = field; &#125; @Override public Type getType() &#123; // 返回字段的声明类型 return this.field.getGenericType(); &#125; @Override public Object getSource() &#123; return this.field; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); try &#123; this.field = this.declaringClass.getDeclaredField(this.fieldName); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Could not find original class structure\", ex); &#125; &#125;&#125; 方法参数包装器其实就是对方法参数类型的代理类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@SuppressWarnings(\"serial\")static class MethodParameterTypeProvider implements TypeProvider &#123; // 方法名 @Nullable private final String methodName; // 参数类型 private final Class&lt;?&gt;[] parameterTypes; // 得到目标属性所在类对应的Class对象 private final Class&lt;?&gt; declaringClass; // 参数索引 private final int parameterIndex; private transient MethodParameter methodParameter; public MethodParameterTypeProvider(MethodParameter methodParameter) &#123; this.methodName = (methodParameter.getMethod() != null ? methodParameter.getMethod().getName() : null); this.parameterTypes = methodParameter.getExecutable().getParameterTypes(); this.declaringClass = methodParameter.getDeclaringClass(); this.parameterIndex = methodParameter.getParameterIndex(); this.methodParameter = methodParameter; &#125; @Override public Type getType() &#123; return this.methodParameter.getGenericParameterType(); &#125; @Override public Object getSource() &#123; return this.methodParameter; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); try &#123; if (this.methodName != null) &#123; this.methodParameter = new MethodParameter( this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex); &#125; else &#123; this.methodParameter = new MethodParameter( this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex); &#125; &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Could not find original class structure\", ex); &#125; &#125;&#125; 返回参数包装器方法返回类型代理类，注意这里的 provider 属性，它指向泛型实例对象。例如，获取 List 字段的原始类型，即调用代理类的 getRawType() 方法，即最终调用 MethodInvokeTypeProvider.getType()，此时 provider 执行 List 的包装类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SuppressWarnings(\"serial\")static class MethodInvokeTypeProvider implements TypeProvider &#123; private final TypeProvider provider; private final String methodName; //方法名 private final Class&lt;?&gt; declaringClass; // 所在类对应的Class对象 private final int index; private transient Method method; @Nullable private transient volatile Object result; public MethodInvokeTypeProvider(TypeProvider provider, Method method, int index) &#123; this.provider = provider; this.methodName = method.getName(); this.declaringClass = method.getDeclaringClass(); this.index = index; this.method = method; &#125; @Override @Nullable public Type getType() &#123; Object result = this.result; if (result == null) &#123; // 延迟调用目标方法 result = ReflectionUtils.invokeMethod(this.method, this.provider.getType()); // 缓存结果 this.result = result; &#125; return (result instanceof Type[] ? ((Type[]) result)[this.index] : (Type) result); &#125; @Override @Nullable public Object getSource() &#123; return null; &#125; private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException &#123; inputStream.defaultReadObject(); Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName); if (method == null) &#123; throw new IllegalStateException(\"Cannot find method on deserialization: \" + this.methodName); &#125; if (method.getReturnType() != Type.class &amp;&amp; method.getReturnType() != Type[].class) &#123; throw new IllegalStateException( \"Invalid return type on deserialized method - needs to be Type or Type[]: \" + method); &#125; this.method = method; &#125;&#125; 看下 SerializableTypeWrapper 类的类属性常量： 1234private static final Class&lt;?&gt;[] SUPPORTED_SERIALIZABLE_TYPES = &#123; GenericArrayType.class, ParameterizedType.class, TypeVariable.class, WildcardType.class&#125;;static final ConcurrentReferenceHashMap&lt;Type, Type&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(256); 从上面的代码可以看出： 定义了一个 Class 类型的数组，其元素分别为 GenericArrayType、ParameterizedType、TypeVariable、WildcardType，也就是为不同的泛型代理实现的接口。使用 cache 缓存已创建的代理 获取类型对外暴露的静态方法，该方法在类型的代理类中也会被调用，在代理类中调用是为了获取泛型的相关类型信息： 12345678910111213141516171819202122232425262728293031323334@Nullablestatic Type forTypeProvider(TypeProvider provider) &#123; Type providedType = provider.getType(); if (providedType == null || providedType instanceof Serializable) &#123; /** * 作为获取原始类型还是与泛型相关的信息(泛型原始类型、参数类型)入口 * 注意： * 1、原始类型，对应 Class，Class实现Serializable接口，直接返回 * 2、泛型类型如List&lt;String&gt;，返回其代理类 */ return providedType; &#125; if (GraalDetector.inImageCode() || !Serializable.class.isAssignableFrom(Class.class)) &#123; // 如果类型在当前运行时环境中通常不可序列化，那么跳过任何包装尝试 return providedType; &#125; // 获取给定提供者的可序列化类型代理 Type cached = cache.get(providedType); if (cached != null) &#123; return cached; &#125; for (Class&lt;?&gt; type : SUPPORTED_SERIALIZABLE_TYPES) &#123; if (type.isInstance(providedType)) &#123; ClassLoader classLoader = provider.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = new Class&lt;?&gt;[] &#123;type, SerializableTypeProxy.class, Serializable.class&#125;; InvocationHandler handler = new TypeProxyInvocationHandler(provider); cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler); cache.put(providedType, cached); return cached; &#125; &#125; throw new IllegalArgumentException(&quot;Unsupported Type class: &quot; + providedType.getClass().getName());&#125; 泛型代理类实现的接口定义获取类型包装器 TypeProvider 对象协议： 123456interface SerializableTypeProxy &#123; /** * 返回基础类型 */ TypeProvider getTypeProvider();&#125; 关联的调用处理程序，当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@SuppressWarnings(\"serial\")private static class TypeProxyInvocationHandler implements InvocationHandler, Serializable &#123; //类型包装类，例如List&lt;String&gt;的包装类 private final TypeProvider provider; public TypeProxyInvocationHandler(TypeProvider provider) &#123; this.provider = provider; &#125; @Override @Nullable public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; /** * 重写equals方法 */ if (method.getName().equals(\"equals\") &amp;&amp; args != null) &#123; Object other = args[0]; // Unwrap proxies for speed if (other instanceof Type) &#123; other = unwrap((Type) other); &#125; // 确定给定的对象是否相等 return ObjectUtils.nullSafeEquals(this.provider.getType(), other); &#125; /** * 重写hashCode方法 */ else if (method.getName().equals(\"hashCode\")) &#123; // 返回给定对象的哈希码 return ObjectUtils.nullSafeHashCode(this.provider.getType()); &#125; /** * 实现SerializableTypeProxy.getTypeProvider()方法 */ else if (method.getName().equals(\"getTypeProvider\")) &#123; // 执行getTypeProvider方法 return this.provider; &#125; /** * 实现Type子接口返回Type类型的方法： * GenericArrayType.getGenericComponentType() * ParameterizedType.getRawType()/getOwnerType() */ if (Type.class == method.getReturnType() &amp;&amp; args == null) &#123; return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1)); &#125; /** * 实现Type子接口返回Type[]类型的方法： * ParameterizedType.getActualTypeArguments() * TypeVariable.getBounds() * WildcardType.getUpperBounds()/getLowerBounds() */ else if (Type[].class == method.getReturnType() &amp;&amp; args == null) &#123; /** * 1: ParameterizedType.getActualTypeArguments() * 返回一个表示此类型的实际类型参数的Type数组,eg: Hash&lt;String, String&gt;返回[class java.lang.String, class java.lang.String] */ Type[] result = new Type[((Type[]) method.invoke(this.provider.getType())).length]; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i)); &#125; return result; &#125; try &#123; return method.invoke(this.provider.getType(), args); &#125; catch (InvocationTargetException ex) &#123; throw ex.getTargetException(); &#125; &#125;&#125; 接下来看下 SerializableTypeWrapper 对外暴露的其他方法： 123456789101112131415161718192021// 返回泛型类型的可序列化变体@Nullablepublic static Type forField(Field field) &#123; return forTypeProvider(new FieldTypeProvider(field));&#125;// 返回方法参数泛型类型的可序列化变体@Nullablepublic static Type forMethodParameter(MethodParameter methodParameter) &#123; return forTypeProvider(new MethodParameterTypeProvider(methodParameter));&#125;// 返回原始类型@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T extends Type&gt; T unwrap(T type) &#123; Type unwrapped = type; while (unwrapped instanceof SerializableTypeProxy) &#123; unwrapped = ((SerializableTypeProxy) type).getTypeProvider().getType(); &#125; return (unwrapped != null ? (T) unwrapped : type);&#125; 获取 Type 实例的调用过程： 总结：通过使用代理类的方式来获取具体的类型信息，特别是想要获取泛型相关的信息时，很直观。 接下来看下参数化类型 ParameterizedType 代理类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public final class $Proxy0 extends Proxy implements ParameterizedType, SerializableTypeProxy, Serializable &#123; private static Method m1; private static Method m6; private static Method m5; private static Method m2; private static Method m7; private static Method m3; private static Method m4; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; // public final boolean equals(Object var1) &#123;...&#125; // public final String toString() &#123;...&#125; // public final int hashCode() &#123;...&#125; public final String getTypeName() throws &#123; try &#123; return (String)super.h.invoke(this, m6, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type getOwnerType() throws &#123; try &#123; return (Type)super.h.invoke(this, m5, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final TypeProvider getTypeProvider() throws &#123; try &#123; return (TypeProvider)super.h.invoke(this, m7, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type[] getActualTypeArguments() throws &#123; try &#123; return (Type[])super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final Type getRawType() throws &#123; try &#123; return (Type)super.h.invoke(this, m4, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m6 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getTypeName\"); m5 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getOwnerType\"); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m7 = Class.forName(\"com.wiket.proxy.Client$SerializableTypeProxy\").getMethod(\"getTypeProvider\"); m3 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getActualTypeArguments\"); m4 = Class.forName(\"java.lang.reflect.ParameterizedType\").getMethod(\"getRawType\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;","tags":[{"name":"反射（reflect）","slug":"反射（reflect）","permalink":"http://www.throne4j.com/tags/反射（reflect）/"}]},{"title":"深入理解java序列化","date":"2019-06-03T13:38:43.000Z","path":"java/java/IO/深入理解java序列化/","text":"深入理解java序列化如果你只知道实现Serializable接口的对象，可以序列化为本地文件。那你最好再阅读该篇文章，文章对序列化进行了更深一步的讨论，用实际的例子代码讲述了序列化的高级认识，包括父类序列化的问题、静态变量问题、transient关键字的影响、序列化ID问题。在笔者实际开发过程中，就多次遇到序列化的问题，在该文章中也会与读者分享。 引言将Java对象序列化为二进制文件的Java序列化技术是Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与Java序列化相关，通过分析情境出现的原因，使读者轻松牢记Java 序列化中的一些高级认识。 序列化 ID 问题 情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C序列化为二进制数据再传给 B，B 反序列化得到 C。 问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable接口，但是反序列化时总是提示不成功。 解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。 12345678910111213141516171819202122232425package com.inout; import java.io.Serializable; public class A implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;package com.inout;import java.io.Serializable;public class A implements Serializable &#123; private static final long serialVersionUID = 2L; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 序列化ID在Eclipse下提供了两种生成策略，一个是固定的1L，一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。 特性使用案例 读者应该听过Façade模式，它是为应用程序提供统一的访问接口，案例程序中的Client客户端使用了该模式，案例程序结构图如图1所示。 Client端通过FaçadeObject才可以与业务逻辑对象进行交互。而客户端的FaçadeObject不能直接由Client生成，而是需要Server端生成，然后序列化后通过网络将二进制对象数据传给Client，Client负责反序列化得到Façade对象。该模式可以使得Client端程序的使用需要服务器端的许可,同时Client端和服务器端的FaçadeObject类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的FaçadeObject类的序列化ID再次生成，当Client端反序列化FaçadeObject就会失败，也就是强制Client端从服务器端获取最新程序。 静态变量序列化 情境：查看清单 2 的代码。 清单 2. 静态变量序列化问题代码 12345678910111213141516171819202122232425262728293031public class Test implements Serializable &#123; private static final long serialVersionUID = 1L; public static int staticVar = 5; public static void main(String[] args) &#123; try &#123; //初始时staticVar为5 ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); //序列化后修改为10 Test.staticVar = 10; ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); oin.close(); //再读取，通过t.staticVar打印新的值 System.out.println(t.staticVar); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 清单2中的main方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单2，这个System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？最后的输出是10，对于无法理解的读者认为，打印的 staticVar是从读取的对象里获得的，应该是保存时的状态才对。之所以打印10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。 父类的序列化与 Transient 关键字 情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。 解决：要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int 型的是 0，对象型的是 null。 特性使用案例 我们熟悉使用Transient关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。 上图中可以看出，attr1、attr2、attr3、attr5都不会被序列化，放在父类中的好处在于当有另外一个Child类时，attr1、attr2、attr3依然不会被序列化，不用重复抒写transient，代码简洁。 对敏感字段加密 情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 解决：在序列化过程中，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单3展示了这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private static final long serialVersionUID = 1L;private String password = &quot;pass&quot;;public String getPassword() &#123; return password;&#125;public void setPassword(String password) &#123; this.password = password;&#125;private void writeObject(ObjectOutputStream out) &#123; try &#123; PutField putFields = out.putFields(); System.out.println(&quot;原密码:&quot; + password); password = &quot;encryption&quot;;//模拟加密 putFields.put(&quot;password&quot;, password); System.out.println(&quot;加密后的密码&quot; + password); out.writeFields(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;private void readObject(ObjectInputStream in) &#123; try &#123; GetField readFields = in.readFields(); Object object = readFields.get(&quot;password&quot;, &quot;&quot;); System.out.println(&quot;要解密的字符串:&quot; + object.toString()); password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;public static void main(String[] args) &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); out.writeObject(new Test()); out.close(); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); Test t = (Test) oin.readObject(); System.out.println(&quot;解密后的字符串:&quot; + t.getPassword()); oin.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对password进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单3后控制台输出如图 3 所示: 特性使用案例 RMI 技术是完全基于 Java序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及RMI的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。 序列化存储规则1234567891011121314151617181920ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(&quot;result.obj&quot;)); Test test = new Test(); //试图将对象两次写入文件 out.writeObject(test); out.flush(); System.out.println(new File(&quot;result.obj&quot;).length()); out.writeObject(test); out.close(); System.out.println(new File(&quot;result.obj&quot;).length()); ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;)); //从文件依次读出两个文件 Test t1 = (Test) oin.readObject(); Test t2 = (Test) oin.readObject(); oin.close(); //判断两个引用是否指向同一个对象 System.out.println(t1 == t2); 清单 3中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入false 才对，但是最后结果输出如图 4 所示。 我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？ 解答：Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 特性案例分析123456789101112131415ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));Test test = new Test();test.i = 1;out.writeObject(test);out.flush();test.i = 2;out.writeObject(test);out.close();ObjectInputStream oin = new ObjectInputStream(new FileInputStream( &quot;result.obj&quot;));Test t1 = (Test) oin.readObject();Test t2 = (Test) oin.readObject();System.out.println(t1.i);System.out.println(t2.i); 清单 4 的目的是希望将 test 对象两次保存到result.obj文件中，写入一次以后修改对象属性值再次保存第二次，然后从result.obj中再依次读出两个对象，输出这两个对象的i属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。结果两个输出的都是 1，原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次writeObject 需要特别注意这个问题。 小结本文通过几个具体的情景，介绍了Java序列化的一些高级知识，虽说高级，并不是说读者们都不了解，希望用笔者介绍的情景让读者加深印象，能够更加合理的利用Java序列化技术，在未来开发之路上遇到序列化问题时，可以及时的解决。由于本人知识水平有限，文章中倘若有错误的地方，欢迎联系我批评指正。 转载自 读书使人进步","tags":[{"name":"序列化","slug":"序列化","permalink":"http://www.throne4j.com/tags/序列化/"}]},{"title":"深入理解java反射(一)","date":"2019-06-03T13:38:43.000Z","path":"java/java/反射/深入理解java反射(一)/","text":"深入理解java反射机制反射(Reflection)是 Java程序开发语言的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。 首先 我们看下java.lang.reflect包下面几个主要类的关系图 AnnotatedElement该接口的实现类代表程序中可以接受注解的程序元素，这个接口提供了获取注解相关的功能，该接口主要有一下几个实现类： Class 类定义 Constructor 构造器定义 Field 属性成员定义 Method 方法定义 Package 包定义 123456789public interface AnnotatedElement &#123; default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass); default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass); default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass); default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass); &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass); Annotation[] getAnnotations(); Annotation[] getDeclaredAnnotations();&#125; 实现用户自定义注解元注解GenericDeclaration提供了获取泛型相关的功能，只有方法和构造方法上支持泛型，所以只有Method，Constructor实现了该接口 Member作为一个对象内部方法和属性的声明的抽象，包含了名称，修饰符，所在的类,其中修饰符包含了 static final public private volatile 等，通过一个整数表示，每一个类型在二进制中占一个位. AccessibleObject这是一个类，提供了权限管理的功能，例如是否允许在反射中在外部调用一个private方法，获取一个private属性的值，所以method，constructor,field都继承该类，下面这段代码展示了如何在反射中访问一个私有的成员变量，class对象的构造方法不允许对外。 123456789101112131415161718private static void setAccessible0(AccessibleObject obj, boolean flag) throws SecurityException&#123; if (obj instanceof Constructor &amp;&amp; flag == true) &#123; Constructor&lt;?&gt; c = (Constructor&lt;?&gt;)obj; if (c.getDeclaringClass() == Class.class) &#123; throw new SecurityException(&quot;Cannot make a java.lang.Class&quot; + &quot; constructor accessible&quot;); &#125; &#125; obj.override = flag;&#125;boolean override;public boolean isAccessible() &#123; return override;&#125; 以下为 Field里面通过field.get(原始对象)获取属性值得实现,先通过override做校验，如果没有重载该权限，则需要校验访问权限 1234567891011public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; return getFieldAccessor(obj).get(obj);&#125;","tags":[{"name":"反射（reflect）","slug":"反射（reflect）","permalink":"http://www.throne4j.com/tags/反射（reflect）/"}]},{"title":"netty权威指南学习（二）","date":"2019-06-02T13:38:43.000Z","path":"netty/netty/netty权威指南学习（二）/","text":"第二章 NIO 入门在本章中，我们会分别对JDK的BIO、NIO、NIO2.0的使用进行详细说明。本章主要内容包括： 传统的同步阻塞式IO编程 基于NIO的非阻塞编程 基于NIO2.0的异步非阻塞(AIO)编程 为什么使用NIO编程 为什么使用Netty 2.1传统的BIO编程 网络编程的基本模型是client/server，也就是client进程与server进程通过3次握手之后建立连接，进而实现相互通信。 2.1.1 BIO通信模型 BIO服务端通信模型（见下图）通常由一个Acceptor 负责接收客户端的请求，它接收到客户端请求之后，为每一个请求新建一个新的线程进行链路处理，处理完成之后，将处理结果数据，以流的方式发送给客户端，然后销毁线程。这就是典型的一请求一应答的通信模式。 该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量上来之后，服务端的线程和客户访问量呈1:1的关系增加，当服务端线程过多消耗java虚拟机的资源后，导致性能急剧下降，甚至将导致服务端宕机、僵死而无法提供服务。 2.1.2 同步阻塞式IO创建的TimeServer源码分析1234567891011121314151617181920212223242526272829303132333435363738package com.shengke.netty.bio;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author qinshengke * @description TODO * @date 2016-06-02 21:40 */public class TimeServer &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; port = Integer.valueOf(args[0]); &#125; ServerSocket server = null; try &#123; server = new ServerSocket(port); System.out.println(&quot;The server is started in port:&quot; + port); // 获取server接待的socket Socket socket = null; while (true) &#123; socket = server.accept(); new Thread(new TimeServerHandler(socket)).start(); &#125; &#125; finally &#123; if (server != null) &#123; System.out.println(&quot;The time server close&quot;); server.close(); server = null; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.shengke.netty.bio;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Date;/** * @author qinshengke * @description TODO * @date 2016-06-02 22:03 */public class TimeServerHandler implements Runnable &#123; private Socket socket; public TimeServerHandler(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; BufferedReader in = null; PrintWriter out = null; // 获取socket 输入流 try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) break; System.out.println(&quot;The time server receive order :&quot; + body); currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body) ? new Date(System.currentTimeMillis()).toString() : &quot;BAD ORDER&quot;; out.println(currentTime); &#125; &#125; catch (IOException e) &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; if (out != null) &#123; out.close(); out = null; &#125; if (this.socket != null) &#123; try &#123; this.socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; this.socket = null; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.shengke.netty.bio;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * @author qinshengke * @description TODO * @date 2019-06-02 22:19 */public class TimeClient &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; port = Integer.valueOf(args[0]); &#125; Socket socket = null; BufferedReader in = null; PrintWriter out = null; try &#123; socket = new Socket(&quot;127.0.0.1&quot;, port); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream(), true); out.println(&quot;QUERY TIME ORDER&quot;); System.out.println(&quot;Send order 2 server succeed.&quot;); String resp = in.readLine(); System.out.println(&quot;Now is :&quot; + resp); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; if (out != null) &#123; out.close(); out = null; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; socket = null; &#125; &#125; &#125;&#125; BIO主要问题在于每当有一个新的客户端请求接入时，服务端都必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接。试想一下，当成千上万甚至百万的客户端请求接入时，对服务器来说无异于灾难来临。 2.2 伪异步IO编程为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题，后来有人对他的线程模型进行了优化–后端通过线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N。 2.2.1伪异步IO模型 采用线程池或者任务队列实现一种伪异步的IO通信框架，它的模型如下图所示: 当有新的客户请求接入的时候，将客户端的socket封装为一个task投递到后端的线程池中进行处理,java线程池维护一个任务队列和N个活跃的线程，因此它消耗资源是可控的，不会造成资源的耗尽。由于伪异步通信模型底层实现依然使用BIO，无法从根本上解决同步阻塞IO的问题。 下面我们结合代码，了解一下伪异步通信模型。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.shengke.netty.bio.fake;import com.shengke.netty.bio.TimeServerHandler;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author qinshengke * @description TODO * @date 2016-06-02 21:40 */public class TimeServer &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; port = Integer.valueOf(args[0]); &#125; ServerSocket server = null; try &#123; server = new ServerSocket(port); System.out.println(&quot;The server is started in port:&quot; + port); // 获取server接待的socket Socket socket = null; TimeServerHandlerExecutePool executePool = new TimeServerHandlerExecutePool(50, 10000); while (true) &#123; socket = server.accept(); executePool.execute(new TimeServerHandler(socket)); &#125; &#125; finally &#123; if (server != null) &#123; System.out.println(&quot;The time server close&quot;); server.close(); server = null; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425package com.shengke.netty.bio.fake;import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author qinshengke * @description TODO * @date 2016-06-02 22:03 */public class TimeServerHandlerExecutePool &#123; private ExecutorService executorService; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executorService = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(Runnable task) &#123; executorService.execute(task); &#125;&#125; 客户端代码没有什么变化，使用2.1.2章节中的 TimeClient。 2.2.3 伪异步通信模型的弊端首先我们看下InputStream的源码 1234567891011121314151617181920212223242526272829303132333435363738public abstract class InputStream implements Closeable &#123; /** * Reads some number of bytes from the input stream and stores them into * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is * returned as an integer. This method blocks until input data is * available, end of file is detected, or an exception is thrown. * * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at * least one byte. If no byte is available because the stream is at the * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;. * * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is, * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the * number of bytes actually read; these bytes will be stored in elements * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;, * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected. * * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt; * * @param b the buffer into which the data is read. * @return the total number of bytes read into the buffer, or * &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of * the stream has been reached. * @exception IOException If the first byte cannot be read for any reason * other than the end of the file, if the input stream has been closed, or * if some other I/O error occurs. * @exception NullPointerException if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. * @see java.io.InputStream#read(byte[], int, int) */ public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125;&#125; InputStream的API中有一段是这样描述This method blocks until input data is available, end of file is detected, or an exception is thrown当对socket的输入流进行读取的时候，它会一直阻塞下去，知道发生以下三件事： 有数据可读 可用数据已经读取完毕 发生空指针或者IO异常 这意味着当对方发送请求或者响应比较慢，或者网络延迟，读取输入流的一方的通信线程将会一直阻塞，在此期间，其他接入消息只能在任务队列中排队等待 下面我们对输出流OutputStream进行分析 123456789101112131415public abstract class OutputStream implements Closeable, Flushable &#123; /** * Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array * to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt; * is that it should have exactly the same effect as the call * &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;. * * @param b the data. * @exception IOException if an I/O error occurs. * @see java.io.OutputStream#write(byte[], int, int) */ public void write(byte b[]) throws IOException &#123; write(b, 0, b.length); &#125;&#125; 当调用OutputStream的write方法写入输出流的时候，它将被阻塞，知道所有要发送的数据发送完毕，或发生异常。当数据的接收方数据处理能力低下时，将不能及时的从TCP缓冲区读取数据，这将会导致数据发送方的TCP windows size不断变小，直到为0，双方处于Keep-Alive状态，数据发送方将不能再向TCP缓冲区写入数据，这是如果采用同步阻塞IO，write操作将会被无限期阻塞，知道TCP windows size大于 0 或者发生异常为止。 下面我们就简单分析下通信对方返回应答时间过长引起的级联故障：（1） 服务端处理缓慢，宴会应答消息消耗60s，平均只需要10ms（2）采用伪异步IO的线程正在读取故障服务节点的响应，由于读取输入流是阻塞的，它将会被同步阻塞60s（3）假设所有线程被阻塞在故障服务器，name后续所有的IO消息都将在任务队列中排队（4）由于线程池采用阻塞队列实现，当队列积压满之后，后续如队列操作将被阻塞，进而acceptor将会拒绝接收客户端请求，导致大量的连接超时。 2.3 NIO编程在开始NIO之前我们首先需要弄明白NIO的概念，什么才是NIO？由于NIO的目标是使Java支持非阻塞IO，所以很多人喜欢称NIO为非阻塞IO（Non-block IO） 与Socket类和ServerSocket类相对应，NIO也童工了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。这两种新增加的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单但是性能和可靠性不好，非阻塞模式正好相反。 2.3.1 NIO类库简介NIO弥补了原来同步阻塞IO的不足，它在标准Java代码中提供了高速的、面向块的IO。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO不用使用本机代码就可以利用低级优化，这是原来IO锁无法做到的。下面我们对NIO的一些概念和功能坐下简单介绍，以便大家能够快速地了解NIO类库和相关概念。 （1）缓冲区BufferBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，踢向了新库与原IO的一个重要区别。在面向流的IO中，可以将数据直接写入或者将数据直接读到Stream对象中。 在NIO库中所有数据都是用缓冲区吃力的。在读取数据时，他是直接读到缓冲区中的，在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。 缓冲区实质上一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置等信息。 最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区（每种Java基本类型都有对应的缓冲区 boolean除外） ByteBuffer 字节缓冲区 CharBuffer 字符缓冲区 ShortBuffer 短整型缓冲区 IntBuffer 整形缓冲区 LongBuffer 长整型缓冲区 FloatBuffer 浮点型缓冲区 DoubleBuffer 双精度浮点型缓冲区 （2）通道 ChannelChannel是一个通道，他就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动，而通道可以用于读、写或者两者同时进行。因为Channel是全双工的，所以他可以比流更好的映射底层操作系统的API。 Channel的类图继承关系如下图所示： 自顶向下看，前三层主要是channel接口，用于定义它的功能，后面是一些具体功能类（抽象类）。从类图可以看出，实际上Channel可以分为两大类：用于网络读写的SelectableChannel和用于文件操作的FileChannel 本文设计到的SocketChannel、ServerSocketChannel都是SelectableChannel的子类 1234567891011121314151617181920212223242526272829303132333435363738394041ReadableByteChannel (java.nio.channels) ReadableByteChannelImpl in Channels (java.nio.channels) ScatteringByteChannel (java.nio.channels) ByteChannel (java.nio.channels) SeekableByteChannel (java.nio.channels) SocketChannel (java.nio.channels) DatagramChannel (java.nio.channels) SourceChannel in Pipe (java.nio.channels)InterruptibleChannel (java.nio.channels) AbstractInterruptibleChannel (java.nio.channels.spi) ReadableByteChannelImpl in Channels (java.nio.channels) SelectableChannel (java.nio.channels) WritableByteChannelImpl in Channels (java.nio.channels) FileChannel (java.nio.channels)SelectableChannel (java.nio.channels) AbstractSelectableChannel (java.nio.channels.spi) SocketChannel (java.nio.channels) SinkChannel in Pipe (java.nio.channels) DatagramChannel (java.nio.channels) SourceChannel in Pipe (java.nio.channels) ServerSocketChannel (java.nio.channels)NetworkChannel (java.nio.channels) AsynchronousServerSocketChannel (java.nio.channels) SocketChannel (java.nio.channels) MulticastChannel (java.nio.channels) ServerSocketChannel (java.nio.channels) AsynchronousSocketChannel (java.nio.channels)WritableByteChannel (java.nio.channels) SinkChannel in Pipe (java.nio.channels) WritableByteChannelImpl in Channels (java.nio.channels) ByteChannel (java.nio.channels) GatheringByteChannel (java.nio.channels)AbstractInterruptibleChannel (java.nio.channels.spi) ReadableByteChannelImpl in Channels (java.nio.channels) SelectableChannel (java.nio.channels) WritableByteChannelImpl in Channels (java.nio.channels) FileChannel (java.nio.channels)AsynchronousChannel (java.nio.channels) AsynchronousServerSocketChannel (java.nio.channels) AsynchronousFileChannel (java.nio.channels) AsynchronousByteChannel (java.nio.channels) （3）多路复用器Selector我们探索下多路复用器Selector，它是Java NIO编程的基础，熟练地掌握Selector对NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单来说Selector会不断的轮询注册在其上的Channel，如果某个Chennel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的IO操作。一个多路复用器Selector可以轮询多个Channel，由于JKD使用epoll代替传统的select，所以它并没有最大句柄 1024/2048的限制。也就是一个Selector就可以负责成千上万的客户端。 2.3.2 NIO服务端通信序列图分析 下面，我们对NIO服务端的主要创建过程进行讲解和说明，作为NI的基础入门，这里忽略掉一些在生产环境部署所需的特性和功能。步骤一： 打开ServerSocketChannel，用于监听客户端的连接，它是所有客户端连接的父管道，伪代码如下: 1ServerSocketChannel acceptor = ServerSocketChannel.open(); 步骤二： 绑定监听端口，设置连接为非阻塞模式，伪代码如下： 12acceptor.socket().bind(new InetSocketAddress(InetAddress.getByName(&quot;IP&quot;), port));acceptor.configureBlooking(false); 步骤三： 创建Reactor线程，创建多路复用器并启动线程，伪代码： 12Selector selector = Selector.open();new Thread(new ReactorTask()).start(); 步骤四： 将ServerSocketChannel 注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件，伪代码： 1SelectionKey key = acceptor.register(selector, SelectionKey.OP_ACCEPT, ioHandler); 步骤五： 多路复用器在线程run方法的无限循环体内轮询准备就绪的Key，伪代码： 12345678int num = selector.select();Set selectedKeys = selector.selectedKeys();Iterator it = selectedKeys.iterator();while (it.hasNext()) &#123; SelectionKey key = (SelectionKey) it.next(); // do with IO event &#125; 步骤六： 多路复用器监听到有新的客接入，处理新的接入请求，完成TCP三次握手，建立物理链路，伪代码如下： 1SocketChannel channel = acceptor.accept(); 步骤七： 设置客户端链路为非阻塞模式，伪代码如下： 12channel.configureBlocking(false);channel.socket().setReuseAddress(true); 步骤八： 将新接入的客户端连接注册到Reactor线程的多路复用器上，监听读操作，读取客户端发送的网络消息，伪代码如下： 1SelectionKey key = socketChannel.register(selector, SelectionKey.OP_READ, ioOHandler); 步骤九： 异步读取客户端请求消息到缓冲区，伪代码： 1int radNumber = channel.read(receivedBuffer); 步骤十： 对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续的报文，将解码成功的消息封装成Task，投递到业务线程池中，进行业务逻辑的编排，伪代码： 12345678910111213141516171819Object message = null;while(buffer.hasRemain()) &#123; byteBuffer.mark(); message = decode(byteBuffer); if (message == null) &#123; byteBuffer.reset(); break; &#125; messageList.add(message);&#125;if (!byteBuffer.hasRemain()) byteBuffer.clear()else byteBuffer.compact();if (messageList !=null &amp;&amp; messageList.size()&gt;0) &#123; for(Object msg : messageList) &#123; handlerTask(msg); &#125;&#125; 步骤十一： 将POJO对象encode成Buffer，调用SocketChannel 的异步write接口，将消息异步发送给客户端，伪代码： 1socketChannel.write(buffer); 注意： 如果发送去TCP 缓冲区满，会导致写半包，此时，需要注册到监听写操作位，循环写，直到整包消息写入到TCP缓冲区，对于这些内容此处暂不赘述。 2.3.3 NIO创建的TimeServer源码分析我们将在TimeServer例程中给出完整的NIO创建的时间服务器源码","tags":[{"name":"netty","slug":"netty","permalink":"http://www.throne4j.com/tags/netty/"}]},{"title":"spring-core包阅读记录","date":"2019-06-02T13:38:43.000Z","path":"spring/spring/spring-core/(一) spring-core学习记录/","text":"spring-core 学习记录org.springframework.util类作用记录 AutoPopulatingList 对list的一个简单包装 DigestUtils 计算摘要的各种方法工具 Base64Utils 一个用于Base64编码和解码的简单实用程序类 ErrorHandler(函数接口) 处理异常的策略接口 InstanceFilter 一个简单的实例过滤器，它根据包含和排除元素的集合检查给定的实例是否匹配。 ClassUtils ReflectionUtils CollectionUtils ConcurrentReferenceHashMap CustomizableThreadCreator 用于创建新的{@link Thread}实例的简单可自定义助手类。提供各种bean属性:线程名称前缀、线程优先级等。 PropertiesPersister 用于持久化{@code java.util的策略接口。属性}，允许可插入的解析策略。 实现有 DefaultPropertiesPersister FastByteArrayOutputStream FileCopyUtils 用于文件和流复制的简单实用程序方法 FileSystemUtils 处理文件系统的实用方法。 InstanceFilter 一个简单的实例过滤器，它根据包含和排除元素的集合检查给定的实例是否匹配。ExceptionTypeFilter LinkedCaseInsensitiveMap LinkedMultiValueMap PatternMatchUtils 用于简单模式匹配的实用方法，特别是对于Spring的典型“xxx”、“xxx”和“xxx”模式样式。 PropertyPlaceholderHelper 用于处理具有占位符值的字符串的实用程序类 SystemPropertyUtils 用于解析文本中的占位符的Helper类。通常应用于文件路径。 MethodInvoker Helper类，它允许指定以声明方式调用的方法，无论是静态的还是非静态的。 NumberUtils ObjectUtils ResourceUtils 可处理jar包内的路径资源 SerializationUtils SocketUtils 处理网络套接字的简单实用方法，例如：用于查找{@code localhost}上的可用端口。 StreamUtils 处理流的实用程序 StringUtils 字符串的实用方法 StringValueResolver(函数接口) 用于解析字符串值的简单策略接口。 TypeUtils 用于处理Java 5泛型类型参数的实用程序。 org.springframework.util.concurrent 并发包类说明 ListenableFuture (接口) 扩展{@link Future}，使其能够接受完成回调。如果在添加回调时未来已完成，则立即触发回调。 CompletableToListenableFutureAdapter 将{@link CompletableFuture}或{@link CompletionStage}调整为Spring {@link ListenableFuture}。 DelegatingCompletableFuture 扩展的{@link CompletableFuture}，允许取消委托 连同{@link CompletableFuture}本身。 FailureCallback (函数接口) Failure callback for a {@link ListenableFuture}. SuccessCallback(函数接口) Success callback for a {@link ListenableFuture}. FutureAdapter 一个抽象类，它将在S上参数化的{@link Future}调整为在T上参数化的{@code Future}。所有方法都委托给适配器，其中{@link #get()}和{@link #get(long, TimeUnit)}对适配器的结果调用{@link #adapt(Object)}。 ListenableFutureAdapter extends FutureAdapter implements ListenableFuture ListenableFutureCallback (接口) 结果(成功或失败)的回调机制，来自{@link ListenableFuture}。 extends SuccessCallback， FailureCallback ListenableFutureCallbackRegistry 用于维护成功和失败回调并帮助通知它们的{@link ListenableFuture}实现的Helper类。 ListenableFutureTask 实现{@link ListenableFuture}的{@link FutureTask}的扩展。 ListenableFutureTask extends FutureTask implements ListenableFuture 其实现类有 SettableTask org.springframework.core.task 任务执行 TaskExecutor 简单的任务执行器接口，抽象了{@link Runnable}的执行。 继承自java.util.concurrent.Executor执行已提交的{@link Runnable}任务的对象。 在java中Executor的实现类 均实现了{@link ExecutorService}这个更加广泛的接口，具体实现类可由Executors类生产。 AsyncTaskExecutor 继承自TaskExecutor，实现了异步扩展功能。 SimpleAsyncTaskExecutor 为每个任务触发一个新线程的实现，异步地执行。 SyncTaskExecutor TaskDecorator(函数接口) 一个回调接口，用于将装饰器应用于将要执行的任何{@link Runnable}。 ExecutorServiceAdapter 适配器，它接受一个Spring {@link org.springframework.core.TaskExecutor}, 并公开一个完整的{@code java.util.concurrent。ExecutorService} TaskExecutorAdapter 适配器，它接受JDK {@code java.util.concurrent。并公开一个Spring {@link org.springframework.core.task。TaskExecutor}。 org.springframework.core 包类解析 AliasRegistry 用于管理别名的通用接口。作为超级接口 SimpleAliasRegistry BeanDefinitionRegistry","tags":[{"name":"spring-core","slug":"spring-core","permalink":"http://www.throne4j.com/tags/spring-core/"}]},{"title":"netty权威指南学习（一）","date":"2019-06-01T13:38:43.000Z","path":"netty/netty/netty权威指南学习（一）/","text":"首先感谢作者李林锋给我们提供出这本关于异步非阻塞通信领域的经典之作，本书基于Netty 5.0编写。Netty如今已经在如下几个领域得到了大规模的商业应用: 互联网领域 电信领域 大数据领域 银行、证券等金融领域 游戏行业 电力等企业市场 看到Netty如火如荼的发展，有心能够深入学习，希望通过此书，站在前辈的肩膀上走出属于自己的路，猿类崛起！ netty 基础篇**走进Java NIO**第一章.java的I/O演进之路在开始学习Netty之前，我们首先对UNIX系统常用的I/O模型进行介绍，然后对Java的I/O历史演进进行简单的说明。 1.1 I/O基础入门传统的BIO 在高性能领域一直被业界所诟病，主要有如下问题： 没有数据缓冲区，I/O性能存在问题 没有C 或 C++中的Channel概念，只有输入和输出流 同步阻塞IO通常会导致通信或线程被长时间阻塞 支持的字符集有限，硬件可移植性不好 1.1.1 Linux 网络I/O模型简介（1） 阻塞I/O 模型 最常用的I/O模型就是阻塞I/O模型，缺省情况下，所有的文件操作都是I/O阻塞的。在系统的进程空间中调用recvfrom，当访问文件系统的时候，其系统调用直到文件到达且被复制到系统的缓冲区或者发生错误异常的时候才会返回，在此期间，系统会一直等待，进程从开始到结束一直处于阻塞状态，因此被称为阻塞I/O模型。 （2） 非阻塞I/O 模型 recvfrom从应用层到内核，如果该缓冲区中没有数据的话，则直接返回一个EWOULDBLOCK错误，一般对非阻塞I/O模型进行轮询检查这个状态，看内核是否有数据到来. （3） I/O复用模型 Linux 提供select/poll，进程通过一个或多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮助我们侦测多个fd是否处于就绪状态。select/poll 系统是瞬息扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些限制。Linux系统还提供了一个epoll系统，它采用事件驱动方式来代替顺序扫描，因此性能更高，当fd就绪的时候，立即回调rollback函数 （4） 信号I/O复用模型 首先开启套接口信号驱动I/O功能,并通过系统调用sigaction执行一个信号处理函数(此操作是非阻塞的),当数据准备就绪的时候,就为该进程生成一个sigio信号，通过信号回调通知应用程序调用recvform来读取数据，并通知主循环函数处理数据。 （5） 异步IO 告知内核启动某个操作，并让内核在整个操作完成是通知我们。这种模型和信号I/O模型的区别是：信号I/O模型是告知我们和是可以开始I/O操作，异步I/O告知我们I/O操作何时已经完成。 1.1.2 I/O 多路复用技术在IO编程过程中，当需要同事处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，IO多路复用的最大优势是系统开销小，IO多路复用技术的主要应用场景如下： 服务器需要同时处理多个处于监听状态或多个连接状态的套接字； 服务器需要同时处理多种网络协议的套接字。 目前支持IO多路复用的系统调用有select、pselect、poll、epoll，在linux网络编程过程中，很长时间都在使用select做轮询和网络事件通知，然而select的固有缺陷迫使Linux寻找替代方案，最终Linux选择了epoll，epoll与select的原理类似，单做了很大改进，总结如下： （1） 支持一个进程打开的socket描述符（FD）不受限制（金受限于操作系统的最大文件句柄数） select的最大缺陷就是单个进程打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。我们可以通过修改这个宏修改并重新编译内核，但这样也给操作系统造成性能的损耗，另外进程间的数据交换非常麻烦，由于java没有共享内存，需要通过Socket通信或者其他方式进行数据同步，这样带来了额外的性能损耗，增加了程序的复杂度，也不是一种很好的解决方案。epoll并没有这个最大文件句柄数的限制，epoll的处理能力和内存的关系比较大，内存越大，epoll的处理能力越强。（2） IO效率不会随着FD数目的增加而线性下降 epoll只会对活跃的socket进行操作，这是因为在内核实现中epoll是根据每个fd上面的额callback函数实现的。（3） 使用mmap加速内核与用户控件的消息传递 无论是select、poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存实现的（4） epoll的API更加简单 1.2 Java的IO演进在JDK 1.4 推出Java NIO 之前，java的所有socket通信都采用了同步阻塞模式（BIO），这种已请求一应答的通信模型简化了上层的应用开发，但是在性能可可靠性方面却存在这巨大的瓶颈。Java 1.4 NIO以 JSR-51 的身份正式随JDK 发布，它新增了java.nio包，同乐很多进行异步IO开发的API和类库，主要的类和接口如下： 进行异步IO操作的缓冲区 ByteBuffer 等 进行异步IO操作的管道Pipe 进行各种IO操作（异步或同步）的Channel，包括ServerSocketChannel和SocketChannel 多种字符集的编码和解码能力 实现非阻塞IO操作的多路复用器Selector 基于流行的Perl实现的额正则表达式类库 文件通道FileChannel 新的NIO类库促进了Java 异步非阻塞编程的发展和应用，但是他还有不完善的地方，特别是对文件系统的处理能力不足，主要问题如下 没有同意的文件属性（例如读写权限） API能力较弱，例如目录的级联创建和递归遍历，往往需要自己实现 所有的文件操作都是同步阻塞调用，不支持异步文件读写操作 底层存储系统的一些高级API无法使用 2017年7月28日JDK1.7发布，将原来的NIO类库进行了升级，被称为NIO2.0，NIO2.0由JSR-203演进而来，它主要提供了如下三个方面的改进： 提供能够批量获取文件属性的API，这些API具有平台无关性，不与特性的文件系统耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现 提供AIO功能，支持基于文件的异步IO操作和针对网络套接字的异步操作 完成JSR-51 定义的通道功能，包括对配置和多波数据报的支持 1.3 总结通过此章了解了UNIX 的网络编程的5种IO模型，学习IO多路复用的基础知识。对java IO 的演进有了一些直观认识，下章对阻塞IO和非阻塞IO进行详细讲解。","tags":[{"name":"netty","slug":"netty","permalink":"http://www.throne4j.com/tags/netty/"}]},{"title":"桥接模式","date":"2018-07-01T13:38:43.000Z","path":"设计模式/设计模式/结构型模型/桥接模式/","text":"桥接模式桥接模式的定义桥接模式（Bridge Pattern），将抽象部分与它的实现部分分离，使它们都可以独立地变化。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 模式结构桥接模式包含如下角色： Abstraction：抽象类 （Shape）RefinedAbstraction：扩充抽象类(Circle)Implementor：实现类接口 (DrawAPI)ConcreteImplementor：具体实现类 (RedCircle、GreenCircle) uml图解 桥接模式使用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 代码实现123public interface DrawAPI &#123; void drawCircle(int radius, int x, int y);&#125; 1234567891011121314public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(\"Drawing Circle[ color: red, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); &#125;&#125;public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(\"Drawing Circle[ color: green, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); &#125;&#125; 使用 DrawAPI 接口创建抽象类 Shape。 1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125; 1234567891011121314public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125; 123456789public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125;","tags":[{"name":"结构型模式","slug":"结构型模式","permalink":"http://www.throne4j.com/tags/结构型模式/"}]},{"title":"collection集合记录","date":"2016-07-03T06:20:14.000Z","path":"java/java/集合/Collection集合大礼包/","text":"java.utils.Collection 集合大礼包 集合表示了一组对象，而Collection是集合层次结构的根接口。一些集合可以存在重复的元素，而有些则不允许，一些是有序的，而又有一些是无序的。jdk并没有提供此接口的直接实现，而是通过具体的子接口，例如List、Set接口来定义集合的实现。此接口通常使用在比较通用的场合来传递集合并操作它们。 首先我们了解下Collection接口的实现，如下图所示： 从图中我们可以看出Collection接口有四个具体的接口实现了不同的集合结构和功能。下面我们开始了解每一种集合类型： 1. List集合List继承了Collection接口，集合有序、允许重复值、可插入null。我们知道在遍历List集合的时候不允许对集合进行修改操作，否则会抛出ConcurrentModifiedException异常信息，为了解决这个问题，可以使用List提供给我们的特殊迭代器ListIterator，此迭代器除了提供集合操作之外还允许双向访问。 123456789101112131415161718192021222324public class ListDemo &#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;李磊&quot;); list.add(&quot;韩梅梅&quot;); list.add(&quot;Lucy&quot;); System.out.println(list); ListIterator&lt;String&gt; iterator = list.listIterator(); while(iterator.hasNext())&#123; String element = iterator.next(); if(element.equals(&quot;李磊&quot;))&#123; iterator.set(&quot;韩梅梅她老公&quot;); &#125; if (element.equals(&quot;Lucy&quot;)) &#123; iterator.remove(); &#125; &#125; System.out.println(list); &#125;&#125;-----------------------------[李磊, 韩梅梅, Lucy][韩梅梅她老公, 韩梅梅] ArrayList基于动态数组实现，可以动态的扩容，用户拥有对元素精确插入的控制权。当集合中对插入元素数据的速度要求不高，但是要求快速访问元素数据，则使用此集合 LinkedList基于链表实现，是一个双向循环列表，可以被当做堆栈使用。当集合中对访问元素数据速度不做要求不高，但是对插入和删除元素数据速度要求高的情况，则使用LinkedList Vector同样基于数组实现，并且满足多线程环境下的安全操作。Collections.synchronizedList(list)或者并发包下面的CopyOnWriteArrayList来实现线程安全的集合。 Stack基于数组实现，是栈，它继承与Vector，特性是FILO（先进后出）。当集合中有需求是希望后保存的数据先读取出来，则使用Stack ArrayListArrayList由于是由数组实现，因此它有个默认初始容量：10，随着ArrayList中元素的添加，它的容量会不断的自动增长。查看ArrayList源码，咱发现用于存储元素的数组elementData被transient关键字修饰，我们知道被transient修饰的对象不被应用在序列化，那么ArrayList是将元素序列化的呢？源码中有如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243transient Object[] elementData;//将ArrayList实例的状态保存到流中(即序列化它)。private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;// 从流(即反序列化)中重新构造ArrayList实例。private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 为什么要这样实现呢？原因在于elementData作为存储元素的缓存数组，它会预留一些容量用于添加元素，这些预留的空间并不存储任何元素，为了保证序列化时拿到的是用户的实际大小的数组数据。java序列化查看此篇章深入理解java序列化 2. Set集合注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 3. Queue队列4. AbstractCollection 抽象Collection实现Collection接口的抽象实现","tags":[{"name":"集合","slug":"集合","permalink":"http://www.throne4j.com/tags/集合/"}]}]