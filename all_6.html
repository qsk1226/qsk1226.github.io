<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15896298176989.html">
                
                  <h1>享元模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">享元模式的定义</h2>

<p>享元模式是一种<strong>结构性设计模式</strong>，它是考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>

<p>采用一个共享类来避免大量拥有相同内容的“小类”的开销。这种开销中最常见、直观的影响就是增加了内存的损耗。</p>

<p>享元模式以共享的方式高效地支持大量的细粒度对象，减少其带来的开销，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。其中：</p>

<ul>
<li>内部状态 是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li>
<li>外部状态 是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 </li>
</ul>

<h2 id="toc_1">享元模式结构</h2>

<p>单纯享元模式的结构。</p>

<ul>
<li>抽象享元角色: 为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式 通过此方法传入。在 Java 中可以由抽象类、接口来担当。</li>
<li>具体享元角色: 实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供 存储空间。</li>
<li>享元工厂角色: 负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关 键!</li>
<li>客户端角色: 维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。 来用类图来形象地表示出它们的关系吧。</li>
</ul>

<p><figure><img src="media/15896298176989/15917826923765.jpg" alt=""/></figure></p>

<h3 id="toc_2">优点</h3>

<p>1）它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；<br/>
2）享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p>

<h3 id="toc_3">缺点</h3>

<p>1）享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化；<br/>
2）为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</p>

<h2 id="toc_4">代码示例</h2>

<pre><code class="language-java">/**
 * 抽象享元角色类
 *
 **/
public interface Flyweight {
    /**
     * 一个示意性方法，参数state是外蕴状态
     */
    public void operation(String state);
}
</code></pre>

<pre><code class="language-java">/**
 * 具体享元角色类
 * &lt;p&gt;
 * 具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象
 * 被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，
 * 在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。
 *
 **/
public class ConcreteFlyweight implements Flyweight {
    private Character intrinsicState = null;

    /**
     * 构造函数，内蕴状态作为参数传入
     *
     * @param state
     */
    public ConcreteFlyweight(Character state) {
        this.intrinsicState = state;
    }


    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，但是并不改变对象的内蕴状态。
     *
     * @param state 外蕴状态
     */
    @Override
    public void operation(String state) {
        // TODO Auto-generated method stub
        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);
        System.out.println(&quot;Extrinsic State = &quot; + state);
    }

}
</code></pre>

<pre><code class="language-java">/**
 * 享元工厂角色类
 * &lt;p&gt;
 * 必须指出的是，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。
 * 一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。
 * 当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。
 **/
public class FlyweightFactory {
    private Map&lt;Character, Flyweight&gt; files = new HashMap&lt;&gt;();

    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;First Call&quot;);

        fly = factory.factory(&#39;b&#39;);
        fly.operation(&quot;Second Call&quot;);

        fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;Third Call&quot;);
    }

}
</code></pre>

<pre><code class="language-java">/**
 * 复合享元角色类
 * &lt;p&gt;
 * 复合享元对象是由单纯享元对象通过复合而成的，因此它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，
 * 这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。
 * 复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。
 * 一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；
 * 而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。
 **/
public class ConcreteCompositeFlyweight implements Flyweight {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 增加一个新的单纯享元对象到聚集中
     */
    public void add(Character key, Flyweight fly) {
        flyweightMap.put(key, fly);
    }

    /**
     * 外蕴状态作为参数传入到方法中
     */
    @Override
    public void operation(String state) {
        Flyweight fly = null;
        for (Object o : flyweightMap.keySet()) {
            fly = flyweightMap.get(o);
            fly.operation(state);
        }

    }

}
</code></pre>

<pre><code class="language-java">/**
 * 复合享元工厂角色类
 * &lt;p&gt;
 * 享元工厂角色提供两种不同的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。
 **/
public class CompositeFlyweightFactory {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 复合享元工厂方法
     */
    public Flyweight factory(List&lt;Character&gt; compositeState) {
        ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight();

        for (Character state : compositeState) {
            compositeFly.add(state, this.factory(state));
        }

        return compositeFly;
    }

    /**
     * 单纯享元工厂方法
     */
    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = flyweightMap.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            flyweightMap.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        List&lt;Character&gt; compositeState = new ArrayList&lt;&gt;();
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);
        compositeState.add(&#39;c&#39;);
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);

        CompositeFlyweightFactory flyFactory = new CompositeFlyweightFactory();
        Flyweight compositeFly1 = flyFactory.factory(compositeState);
        Flyweight compositeFly2 = flyFactory.factory(compositeState);
        compositeFly1.operation(&quot;Composite Call&quot;);

        System.out.println(&quot;---------------------------------&quot;);
        System.out.println(&quot;复合享元模式是否可以共享对象：&quot; + (compositeFly1 == compositeFly2));

        Character state = &#39;a&#39;;
        Flyweight fly1 = flyFactory.factory(state);
        Flyweight fly2 = flyFactory.factory(state);
        System.out.println(&quot;单纯享元模式是否可以共享对象：&quot; + (fly1 == fly2));
    }

}
</code></pre>

<h2 id="toc_5">适用场景</h2>

<p>在以下情况下可以使用享元模式：</p>

<ul>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中(细粒度对象)；</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li>
</ul>

<p><strong>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15896087713606.html">
                
                  <h1>模板方法模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">模板方法模式的定义</a>
</li>
<li>
<a href="#toc_1">模板方法模式结构</a>
<ul>
<li>
<a href="#toc_2">模板方法模式 UML</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">使用场景</a>
</li>
</ul>


<h2 id="toc_0">模板方法模式的定义</h2>

<p>模板方法(Template Method)模式: 定义一个操作中的算法的骨架，而将一些步骤延<br/>
迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<p>模板方法模式也是为了解决某些变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。</p>

<h2 id="toc_1">模板方法模式结构</h2>

<ul>
<li><p>抽象类</p>
<ul>
<li>定义了一到多个的抽象方法，以供具体的子类来实现它们</li>
<li>需要实现一个模板方法，来定义一个算法的骨架。该模板方法不仅调用前面的抽象方法，也可以调用其他的操作，只要能完成自身的使命。</li>
</ul></li>
<li><p>具体类<br/>
实现父类中的抽象方法以完成算法中与特定子类相关的步骤。</p></li>
</ul>

<h3 id="toc_2">模板方法模式 UML</h3>

<p><figure><img src="media/15896087713606/15917532214702.jpg" alt=""/></figure></p>

<h2 id="toc_3">使用场景</h2>

<p>模板方法适用于以下情况:</p>

<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>控制子类扩展。<br/>
模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做:一是在 API 中不体现出你的模板方法;或者将你的模板方法置为 final 就可以了。 可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。这样你在实现子类的时候，根本不需要对业务流程有太多的了解。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15896081275436.html">
                
                  <h1>适配器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">适配器定义</a>
</li>
<li>
<a href="#toc_1">适配器模式结构</a>
<ul>
<li>
<a href="#toc_2">对象适配器模式</a>
</li>
<li>
<a href="#toc_3">类适配器模式</a>
</li>
<li>
<a href="#toc_4">优点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">代码示例</a>
</li>
<li>
<a href="#toc_7">使用场景</a>
</li>
</ul>


<h2 id="toc_0">适配器定义</h2>

<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>

<h2 id="toc_1">适配器模式结构</h2>

<p>适配器模式角色：</p>

<ul>
<li>Target： 目标角色，客户端期待得到的接口</li>
<li>Adaptee: 适配者角色，被适配的接口</li>
<li>Adapter：适配器角色，将原接口转换成目标接口</li>
</ul>

<h3 id="toc_2">对象适配器模式</h3>

<p><figure><img src="media/15896081275436/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="对象适配器模式"/><figcaption>对象适配器模式</figcaption></figure></p>

<h3 id="toc_3">类适配器模式</h3>

<p><figure><img src="media/15896081275436/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="类适配器模式"/><figcaption>类适配器模式</figcaption></figure></p>

<h3 id="toc_4">优点</h3>

<ul>
<li><p>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</p></li>
<li><p>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</p></li>
<li><p>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p></li>
<li><p>类适配器模式还具有如下优点：<br/>
由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p></li>
<li><p>对象适配器模式还具有如下优点：<br/>
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 </p>
<h3 id="toc_5">缺点</h3></li>
<li><p>类适配器模式的缺点如下：<br/>
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p></li>
<li><p>对象适配器模式的缺点如下：<br/>
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 </p></li>
</ul>

<h2 id="toc_6">代码示例</h2>

<pre><code class="language-java">
/**
 * 被适配接口--安卓传统方式充电接口
 */
public interface TraditionalCharge {

    /**
     * 传统充电
     */
    void chargeWithTraditional();
}

/**
 * 安卓传统方式充电实现--adaptee
 *
 **/
public class TraditionalChargeImpl implements TraditionalCharge {
    @Override
    public void chargeWithTraditional() {
        System.out.println(&quot;使用传统的安卓充电头进行充电&quot;);
    }
}


/**
 * typeC充电接口 target
 **/
public interface TypeCCharge {
    /**
     * type-C充电
     */
    void chargeWithTypeC();
}

</code></pre>

<p>对象适配器</p>

<pre><code class="language-java">/**
 * 对象适配器  --- adapter
 **/
public class ChargeAdapter implements TypeCCharge {
    /**
     * 被适配对象
     */
    private TraditionalCharge traditionalCharge;

    public ChargeAdapter(TraditionalCharge traditionalCharge) {
        this.traditionalCharge = traditionalCharge;
    }

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        traditionalCharge.chargeWithTraditional();
    }

    public static void main(String[] args) {
        ChargeAdapter chargeAdapter = new ChargeAdapter(new TraditionalChargeImpl());
        chargeAdapter.chargeWithTypeC();
    }
}
</code></pre>

<p>类适配器</p>

<pre><code class="language-java">/**
 * 类适配器  --- adapter
 **/
public class AndroidChargeAdapter extends TraditionalChargeImpl implements TypeCCharge{

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        chargeWithTraditional();
    }

    public static void main(String[] args) {
        AndroidChargeAdapter androidChargeAdapter = new AndroidChargeAdapter();
        androidChargeAdapter.chargeWithTypeC();
    }
}

</code></pre>

<h2 id="toc_7">使用场景</h2>

<ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15896032913368.html">
                
                  <h1>单例模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>

<p>单例模式的要点有三个：</p>

<ul>
<li>是某个类只能有一个实例；</li>
<li>是它必须自行创建这个实例；</li>
<li>是它必须自行向整个系统提供这个实例。</li>
</ul>

<p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>

<h2 id="toc_0">单例模式结构</h2>

<p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<p>单例模式包含的角色只有一个，就是单例类——Singleton。</p>

<p>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。</p>

<p>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p>

<p>在单例模式的实现过程中，需要注意如下三点：</p>

<ul>
<li>单例类的构造函数为私有；</li>
<li>提供一个自身的静态私有成员变量；</li>
<li>提供一个公有的静态工厂方法。</li>
</ul>

<p><figure><img src="media/15896032913368/15896221967721.jpg" alt=""/></figure></p>

<h2 id="toc_1">常见的单例实现</h2>

<h3 id="toc_2">饿汉模式</h3>

<pre><code class="language-java">public class Singleton {  
     private static Singleton instance = new Singleton();  
     private Singleton (){
     }
     public static Singleton getInstance() {  
     return instance;  
     }  
 }  
</code></pre>

<h3 id="toc_3">懒汉模式</h3>

<pre><code class="language-java">public class Singleton {

    private Singleton(){} // 私有构造

    private static volatile Singleton instance = null; // 私有单例对象

    // 静态工厂
    public static Singleton getInstance(){
        if (instance == null) { // 双重检测机制
            synchronized (Singleton.class) { // 同步锁
                if (instance == null) { // 双重检测机制
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}

</code></pre>

<h3 id="toc_4">静态内部类实现方式</h3>

<pre><code class="language-java">/**
 * 从外部无法访问静态内部类 LazyHolder，只有当调用 Singleton.getInstance() 方法的时候，才能得到单例对象 INSTANCE。
* INSTANCE 对象初始化的时机并不是在单例类 Singleton 被加载的时候，而是在调用 getInstance 方法，使得静态内部类 LazyHolder 被加载的时候。
* 这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。
 */
public class Singleton {

    private static class LazyHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton (){}

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }

}

</code></pre>

<h3 id="toc_5">使用容器实现</h3>

<pre><code class="language-java">public class SingletonManager { 
　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();
　　private Singleton() { 
　　}
　　public static void registerService(String key, Object instance) {
　　　　if (!objMap.containsKey(key) ) {
　　　　　　objMap.put(key, instance) ;
　　　　}
　　}
　　public static Object getService(String key) {
　　　　return objMap.get(key) ;
　　}
}
</code></pre>

<h3 id="toc_6">枚举实现</h3>

<pre><code class="language-java">public enum Singleton {
    INSTANCE;
    
    public void doSomeThing() {
        //做点什么
    }  
}
</code></pre>

<h2 id="toc_7">使用场景</h2>

<p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>

<p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>

<p>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15894404386842.html">
                
                  <h1>建造者模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式，建造者模式又可以称为生成器模式。</p>

<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>

<h2 id="toc_0">建造者模式结构</h2>

<p>建造者模式包含如下角色：</p>

<ul>
<li>Builder 抽象建造者</li>
<li>BuilderImpl 具体建造者</li>
<li>Director 指挥者</li>
<li>Product 产品</li>
</ul>

<p><figure><img src="media/15894404386842/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="建造者模式"/><figcaption>建造者模式</figcaption></figure></p>

<p>抽象建造者类中定义了产品的创建方法和返回方法;</p>

<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>

<p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p>

<h2 id="toc_1">优点</h2>

<ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>

<h2 id="toc_2">代码示例（简化版的建造者模式）</h2>

<pre><code class="language-java">public class Race {
    private String name;
    private String feature;

    public Race(String name, String feature) {
        this.name = name;
        this.feature = feature;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getFeature() {
        return feature;
    }

    public void setFeature(String feature) {
        this.feature = feature;
    }

    public static RaceBuilder builder() {
        return new RaceBuilder();
    }

    public static class RaceBuilder {
        private String name;
        private String feature;

        public RaceBuilder name(String name) {
            this.name = name;
            return this;
        }

        public RaceBuilder feature(String feature) {
            this.feature = feature;
            return this;
        }

        public Race build() {
            return new Race(this.name, this.feature);
        }

    }
}
</code></pre>

<h2 id="toc_3">使用场景</h2>

<p>在以下情况下可以使用建造者模式：</p>

<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>

<h3 id="toc_4">注意</h3>

<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br/>
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_5.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_7.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
