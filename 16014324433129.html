<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    进程与线程的区别 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            进程与线程的区别   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/09/30</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>线程具有许多传统进程锁具有的特征，故又称为轻型进程，而把传统的进程成为重型进程，它相当于只有一个线程的任务。在引入线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>

<ul>
<li>根本区别：进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位</li>
<li>资源开销： 每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换开销较小</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多线程共同完成的；线程是进程的一部分，所以线程也被成为轻量进程</li>
<li>内存分配：同一个进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li>
<li>影响关系： 一个进程崩溃后，在保护模式下不会对其它进程产生影响，但是一个线程崩溃整个进程都会crash，所以多进程要比多线程健壮</li>
<li>执行过程：每个独立的进程有程序运行入口、顺序执行序列和程序出口，但是线程不能独立运行，必须依存在应用程序中，有应用程序提供多个线程执行控制，两者均可并发执行。</li>
</ul>

<h2 id="toc_0">什么是线程组，为什么在 Java 中不推荐使用?</h2>

<p>线程组 ThreadGroup 对象中比较有用的方法是 stop、resume、suspend 等 方法，由于这几个方法会导致线程的安全问题(主要是死锁问题)，已经被官方 废弃掉了，所以线程组本身的应用价值就大打折扣了。</p>

<p>线程组 ThreadGroup 不是线程安全的，这在使用过程中获取的信息并不全 是及时有效的，这就降低了它的统计使用价值。</p>

<h2 id="toc_1">什么是 Executors 框架?为什么使用 Executor 框架</h2>

<p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务 的框架。</p>

<p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗 时、耗资源的。</p>

<p>调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间 的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替 也会消耗很多系统资源。</p>

<p>接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、 定时定期执行、线程中断等都不便实现。</p>

<h2 id="toc_2">多线程同步和互斥有几种实现方法，都是什么</h2>

<p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个 线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>

<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当 有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用， 其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以 看成是一种特殊的线程同步。</p>

<p>线程间的同步方法大体可分为两类:用户模式和内核模式。顾名思义，内核 模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用 户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p>

<p>用户模式下的方法有:原子操作(例如一个单一的全局变量)，临界区。内 核模式下的方法有:事件，信号量，互斥量。</p>

<h2 id="toc_3">什么是可重入锁(ReentrantLock)?谈谈它的实现</h2>

<p>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块， synchronized、ReentrantLock 都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每释放一次锁， 进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p>

<h2 id="toc_4">乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h2>

<ul>
<li>悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所 以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。 Java 里面的同步原语 synchronized 关键字的实现是悲观锁。</li>
<li>乐观锁:顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改， 所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，可以使用版本号等机制。在 Java 中 j 原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 乐观锁的实现方式:
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交 后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程 都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以 再次尝试。</li>
</ul></li>
</ul>

<h3 id="toc_5">什么是 CAS 操作，缺点是什么?</h3>

<p>CAS 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新 值，否则不做任何事儿，但是要返回原值是多少。每一个 CAS 操作过程都包含三个运算符:一个内存地址 V，一个期望的值 A 和一个新值 B，操作的时候如果这 个地址上存放的值等于这个期望的值 A，则将地址上的值赋为新值 B，否则不做 任何操作。</p>

<ul>
<li><p>ABA 问题:<br/>
比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内 存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变 成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。 尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p></li>
<li><p>循环时间长开销大:<br/>
对于资源竞争严重(线程冲突严重)的情况，CAS 自旋的概率会比较大，从<br/>
而浪费更多的 CPU 资源，效率低于 synchronized。</p></li>
<li><p>只能保证一个共享变量的原子操作:<br/>
当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操 作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候 就可以用锁。</p></li>
</ul>

<h2 id="toc_6">写时复制容器可以用于什么应用场景</h2>

<p>CopyOnWrite 并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。<br/>
透露的思想：读写分离，读和写分开<br/>
最终一致性<br/>
使用另外开辟空间的思路，来解决并发冲突</p>

<h2 id="toc_7">为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面?</h2>

<p>JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获 得。如果线程需要等待某些锁那么调用对象中的 wait()方法就有意义了。如果 wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说， 由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中 因为锁属于对象。</p>

<h3 id="toc_8">为什么 wait 和 notify 方法要在同步块中调用?</h3>

<p>主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</p>

<h2 id="toc_9">Java 线程池中 submit() 和 execute()方法有什么区别?</h2>

<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定 义在 Executor 接口中。<br/>
而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  















  
    




  </body>
</html>
