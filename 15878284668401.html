<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    线程池 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            线程池   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/04/25</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>#并发编程</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>为什么要用线程池?<br/>
Java 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行 任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来 3 个好处。</p>

<ul>
<li>第一:降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二:提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立 即执行。</li>
<li>第三:提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>

<p>下面是线程池的简单实现:</p>

<pre><code class="language-java">public class MyThreadPool {
    // 任务队列
    private static BlockingQueue&lt;Runnable&gt; taskBlockingQueue;

    private Worker[] workers;

    public MyThreadPool(int taskCount, int workerCount) {
        if (taskCount &lt;=0 || workerCount &lt;=0)
            throw new IllegalArgumentException();
        taskBlockingQueue = new ArrayBlockingQueue&lt;&gt;(taskCount);
        initWorker(workerCount);
    }
    
    /*初始化线程池*/
    private void initWorker(int workerCount) {
        this.workers = new Worker[workerCount];
        for (int i = 0; i &lt; workerCount; i++) {
            Worker worker = new Worker();
            workers[i] = worker;
            workers[i].start();
        }
    }

    public void execute(Runnable task) {
        try {
            taskBlockingQueue.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


    public void destroy() {
        for (Worker worker : workers) {
            worker.shutdown();
        }
        workers = null;
    }

    // 工作线程
    private final class Worker extends Thread {
        @Override
        public void run() {
            Runnable task = null;
            while (!isInterrupted()) {
                try {
                    task = taskBlockingQueue.take();
                } catch (InterruptedException e) {
                    // something
                }
                if (task != null) {
                    task.run();
                }
            }
        }

        public void shutdown() {
            interrupt();
        }
    }

}
</code></pre>

<h2 id="toc_0">jdk的线程池</h2>

<pre><code class="language-text">Executor
|----ThreadPerTaskExecutor in CompletableFuture
|----ExecutorService 
|--------AbstractExecutorService
|------------ThreadPoolExecutor
|----------------ScheduledThreadPoolExecutor
|------------ForkJoinPool (java.util.concurrent)
|------------DelegatedExecutorService in Executors 
|----------------FinalizableDelegatedExecutorService in Executors 
|----------------DelegatedScheduledExecutorService in Executors 
|--------ScheduledExecutorService
|------------ScheduledThreadPoolExecutor
|------------DelegatedScheduledExecutorService in Executors 
</code></pre>

<p>Executor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的<br/>
执行分离开来。</p>

<p>ExecutorService 接口继承了 Executor，在其上做了一些 shutdown()、submit() 的扩展，可以说是真正的线程池接口;</p>

<p>AbstractExecutorService 抽象类实现了 ExecutorService 接口中的大部分方法;</p>

<p>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。</p>

<p>ScheduledExecutorService 接口继承了 ExecutorService 接口，提供了带&quot;周期 执行&quot;功能 ExecutorService;</p>

<p>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令， 或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大</p>

<hr/>

<h3 id="toc_1">ThreadPoolExecutor类的构造函数</h3>

<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
</code></pre>

<p>参数说明：</p>

<ul>
<li><p>corePoolSize<br/>
线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize;<br/>
如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行;<br/>
如果执行了线程池的 prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p></li>
<li><p>maximumPoolSize<br/>
线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则 创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize</p></li>
<li><p>keepAliveTime<br/>
线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于 corePoolSize 时才有用</p></li>
<li><p>TimeUnit<br/>
keepAliveTime 的时间单位 workQueue</p></li>
<li><p>workQueue<br/>
workQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能。<br/>
用于保存等待执行的任务的阻塞队列，一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：</p>
<ul>
<li>当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待， 因此线程池中的线程数不会超过 corePoolSize。</li>
<li>使用无界队列时 maximumPoolSize 将是一个无效参数。</li>
<li>使用无界队列时 keepAliveTime 将是一个无效参数。</li>
<li>更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防 止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。<br/>
所以我们一般会使用，ArrayBlockingQueue、LinkedBlockingQueue、 SynchronousQueue、PriorityBlockingQueue。</li>
</ul></li>
<li><p>ThreadFactory<br/>
新线程使用ThreadFactory创建。如果没有另外指定，则使用Executors.defaultThreadFactory()。通过提供不同的ThreadFactory，您可以更改线程的名称，线程组，优先级，守护进程状态等。</p></li>
<li><p>RejectedExecutionHandler<br/>
提供了四个预定义的处理程序策略：</p>
<ul>
<li>在默认ThreadPoolExecutor.AbortPolicy ，处理程序会引发运行RejectedExecutionException后排斥反应。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy中，调用execute本身的线程运行任务。 这提供了一个简单的反馈控制机制，将降低新任务提交的速度。</li>
<li>ThreadPoolExecutor.DiscardPolicy中 ，直接丢弃任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy中   丢弃阻塞队列中靠最前的任务，并执行当前任务。<br/>
可以定义和使用其他类型的RejectedExecutionHandler类。 这样做需要特别注意，特别是当策略被设计为仅在特定容量或排队策略下工作时。</li>
</ul></li>
</ul>

<hr/>

<h3 id="toc_2">扩展ThreadPoolExecutor</h3>

<p>该类提供了在每个任务执行之前和之后调用的protected可悲子类覆写的beforeExecute(Thread, Runnable)和afterExecute(Runnable, Throwable)方法。 这些可以用来操纵执行环境; 例如，重新初始化ThreadLocals，收集统计信息或添加日志条目。 另外，方法terminated()可以被覆盖，以执行执行程序完全终止后需要执行的任何特殊处理。</p>

<pre><code class="language-java">public class PausableThreadPoolExecutor extends ThreadPoolExecutor {
    private boolean isPaused;
    private ReentrantLock pauseLock = new ReentrantLock();

    private Condition unpaused = pauseLock.newCondition();

    public PausableThreadPoolExecutor(int corePoolSize,
                                      int maximumPoolSize,
                                      long keepAliveTime,
                                      TimeUnit unit,
                                      BlockingQueue&lt;Runnable&gt; workQueue,
                                      ThreadFactory threadFactory,
                                      RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        pauseLock.lock();
        try {
            while (isPaused) unpaused.await();
        } catch (InterruptedException ie) {
            t.interrupt();
        } finally {
            pauseLock.unlock();
        }
    }

    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        if (t != null) System.out.println(t);
    }


    public void pause() {
        pauseLock.lock();
        try {
            isPaused = true;
        } finally {
            pauseLock.unlock();
        }
    }

    public void resume() {
        pauseLock.lock();
        try {
            isPaused = false;
            unpaused.signalAll();
        } finally {
            pauseLock.unlock();
        }
    }

}
</code></pre>

<hr/>

<h2 id="toc_3">线程池的工作机制</h2>

<ol>
<li>如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务(注意， 执行这一步骤需要获取全局锁)。</li>
<li>如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。 </li>
<li>如果无法将任务加入 BlockingQueue(队列已满)，则创建新的线程来处理任务。</li>
<li>如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>

<h3 id="toc_4">提交任务</h3>

<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程 池执行成功。</p>

<p>submit()方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get (long timeout，TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>

<h3 id="toc_5">关闭线程池</h3>

<p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池。它们 的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断 线程，所以无法响应中断的任务可能永远无法终止。</p>

<p>但是它们存在一定的区别， shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行 或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的 状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程</p>

<h2 id="toc_6">如何合理使用线程池</h2>

<p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>

<ul>
<li>任务的性质:CPU 密集型任务、IO 密集型任务和混合型任务。 •任务的优先级:高、中和低。</li>
<li>任务的执行时间:长、中和短。 </li>
<li>任务的依赖性:是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。</li>
</ul>

<p>CPU 密集型任务应配置尽可能小的线程，如配置 Ncpu+1 个线程的线程池。 </p>

<p>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2*Ncpu。</p>

<p>混合型的任务，如果可以拆分，将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行 分解。</p>

<p>可以通过 Runtime.getRuntime().availableProcessors()方法获得当前设备的 CPU 个数。</p>

<p>对于 IO 型的任务的最佳线程数，有个公式可以计算 ：<br/>
Nthreads = NCPU * UCPU * (1 + W/C)</p>

<p>其中:<br/>
NCPU 是处理器的核的数目<br/>
UCPU 是期望的 CPU 利用率(该值应该介于 0 和 1 之间)<br/>
W/C 是等待时间与计算时间的比率</p>

<p>等待时间与计算时间我们在 Linux 下使用相关的 vmstat 命令或者 top 命令查看。</p>

<p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先执行。</p>

<p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果， 等待的时间越长，则 CPU 空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用 CPU。</p>

<p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设的大一点儿。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
