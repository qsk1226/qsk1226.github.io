<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    # 阿里面试题 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            # 阿里面试题   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/05/12</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='other.html'>other</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2><a id="java%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java基础</h2>
<ul>
<li>List 和 Set 的区别<br />
list是可以重复. 在遍历时按照插入顺序<br />
set底层实现是hashMap. 是不可以重复的. 遍历的顺序页不是插入时的循序</li>
<li>HashSet 是如何保证不重复的<br />
HashSet的add方法, 内部调用的是hashMap的put方法.<br />
put方法的插入步骤如下:</li>
</ul>
<ol>
<li>检查table的数组是否为null或者length是否为0  true 初始化table</li>
<li>通过key的hash和length-1算出桶的位置i table[i] == null. newNode(hash, key , val, null) 直接插入, p</li>
<li>如果p的hash值和key都和当前待插入的key和hash值相等. 插入</li>
<li>如果p位置是treeNode, 调用红黑树的put方法插入</li>
<li>上述都不是. 那p一定是链表. 遍历整个链表. 如果能找到当期key相等的. 替换他的val 否则尾插法. 插入链表. 当链表的长度超过阈值时, 转换为treeNode</li>
<li>当size阈值的时候. 扩容.</li>
</ol>
<p>通过上述流程. 保证了HashSet是不会出现重复的.</p>
<ul>
<li>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</li>
</ul>
<p>HashMap是线程不安全的. 在扩容和计算map容量的时候, 添加链表修改指针的时候  没有进行同步操作.</p>
<ul>
<li>HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</li>
</ul>
<p>1.8的hashMap 将超过阈值的链表转化为红黑树. 这是一点优化.</p>
<ul>
<li>final finally finalize</li>
</ul>
<p>final关键字修饰的类. 表示类不可以被继承.<br />
final关键字修饰的方法. 表示不可以被重写.<br />
final修饰的成员变量. 表示必须要在构造器初始化.</p>
<p>final修饰的成员变量. 在java的内存模型中是有语义的.</p>
<p>构造函数对final属性的初始化, 和随后把这个被构造对象的引用赋值给一个引用对象. 是不能重排序的<br />
初次读一个包含final域的对象.于随后初次读这个final域. 不能重排序</p>
<p>重排序是现代计算机在执行程序时，为了保证性能，处理器和编译器常常会对指令进行重排序.</p>
<p>而java内存模型会进制特定类型的重排序.<br />
比如 一个锁的解锁, 和随后对这个锁的加锁.<br />
对一个volatile域的写, 和随后对这个volatile的读.<br />
线程A执行线程b.start()操作, 和随后线程b的任意操作.<br />
线程A执行线程b.join返回成功. name线程b的所有操作和线程a执行b.join操作. 以上这些都是不可以重排序的.</p>
<p>禁止重排序是通过内存屏障完成的.</p>
<ul>
<li>强引用 、软引用、 弱引用、虚引用</li>
</ul>
<p>强 是通常我们new的对象. 只要对象是可达的. 就不会被回收<br />
软 但内存紧张时会被回收  softReference可以和ReferenceQueue关联<br />
弱 只能活到下次GC  weakReference可以和ReferenceQueue关联<br />
虚 并不会影响执行object的声明周期. 但是在被回收时, 会将应引用对象放入队列中. phantomReference必须和ReferenceQueue管理</p>
<ul>
<li>Java反射</li>
</ul>
<p>获得实例的Class信息, Class信息包含类的方法 属性 构造器 父类 注解等信息.  也可以操作他们. 比如赋值什么的</p>
<ul>
<li>Arrays.sort 实现原理和 Collection 实现原理</li>
</ul>
<p>不同的数组大小 应用不同排序.</p>
<ul>
<li>LinkedHashMap的应用</li>
</ul>
<p>为了保证hashMap在遍历的时候. 按照插入顺序遍历. linked内部的entry拓展hashMap的Node节点, 添加了额外的指针 before和after. 来保存插入时表示的前后信息</p>
<ul>
<li>cloneable接口实现原理</li>
</ul>
<p>cloneable接口相当于标记, 表示该对象可以被克隆, 克隆的实现是直接复制对象二进制数据. 深拷贝和浅拷贝的问题</p>
<p>克隆不会执行构造函数</p>
<ul>
<li>
<p>异常分类以及处理机制</p>
</li>
<li>
<p>wait和sleep的区别<br />
wait 必须要同步的情况才能使用 会释放锁. 语义是线程在加锁对象上等待. 可以被notify/all方法唤醒<br />
sleep 不会释放锁. 语义是休眠当前线程</p>
</li>
</ul>
<h2><a id="java%E5%B9%B6%E5%8F%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java 并发</h2>
<ul>
<li>synchronized 的实现原理以及锁优化？</li>
</ul>
<p>synchronized是锁的意思.</p>
<ol>
<li>锁放在那里. 对象的头部会有一个叫Mark Ward的结构. 存放着对象的hashcode 分代年龄 gc标记  锁信息, MW的数据结构是动态变化的. 比如偏向锁 就会保存线程ID. 轻量级锁则保存指向栈信息的指针, 重量级锁会保存一个指向Monitor的指针,</li>
<li>Monitor的数据结构可以简单描述为 WaitSet EntryList owner count 当线程在等待获得锁的时候 它在entryList中. 获得了锁 进入owner区域. count+1. 当调用wait()方法, owner会释放锁, 进入waitSet区域. count-1. 当线程被notify后. 会从waitset区域进入entryList区域. 等待获得锁. 重量级锁是性能低下的, 因为需要依赖系统的互斥体, 线程间的切换也需要从用户态到核心态的切换, 这都非常消耗性能. jvm在此基础上添加了偏向锁和轻量级锁.</li>
<li>偏向锁是基于一种大多数情况下是不存在竞争的, 都是一个线程多次获得. 思路是当线程获得了锁. 就会进入偏向模式, MW也会变为偏向结构. 记录线程ID, 线程加锁时会判断线程ID是否和自己相等. 如果相等直接进入同步块. 当线程ID不相等. 说明存在竞争了. 锁会膨胀为轻量级锁.</li>
<li>轻量级锁是基于一种 大多数情况都是多个线程交替获取. 这样对象的MW会转变为轻量级锁结构. 加锁实际上是将MW的部分信息CAS的放入栈中, 成功进入同步块. 失败 当期线程则尝试通过自旋来获得锁.  解锁, 是将栈的MW信息CAS的替换回对象头.成功释放锁, 失败了说明有其他线程在尝试获得锁,  则锁膨胀为重量级锁</li>
</ol>
<p>锁只能膨胀. 不能撤销,  自旋锁是为了防止用户态和和心态的切换.</p>
<ul>
<li>volatile 的实现原理？</li>
</ul>
<p>为了平衡cpu和硬盘效率的不一致. 所以引入了内存. 但是现代CPU越来越快. 还出现了多核心. 所以在cpu周围出现大量寄存器. 可称为缓存. 缓存和内存的信息同步. 内存和硬盘的信息同步. 都是问题.<br />
Java内存模型描述为  线程的本地缓存  和  直接内存也可以叫共享内存</p>
<p>volatile的写入数据会直接同步到直接内存的. 这一点是通过lock前缀的命令实现的.</p>
<p>其他的缓存如何知道本地的缓存失效了呢, 是基于缓存一致性协议. 是通过嗅探总线上的指令来判定自己的缓存是否有效的.</p>
<p>基本流程是 volatile域的写入会直接写入直接内存. 其他本地缓存通过嗅探总线得知了自己本地缓存失效了, 下次再读取的时候, 回去直接内存读取.</p>
<p>volatile域只能保证可见性.</p>
<ul>
<li>Java 的信号灯？</li>
</ul>
<p>java并发包的信号量. 可以理解为许可证. 创建信号量的时候, 会初始化一定数量的许可证, 线程想要执行必须获得一定数量的许可证, 执行完成后释放许可证.</p>
<p>内部实现是基于AQS的共享锁实现的. 信号量分公平和非公平的区别. 默认是非公平的.  例如 Semaphore s = new Semaphore(2); TA.acquire(1) TB.acquire(2) TC.acquire(1) TA.release(1) TB.release(2) TC.release(1)</p>
<p>公平锁的流程:<br />
TA.acquire(1)</p>
<ol>
<li>
<p>响应中断</p>
</li>
<li>
<p>tryAcquireShared(1)尝试获得state</p>
<ol>
<li>自旋 保证CAS成功</li>
<li>判断等待队列中是否存在等待的节点. 存在获得状态失败 结束自自旋返回 -1</li>
<li>不存在.int s =  getState - 1  s &lt; 0或者CAS将state更新为s失败 都会结束自旋 返回s</li>
</ol>
</li>
<li>
<p>这里会成功  state =1<br />
TB.acquire(2) s=-1  &lt;0. 执行等待流程.</p>
</li>
<li>
<p>addWaiter()  将当期线程封装成共享Node. 加入等待队列尾部.</p>
</li>
<li>
<p>自旋.</p>
</li>
<li>
<p>获取当期节点的前置节点p, 如果p==head. 执行tryAcquireShared(2)  TB会失败, 因为1-2 =-1</p>
</li>
<li>
<p>shouldParkAfterFailedAcquire(p, node) 获得许可证失败后应该阻塞的前置方法</p>
<ol>
<li>检查p的waitStatus, ws  == SIGNAL(-1) 相等自己可以安心阻塞了 return</li>
<li>ws&gt;0 说明节点超时或者取消了, p开始向前遍历 直到找到节点的ws&lt;=0的, 将node节点添加在他的后面</li>
<li>CAS的更新p的ws为SIGNAL</li>
</ol>
</li>
<li>
<p>阻塞自己 lockSupport.park(this)      state =1</p>
</li>
</ol>
<p>TC.acquire(1)<br />
因为是公平的缘故, 在执行tryAcquireShared(1)的时候 发现等待队列中存在等待的节点. 也会执行和TB相同的流程. 最后阻塞自己.</p>
<p>TA.release(1)</p>
<ol>
<li>tryReleaseShared(1)
<ol>
<li>自旋 保证CAS一定能成功</li>
<li>获得当期状态int c = getState + 1</li>
<li>CAS的将state更新为c. 成功返回true.</li>
</ol>
</li>
<li>执行唤醒操作
<ol>
<li>自旋</li>
<li>哨兵 head !=null &amp;&amp; head != tail</li>
<li>int ws = head.waitStatus. 获得head的等待状态</li>
<li>ws == signal  并且将成功用CAS将h的状态从-1改为0后 唤醒h.next
<ol>
<li>判断h节点的ws &lt; 0 将状态改为0</li>
<li>
<blockquote>
<p>0 从tail节点开始向前遍历. 直到找到一个ws&lt;=0的s  唤醒s lockSupor</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>
<p>synchronized 在静态方法和普通方法的区别？</p>
</li>
<li>
<p>怎么实现所有线程在等待某个事件的发生才会去执行？</p>
</li>
<li>
<p>CAS？CAS 有什么缺陷，如何解决？</p>
</li>
<li>
<p>synchronized 和 lock 有什么区别？</p>
</li>
<li>
<p>Hashtable 是怎么加锁的 ？</p>
</li>
<li>
<p>HashMap 的并发问题？</p>
</li>
<li>
<p>ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？</p>
</li>
<li>
<p>AQS</p>
</li>
<li>
<p>如何检测死锁？怎么预防死锁？</p>
</li>
<li>
<p>Java 内存模型？</p>
</li>
<li>
<p>如何保证多线程下 i++ 结果正确？</p>
</li>
<li>
<p>线程池的种类，区别和使用场景？</p>
</li>
<li>
<p>分析线程池的实现原理和线程的调度过程？</p>
</li>
<li>
<p>线程池如何调优，最大数目如何确认？</p>
</li>
<li>
<p>ThreadLocal原理，用的时候需要注意什么</p>
</li>
<li>
<p>CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?</p>
</li>
<li>
<p>LockSupport工具</p>
</li>
<li>
<p>Condition接口及其实现原理</p>
</li>
<li>
<p>Fork/Join框架的理解</p>
</li>
<li>
<p>分段锁的原理,锁力度减小的思考</p>
</li>
<li>
<p>八种阻塞队列以及各个阻塞队列的特性</p>
</li>
</ul>
<h2><a id="spring" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Spring</h2>
<p>BeanFactory 和 FactoryBean<br />
Spring IOC 的理解，其初始化过程？<br />
BeanFactory 和 ApplicationContext？<br />
Spring Bean 的生命周期，如何被管理的？Spring Bean 的加载过程是怎样的？<br />
如果要你实现Spring AOP，请问怎么实现？<br />
如果要你实现Spring IOC，你会注意哪些问题？<br />
Spring 是如何管理事务的，事务管理机制？<br />
Spring 的不同事务传播行为有哪些，干什么用的？<br />
Spring 中用到了那些设计模式？<br />
Spring MVC 的工作原理？<br />
Spring 循环注入的原理？<br />
Spring 如何保证 Controller 并发的安全？</p>
<h2><a id="%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分布式相关</h2>
<p>Dubbo的底层实现原理和机制<br />
描述一个服务从发布到被消费的详细过程<br />
分布式系统怎么做服务治理<br />
接口的幂等性的概念<br />
消息中间件如何解决消息丢失问题<br />
Dubbo的服务请求失败怎么处理<br />
重连机制会不会造成错误<br />
对分布式事务的理解<br />
如何实现负载均衡，有哪些算法可以实现？<br />
Zookeeper的用途，选举的原理是什么？<br />
数据的垂直拆分水平拆分。<br />
zookeeper原理和适用场景<br />
zookeeper watch机制<br />
redis/zk节点宕机如何处理<br />
分布式集群下如何做到唯一序列号<br />
如何做一个分布式锁<br />
用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗<br />
MQ系统的数据如何保证不丢失<br />
列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题<br />
zookeeper的选举策略</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据库</h2>
<p>事务四大特性（ACID）原子性、一致性、隔离性、持久性？<br />
事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？<br />
MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？<br />
MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？<br />
查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？<br />
什么是临时表，临时表什么时候删除?<br />
MySQL B+Tree索引和Hash索引的区别？<br />
sql查询语句确定创建哪种类型的索引？如何优化查询？<br />
聚集索引和非聚集索引区别？<br />
有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？<br />
非关系型数据库和关系型数据库区别，优势比较？<br />
数据库三范式，根据某个场景设计数据表？<br />
数据库的读写分离、主从复制，主从复制分析的 7 个问题？<br />
使用explain优化sql和索引？<br />
MySQL慢查询怎么解决？<br />
什么是 内连接、外连接、交叉连接、笛卡尔积等？<br />
mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？<br />
varchar和char的使用场景？<br />
mysql 高并发环境解决方案？<br />
数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</p>
<h2><a id="redis" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redis</h2>
<p>Redis用过哪些数据数据，以及Redis底层怎么实现<br />
Redis缓存穿透，缓存雪崩<br />
如何使用Redis来实现分布式锁<br />
Redis的并发竞争问题如何解决<br />
Redis持久化的几种方式，优缺点是什么，怎么实现的<br />
Redis的缓存失效策略<br />
Redis集群，高可用，原理<br />
Redis缓存分片，Redis的数据淘汰策略</p>
<h2><a id="netty" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Netty</h2>
<p>BIO、NIO和AIO<br />
Netty 的各大组件，Netty的线程模型<br />
TCP 粘包/拆包的原因及解决方法<br />
了解哪几种序列化协议？包括使用场景和如何去选择<br />
Netty的零拷贝实现<br />
Netty的高性能表现在哪些方面</p>
<h2><a id="jvm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JVM</h2>
<p>详细jvm内存模型<br />
讲讲什么情况下回出现内存溢出，内存泄漏？<br />
说说Java线程栈<br />
JVM 年轻代到年老代的晋升过程的判断条件是什么呢？<br />
JVM 出现 fullGC 很频繁，怎么去线上排查问题？<br />
类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？<br />
类的实例化顺序<br />
JVM垃圾回收机制，何时触发MinorGC等操作<br />
JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的<br />
各种回收器，各自优缺点，重点CMS、G1<br />
各种回收算法<br />
OOM错误，stackoverflow错误，permgen space错误</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  















  
    




  </body>
</html>
