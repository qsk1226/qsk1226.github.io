<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  ThreadLocal源码分析以及使用 - 大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>ThreadLocal源码分析以及使用</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/03/28</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <ul>
<li>
<a href="#toc_0">ThreadLocal结构分析</a>
</li>
<li>
<a href="#toc_1">ThreadLocal的源码解析</a>
</li>
<li>
<a href="#toc_2">ThreadLocalMap解析</a>
<ul>
<li>
<a href="#toc_3">ThreadLocalMap源码分析</a>
</li>
<li>
<a href="#toc_4">ThreadLocal的引用关系</a>
<ul>
<li>
<a href="#toc_5">内存泄漏问题及解决办法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Hash冲突怎么解决</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">线程不安全问题</a>
</li>
</ul>


<p>ThreadLocal该类提供线程局部变量，起到线程隔离的作用。</p>

<h2 id="toc_0">ThreadLocal结构分析</h2>

<ul>
<li>首先我们看下ThreadLocal和Thread的它们之间的关系，如下图所示：</li>
</ul>

<p><figure><img src="media/15864440934982/15865132297584.jpg" alt=""/></figure></p>

<p><strong>Thread类内部声明了一个ThreadLocal.ThreadLocalMap类型的变量 threadLocals</strong>，ThreadLocal类负责维护ThreadLocal与Thread 之间关系的 ThreadLocalMap散列映射。</p>

<h2 id="toc_1">ThreadLocal的源码解析</h2>

<p><figure><img src="media/15864440934982/15865038471517.jpg" alt=""/></figure></p>

<p>我们一起来看下ThreadLocal 内部代码</p>

<pre><code class="language-java">// 创建线程和ThreadLocal的关联映射
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// 获取线程 t 的threadLocalMap
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// 设置当前线程的局部变量值
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

//获取当前线程的局部变量值
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

// 设置初始值
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

// 移除此线程局部变量的当前线程值。
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
</code></pre>

<h2 id="toc_2">ThreadLocalMap解析</h2>

<h3 id="toc_3">ThreadLocalMap源码分析</h3>

<p><figure><img src="media/15864440934982/15865034564443.jpg" alt=""/></figure></p>

<pre><code class="language-java">
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        // k已经过时，被垃圾回收啦
        if (k == null) 
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}

private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    
    // 发生了hash碰撞问题，采用线性探测法，按照一定步长查找下一个位置，直到找到空余的位置存放value值为止,如果遇到过时的局部变量值，则将过时的value值替换为新的value值
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key) {
            e.value = value;
            return;
        }
        // 遇到过时的线程局部变量
        if (k == null) {
            // 用指定键的项替换set操作期间遇到的过时项。
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    // entry 条目个数大于表的扩容阈值的时候
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        // 重新调整table的大小。首先扫描整个表，删除陈旧的条目。如果这还不足以缩小表的大小，则将表的大小加倍。
        rehash();
}


private void remove(ThreadLocal&lt;?&gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear(); // 清除ThreadLocal引用
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
            return;
        }
    }
}

private void rehash() {
    // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
    expungeStaleEntries();

    // 使用较低的阈值加倍，以避免扩容滞后
    if (size &gt;= threshold - threshold / 4)
        resize();
}
</code></pre>

<h3 id="toc_4">ThreadLocal的引用关系</h3>

<p>ThreadLocal的引用关系 如下图所示：</p>

<p><figure><img src="media/15864440934982/15865783936571.jpg" alt="" style="width:708px;"/></figure></p>

<h4 id="toc_5">内存泄漏问题及解决办法</h4>

<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么下次gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链： <br/>
current thread 引用 -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value <br/>
永远无法回收，造成内存泄露。</p>

<p>针对这种情况ThreadLocalMap提供了一些防护措施：</p>

<ul>
<li><p>1、 getEntry(ThreadLocal&lt;?&gt; key)、set(ThreadLocal&lt;?&gt; key, Object value)提供了针对key为null的entry的擦除操作expungeStaleEntry(i)</p></li>
<li><p>2、 remove(ThreadLocal&lt;?&gt; key)方法内部提供了针对ThreadLocal的擦除操作</p></li>
</ul>

<p>如下代码所示：</p>

<pre><code class="language-java">public class ThreadLocalContext {

    private static final ThreadLocal&lt;Object&gt; UNKNOWN_THREAD_LOCAL = new ThreadLocal&lt;&gt;();

    public static Object get() {
        return UNKNOWN_THREAD_LOCAL.get();
    }

    public static void set(Object value) {
        UNKNOWN_THREAD_LOCAL.set(value);
    }

    public static void remove(){
        UNKNOWN_THREAD_LOCAL.remove();
    }
}

/**
 * ThreadLocal内存泄漏的风险演示
 * -XX:+PrintGCDetails -Xmx50m
 * @author goddess
 * @since 2020/4/8 23:16
 **/
public class ThreadOOM {

    static class UseData {
        private byte[] element = new byte[1024 * 1024 * 10];// 10M
    }

    static class UseThreadOOM implements Runnable {
        @Override
        public void run() {
            ThreadLocalContext.set(new UseData());
            //ThreadLocalContext.remove();
        }
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 3000; i++) {
                executorService.execute(new UseThreadOOM());
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }
}
</code></pre>

<p>放开ThreadLocalContext.remove的gc信息<br/>
<figure><img src="media/15864440934982/15865803964880.jpg" alt="" style="width:1569px;"/></figure></p>

<p>注释掉ThreadLocalContext.remove的部分gc信息：<br/>
<figure><img src="media/15864440934982/15865798232002.jpg" alt="" style="width:1570px;"/></figure></p>

<p><strong>方式1 的前提条件是当key为null的时候咱得去调用getEntry、set方法，单这并不是任何时候都会执行的操作，所以保险的做法就是手动调用ThreadLocal的remove函数，删除不再需要的ThreadLocal，防止内存泄露。</strong></p>

<h3 id="toc_6">Hash冲突怎么解决</h3>

<p>ThreadLocalMap当执行set(Object value)的时候可能会发生hash冲突，当发生了hash碰撞的时候，map采用了一种<strong>线性探测法(就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用,按照一定步长查找下一个位置，直到找到空余的位置存放value值为止)</strong></p>

<p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置，如下代码：</p>

<pre><code class="language-text">private static int nextIndex(int i, int len) {
    return ((i + 1 &lt; len) ? i + 1 : 0);
}
private static int prevIndex(int i, int len) {
    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);
}
</code></pre>

<p>如果有大量不同的ThreadLocal对象放入ThreadLocalMap中时发一次或多次hash冲突，就要多次执行线性探测法，则效率很低。</p>

<p><strong>建议：</strong> 由于存在hash冲突问题，每个线程只存一个ThreadLocal变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，可以避免hash碰撞引起效率低下的问题。</p>

<h2 id="toc_7">线程不安全问题</h2>

<p>记住一点，本次线程任务使用完ThreadLocal之后要调用threadLocal.remove()方法。当使用线程池的时候，线程执行完任务之后，线程并不会消亡，而是重新回到了线程池中，等待下次任务的分派。可能产生的问题：<strong>造成线程不安全的问题，访问threadLocal.get()获取的值可能不是自己预期的变量值</strong><br/>
看如下代码：</p>

<pre><code class="language-java">public class ThreadUnsafe {

    static class UseThreadUnsafe implements Runnable {
        private int value;

        UseThreadUnsafe(int value) {
            this.value = value;
        }

        @Override
        public void run() {
            Object o = ThreadLocalContext.get();
            if (o == null) {
                ThreadLocalContext.set(value+1);
            }
            System.out.println(Thread.currentThread().getName()+&quot; 线程局部变量表：&quot; + ThreadLocalContext.get());
            // tips：开启和注释的情况下完全不一样
            ThreadLocalContext.remove();
        }
    }


    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 6; i++) {
                executorService.execute(new UseThreadUnsafe(i));
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }

}
</code></pre>

<p>开启的情况下：<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：5<br/>
pool-1-thread-3 线程局部变量表：4<br/>
pool-1-thread-1 线程局部变量表：6</p>

<p>注释的情况下：<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3</p>

<hr/>

<p><strong>综上所述 ThreadLocal使用完变量之后，千万要记着调用ThreadLocal的remove()完成擦除操作</strong></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15857296160676.html" 
          title="Previous Post: 查看远程mysql 主机的 binlog 日志">&laquo; 查看远程mysql 主机的 binlog 日志</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15865981620428.html" 
          title="Next Post: 软引用（SoftReference）和引用队列（ReferenceQueue）">软引用（SoftReference）和引用队列（ReferenceQueue） &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
