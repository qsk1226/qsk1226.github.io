<!DOCTYPE HTML>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="大爷来玩儿啊">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://www.throne4j.com">
    <!--SEO-->

<meta name="keywords" content="集合">


<meta name="description" content="Map详解HashMap 是我们开发过程中使用频率及其高又及其重要的集合类。它是将键映射到值的对象。Map不能包含重复的键,每个键最多可以映射到一个值。一些map实现，比如TreeMap类，对它...">


<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->

<title>
    
    Map详解 |
    
    大爷来玩儿啊
</title>

<link rel="alternate" href="/atom.xml" title="大爷来玩儿啊" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header" style="background-image:url(
    http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="我跟人飙车来着">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                只要干不死，就往死里干
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://www.throne4j.com">
                        大爷来玩儿啊</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                Main</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/netty/"><i class="fa fa-book"></i>
                                Netty</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/java/"><i class="fa fa-book"></i>
                                Java</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/database/"><i class="fa fa-book"></i>
                                Database</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/spring/"><i class="fa fa-book"></i>
                                Spring</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/protocol/"><i class="fa fa-book"></i>
                                Protocol</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/design-pattern/"><i class="fa fa-book"></i>
                                DesignPattern</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/domain-driver/"><i class="fa fa-book"></i>
                                DomainDrive</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/redis/"><i class="fa fa-book"></i>
                                Redis</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/zookeeper/"><i class="fa fa-book"></i>
                                Zookepper</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa fa-archive"></i>
                                TimeMachine</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/about/"><i class="fa fa-archive"></i>
                                Interestion</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Map详解">
            
            Map详解
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/java/">java</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/集合/">集合</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2016/07/03</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="Map详解"><a href="#Map详解" class="headerlink" title="Map详解"></a>Map详解</h1><p>HashMap 是我们开发过程中使用频率及其高又及其重要的集合类。它是将键映射到值的对象。Map不能包含重复的键,每个键最多可以映射到一个值。一些map实现，比如TreeMap类，对它们的顺序做出了特定的保证;其他类，如HashMap类，则没有。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="/qsk/java/Map%E8%AF%A6%E8%A7%A3/Map_UML.png" alt="Map_UML"></p>
<h2 id="Map默认方法说明"><a href="#Map默认方法说明" class="headerlink" title="Map默认方法说明"></a>Map默认方法说明</h2><p>Map接口除了定义此类集合应该具有的行为模式之外，还定义了Map的集合视图Entry内部类。</p>
<ul>
<li><p>default V getOrDefault(Object key, V defaultValue)</p>
<blockquote>
<p>返回指定键映射到的值，如果此映射不包含键的映射，则返回 defaultValue。</p>
</blockquote>
</li>
<li><p>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</p>
<blockquote>
<p>为映射中的每个条目执行给定的操作，直到处理完所有条目或操作引发异常为止。</p>
</blockquote>
</li>
<li><p>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</p>
<blockquote>
<p>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或函数抛出异常。</p>
</blockquote>
</li>
<li><p>default V putIfAbsent(K key, V value)</p>
<blockquote>
<p>如果指定的键尚未与值关联(或映射到 null)，则将其与给定值关联并返回null，否则将返回当前值。</p>
</blockquote>
</li>
<li><p>default boolean remove(Object key, Object value)</p>
<blockquote>
<p>仅当当前映射到指定值时，才删除指定键的项。</p>
</blockquote>
</li>
<li><p>default boolean replace(K key, V oldValue, V newValue)</p>
<blockquote>
<p>仅当当前映射到指定值时，才替换指定键的项。</p>
</blockquote>
</li>
<li><p>default V replace(K key, V value)</p>
<blockquote>
<p>仅当指定键的项当前映射到某个值时，才替换该项。</p>
</blockquote>
</li>
<li><p>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</p>
<blockquote>
<p>如果指定的键尚未与值关联(或映射到null)，则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非null。</p>
</blockquote>
</li>
<li><p>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</p>
<blockquote>
<p>如果指定键的值为present且非null，则尝试计算给定键及其当前映射值的新映射。</p>
</blockquote>
</li>
<li><p>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</p>
<blockquote>
<p>尝试为指定的键及其当前映射值计算映射(如果没有当前映射，则为null)。</p>
</blockquote>
</li>
<li><p>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</p>
<blockquote>
<p>如果指定的键尚未与值关联或与null关联，则将其与给定的非null值关联。否则，将关联值替换为给定映射函数的结果，如果结果是null，则删除关联值。</p>
</blockquote>
</li>
</ul>
<h2 id="HashMap数据结构图"><a href="#HashMap数据结构图" class="headerlink" title="HashMap数据结构图"></a>HashMap数据结构图</h2><p>HashMap继承自AbstractMap、Map、Cloneable、Serializable</p>
<p><img src="/qsk/java/Map%E8%AF%A6%E8%A7%A3/map%E7%BB%93%E6%9E%84.png" alt="map结构"></p>
<h3 id="HashMap内部属性"><a href="#HashMap内部属性" class="headerlink" title="HashMap内部属性"></a>HashMap内部属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量—必须是2的幂。(16)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，如果较高的值由带参数的任何构造函数隐式指定，则使用该值。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数中没有指定时使用的负载因子。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶的树化阈值，当桶的大小大于这个阈值时，普通Node链表结构转化为TreeNode红黑树结构。</span></span><br><span class="line"><span class="comment">// 树化的链表长度须是2的且最小得大于8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶的链表化阈值,当在resize()时，treeNode红黑树的映射数量小于这个阈值时，TreeNode红黑树结构将转化为Node链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表允许转化为TreeNode红黑树的最小容量值(为了避免在扩容还是树化的冲突，这个值必须至少是4 * TREEIFY_THRESHOLD)。在哈希表的容量没达到这个阈值的时候，桶会直接扩容。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表，第一次使用时初始化，并根据需要调整大小。 当分配时，长度总是2的幂。</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存entrySet ()。注意AbstractMap字段用于keySet()和values()。</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此映射中包含的键值映射的数目。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个HashMap在结构上被修改的次,数结构修改是指改变HashMap中映射的数量或修改其内部结构的次数(例如，rehash)。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容临界值 这个值为 大于cap的且距离最近的2的n次幂数，用于扩容判断</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap部分内部类"><a href="#HashMap部分内部类" class="headerlink" title="HashMap部分内部类"></a>HashMap部分内部类</h3><h4 id="Node-内部类-链表数据结构"><a href="#Node-内部类-链表数据结构" class="headerlink" title="Node 内部类: 链表数据结构"></a>Node 内部类: 链表数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 记录位于哪个桶中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 指向下一个元素</span></span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeNode-内部类-红黑树数据结构，LinkedHashMap-Entry-继承自HashMap-Node。关于红黑树会单独抽出一篇幅去分析。"><a href="#TreeNode-内部类-红黑树数据结构，LinkedHashMap-Entry-继承自HashMap-Node。关于红黑树会单独抽出一篇幅去分析。" class="headerlink" title="TreeNode 内部类: 红黑树数据结构，LinkedHashMap.Entry 继承自HashMap.Node。关于红黑树会单独抽出一篇幅去分析。"></a>TreeNode 内部类: 红黑树数据结构，LinkedHashMap.Entry 继承自HashMap.Node。关于红黑树会单独抽出一篇幅去分析。</h4><p>红黑树见：<a href="/qsk/structure/red-black.html">红黑树</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 记录父节点</span></span><br><span class="line">    TreeNode&lt;K, V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 左孩子</span></span><br><span class="line">    TreeNode&lt;K, V&gt; left;</span><br><span class="line">    <span class="comment">// 右孩子</span></span><br><span class="line">    TreeNode&lt;K, V&gt; right;</span><br><span class="line">    <span class="comment">//删除后需要断开next链接</span></span><br><span class="line">    TreeNode&lt;K, V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">// 红黑颜色标记</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br></pre></td></tr></table></figure>

<p>从源码中可以发现TreeNode继承自LinkedHashMap.Entry&lt;K, V&gt;，在LinkedHashMap中的Entry实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认16长度，负载因子0.75</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap方法"><a href="#HashMap方法" class="headerlink" title="HashMap方法"></a>HashMap方法</h3><h4 id="static-final-int-hash-Object-key-计算"><a href="#static-final-int-hash-Object-key-计算" class="headerlink" title="static final int hash(Object key) 计算"></a>static final int hash(Object key) 计算</h4><ul>
<li><ol>
<li>获取key的hashCode值</li>
</ol>
</li>
<li><ol start="2">
<li>获取key的hashCode值的高16位</li>
</ol>
</li>
<li><ol start="3">
<li>高16位和hashCode进行异或操作获取新的hash值</li>
</ol>
</li>
</ul>
<p>计算hash桶的索引公式：(table.length - 1) &amp; hash</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="int-tableSizeFor-int-cap-计算table扩容临界值"><a href="#int-tableSizeFor-int-cap-计算table扩容临界值" class="headerlink" title="int tableSizeFor(int cap) 计算table扩容临界值"></a>int tableSizeFor(int cap) 计算table扩容临界值</h4><p>入参cap 大于0 且小于最大容量，如果cap是2次幂则返回cap，否则将cap转为大于cap且距离最小的2次幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;  <span class="comment">//cap = 16 二进制:           00010000</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;                                        n=        <span class="number">00001111</span> (<span class="number">15</span>)</span><br><span class="line">    </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// n = n |(n &gt;&gt;&gt; 1)  含义是n= n或等 n&gt;&gt;&gt;1             00001111</span></span><br><span class="line">                                                            n=     |  <span class="number">00000111</span></span><br><span class="line">                                                                    -----------</span><br><span class="line">                                                            n=        <span class="number">00001111</span> (<span class="number">15</span>)</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; <span class="comment">// 返回16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict-以-m-为基础构造新的映射，或者在已有映射基础上添加映射-m"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict-以-m-为基础构造新的映射，或者在已有映射基础上添加映射-m" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) 以 m 为基础构造新的映射，或者在已有映射基础上添加映射 m"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) 以 m 为基础构造新的映射，或者在已有映射基础上添加映射 m</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、判断table是否已初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>) s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>) ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">// 1.1、设置扩容临界值</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">// 2、如果s已经超出了扩容临界值，则进行扩容操作</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 3、执行存入映射操作</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="V-put-K-key-V-value-存放映射"><a href="#V-put-K-key-V-value-存放映射" class="headerlink" title="V put(K key, V value) 存放映射"></a>V put(K key, V value) 存放映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="V-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#V-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a>V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</h4><p>存放映射 key-value</p>
<ul>
<li>onlyIfAbsent 如果为true，不修改已存在映射，</li>
<li>evict 如果为false，则处于创建模式(从源码上看的话，是为LinkedHashMap服务的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 存放映射</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//计算index，并对null做处理 ,(n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//发生碰撞的时候,桶中已经存在元素</span></span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">//节点key存在，直接覆盖value,比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断该链为红黑树,hash值不相等，即key不相等；为红黑树结点,并放入树当中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//到达链表的尾部,在尾部插入新结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或旧值为null,用新值替换旧值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结构性修改,modCount加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//超过扩容临界值，就扩容 </span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 此方法被LinkedHashMap实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-Node-lt-K-V-gt-resize-扩容"><a href="#final-Node-lt-K-V-gt-resize-扩容" class="headerlink" title="final Node&lt;K, V&gt;[] resize() 扩容"></a><strong>final Node&lt;K, V&gt;[] resize()</strong> 扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 源table的容量大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 源扩容临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">// 定义新table的容量大小和扩容临界值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 源容量大于0时</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 达到最大容量，不能在扩容了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// newCap 是源容量左移一位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始容量设置为阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;               </span><br><span class="line">        <span class="comment">// 初始阈值为零表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//新建hash桶数组</span></span><br><span class="line">    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//进行扩容操作，复制Node对象值到新的hash桶数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="comment">//如果旧的hash桶数组在j结点处不为空，复制给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将旧的hash桶数组在j结点处设置为空，方便gc</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e的后面没有node节点，直接对e的hash值对新的数组长度求模获得存储位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果e是红黑树的类型，那么添加到红黑树中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//将树仓中的节点拆分为上下树，如果太小，则取消树。仅从resize调用;</span></span><br><span class="line">                    ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 如果是普通的链表节点，则进行普通的hash分布</span></span><br><span class="line">                    <span class="comment">// 存储索引位置为 原索引位置的 节点</span></span><br><span class="line">                    Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 索引位置为 原索引位置+oldCap位置的节点</span></span><br><span class="line">                    Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K, V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//将Node结点的next赋值给next</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算为0，则扩容后的索引位置跟老表的索引位置相同</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// loTail为空，代表该节点为第一个节点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) </span><br><span class="line">                                <span class="comment">// 将节点e 赋值给loHead</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">// loTail不为空，则将节点添加到loTail后面</span></span><br><span class="line">                            loTail = e; <span class="comment">// 将此次循环的新节点赋值给loTail</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果结点e的hash值与原hash桶数组的长度作与运算不为0，则扩容后索引位置为老表的索引位置+oldCap</span></span><br><span class="line">                            <span class="comment">// 如果hiTail为空，代表该节点为第一个节点</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) </span><br><span class="line">                                hiHead = e; <span class="comment">//将节点e赋值给hiHead </span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e; <span class="comment">// 将节点添加到hiTail后面</span></span><br><span class="line">                            hiTail = e; <span class="comment">// 将此次循环的新节点赋值给hiTail</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果loTail不为空（扩容后，有老表的数据分布在新表的原索引位置），则将最后一个节点的next设为空，并将新表上对应`原索引位置`的节点设置为相应的头结点</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果hiTail不为空，（扩容后，有老表的数据分布在新表的原索引位置+oldCap的位置上），将最后一个节点的next设置为空，并将新表的 `原索引+oldCap` 的节点设置为对应的头结点hiHead</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="V-get-Object-key"><a href="#V-get-Object-key" class="headerlink" title="V get(Object key)"></a>V get(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-Node-lt-K-V-gt-getNode-int-hash-Object-key"><a href="#final-Node-lt-K-V-gt-getNode-int-hash-Object-key" class="headerlink" title="final Node&lt;K, V&gt; getNode(int hash, Object key)"></a><code>final Node&lt;K, V&gt; getNode(int hash, Object key)</code></h4><p>获取key所在的Node节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">// 1、table不为空、table长度大于0、hash计算所得桶索引的第一个映射不为空，则继续查找，否则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2、如果第一个映射的hash和参数hash相等并且key和value都相等的时候返回第一条，否则去链表或者红黑树中查询</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 3、在链表或者红黑树中获取key对应的映射</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 从红黑树中获取key映射</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 遍历Node链表，获取key映射</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="treeIfbBin-Node-lt-K-V-gt-tab-int-hash-将链表树形化"><a href="#treeIfbBin-Node-lt-K-V-gt-tab-int-hash-将链表树形化" class="headerlink" title="treeIfbBin(Node&lt;K, V&gt;[] tab, int hash) 将链表树形化"></a>treeIfbBin(Node&lt;K, V&gt;[] tab, int hash) 将链表树形化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将Node节点转化为TreeNode节点</span></span><br><span class="line">            TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="V-remove-Object-key"><a href="#V-remove-Object-key" class="headerlink" title="V remove(Object key)"></a>V remove(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-Node-lt-K-V-gt-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#final-Node-lt-K-V-gt-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h4><ul>
<li>matchValue 如果为真，则仅在值相等时删除</li>
<li>movable 如果为false，删除时不要移动其他节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                                    (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="final-void-split-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-int-index-int-bit"><a href="#final-void-split-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-int-index-int-bit" class="headerlink" title="final void split(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int index, int bit)"></a>final void split(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int index, int bit)</h4><p>将树中的节点拆分为上下树，如果太小，则取消树。仅从resize调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K, V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K, V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K, V&gt;) e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap注意事项"><a href="#HashMap注意事项" class="headerlink" title="HashMap注意事项"></a>HashMap注意事项</h3><ul>
<li><p>当桶转变为红黑树的时候，树的root节点不一定是桶的索引位置的头节点。</p>
<blockquote>
<p>在TreeNode结构中有一个方法moveRootToFront(Node&lt;K,V&gt; tab, TreeNode&lt;K,V&gt; root),此方法确保在树形化时，树的root节点设置为桶的索引位置。</p>
</blockquote>
</li>
<li><p>在链表转变为红黑树之后，链表依然会通过TreeNode的next属性维持。</p>
</li>
<li><p>由于红黑树依然通过next维护这链表结构,所以红黑树的叶子节点可能存在next节点。</p>
</li>
<li><p>树化发生在putVal方法中，去树化发生在扩容resize()</p>
</li>
</ul>
<h3 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h3><ul>
<li><p>HashMap 由 Node 数组（Node&lt;K,V&gt;[] table）实现，当hash冲突的时候(数组的索引位置相同的时候)，则可能是以链表或红黑树的形式存在。</p>
</li>
<li><p>增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步：</p>
<ol>
<li>拿到 key 的 hashCode 值；</li>
<li>将 hashCode 的高位参与运算，重新计算 hash 值；</li>
<li>将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。</li>
</ol>
</li>
<li><p>HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。</p>
<ol>
<li>threshold 的值计算规则是比capacity大但离capacity最近的2的n次方值</li>
</ol>
</li>
<li><p>导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是：</p>
<ol>
<li>table的长度始终为 2 的 n 次方；</li>
<li>索引位置的计算方法为 “(table.length - 1) &amp; hash”。</li>
</ol>
<p>HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。</p>
</li>
<li><p>HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。</p>
</li>
<li><p>当同一个索引位置的节点数增加到至少8个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。</p>
</li>
<li><p>当同一个索引位置的节点数量在移除后达到至多 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。</p>
</li>
<li><p>HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。</p>
</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap 可自然排序或通过comparator进行排序</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap继承自HashMa,所以它具有HashMap的所有特性,它的扩展了HashMap节点结构来作为自己的节点结构;LinkedHashMap通过head、tail维护了双向链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><ul>
<li>HashMap 允许 key 和 value 为 null，Hashtable 不允许。</li>
<li>HashMap 的默认初始容量为 16，Hashtable 为 11。</li>
<li>HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。</li>
<li>HashMap 是非线程安全的，Hashtable是线程安全的。</li>
<li>HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。</li>
<li>HashMap 去掉了 Hashtable 中的 contains 方法。</li>
<li>HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/qsk/java/collection_record.html" class="pre-post btn btn-default" title="collection集合记录">
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            collection集合记录</span>
    </a>
    
    
    <a href="/qsk/java/understand_java_serial.html" class="next-post btn btn-default" title="深入理解java序列化">
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            深入理解java序列化</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>
<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'rs94TvqsO1CHWHQNk3Kx3jSg-gzGzoHsz',
    appKey: 'OnRH4bvLKckbcSHTx8EleVkw',
    placeholder: '骚年，发出你的10万个为什么',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '10',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Map详解"><span class="toc-text">Map详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-text">UML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map默认方法说明"><span class="toc-text">Map默认方法说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap数据结构图"><span class="toc-text">HashMap数据结构图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap内部属性"><span class="toc-text">HashMap内部属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap部分内部类"><span class="toc-text">HashMap部分内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-内部类-链表数据结构"><span class="toc-text">Node 内部类: 链表数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeNode-内部类-红黑树数据结构，LinkedHashMap-Entry-继承自HashMap-Node。关于红黑树会单独抽出一篇幅去分析。"><span class="toc-text">TreeNode 内部类: 红黑树数据结构，LinkedHashMap.Entry 继承自HashMap.Node。关于红黑树会单独抽出一篇幅去分析。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap构造器"><span class="toc-text">HashMap构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap方法"><span class="toc-text">HashMap方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static-final-int-hash-Object-key-计算"><span class="toc-text">static final int hash(Object key) 计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-tableSizeFor-int-cap-计算table扩容临界值"><span class="toc-text">int tableSizeFor(int cap) 计算table扩容临界值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict-以-m-为基础构造新的映射，或者在已有映射基础上添加映射-m"><span class="toc-text">putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) 以 m 为基础构造新的映射，或者在已有映射基础上添加映射 m</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-put-K-key-V-value-存放映射"><span class="toc-text">V put(K key, V value) 存放映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><span class="toc-text">V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-Node-lt-K-V-gt-resize-扩容"><span class="toc-text">final Node&lt;K, V&gt;[] resize() 扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-get-Object-key"><span class="toc-text">V get(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-Node-lt-K-V-gt-getNode-int-hash-Object-key"><span class="toc-text">final Node&lt;K, V&gt; getNode(int hash, Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#treeIfbBin-Node-lt-K-V-gt-tab-int-hash-将链表树形化"><span class="toc-text">treeIfbBin(Node&lt;K, V&gt;[] tab, int hash) 将链表树形化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V-remove-Object-key"><span class="toc-text">V remove(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-Node-lt-K-V-gt-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><span class="toc-text">final Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-void-split-HashMap-lt-K-V-gt-map-Node-lt-K-V-gt-tab-int-index-int-bit"><span class="toc-text">final void split(HashMap&lt;K, V&gt; map, Node&lt;K, V&gt;[] tab, int index, int bit)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap注意事项"><span class="toc-text">HashMap注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap总结"><span class="toc-text">HashMap总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-和-HashTable-的区别"><span class="toc-text">HashMap 和 HashTable 的区别</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>