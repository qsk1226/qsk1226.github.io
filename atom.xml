<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-04-12T16:14:33+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Hotspot虚拟机中java对象管理]]></title>
    <link href="http://www.throne4j.com/15866239860150.html"/>
    <updated>2020-04-12T00:53:06+08:00</updated>
    <id>http://www.throne4j.com/15866239860150.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">对象的创建</h2>

<h2 id="toc_1">对象的内存布局</h2>

<h2 id="toc_2">对象访问定位</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM自动内存管理]]></title>
    <link href="http://www.throne4j.com/15866079598905.html"/>
    <updated>2020-04-11T20:25:59+08:00</updated>
    <id>http://www.throne4j.com/15866079598905.html</id>
    <content type="html"><![CDATA[
<p>我们在进行java开发的过程中，我们根本不用去为每一个对象申请以及释放内存空间，这是是由于JVM帮我们完成了对象的内存管理，如果我们不了解JVM是怎么使用内存的，一旦发生内存泄漏或者溢出方面的问题，那只能火急火燎的找大牛过来帮忙处理了。</p>

<h2 id="toc_0">运行时数据区域</h2>

<p>JVM在运行过程中，会把内存分为多个不同的数据区，他们各有各的用途，我们通过下图看下JVM是如何对内存结构进行划分的：<br/>
<img src="media/15866079598905/15866792581507.jpg" alt="" style="width:1002px;"/></p>

<h2 id="toc_1">程序计数器</h2>

<p>字节码解释器工作室就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，他是程序控制流的指示器(分支、循环、跳转、异常处理、线程回复等基础功能都需要程序计数器)。<br/>
由于jvm多线程是通过线程轮流切、分配处理器执行时间(cpu时间片轮转机制)来实现，因此为了线程在切换后能恢复到正确的执行位置，每条线程需要一个独立的程序计数器，各条线程的程序计数器互不影响，独立存储，因此<strong>程序计数器是线程私有的</strong>。此块区域也是唯一一个没有OOM的内存区。</p>

<h2 id="toc_2">java虚拟机栈</h2>

<p>JVM栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，JVM都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>

<ul>
<li>栈帧<br/>
一个线程中，每调用一个方法就创建一个栈帧（stack frame），方法结束栈帧销毁
<ul>
<li>局部变量表 <br/>
存放了编译期可知的各种java虚拟机基本数据类型、对象引用(方法参数、局部变量等)和returnAddress类型(指向了一条字节码指令的地址)，这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，局部变量表的容量以变量槽（Variable Slot）为最小单位。</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法出口</li>
</ul></li>
</ul>

<p>java虚拟机规范允许虚拟机自行选择是否支持栈的动态扩容，但Hotspot选择不支持扩容。所以除非在创建线程申请内存时，因无法获取足够内存而出现OOM异常。<br/>
OutOfMemoryError：</p>

<pre><code class="language-java">/**
 * jvm栈OOM(此操作可能拖垮cpu，请谨慎执行)
 * -Xss256k
 **/
public class StackOOMErrorMock {
    public static void main(String[] args) {
        for (int i = 0; ; i++) {
            new Thread(()-&gt;{
                while (true) {

                }
            }).start();
        }
    }
}
</code></pre>

<p>StackOverFlowError：</p>

<pre><code class="language-java">/**
 * StackOverFlowError
 * -Xss256k 栈大小
 */
public class StackOverFlowMock {
    private static int index = 1;

    public void call() {
        index++;
        call();
    }

    public static void main(String[] args) {
        StackOverFlowMock mock = new StackOverFlowMock();
        try {
            mock.call();
        } catch (Throwable e) {
            System.out.println(&quot;Stack deep : &quot; + index);
            e.printStackTrace();
        }
    }
}
</code></pre>

<h2 id="toc_3">本地方法栈</h2>

<p>与java虚拟机栈的作用相似，不同的是此块区域是为本地方(native)法服务的。</p>

<p>OutOfMemoryError：</p>

<p>StackOverFlowError：</p>

<h2 id="toc_4">java堆内存</h2>

<p>java堆内存是所有线程共享的一块内存区域，用于存储对象的实例数据。在JVM启动的时候创建。</p>

<p>从垃圾回收的角度看的话，基于“经典分代”设计的垃圾收集器看来，java堆可以分为新生代、老年代（主要存放应用程序中生命周期长的内存对象）和永久代，新生代又分为Eden区、to suvivor区、from survivor区。</p>

<p>从分配内存的角度看的话，所有线程共享的java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）,可以提升对象分配时的效率。</p>

<p>可引起OutOfMemoryError异常</p>

<pre><code class="language-java">
/**
 * OOM 异常 -Xms5m -Xmx5m
 */
public class HeapOomMock {
    public static void main(String[] args) {
        List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;();
        int i = 0;
        boolean flag = true;
        while (flag) {
            try {
                i++;
                list.add(new byte[1024 * 1024]);//每次增加一个1M大小的数组对象
            } catch (Throwable e) {
                e.printStackTrace();
                flag = false;
                System.out.println(&quot;count=&quot; + i);//记录运行的次数
            }
        }
    }
}
</code></pre>

<h2 id="toc_5">方法区</h2>

<p>方法区是所有线程共享的一块内存区域，用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>

<p>jdk7之前采用永久代来实现，占用jvm的堆内存不说，还可能会OOM: PermGen space,<br/>
jdk8之后移除永久代而采用了本地内存来实现方法区，理论上来说，只要物理条件允许，这个区域要多大有多大。</p>

<p>可引起OutOfMemoryError异常：</p>

<pre><code class="language-java">import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;

/**
 * jdk8之前： -XX:PermSize=10M -XX:MaxPermSize=10M
 * jdk8及之后： -XX:MaxMetaspaceSize=20m
 *
 */
public class MetaSpaceMemory {
    public static void main(String[] args) {
        for (; ; ) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(MetaSpaceMemory.class);
            enhancer.setUseCache(false);
            enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));
            System.out.println(&quot;metaspace oom&quot;);
            enhancer.create();
        }
    }

    private Object person;

    public Object getPerson() {
        return person;
    }

    public void setPerson(Object person) {
        this.person = person;
    }

}
</code></pre>

<h2 id="toc_6">运行时常量池</h2>

<p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到运行时常量池中。</p>

<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。java语言并不要求常量一定只在编译器产生。</p>

<p>例如 String类的intern()方法就是在JVM运行期间将新的常量放入到常量池中。</p>

<p><strong>注意：</strong> jdk6之前字符串常量池是放在永久区中的，第一次创建字符串实例的时候讲字符串复制到常量池中，intern()返回常量池中的引用地址，而jdk6之后字符串常量池被移动到了java堆内存中,所以直接将字符串首次出现的引用地址记录到常量池就可以了，这是intern()方法返回的和堆中字符串实例是同一个引用地址。</p>

<p>可引起OutOfMemoryError异常：</p>

<pre><code class="language-java">/**
 * jdk1.6之前 -XX:PermSize=6M -XX:MaxPermSize=6M
 * jdk1.6之后 -Xmx6M
 **/
public class ConstantPoolOOMMock {

    public static void main(String[] args) {
        Set&lt;String&gt; stringSet = new HashSet&lt;&gt;();
        int i = 0;
        while (true) {
            stringSet.add(String.valueOf(i++).intern());
        }
    }
}
</code></pre>

<h2 id="toc_7">直接内存</h2>

<p><strong>直接内存不是虚拟机运行时数据区的一部分</strong><br/>
NIO 使用区域，基于管道(channel)与缓冲区(buffer)的IO方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在java堆里面的 DirectByteBuffer 作为这块直接内存的引用进行操作。使用直接内存避免了java堆与Native堆来回复制数据，一些场景下，能显著提高运行性能。</p>

<p>jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。见 sun.misc.Cleaner类</p>

<p>OOM异常：</p>

<pre><code class="language-java">/**
 * -XX:MaxDirectMemorySize=5M -Xmx20M
 **/
public class DirectMemoryOOMMock {
    private static final int _1MB = 1024*1024*10;
    public static void main(String[] args) throws IllegalAccessException {
        Field declaredField = Unsafe.class.getDeclaredFields()[0];
        declaredField.setAccessible(true);
        Unsafe unsafe = (Unsafe)declaredField.get(null);
        while (true)
            unsafe.allocateMemory(_1MB);
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软引用（SoftReference）和引用队列（ReferenceQueue）]]></title>
    <link href="http://www.throne4j.com/15865981620428.html"/>
    <updated>2020-04-11T17:42:42+08:00</updated>
    <id>http://www.throne4j.com/15865981620428.html</id>
    <content type="html"><![CDATA[
<p>软引用可用来实现内存敏感的高速缓存。</p>

<h2 id="toc_0">软引用（SoftReference）</h2>

<p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p>

<p>SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p>

<pre><code class="language-java">MyObject aRef = new MyObject();
SoftReference aSoftRef=new SoftReference(aRef);
</code></pre>

<p>此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。<br/>
随即，我们可以结束aReference对这个MyObject实例的强引用: aRef = null;</p>

<p>此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:</p>

<pre><code class="language-java">MyObject anotherRef=(MyObject)aSoftRef.get();
</code></pre>

<p>重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。</p>

<h2 id="toc_1">ReferenceQueue工作机制</h2>

<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。使用ReferenceQueue清除失去了软引用对象的SoftReference。</p>

<p>作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:</p>

<pre><code class="language-text">ReferenceQueue queue = new ReferenceQueue();
SoftReference ref=new SoftReference(aMyObject, queue);
</code></pre>

<p>那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。<br/>
在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:</p>

<pre><code class="language-text">SoftReference ref = null;
while ((ref = (EmployeeRef) q.poll()) != null) {
    // 清除ref
}
</code></pre>

<h2 id="toc_2">使用软引用构建敏感数据的缓存</h2>

<h3 id="toc_3">为什么需要使用软引用</h3>

<p>首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。</p>

<h2 id="toc_4">通过软可及对象重获方法实现Java对象的高速缓存</h2>

<p>利用Java平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类:</p>

<pre><code class="language-java">@Data
public class Employee {
    private String id;// 雇员的标识号码
    private String name;// 雇员姓名
    private String department;// 该雇员所在部门
    private String Phone;// 该雇员联系电话
    private int salary;// 该雇员薪资
    private String origin;// 该雇员信息的来源
}
</code></pre>

<p>这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义:</p>

<pre><code class="language-java">import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.HashTable;

public class EmployeeCache {
    // 一个Cache实例
    private static EmployeeCache cache;
    // 用于Chche内容的存储
    private HashTable&lt;String,EmployeeRef&gt; employeeRefs;
    private ReferenceQueue&lt;Employee&gt; q;// 垃圾Reference的队列
    // 继承SoftReference，使得每一个实例都具有可识别的标识。并且该标识与其在HashMap内的key相同。
    private class EmployeeRef extends SoftReference&lt;Employee&gt; {
        private String _key = &quot;&quot;;
        public EmployeeRef(Employee em, ReferenceQueue&lt;Employee&gt; q) {
            super(em, q);
            _key = em.getID();
        }
    }
    // 构建一个缓存器实例
    private EmployeeCache() {
        employeeRefs = new HashTable&lt;String,EmployeeRef&gt;();
        q = new ReferenceQueue&lt;Employee&gt;();
    }
    // 取得缓存器实例
    public static EmployeeCache getInstance() {
        if (cache == null) {
            cache = new EmployeeCache();
        }
        return cache;
    }
    // 以软引用的方式对一个Employee对象的实例进行引用并保存该引用
    private void cacheEmployee(Employee em) {
        cleanCache();// 清除垃圾引用
        EmployeeRef ref = new EmployeeRef(em, q);
        employeeRefs.put(em.getID(), ref);
    }
    // 依据所指定的ID号，重新获取相应Employee对象的实例
    public Employee getEmployee(String ID) {
        Employee em = null;
        // 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。
        if (employeeRefs.containsKey(ID)) {
            EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);
            em = (Employee) ref.get();
        }
        // 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，
        // 并保存对这个新建实例的软引用
        if (em == null) {
            em = new Employee(ID);
            System.out.println(&quot;Retrieve From EmployeeInfoCenter. ID=&quot; + ID);
            this.cacheEmployee(em);
        }
        return em;
    }
    // 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象
    private void cleanCache() {
        EmployeeRef ref = null;
        while ((ref = (EmployeeRef) q.poll()) != null) {
            employeeRefs.remove(ref._key);
        }
    }
    // 清除Cache内的全部内容
    public void clearCache() {
        cleanCache();
        employeeRefs.clear();
        System.gc();
        System.runFinalization();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解java序列化]]></title>
    <link href="http://www.throne4j.com/java%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <updated>2020-04-11T14:47:08+08:00</updated>
    <id>http://www.throne4j.com/java%E5%BA%8F%E5%88%97%E5%8C%96.html</id>
    <content type="html"><![CDATA[
<p>如果你只知道实现Serializable接口的对象，可以序列化为本地文件。那你最好再阅读该篇文章，文章对序列化进行了更深一步的讨论，用实际的例子代码讲述了序列化的高级认识，包括父类序列化的问题、静态变量问题、transient关键字的影响、序列化ID问题。在笔者实际开发过程中，就多次遇到序列化的问题，在该文章中也会与读者分享。</p>

<h2 id="toc_0">引言</h2>

<p>将Java对象序列化为二进制文件的Java序列化技术是Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与Java序列化相关，通过分析情境出现的原因，使读者轻松牢记<br/>
Java 序列化中的一些高级认识。</p>

<h2 id="toc_1">序列化 ID 问题</h2>

<ul>
<li><p><strong>情境</strong>：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C序列化为二进制数据再传给 B，B 反序列化得到 C。</p></li>
<li><p><strong>问题</strong>：C 对象的全类路径假设为 com.inout.Test，在 A 和 B端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable接口，但是反序列化时总是提示不成功。</p></li>
<li><p><strong>解决</strong>：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p></li>
</ul>

<pre><code class="language-text">package com.inout; 
import java.io.Serializable; 
public class A implements Serializable { 

    private static final long serialVersionUID = 1L; 
    private String name; public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
    }
}

package com.inout;
import java.io.Serializable;
public class A implements Serializable {
    private static final long serialVersionUID = 2L;
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
} 
</code></pre>

<p>序列化ID在Eclipse下提供了两种生成策略，一个是固定的1L，一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。</p>

<h3 id="toc_2">特性使用案例</h3>

<p>　　读者应该听过Façade模式，它是为应用程序提供统一的访问接口，案例程序中的Client客户端使用了该模式，案例程序结构图如图1所示。<br/>
<img src="media/15865876286788/image.png" alt="image"/></p>

<p>　　Client端通过FaçadeObject才可以与业务逻辑对象进行交互。而客户端的FaçadeObject不能直接由Client生成，而是需要Server端生成，然后序列化后通过网络将二进制对象数据传给Client，Client负责反序列化得到Façade对象。该模式可以使得Client端程序的使用需要服务器端的许可,同时Client端和服务器端的FaçadeObject类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的FaçadeObject类的序列化ID再次生成，当Client端反序列化FaçadeObject就会失败，也就是强制Client端从服务器端获取最新程序。</p>

<h2 id="toc_3">静态变量序列化</h2>

<ul>
<li><strong>情境</strong>：查看清单 2 的代码。</li>
</ul>

<p>清单 2. 静态变量序列化问题代码</p>

<pre><code class="language-text">public class Test implements Serializable {
    private static final long serialVersionUID = 1L;
    public static int staticVar = 5;
    public static void main(String[] args) {
        try {
            //初始时staticVar为5
            ObjectOutputStream out = new ObjectOutputStream(
                    new FileOutputStream(&quot;result.obj&quot;));
            out.writeObject(new Test());
            out.close();

            //序列化后修改为10
            Test.staticVar = 10;
 
            ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
            Test t = (Test) oin.readObject();
            oin.close();
             
            //再读取，通过t.staticVar打印新的值
            System.out.println(t.staticVar);
             
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>　　清单2中的main方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单2，这个System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？最后的输出是10，对于无法理解的读者认为，打印的 staticVar是从读取的对象里获得的，应该是保存时的状态才对。之所以打印10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。</p>

<h2 id="toc_4">父类的序列化与 Transient 关键字</h2>

<ul>
<li><p><strong>情境</strong>：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p></li>
<li><p><strong>解决</strong>：要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p></li>
</ul>

<p>　　Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int 型的是 0，对象型的是 null。</p>

<h3 id="toc_5">特性使用案例</h3>

<p>　　我们熟悉使用Transient关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</p>

<p><img src="media/15865876286788/%E6%A1%88%E4%BE%8B%E7%A8%8B%E5%BA%8F%E5%9B%BE.png" alt="案例程序图"/></p>

<p>　　上图中可以看出，attr1、attr2、attr3、attr5都不会被序列化，放在父类中的好处在于当有另外一个Child类时，attr1、attr2、attr3依然不会被序列化，不用重复抒写transient，代码简洁。</p>

<h2 id="toc_6">对敏感字段加密</h2>

<ul>
<li><strong>情境</strong>：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
<li><strong>解决</strong>：在序列化过程中，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单3展示了这个过程。</li>
</ul>

<pre><code class="language-text">private static final long serialVersionUID = 1L;
private String password = &quot;pass&quot;;
public String getPassword() {
    return password;
}
public void setPassword(String password) {
    this.password = password;
}

private void writeObject(ObjectOutputStream out) {
    try {
        PutField putFields = out.putFields();
        System.out.println(&quot;原密码:&quot; + password);
        password = &quot;encryption&quot;;//模拟加密
        putFields.put(&quot;password&quot;, password);
        System.out.println(&quot;加密后的密码&quot; + password);
        out.writeFields();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void readObject(ObjectInputStream in) {
    try {
        GetField readFields = in.readFields();
        Object object = readFields.get(&quot;password&quot;, &quot;&quot;);
        System.out.println(&quot;要解密的字符串:&quot; + object.toString());
        password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    try {
        ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream(&quot;result.obj&quot;));
        out.writeObject(new Test());
        out.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                &quot;result.obj&quot;));
        Test t = (Test) oin.readObject();
        System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());
        oin.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}  
</code></pre>

<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对<br/>
password进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单<br/>
3后控制台输出如图 3 所示:</p>

<p><img src="/qsk/java/understand_java_serial/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/><img src="media/15865876286788/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/></p>

<h3 id="toc_7">特性使用案例</h3>

<p>　　RMI 技术是完全基于 Java序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及RMI的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>

<h3 id="toc_8">序列化存储规则</h3>

<pre><code class="language-text">ObjectOutputStream out = new ObjectOutputStream(
                   new FileOutputStream(&quot;result.obj&quot;));
   Test test = new Test();
   //试图将对象两次写入文件
   out.writeObject(test);
   out.flush();
   System.out.println(new File(&quot;result.obj&quot;).length());
   out.writeObject(test);
   out.close();
   System.out.println(new File(&quot;result.obj&quot;).length());

   ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
           &quot;result.obj&quot;));
   //从文件依次读出两个文件
   Test t1 = (Test) oin.readObject();
   Test t2 = (Test) oin.readObject();
   oin.close();

   //判断两个引用是否指向同一个对象
   System.out.println(t1 == t2);
</code></pre>

<p>　　清单 3中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入false 才对，但是最后结果输出如图 4 所示。</p>

<p><img src="/qsk/java/understand_java_serial/image.png" alt="image"/><img src="media/15865876286788/image.png" alt="image"/></p>

<p>　　我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？</p>

<ul>
<li><strong>解答</strong>：Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</li>
</ul>

<h3 id="toc_9">特性案例分析</h3>

<pre><code class="language-text">
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));
Test test = new Test();
test.i = 1;
out.writeObject(test);
out.flush();
test.i = 2;
out.writeObject(test);
out.close();
ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
Test t1 = (Test) oin.readObject();
Test t2 = (Test) oin.readObject();
System.out.println(t1.i);
System.out.println(t2.i);
</code></pre>

<p>　　清单 4 的目的是希望将 test 对象两次保存到result.obj文件中，写入一次以后修改对象属性值再次保存第二次，然后从result.obj中再依次读出两个对象，输出这两个对象的i属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。结果两个输出的都是 1，原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次writeObject 需要特别注意这个问题。</p>

<h2 id="toc_10">小结</h2>

<p>本文通过几个具体的情景，介绍了Java序列化的一些高级知识，虽说高级，并不是说读者们都不了解，希望用笔者介绍的情景让读者加深印象，能够更加合理的利用Java序列化技术，在未来开发之路上遇到序列化问题时，可以及时的解决。由于本人知识水平有限，文章中倘若有错误的地方，欢迎联系我批评指正。</p>

<h1 id="toc_11">转载自  <a href="https://www.cnblogs.com/wxgblogs/p/5849951.html">读书使人进步</a></h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kubenetes 在 CentOS 7 上的安装]]></title>
    <link href="http://www.throne4j.com/15856577150075.html"/>
    <updated>2020-03-31T20:28:35+08:00</updated>
    <id>http://www.throne4j.com/15856577150075.html</id>
    <content type="html"><![CDATA[
<p>swapoff -a 关闭<br/>
getenforce 关闭<br/>
vim /etc/sysconfig/selinux 关闭</p>

<p>vim /proc/sys/net/ipv4/ip_forward   ---&gt;1  开启</p>

<p>Docker <br/>
kubeadm<br/>
kubelet<br/>
kubectl<br/>
kube-flannel</p>

<pre><code class="language-text">kubeadm join 172.16.65.134:6443 --token jw3hog.3eoi736vivuje486     --discovery-token-ca-cert-hash sha256:4ff0b56297567aa67ef7511927fa39c6af8654c6709b444182b839f1e0449149
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker.  swarm]]></title>
    <link href="http://www.throne4j.com/15856442943422.html"/>
    <updated>2020-03-31T16:44:54+08:00</updated>
    <id>http://www.throne4j.com/15856442943422.html</id>
    <content type="html"><![CDATA[
<p>swarm: 一组 docker 引擎的集群<br/>
node: 单个 docker 引擎的实例，可以在一个物理机上，也可以在多个物理机上<br/>
application: 应用<br/>
Manager Node : 部署应用的时候会有一个 manager node 节点<br/>
Worker Nodes: <br/>
Service: 一堆被 worker 执行的任务<br/>
replicated services: 负载均衡节点<br/>
global service： 在所有节点上都会执行的一个服务<br/>
task： 一个 task 就是一台 docker 容器，是 swarm 的工作单元</p>

<p>sodcker swarm init --advertise-addr   manager_ip</p>

<p>/lib/systemd/system/docker.service</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker-compose]]></title>
    <link href="http://www.throne4j.com/15856304975372.html"/>
    <updated>2020-03-31T12:54:57+08:00</updated>
    <id>http://www.throne4j.com/15856304975372.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text"> curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>

<p>uname -m   ---&gt;  x86_64</p>

<p><img src="media/15856304975372/15856400125972.jpg" alt="" style="width:657px;"/></p>

<p>version: &#39;3&#39;：   表示使用第三代语法<br/>
services:  表示 compose 需要启动的服务<br/>
container_name: 容器名称<br/>
environment:  容器环境变量<br/>
ports:  对外开放的端口<br/>
restart: always  如果服务启动不成功一直尝试。<br/>
volumes:  加载本地目录到容器目标路径<br/>
depends_on： 依赖服务，先启动 depends_on 服务<br/>
command: mvn clean spring-boot:run :  表示以这个命令来启动项目</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerfile]]></title>
    <link href="http://www.throne4j.com/15855754851859.html"/>
    <updated>2020-03-30T21:38:05+08:00</updated>
    <id>http://www.throne4j.com/15855754851859.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">FROM 指定基础镜像</h2>

<h2 id="toc_1">RUN</h2>

<ul>
<li><p>shell 格式：<br/>
RUN &lt;命令行命令&gt;<br/>
&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</p></li>
<li><p>exec 格式： RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br/>
例如： RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</p></li>
</ul>

<h2 id="toc_2">CMD 执行命令</h2>

<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>

<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。<br/>
作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li>
</ul>

<p>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>

<p>格式：</p>

<pre><code class="language-text">CMD &lt;shell 命令&gt; 
CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供
默认参数
</code></pre>

<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh</p>

<h2 id="toc_3">ADD 复制指定的文件到容器中（压缩包会自动解压）</h2>

<h2 id="toc_4">COPY 复制</h2>

<p>复制指令，同 ADD 从上下文目录中复制文件或者目录到容器里指定路径。<br/>
格式：</p>

<pre><code class="language-text">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]
</code></pre>

<p>[--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>

<p>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>

<pre><code class="language-text">COPY hom* /mydir/
COPY hom?.txt /mydir/
</code></pre>

<h2 id="toc_5">WORKDIR 指定工作空间</h2>

<p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>

<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>

<h2 id="toc_6">VOLUME 为容器创建一个本地主机或其他容器的挂载点</h2>

<h2 id="toc_7">EXPOSE 容器需要暴露的端口</h2>

<h2 id="toc_8">USER 指定运行容器时的用户名，后续的 RUN 也会指定该用户</h2>

<h2 id="toc_9">ENTRYPOINT</h2>

<p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>

<p>但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>

<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>

<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>

<p>格式：</p>

<p>ENTRYPOINT [&quot;<executeable>&quot;,&quot;<param1>&quot;,&quot;<param2>&quot;,...]<br/>
可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>

<p>示例：</p>

<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>

<p>FROM nginx</p>

<p>ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参<br/>
CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 <br/>
1、不传参运行</p>

<p>$ docker run  nginx:test<br/>
容器内会默认运行以下命令，启动主进程。</p>

<p>nginx -c /etc/nginx/nginx.conf<br/>
2、传参运行</p>

<p>$ docker run  nginx:test -c /etc/nginx/new.conf<br/>
容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>

<p>nginx -c /etc/nginx/new.conf</p>

<h2 id="toc_10">ENV 环境变量</h2>

<p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>

<p>格式：</p>

<p>ENV <key> <value><br/>
ENV <key1>=<value1> <key2>=<value2>...<br/>
以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>

<p>ENV NODE_VERSION 7.2.0</p>

<p>RUN curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz</a>&quot; \<br/>
  &amp;&amp; curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc</a>&quot;</p>

<h2 id="toc_11">MAINTAINER 维护者信息</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 普通用户添加 sudo 免密码执行权限]]></title>
    <link href="http://www.throne4j.com/sudo%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C.html"/>
    <updated>2020-03-30T02:40:49+08:00</updated>
    <id>http://www.throne4j.com/sudo%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C.html</id>
    <content type="html"><![CDATA[
<p>在使用普通用户登录的时候，会经常使用sudo指令执行一些操作，有时候感觉输入密码比较繁琐，特别是需要设置一些开机启动的时候操作，而这些操作往往就需要sudo指令，如果没有免密的话，在使用普通用户登录的时候就无法执行，这个时候给普通用户添加免密码sudo功能就非常的必要了  </p>

<p>注意：sudo面密码只是在执行sudo指令的时候不需要输入密码，并不是普通用户拥有超级用户的权限，需要root才有的权限不加sudo 一样执行不了 ，所以这一点也保证了使用免密码的安全性 ，只是在使用sudo的时候不需要输入密码</p>

<p>很简单，在命令行输入：</p>

<p>sudo vim /etc/sudoers  </p>

<p>在代码的最后加上：</p>

<p>yourusername   ALL=(ALL)NOPASSWD:ALL      </p>

<p>username是指定的普通用户名称，这样就是保证在指定用户使用sudo的时候不需要输入密码，如果想给执行命令添加免密而已，只需要把最后的ALL替换为命令的绝对路径即可，</p>

<p>如下：</p>

<p>username   ALL=(ALL)NOPASSWD:/bin/hello</p>

<p>这样就为指定用户在执行/bin目录下的hello目录的时候 不需输入密码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker 命令]]></title>
    <link href="http://www.throne4j.com/15855064473314.html"/>
    <updated>2020-03-30T02:27:27+08:00</updated>
    <id>http://www.throne4j.com/15855064473314.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">容器生命周期管理</h2>

<ul>
<li>run  创建一个新的容器并运行一个命令</li>
</ul>

<p>eg: docker run -d --name nginx -p 80:80 -v /docker/nginx:/etc/nginx/conf.d nginx:latest </p>

<p>说明： 使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/docker/nginx/conf.d 映射到容器的 /etc/nginx/conf.d</p>

<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</p>

<pre><code class="language-text">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-P: 随机端口映射，容器内部端口随机映射到主机的高端口
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h &quot;mars&quot;: 指定容器的hostname；
-e username=&quot;ritchie&quot;: 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；
--volume , -v: 绑定一个卷
</code></pre>

<p>注意： 关于容器的输出以及配置的文件一定要挂载到宿主机上<br/>
配置文件<br/>
日志文件<br/>
业务数据</p>

<p>数据卷容器：<br/>
创建数据卷容器 data<br/>
docker run -d --name data -v /home/godson/docker/nginx/conf.d:/etc/nginx/conf.d -v /home/godson/docker/mysql/conf:/etc/mysql hello-world</p>

<p>创建容器挂载到 data 容器数据卷上 (volumes-from参数)<br/>
docker run -d --name nginx -p 80:80 --volumes-from data nginx</p>

<ul>
<li>start/stop/restart</li>
</ul>

<pre><code class="language-text">start： 启动一个或多个已被停止的容器
stop： 停止一个或多个运行中的容器
restart: 重启一个或多个容器
</code></pre>

<ul>
<li><p>kill 杀掉一个运行中的容器</p></li>
<li><p>rm 删除一个或多个容器</p></li>
</ul>

<pre><code class="language-text">-f :通过SIGKILL信号强制删除一个运行中的容器
-l :移除容器间的网络连接，而非容器本身
-v :-v 删除与容器关联的卷
</code></pre>

<ul>
<li><p>docker rm -fv 删除容器服务</p></li>
<li><p>pause/unpause  暂停/恢复 容器中的所有进程</p></li>
<li><p>create 创建一个新容器，但是不启动它<br/>
语法同 run</p></li>
<li><p>exec</p></li>
</ul>

<pre><code class="language-text">&gt; docker exec -it nginx /bin/bash
-d :分离模式: 在后台运行
-i :即使没有附加也保持STDIN 打开
-t :分配一个伪终端
</code></pre>

<h2 id="toc_1">容器操作</h2>

<ul>
<li>ps  列出容器</li>
</ul>

<pre><code class="language-text">-a :显示所有的容器，包括未运行的。
-f :根据条件过滤显示的内容。
--format :指定返回值的模板文件。
-l :显示最近创建的容器。
-n :列出最近创建的n个容器。
--no-trunc :不截断输出。
-q :静默模式，只显示容器编号。
-s :显示总的文件大小。
</code></pre>

<ul>
<li>inspect 获取容器/镜像的元数据。<br/>
docker inspect -f &#39;{{.NetworkSettings.IPAddress}}&#39; nginx</li>
</ul>

<pre><code class="language-text">-f :指定返回值的模板文件。
-s :显示总的文件大小。
--type :为指定类型返回JSON。
</code></pre>

<ul>
<li>top</li>
<li>attach</li>
<li>events</li>
<li>logs</li>
</ul>

<pre><code class="language-text">-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail :仅列出最新N条容器日志
</code></pre>

<ul>
<li>wait</li>
<li>export</li>
<li>port  列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</li>
</ul>

<pre><code class="language-text">&gt; docker port nginx
80/tcp -&gt; 0.0.0.0:8080
</code></pre>

<h2 id="toc_2">容器rootfs命令</h2>

<ul>
<li>commit  从容器创建一个新的镜像。<br/>
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br/>
docker commit -a &quot;作者&quot; -m &quot;描述&quot; nginx  mynginx:v1</li>
<li>cp<br/>
容器和宿主机的文件传输 nginx:表示了容器目录<br/>
docker cp nginx:/etc/nginx/conf.ddefault.conf ./</li>
<li>diff</li>
</ul>

<h2 id="toc_3">镜像仓库</h2>

<ul>
<li>login</li>
<li>pull</li>
<li>push</li>
<li>search</li>
</ul>

<h2 id="toc_4">本地镜像管理</h2>

<ul>
<li>images  列出本地镜像。</li>
</ul>

<pre><code class="language-text">-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；
--digests :显示镜像的摘要信息；
-f :显示满足条件的镜像；
--format :指定返回值的模板文件；
--no-trunc :显示完整的镜像信息；
-q :只显示镜像ID。
</code></pre>

<ul>
<li>rmi</li>
<li>tag  标记本地镜像，将其归入某一仓库。</li>
</ul>

<pre><code class="language-text">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]

将镜像ubuntu:15.10标记为 w3cschool/ubuntu:v3 镜像

docker tag nginx w3cschool/ubuntu:v3
</code></pre>

<ul>
<li>build   使用Dockerfile创建镜像。</li>
</ul>

<pre><code class="language-text">&gt; docker build -t w3cschool/ubuntu:v1 ./
&gt; docker build -f /home/user/Dockerfile ./

--build-arg=[] :设置镜像创建时的变量；
--cpu-shares :设置 cpu 使用权重；
--cpu-period :限制 CPU CFS周期；
--cpu-quota :限制 CPU CFS配额；
--cpuset-cpus :指定使用的CPU id；
--cpuset-mems :指定使用的内存 id；
--disable-content-trust :忽略校验，默认开启；
-f :指定要使用的Dockerfile路径； -f /path/to/a/Dockerfile .
--force-rm :设置镜像过程中删除中间容器；
--isolation :使用容器隔离技术；
--label=[] :设置镜像使用的元数据；
-m :设置内存最大值；
--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；
--no-cache :创建镜像的过程不使用缓存；
--pull :尝试去更新镜像的新版本；
-q :安静模式，成功后只输出镜像ID；
--rm :设置镜像成功后删除中间容器；
--shm-size :设置/dev/shm的大小，默认值是64M；
--ulimit :Ulimit配置。
--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
--network: 默认 default。在构建期间设置RUN指令的网络模式
</code></pre>

<p>history<br/>
save<br/>
import</p>

<h2 id="toc_5">info|version</h2>

<p>info<br/>
version</p>

<p>获取 selinux 是否关闭<br/>
getenforce<br/>
暂时关闭<br/>
setenforce 1</p>

<p>vi /etc/sysconfig/selinux</p>

<p><img src="media/15855064473314/15855732599905.jpg" alt="" style="width:620px;"/></p>

<p>SELINUX=disable</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac vmware fusion 设置静态 IP 地址]]></title>
    <link href="http://www.throne4j.com/vm_fusion.html"/>
    <updated>2020-03-30T00:59:39+08:00</updated>
    <id>http://www.throne4j.com/vm_fusion.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">配置静态IP</h2>

<h3 id="toc_1">把网络配置改成nat模式</h3>

<h3 id="toc_2">通过Mac终端进入VMware Fusion的vmnet8目录</h3>

<pre><code class="language-text">cd /Library/Preferences/VMware Fusion/vmnet8
</code></pre>

<ul>
<li>查看nat.conf内容</li>
</ul>

<p><img src="media/15855011797141/15855038592835.jpg" alt=""/></p>

<ul>
<li>查看cat dhcpd.conf</li>
</ul>

<p><img src="media/15855011797141/15855037846968.jpg" alt=""/></p>

<p>注意range 这个是虚拟机允许选择的静态ip地址范围，自定义的静态ip地址必须要在这个范围内</p>

<h3 id="toc_3">登录虚拟机 CentOS7</h3>

<p>进入虚拟机的network-scripts目录</p>

<pre><code class="language-text">cd /etc/sysconfig/network-scripts
</code></pre>

<p>找到ifcfg-en开头的文件,上图中我的是ifcfg-ens33<br/>
修改前：</p>

<pre><code class="language-text">&gt; cd /etc/sysconfig/network-scripts
&gt; vim ifcfg-ens33

TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
</code></pre>

<p>我们将它改成如下配置:</p>

<pre><code class="language-text">TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=no
IPV6_DEFROUTE=no
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
IPADDR=172.16.65.134
GATEWAY=172.16.65.2
NETMASK=255.255.255.0
DNS1=114.114.114.114
</code></pre>

<p>保存之后，重启服务使修改生效</p>

<p>service network restart<br/>
ping一下百度看看，成功Ping到</p>

<p>接下来我们就可以通过SecureCRT等工具远程连接了，有一点请记住，如果你换了一个地方上网的话，可能会发现你的虚拟机有不通了，那是因为DNS地址发生了变化，此时只需要再次编辑ifcfg-enxxx文件，然后加上你现在网络的DNS地址即可</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 7 主机名的修改]]></title>
    <link href="http://www.throne4j.com/hostnamectl.html"/>
    <updated>2020-03-30T00:32:37+08:00</updated>
    <id>http://www.throne4j.com/hostnamectl.html</id>
    <content type="html"><![CDATA[
<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如godson）。</p>

<p>在CentOS 7中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>

<ol>
<li>要查看主机名相关的设置：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl 
   Static hostname: localhost.localdomain
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 50565701419746a08905ba05b882cd40
           Boot ID: a599742730414a448408e1d7a9bbf9d3
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-957.el7.x86_64
      Architecture: x86-64
</code></pre>

<ol>
<li>只查看静态、瞬态或灵活主机名，分别使用“--static”，“--transient”或“--pretty”选项。</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl --static
localhost.localdomain
[[godson@localhost ~]$ hostnamectl --transient
localhost.localdomain
[godson@localhost ~]$ hostnamectl --pretty
</code></pre>

<ol>
<li>要同时修改所有三个主机名：静态、瞬态和灵活主机名：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ se
[godson@localhost ~]$ hostnamectl --pretty
godson
[godson@localhost ~]$ hostnamectl --static
godson
[godson@localhost ~]$ hostnamectl --transient
godson
</code></pre>

<p>就像上面展示的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。一旦修改了静态主机名，/etc/hostname 将被自动更新。然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS 7。否则系统再启动时会很慢。</p>

<ol>
<li>手动更新/etc/hosts</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ vim /etc/hosts
127.0.0.1      godson
#127.0.0.1  localhost localhost.localdomain localhost4 localhost4.localdomain
::1        localhost localhost.localdomain localhost6 localhost6.localdomain
</code></pre>

<ol>
<li>重启CentOS 7 之后</li>
</ol>

<pre><code class="language-text">[godson@godson ~]# hostname
godson
[godson@godson ~]# hostnamectl --transient
godson
[godson@godson ~]# hostnamectl --static
godson
[godson@godson ~]# hostnamectl --pretty
godson
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh 免密登录服务器]]></title>
    <link href="http://www.throne4j.com/SSH.html"/>
    <updated>2020-03-30T00:02:55+08:00</updated>
    <id>http://www.throne4j.com/SSH.html</id>
    <content type="html"><![CDATA[
<p>现在有服务器 Server-A,用户名: jetty, ip: 172.16.65.133, 现在希望从本地能够免密访问 Server-A。<br/>
这里我们需要 ssh-keygen 命令来帮我们完成这项任务。</p>

<p>ssh-keygen: 为了让两个linux机器之间使用ssh不需要用户名和密码。<br/>
采用了数字签名RSA或者DSA来完成这个操作。</p>

<h2 id="toc_0">生成本地公钥和私钥</h2>

<pre><code class="language-text">&gt; ssh-keygen -t rsa -C &#39;注释&#39;
</code></pre>

<p>本地机器 .ssh 目录下生成文件 :  id_rsa  id_rsa.pub</p>

<h2 id="toc_1">将本地生成的id_rsa.pub(公钥)追加到 Server-A 的目录~/.ssh/authorized_keys文件中</h2>

<pre><code class="language-text">&gt; ssh-copyid jetty@172.16.65.133
</code></pre>

<p>上传文件方式：</p>

<ul>
<li>cat ~/.ssh/id_rsa.pub | ssh -p 22 jetty@172.16.65.133 &#39;cat &gt;&gt; ~/.ssh/authorized_keys&#39;</li>
<li>ssh-copyid jetty@172.16.65.133</li>
<li>scp -P 22 ~/.ssh/id_rsa.pub jetty@172.16.65.133:~/。<br/>
注意： Server-A 服务器上.ssh 目录的权限为700，其下文件authorized_keys和私钥的权限为600。否则会因为权限问题导致无法免密码登录。</li>
</ul>

<p>上面步骤做完之后我们就可以免密登录 Server-A 了</p>

<pre><code class="language-text">&gt; ssh jetty@172.16.65.133
Last login: Sun Mar 29 12:17:53 2020 from 172.16.65.1
-bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory
&gt; [jetty@jetty ~]$ 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初见 Docker]]></title>
    <link href="http://www.throne4j.com/15854879924872.html"/>
    <updated>2020-03-29T21:19:52+08:00</updated>
    <id>http://www.throne4j.com/15854879924872.html</id>
    <content type="html"><![CDATA[
<p>Docker官方网址: <a href="https://docs.docker.com/">https://docs.docker.com/</a> 英文地址<br/>
Docker中文网址: <a href="http://www.docker.org.cn/">http://www.docker.org.cn/</a> 中文地址</p>

<h2 id="toc_0">docker 架构</h2>

<p>Images </p>

<p>Container</p>

<p>Client</p>

<p>Host</p>

<p>Registry</p>

<p>Machine</p>

<h2 id="toc_1">docker 组件</h2>

<ol>
<li><p>镜像 image<br/>
Docker运行容器之前需要本地存在对应的镜像。镜像是用来创建Docker容器的。一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序，在Docker Hub里面有大量现成的镜像提供下载，Docker的镜像是只读的，一个镜像可以创建多个容器。</p></li>
<li><p>容器 Container<br/>
Docker利用容器来进行开发，运行应用。容器是镜像创建的实列，它可以启动，开始，停止，删除，每个容器都是相互隔离的，保证安全的平台。</p></li>
<li><p>仓库 Repository<br/>
仓库是集中存放镜像文件的地方。每个仓库中又包含了多个镜像，每个镜像有不同的标签(TAG)</p></li>
</ol>

<h2 id="toc_2">docker 安装</h2>

<p>1、删除 Linux 机器上已存在的 docker 程序</p>

<pre><code class="language-text">&gt; sudo yum list installed | grep docker
&gt; sudo yum  -y remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
</code></pre>

<p>删除 docker 老的镜像</p>

<pre><code class="language-text">&gt; rm -rf /var/lib/docker
</code></pre>

<p>2、安装 docker 程序</p>

<ul>
<li>安装基本的系统工具<br/>
sudo yum install -y yum-utils device-mapper-persistent-data lvm2</li>
<li><p>配置 yum 源<br/>
yum-config-manager --add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></li>
<li><p>查看可安装的 docker 版本<br/>
yum list docker-ce --showduplicates | sort -r</p></li>
<li><p>安装 docker</p></li>
</ul>

<pre><code class="language-text">sudo yum install docker-ce(最新版)

sudo yum install -y containerd.io-1.2.13-3.1.el7 docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9-3.el7(指定版本)
</code></pre>

<ul>
<li><p>配置 docker 开机启动<br/>
sudo systemctl start docker<br/>
sudo systemctl enable docker</p></li>
<li><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)<br/>
docker version</p></li>
<li><p>更换 docker 镜像仓库为国内仓库<br/>
修改或创建daemon.json文件：<br/>
vim /etc/docker/daemon.json<br/>
内容如下：<br/>
{<br/>
&quot;registry-mirrors&quot;:[&quot;<a href="https://registry.docker-cn.com%22">https://registry.docker-cn.com&quot;</a>]<br/>
}</p></li>
<li><p>加载 daemon.json 文件<br/>
sudo systemctl daemon-reload</p></li>
<li><p>重启 docker<br/>
systemctl restart docker</p></li>
<li><p>验证 docker 是否完成安装<br/>
执行 sudo docker verxion,完成安装如下图所示<br/>
<img src="media/15854879924872/15855354770652.jpg" alt="" style="width:484px;"/></p></li>
</ul>

<p>用非 root 账户安装完 docker 之后会,执行 docker 命令会遇到这样一个问题：</p>

<pre><code class="language-text">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied
</code></pre>

<p>原因： docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p>

<p>解决方法：</p>

<pre><code class="language-text">&gt; sudo groupadd docker     #添加docker用户组
&gt; sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中
&gt; newgrp docker     #更新用户组
&gt; docker ps    #测试docker命令是否可以使用sudo正常使用
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说Reactor模式]]></title>
    <link href="http://www.throne4j.com/15586898110083.html"/>
    <updated>2019-05-24T17:23:31+08:00</updated>
    <id>http://www.throne4j.com/15586898110083.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概念</h2>

<p>reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，其他框架都或多或少地用到了Reactor框架。 </p>

<p>在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 </p>

<p>reactor模式与外观模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>

<h2 id="toc_1">优点</h2>

<p>  1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的； <br/>
  2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； <br/>
  3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； <br/>
  4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>

<h2 id="toc_2">缺点</h2>

<p> 1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 <br/>
 2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 <br/>
 3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。<br/>
 </p>

<h2 id="toc_3">架构模式</h2>

<h3 id="toc_4">1、架构图</h3>

<p> <img src="media/15586898110083/15590230630201.jpg" alt="" style="width:556px;"/></p>

<h3 id="toc_5">2、构成</h3>

<p>Handles ：表示操作系统管理的资源，我们可以理解为fd。</p>

<p>Synchronous Event Demultiplexer ：同步事件分离器，阻塞等待Handles中的事件发生。</p>

<p>Initiation Dispatcher ：初始分派器，作用为添加Event handler（事件处理器）、删除Event handler以及分派事件给Event handler。也就是说，Synchronous Event Demultiplexer负责等待新事件发生，事件发生时通知Initiation Dispatcher，然后Initiation Dispatcher调用event handler处理事件。</p>

<p>Event Handler ：事件处理器的接口<br/>
Concrete Event Handler ：事件处理器的实际实现，而且绑定了一个Handle。因为在实际情况中，我们往往不止一种事件处理器，因此这里将事件处理器接口和实现分开，与C++、Java这些高级语言中的多态类似。</p>

<h3 id="toc_6">3、模块交互</h3>

<p> 1）我们注册Concrete Event Handler到Initiation Dispatcher中。 <br/>
 2）Initiation Dispatcher调用每个Event Handler的get_handle接口获取其绑定的Handle。 <br/>
 3）Initiation Dispatcher调用handle_events开始事件处理循环。在这里，Initiation Dispatcher会将步骤2获取的所有Handle都收集起来，使用Synchronous Event Demultiplexer来等待这些Handle的事件发生。 <br/>
 4）当某个（或某几个）Handle的事件发生时，Synchronous Event Demultiplexer通知Initiation Dispatcher。 <br/>
 5）Initiation Dispatcher根据发生事件的Handle找出所对应的Handler。 <br/>
 6）Initiation Dispatcher调用Handler的handle_event方法处理事件。</p>

<pre><code class="language-text">import java.io.IOException;  
import java.net.InetAddress;  
import java.net.InetSocketAddress;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.ServerSocketChannel;  
import java.util.Iterator;  
import java.util.Set;  

/** 
 * 反应器模式 
 * 用于解决多用户访问并发问题 
 *  
 * 举个例子：餐厅服务问题 
 *  
 * 传统线程池做法：来一个客人(请求)去一个服务员(线程) 
 * 反应器模式做法：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员” 
 *  
 * @author linxcool 
 */  
public class Reactor implements Runnable{  
    public final Selector selector;  
    public final ServerSocketChannel serverSocketChannel;  

    public Reactor(int port) throws IOException{  
        selector=Selector.open();  
        serverSocketChannel=ServerSocketChannel.open();  
        InetSocketAddress inetSocketAddress=new InetSocketAddress(InetAddress.getLocalHost(),port);  
        serverSocketChannel.socket().bind(inetSocketAddress);  
        serverSocketChannel.configureBlocking(false);  

        //向selector注册该channel    
        SelectionKey selectionKey=serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  

        //利用selectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor   
        selectionKey.attach(new Acceptor(this));  
    }  

    @Override  
    public void run() {  
        try {  
            while(!Thread.interrupted()){  
                selector.select();  
                Set&lt;SelectionKey&gt; selectionKeys= selector.selectedKeys();  
                Iterator&lt;SelectionKey&gt; it=selectionKeys.iterator();  
                //Selector如果发现channel有OP_ACCEPT或READ事件发生，下列遍历就会进行。  
                while(it.hasNext()){  
                    //来一个事件 第一次触发一个accepter线程    
                    //以后触发SocketReadHandler  
                    SelectionKey selectionKey=it.next();  
                    dispatch(selectionKey);  
                    selectionKeys.clear();  
                }  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 运行Acceptor或SocketReadHandler 
     * @param key 
     */  
    void dispatch(SelectionKey key) {  
        Runnable r = (Runnable)(key.attachment());    
        if (r != null){    
            r.run();  
        }    
    }    

} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.channels.SocketChannel;  

public class Acceptor implements Runnable{  
    private Reactor reactor;  
    public Acceptor(Reactor reactor){  
        this.reactor=reactor;  
    }  
    @Override  
    public void run() {  
        try {  
            SocketChannel socketChannel=reactor.serverSocketChannel.accept();  
            if(socketChannel!=null)//调用Handler来处理channel  
                new SocketReadHandler(reactor.selector, socketChannel);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.ByteBuffer;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.SocketChannel;  

public class SocketReadHandler implements Runnable{  
    private SocketChannel socketChannel;  
    public SocketReadHandler(Selector selector,SocketChannel socketChannel) throws IOException{  
        this.socketChannel=socketChannel;  
        socketChannel.configureBlocking(false);  

        SelectionKey selectionKey=socketChannel.register(selector, 0);  

        //将SelectionKey绑定为本Handler 下一步有事件触发时，将调用本类的run方法。    
        //参看dispatch(SelectionKey key)    
        selectionKey.attach(this);  

        //同时将SelectionKey标记为可读，以便读取。    
        selectionKey.interestOps(SelectionKey.OP_READ);    
        selector.wakeup();  
    }  

    /** 
     * 处理读取数据 
     */  
    @Override  
    public void run() {  
        ByteBuffer inputBuffer=ByteBuffer.allocate(1024);  
        inputBuffer.clear();  
        try {  
            socketChannel.read(inputBuffer);  
            //激活线程池 处理这些request  
            //requestHandle(new Request(socket,btt));   
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
</code></pre>

<h2 id="toc_7">总结</h2>

<p>reactor模式是javaNIO非堵塞技术的实现原理，我们不仅要知道其原理流程，还要知道其代码实现，当然这个reactor模式不仅仅在NIO中实现，而且在redies等其他地方也出现过，说明这个模式还是比较实用的，尤其是在多线程高并发的情况下使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[熔断模式]]></title>
    <link href="http://www.throne4j.com/15586676190905.html"/>
    <updated>2019-05-24T11:13:39+08:00</updated>
    <id>http://www.throne4j.com/15586676190905.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一 问题的产生</h2>

<p>在大型的分布式系统中，通常需要调用或操作远程的服务或者资源，这些远程的服务或者资源由于调用者不可以控的原因比如网络连接缓慢，资源被占用或者暂时不可用等原因，导致对这些远程资源的调用失败。这些错误通常在稍后的一段时间内可以恢复正常。</p>

<p>但是，在某些情况下，由于一些无法预知的原因导致结果很难预料，远程的方法或者资源可能需要很长的一段时间才能修复。这种错误严重到系统的部分失去响应甚至导致整个服务的完全不可用。在这种情况下，采用不断地重试可能解决不了问题，相反，应用程序在这个时候应该立即返回并且报告错误。</p>

<p>通常，如果一个服务器非常繁忙，那么系统中的部分失败可能会导致 “连锁失效”（cascading failure）。比如，某个操作可能会调用一个远程的WebService，这个service会设置一个超时的时间，如果响应时间超过了该时间就会抛出一个异常。但是这种策略会导致并发的请求调用同样的操作会阻塞，一直等到超时时间的到期。这种对请求的阻塞可能会占用宝贵的系统资源，如内存，线程，数据库连接等等，最后这些资源就会消耗殆尽，使得其他系统不相关的部分所使用的资源也耗尽从而拖累整个系统。在这种情况下，操作立即返回错误而不是等待超时的发生可能是一种更好的选择。只有当调用服务有可能成功时我们再去尝试。</p>

<h2 id="toc_1">解决之道</h2>

<p>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>

<p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。<br/>
<img src="media/15586676190905/15586775537030.jpg" alt=""/><br/>
熔断器可以使用状态机来实现，内部模拟以下几种状态。</p>

<ul>
<li>闭合（closed）状态： 对应用程序的请求能够直接引起方法的调用。代理类维护了最近调用失败的次数，如果某次调用失败，则使失败次数加1。如果最近失败次数超过了在给定时间内允许失败的阈值，则代理类切换到断开(Open)状态。此时代理开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误。</li>
<li>断开(Open)状态：在该状态下，对应用程序的请求会立即返回错误响应。</li>
<li>半断开（Half-Open）状态：允许对应用程序的一定数量的请求可以去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态(并且将错误计数器重置)；如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开方式，然后开始重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。<br/>
各个状态之间的转换如下图：
<img src="media/15586676190905/15586778712353.jpg" alt=""/></li>
</ul>

<p>在Close状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。触发熔断器进入断开状态的失败阈值只有在特定的时间间隔内，错误次数达到指定错误次数的阈值才会产生。在Half-Open状态中使用的连续成功次数计数器记录调用的成功次数。当连续调用成功次数达到某个指定值时，切换到闭合状态，如果某次调用失败，立即切换到断开状态，连续成功调用次数计时器在下次进入半断开状态时归零。</p>

<p>实现熔断器模式使得系统更加稳定和有弹性，在系统从错误中恢复的时候提供稳定性，并且减少了错误对系统性能的影响。它通过快速的拒绝那些试图有可能调用会导致错误的服务，而不会去等待操作超时或者永远不会不返回结果来提高系统的响应事件。如果熔断器设计模式在每次状态切换的时候会发出一个事件，这种信息可以用来监控服务的运行状态，能够通知管理员在熔断器切换到断开状态时进行处理。</p>

<p>可以对熔断器模式进行定制以适应一些可能会导致远程服务失败的特定场景。比如，可以在熔断器中对超时时间使用不断增长的策略。在熔断器开始进入断开状态的时候，可以设置超时时间为几秒钟，然后如果错误没有被解决，然后将该超时时间设置为几分钟，依次类推。在一些情况下，在断开状态下我们可以返回一些错误的默认值，而不是抛出异常。</p>

<h2 id="toc_2">要考虑的因素</h2>

<p>在实现熔断器模式的时候，以下这些因素需可能需要考虑：</p>

<ul>
<li>异常处理：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li>
<li>异常的类型：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li>
<li>日志：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。</li>
<li>测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li>
<li>手动重置：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。</li>
<li>并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。</li>
<li>资源的差异性：使用单个熔断器时，一个资源如果​​有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li>
<li>加快熔断器的熔断操作:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么可以断定出不建议立即重试，而是应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li>
<li>重复失败请求：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li>
</ul>

<h2 id="toc_3">使用场景</h2>

<p>应该使用该模式来：</p>

<ul>
<li>防止应用程序直接调用那些很可能会调用失败的远程服务或共享资源。</li>
</ul>

<p>不适合的场景</p>

<ul>
<li>对于应用程序中的直接访问本地私有资源，比如内存中的数据结构，如果使用熔断器模式只会增加系统额外开销。</li>
<li>不适合作为应用程序中业务逻辑的异常处理替代品</li>
</ul>

<p>根据上面的状态切换图，我们很容易实现一个基本的熔断器，只需要在内部维护一个状态机，并定义好状态转移的规则，可以使用State模式来实现。首先，我们定义一个表示状态转移操作的抽象类CircuitBreakerState：</p>

<pre><code class="language-java">public abstract class CircuitBreakerState
{
    //熔断器
    protected static CircuitBreaker circuitBreaker;
    
    protected CircuitBreakerState(CircuitBreaker circuitBreaker) {
        this.circuitBreaker = circuitBreaker;
    }
    // 调用受保护方法之前处理的操作
    public void protectedCodeIsAboutToBeCalled() {
        //如果是断开状态，直接返回,然后坐等超时转换到半断开状态
        if (circuitBreaker.isOpen) {
            throw new OpenCircuitException();
        }
    }

    // 受熔断器保护的方法调用成功之后的操作
    public virtual void protectedCodeHasBeenCalled() {
        circuitBreaker.IncreaseSuccessCount();
    }

    //受熔断器保护的方法调用发生异常操作后的操作
    public virtual void actUponException(Exception e) {
        //增加失败次数计数器，并且保存错误信息
        circuitBreaker.increaseFailureCount(e);
        //重置连续成功次数
        circuitBreaker.resetConsecutiveSuccessCount();
    }
}
</code></pre>

<p>抽象类中，状态机CircuitBreaker通过构造函数注入；当发生错误时，我们增加错误计数器，并且重置连续成功计数器，在增加错误计数器操作中，同时也记录了出错的异常信息。</p>

<p>然后在分别实现表示熔断器三个状态的类。首先实现闭合状态CloseState：</p>

<pre><code class="language-java">public class ClosedState extends CircuitBreakerState {
    public ClosedState(CircuitBreaker circuitBreaker) {
        super(circuitBreaker)
        //重置失败计数器
        circuitBreaker.resetFailureCount();
    }
    
    @override
    public void actUponException(Exception e) {
        super.actUponException(e);
        //如果失败次数达到阈值，则切换到断开状态
        if (circuitBreaker.failureThresholdReached()){
            circuitBreaker.moveToOpenState();
        }
    }
}
</code></pre>

<p>在闭合状态下，如果发生错误，并且错误次数达到阈值，则状态机切换到断开状态。断开状态OpenState的实现如下：</p>

<pre><code class="language-java">public class OpenState extends CircuitBreakerState {
    private final static Timer timer;

    public OpenState(CircuitBreaker circuitBreaker) {
        timer = new Timer(circuitBreaker.Timeout.TotalMilliseconds);
        timer.Elapsed += TimeoutHasBeenReached;
        timer.AutoReset = false;
        timer.Start();
    }

    // 断开超过设定的阈值，自动切换到半断开状态
    private void timeoutHasBeenReached(object sender, ElapsedEventArgs e) {
        circuitBreaker.moveToHalfOpenState();
    }

    public void protectedCodeIsAboutToBeCalled() {
        super.protectedCodeIsAboutToBeCalled();
        throw new OpenCircuitException();
    }
}
</code></pre>

<p>断开状态内部维护一个计数器，如果断开达到一定的时间，则自动切换到版断开状态，并且，在断开状态下，如果需要执行操作，则直接抛出异常。</p>

<p>最后半断开Half-Open状态实现如下：</p>

<pre><code class="language-java">public class HalfOpenState extends CircuitBreakerState {
    public HalfOpenState(CircuitBreaker circuitBreaker)  {
        // 重置连续成功计数
        circuitBreaker.resetConsecutiveSuccessCount();
    }

    public override void actUponException(Exception e) {
        super.ActUponException(e);
        //只要有失败，立即切换到断开模式
        circuitBreaker.moveToOpenState();
    }
    
    public void protectedCodeHasBeenCalled() {
        super.ProtectedCodeHasBeenCalled();
        //如果连续成功次数达到阈值，切换到闭合状态
        if (circuitBreaker.consecutiveSuccessThresholdReached()) {
            circuitBreaker.moveToClosedState();
        }
    }
}
</code></pre>

<p>切换到半断开状态时，将连续成功调用计数重置为0，当执行成功的时候，自增改字段，当达到连读调用成功次数的阈值时，切换到闭合状态。如果调用失败，立即切换到断开模式。</p>

<p>有了以上三种状态切换之后，我们要实现CircuitBreaker类了:</p>

<pre><code class="language-java">@data
public class CircuitBreaker {
    private final static object monitor = new object();
    private CircuitBreakerState state;
    private int failureCount;
    public int consecutiveSuccessCount;
    public int failureThreshold;
    public int consecutiveSuccessThreshold;
    public TimeSpan Timeout;
    public Exception LastException;

    public CircuitBreaker(int failedThreshold, int consecutiveSuccessThreshold, TimeSpan timeout) {
        if (failedThreshold &lt; 1 || consecutiveSuccessThreshold &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;threshold&quot;, &quot;Threshold should be greater than 0&quot;);
        }

        if (timeout.TotalMilliseconds &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;timeout&quot;, &quot;Timeout should be greater than 0&quot;);
        }

        failureThreshold = failedthreshold;
        consecutiveSuccessThreshold = consecutiveSuccessThreshold;
        timeout = timeout;
        moveToClosedState();
    }
    
    public bool IsClosed {
        return state is ClosedState; 
    }

    public bool IsOpen {
        return state == OpenState; 
    }

    public bool IsHalfOpen {
       return state is HalfOpenState; }
    }

   public void moveToClosedState() {
        state = new ClosedState(this);
    }

   public void moveToOpenState() {
        state = new OpenState(this);
    }

    public void moveToHalfOpenState() {
        state = new HalfOpenState(this);
    }

    public void increaseFailureCount(Exception ex) {
        LastException = ex;
        failureCount++;
    }

    public void resetFailureCount() {
        failureCount = 0;
    }

    public bool failureThresholdReached() {
        return failureCount &gt;= failureThreshold;
    }

    public void increaseSuccessCount() {
        consecutiveSuccessCount++;
    }

    public void resetConsecutiveSuccessCount() {
        consecutiveSuccessCount = 0;
    }
    
    public bool consecutiveSuccessThresholdReached() {
        return consecutiveSuccessCount &gt;= consecutiveSuccessThreshold;
    }
    
    // 执行代理方法， action 需要执行的代理方法
    public void attemptCall(function protectedCode) {
       synchronized (monitor) {
            state.protectedCodeIsAboutToBeCalled();
        }
    
        try {
            protectedCode();
        } catch (Exception e) {
            synchronized (monitor) {
                state.actUponException(e);
            }
            throw e;
        }
    
        synchronized (monitor) {
            state.protectedCodeHasBeenCalled();
        }
    }
    
    public void Close() {
       synchronized (monitor) {
            moveToClosedState();
        }
    }
    
    public void Open() {
       synchronized (monitor) {
            moveToOpenState();
        }
    }
}
</code></pre>

<p>在该类中</p>

<ul>
<li><p>首先： 定义了一些记录状态的变量，如failureCount，consecutiveSuccessCount 记录失败次数，连续成功次数，以及failureThreshold，consecutiveSuccessThreshold记录最大调用失败次数，连续调用成功次数。这些对象对外部来说是只读的。</p></li>
<li><p>定义了一个 circuitBreakerState类型的state变量，以表示当前系统的状态。</p></li>
<li><p>定义了一些列获取当前状态的方法isOpen, isClose, isHalfOpen,以及表示状态转移的方法moveToOpenState，moveToClosedState等，这些方法比较简单，根据名字即可看出用意。</p></li>
<li><p>然后，可以通过构造函数将在Close状态下最大失败次数，HalfOpen状态下使用的最大连续成功次数，以及Open状态下的超时时间通过构造函数传进来：</p></li>
<li><p>在初始状态下，熔断器切换到闭合状态。</p></li>
<li><p>然后，可以通过attempCall调用，传入期望执行的代理方法，该方法的执行受熔断器保护。这里使用了锁来处理并发问题。</p></li>
<li><p>最后，提供Close和Open两个方法来手动切换当前状态。</p></li>
</ul>

<h2 id="toc_4">测试</h2>

<p>以上的熔断模式，我们可以对其建立单元测试。</p>

<p>首先我们编写几个帮助类以模拟连续执行次数：</p>

<pre><code class="language-java">private static void CallXAmountOfTimes(function codeToCall, int timesToCall) {
    for (int i = 0; i &lt; timesToCall; i++) {
        codeToCall();
    }
}
</code></pre>

<p>以下类用来抛出特定异常：</p>

<pre><code class="language-java">private static void AssertThatExceptionIsThrown&lt;T&gt;(Action code) where T : Exception {
    try {
        code();
    } catch (T) {
        return;
    }

    Assert.Fail(&quot;Expected exception of type {0} was not thrown&quot;, typeof(T).FullName);
}
</code></pre>

<p>然后，使用NUnit，可以建立如下Case：</p>

<pre><code class="language-java">@test
public void ClosesIfProtectedCodeSucceedsInHalfOpenState()
{
    var stub = new Stub(10);
    //定义熔断器，失败10次进入断开状态
    //5秒后进入半断开状态
    //在半断开状态下，连续成功15次，进入闭合状态
    CircuitBreaker circuitBreaker = new CircuitBreaker(10, 15, TimeSpan.FromMilliseconds(5000));
    Assert.That(circuitBreaker.IsClosed);
    //失败10次调用
    CallXAmountOfTimes(() =&gt; AssertThatExceptionIsThrown&lt;ApplicationException&gt;(() =&gt; circuitBreaker.AttemptCall(stub.DoStuff)), 10);

    Assert.AreEqual(10, circuitBreaker.FailureCount);

    Assert.That(circuitBreaker.IsOpen);

    //等待从Open转到HalfOpen
    Thread.Sleep(6000);
    Assert.That(circuitBreaker.IsHalfOpen);
    //成功调用15次
    CallXAmountOfTimes(()=&gt;circuitBreaker.AttemptCall(stub.DoStuff), 15);

    Assert.AreEqual(15, circuitBreaker.ConsecutiveSuccessCount);
    Assert.AreEqual(0, circuitBreaker.FailureCount);
    Assert.That(circuitBreaker.IsClosed);
}
</code></pre>

<p>这个Case模拟了熔断器中状态的转换。首先初始化时，熔断器处于闭合状态，然后连续10次调用抛出异常，这时熔断器进去了断开状态，然后让线程等待6秒，此时在第5秒的时候，状态切换到了半断开状态。然后连续15次成功调用，此时状态又切换到了闭合状态。</p>

<p>七 结论<br/>
在应用系统中，我们通常会去调用远程的服务或者资源(这些服务或资源通常是来自第三方)，对这些远程服务或者资源的调用通常会导致失败，或者挂起没有响应，直到超时的产生。在一些极端情况下，大量的请求会阻塞在对这些异常的远程服务的调用上，会导致一些关键性的系统资源耗尽，从而导致级联的失败，从而拖垮整个系统。熔断器模式在内部采用状态机的形式，使得对这些可能会导致请求失败的远程服务进行了包装，当远程服务发生异常时，可以立即对进来的请求返回错误响应，并告知系统管理员，将错误控制在局部范围内，从而提高系统的稳定性和可靠性。</p>

<p>本文首先介绍了熔断器模式使用的场景，能够解决的问题，以及需要考虑的因素，最后使用代码展示了如何实现一个简单的熔断器，并且给出了测试用例，希望这些对您有帮助，尤其是在当您的系统调用了外部的远程服务或者资源，同时访问量又很大的情况下对提高系统的稳定性和可靠性有所帮助。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看远程mysql 主机的 binlog 日志]]></title>
    <link href="http://www.throne4j.com/15857296160676.html"/>
    <updated>2020-04-01T16:26:56+08:00</updated>
    <id>http://www.throne4j.com/15857296160676.html</id>
    <content type="html"><![CDATA[
<p>show master status;</p>

<p>show binary logs;</p>

<p>show binlog events in &#39;mysql-bin.000030&#39;;</p>

<p>c查看<br/>
show global variables like &quot;%binlog_format%&quot;;</p>

<pre><code class="language-text">mysqlbinlog -u temp_admin  -h psi.mysql.test.tcit.cc -P 3306 --read-from-remote-server -p  --base64-output=&quot;decode-rows&quot; -v  --start-datetime=&#39;2020-04-01 14:00:00&#39; --stop-datetime=&#39;2020-04-01 16:00:00&#39;  mysql-bin.000030 &gt; xxx.txt
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThreadLocal源码分析以及使用]]></title>
    <link href="http://www.throne4j.com/ThreadLocal.html"/>
    <updated>2020-04-09T22:54:53+08:00</updated>
    <id>http://www.throne4j.com/ThreadLocal.html</id>
    <content type="html"><![CDATA[
<p>ThreadLocal该类提供线程局部变量，起到线程隔离的作用。</p>

<h2 id="toc_0">ThreadLocal结构分析</h2>

<ul>
<li>首先我们看下ThreadLocal和Thread的它们之间的关系，如下图所示：</li>
</ul>

<p><img src="media/15864440934982/15865132297584.jpg" alt=""/></p>

<p><strong>Thread类内部声明了一个ThreadLocal.ThreadLocalMap类型的变量 threadLocals</strong>，ThreadLocal类负责维护ThreadLocal与Thread 之间关系的 ThreadLocalMap散列映射。</p>

<h2 id="toc_1">ThreadLocal的源码解析</h2>

<p><img src="media/15864440934982/15865038471517.jpg" alt=""/></p>

<p>我们一起来看下ThreadLocal 内部代码</p>

<pre><code class="language-java">// 创建线程和ThreadLocal的关联映射
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

// 获取线程 t 的threadLocalMap
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

// 设置当前线程的局部变量值
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

//获取当前线程的局部变量值
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

// 设置初始值
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}

// 移除此线程局部变量的当前线程值。
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
</code></pre>

<h2 id="toc_2">ThreadLocalMap解析</h2>

<h3 id="toc_3">ThreadLocalMap源码分析</h3>

<p><img src="media/15864440934982/15865034564443.jpg" alt=""/></p>

<pre><code class="language-java">
private Entry getEntry(ThreadLocal&lt;?&gt; key) {
    int i = key.threadLocalHashCode &amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;&amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}

private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key)
            return e;
        // k已经过时，被垃圾回收啦
        if (k == null) 
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}

private void set(ThreadLocal&lt;?&gt; key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    
    // 发生了hash碰撞问题，采用线性探测法，按照一定步长查找下一个位置，直到找到空余的位置存放value值为止,如果遇到过时的局部变量值，则将过时的value值替换为新的value值
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == key) {
            e.value = value;
            return;
        }
        // 遇到过时的线程局部变量
        if (k == null) {
            // 用指定键的项替换set操作期间遇到的过时项。
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    // entry 条目个数大于表的扩容阈值的时候
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        // 重新调整table的大小。首先扫描整个表，删除陈旧的条目。如果这还不足以缩小表的大小，则将表的大小加倍。
        rehash();
}


private void remove(ThreadLocal&lt;?&gt; key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len - 1);
    for (Entry e = tab[i];  e != null;  e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear(); // 清除ThreadLocal引用
            // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
            expungeStaleEntry(i);
            return;
        }
    }
}

private void rehash() {
    // 通过重新哈希位于staleSlot和下一个空槽之间的任何可能碰撞的条目，删除陈旧的条
    expungeStaleEntries();

    // 使用较低的阈值加倍，以避免扩容滞后
    if (size &gt;= threshold - threshold / 4)
        resize();
}
</code></pre>

<h3 id="toc_4">ThreadLocal的引用关系</h3>

<p>ThreadLocal的引用关系 如下图所示：</p>

<p><img src="media/15864440934982/15865783936571.jpg" alt="" style="width:708px;"/></p>

<h4 id="toc_5">内存泄漏问题及解决办法</h4>

<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么下次gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链： <br/>
current thread 引用 -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value <br/>
永远无法回收，造成内存泄露。</p>

<p>针对这种情况ThreadLocalMap提供了一些防护措施：</p>

<ul>
<li><p>1、 getEntry(ThreadLocal&lt;?&gt; key)、set(ThreadLocal&lt;?&gt; key, Object value)提供了针对key为null的entry的擦除操作expungeStaleEntry(i)</p></li>
<li><p>2、 remove(ThreadLocal&lt;?&gt; key)方法内部提供了针对ThreadLocal的擦除操作</p></li>
</ul>

<p>如下代码所示：</p>

<pre><code class="language-java">public class ThreadLocalContext {

    private static final ThreadLocal&lt;Object&gt; UNKNOWN_THREAD_LOCAL = new ThreadLocal&lt;&gt;();

    public static Object get() {
        return UNKNOWN_THREAD_LOCAL.get();
    }

    public static void set(Object value) {
        UNKNOWN_THREAD_LOCAL.set(value);
    }

    public static void remove(){
        UNKNOWN_THREAD_LOCAL.remove();
    }
}

/**
 * ThreadLocal内存泄漏的风险演示
 * -XX:+PrintGCDetails -Xmx50m
 * @author goddess
 * @since 2020/4/8 23:16
 **/
public class ThreadOOM {

    static class UseData {
        private byte[] element = new byte[1024 * 1024 * 10];// 10M
    }

    static class UseThreadOOM implements Runnable {
        @Override
        public void run() {
            ThreadLocalContext.set(new UseData());
            //ThreadLocalContext.remove();
        }
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 3000; i++) {
                executorService.execute(new UseThreadOOM());
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }
}
</code></pre>

<p>放开ThreadLocalContext.remove的gc信息<br/>
<img src="media/15864440934982/15865803964880.jpg" alt="" style="width:1569px;"/></p>

<p>注释掉ThreadLocalContext.remove的部分gc信息：<br/>
<img src="media/15864440934982/15865798232002.jpg" alt="" style="width:1570px;"/></p>

<p><strong>方式1 的前提条件是当key为null的时候咱得去调用getEntry、set方法，单这并不是任何时候都会执行的操作，所以保险的做法就是手动调用ThreadLocal的remove函数，删除不再需要的ThreadLocal，防止内存泄露。</strong></p>

<h3 id="toc_6">Hash冲突怎么解决</h3>

<p>ThreadLocalMap当执行set(Object value)的时候可能会发生hash冲突，当发生了hash碰撞的时候，map采用了一种<strong>线性探测法(就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用,按照一定步长查找下一个位置，直到找到空余的位置存放value值为止)</strong></p>

<p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置，如下代码：</p>

<pre><code class="language-text">private static int nextIndex(int i, int len) {
    return ((i + 1 &lt; len) ? i + 1 : 0);
}
private static int prevIndex(int i, int len) {
    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);
}
</code></pre>

<p>如果有大量不同的ThreadLocal对象放入ThreadLocalMap中时发一次或多次hash冲突，就要多次执行线性探测法，则效率很低。</p>

<p><strong>建议：</strong> 由于存在hash冲突问题，每个线程只存一个ThreadLocal变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，可以避免hash碰撞引起效率低下的问题。</p>

<h2 id="toc_7">线程不安全问题</h2>

<p>记住一点，本次线程任务使用完ThreadLocal之后要调用threadLocal.remove()方法。当使用线程池的时候，线程执行完任务之后，线程并不会消亡，而是重新回到了线程池中，等待下次任务的分派。可能产生的问题：<strong>造成线程不安全的问题，访问threadLocal.get()获取的值可能不是自己预期的变量值</strong><br/>
看如下代码：</p>

<pre><code class="language-java">public class ThreadUnsafe {

    static class UseThreadUnsafe implements Runnable {
        private int value;

        UseThreadUnsafe(int value) {
            this.value = value;
        }

        @Override
        public void run() {
            Object o = ThreadLocalContext.get();
            if (o == null) {
                ThreadLocalContext.set(value+1);
            }
            System.out.println(Thread.currentThread().getName()+&quot; 线程局部变量表：&quot; + ThreadLocalContext.get());
            // tips：开启和注释的情况下完全不一样
            ThreadLocalContext.remove();
        }
    }


    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        try {
            for (int i = 0; i &lt; 6; i++) {
                executorService.execute(new UseThreadUnsafe(i));
            }
            System.out.println(&quot;pool execute over&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            executorService.shutdown();
        }
    }

}
</code></pre>

<p>开启的情况下：<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：5<br/>
pool-1-thread-3 线程局部变量表：4<br/>
pool-1-thread-1 线程局部变量表：6</p>

<p>注释的情况下：<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-2 线程局部变量表：2<br/>
pool-1-thread-1 线程局部变量表：1<br/>
pool-1-thread-3 线程局部变量表：3</p>

<hr/>

<p><strong>综上所述 ThreadLocal使用完变量之后，千万要记着调用ThreadLocal的remove()完成擦除操作</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程基础、线程之间的共享和协作]]></title>
    <link href="http://www.throne4j.com/15853612430664.html"/>
    <updated>2020-03-28T10:07:23+08:00</updated>
    <id>http://www.throne4j.com/15853612430664.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础概念</h2>

<ul>
<li>Cpu 核心数和线程数的关系<br/>
核心数:线程数 = 1:1<br/>
超线程技术引入以后<br/>
核心数:线程数 = 1:2</li>
<li><p>cpu 时间片轮转机制<br/>
轮转机制会公平的把 cpu 时间分配给各个进程，在线程的切换的过程中，会产生线程上下文开销，也称为 RR 调度</p></li>
<li><p>什么是进程和线程</p>
<ul>
<li><p>进程：操作系统进行资源分配的最小单位，进程内部有多个线程共享这个进程的资源，进程与进程之间相互独立</p></li>
<li><p>线程：cpu 调度的最小单位，必须依赖于进程而存在</p></li>
</ul></li>
<li><p>什么是并行和并发<br/>
并行：同一时刻，可以处理事情的能力。<br/>
并发：单位时间内，处理事情的能力。例如：1秒内，一个应用内可以处理10个提交任务，</p></li>
<li><p>高并发编程的意义和注意事项<br/>
操作系统会限制线程数量，以防线程耗尽系统资源，Linux：1000个；windows：2000个</p>
<ul>
<li>优点：
<ul>
<li>可以充分利用系统资源</li>
<li>加快系统对用户的响应速度</li>
</ul></li>
<li>弊端： 
<ul>
<li>存在资源竞争关系</li>
<li>可能会产生死锁</li>
<li>消耗系统资源</li>
</ul></li>
</ul></li>
</ul>

<hr/>

<h2 id="toc_1">java 语言的线程</h2>

<h3 id="toc_2">构建线程的方式</h3>

<p>Thread类、Runnable接口，Thread类是对线程的抽象，Runnable是对任务的抽象</p>

<h3 id="toc_3">停止线程方式：</h3>

<ul>
<li>interrupt()  中断线程通知，非强制打断，中断标志位设置为true(已中断)</li>
<li>isInterrupted()    判断线程是否要中断</li>
<li>static interrupted()  判断当前线程是否处于中断状态，中断标志位会进行重置</li>
</ul>

<p>*** 注意：***<br/>
stop()、destroy()、suspend()、resume()官方已作为废弃API处理</p>

<h3 id="toc_4">run()和 start()区别</h3>

<ul>
<li>run() 不会新启线程，可以视为普通的业务方法，执行run()方法，当前线程是主线程</li>
<li>start() 启动新线程</li>
</ul>

<h3 id="toc_5">join()</h3>

<p>ThreadA.join() 是先等待ThreadA运行至死亡</p>

<h3 id="toc_6">yield()</h3>

<p>将线程从运行态转到就绪态,让线程让出cpu资源</p>

<h3 id="toc_7">线程优先级</h3>

<p>1~10，缺省 5<br/>
thread.setPriority(int xx); 优先级不是特别靠谱的东西</p>

<h3 id="toc_8">守护线程</h3>

<p>守护线程是一种支持型线程，因为它主要被用作程序中 后台调度以及支持性工作。</p>

<p>线程的状态切换<br/>
<img src="media/15853612430664/15862720985637.jpg" alt="" style="width:937px;"/></p>

<h2 id="toc_9">线程间共享和互斥</h2>

<h3 id="toc_10">Synchronized 内置锁</h3>

<p>关于 Synchronized 是作用在对象上，在对象头中 有锁的标志位<br/>
对象锁<br/>
类锁</p>

<h3 id="toc_11">Lock</h3>

<h3 id="toc_12">volatile</h3>

<h3 id="toc_13">ThreadLocal</h3>

<p><a href="ThreadLocal.html">ThreadLocal源码分析以及使用</a></p>

<h2 id="toc_14">线程间协作</h2>

<h3 id="toc_15">等待/通知机制</h3>

<p>是指一个线程 A 调用了对象 X 的 wait()方法进入等待状态，而另一个线程 B 调用了对象 X的 notify()或者 notifyAll()方法，线程 A 收到通知后从对象 X 的 wait() 方法返回，进而执行后续操作。上述两个线程通过对象 X 来完成交互，而对象 上的 wait()和 notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通 知方之间的交互工作。</p>

<p>notify()： 通知一个在对象上等待的线程,使其从 wait 方法返回,而返回的前提是该线程 获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。 </p>

<p>notifyAll()： 通知所有等待在该对象上的线程 </p>

<p>wait() 调用该方法的线程进入 WAITING 状态,只有等待另外线程的通知或被中断 才会返回.需要注意,调用 wait()方法后,会释放对象的锁 </p>

<p>wait(long) 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n 毫秒,如果没有 通知就超时返回 wait (long,int) 对于超时时间更细粒度的控制,可以达到纳秒</p>

<p>等待和通知的标准范式 等待方遵循如下原则:</p>

<p>1）获取对象的锁。 <br/>
2）如果条件不满足，那么调用对象的 wait()方法，被通知后仍要检查条件。 <br/>
3）条件满足则执行对应的逻辑。</p>

<pre><code class="language-text">synchronized(obj) {
    while(obj.isOk()) {
        obj.wait();
    }
}
</code></pre>

<p>通知方遵循如下原则: </p>

<p>1）获得对象的锁。 <br/>
2）改变条件。 <br/>
3）通知所有等待在对象上的线程。</p>

<pre><code class="language-text">synchronized(obj) {
    obj.notifyAll();
}
</code></pre>

<p>在调用 wait（）、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait(）方法、notify()系列方法，进入 wait(）方法后，当前线程释放锁，在从 wait(）返回前，线程与其他线程竞 争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会 继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的 线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mysql索引]]></title>
    <link href="http://www.throne4j.com/15866068042885.html"/>
    <updated>2020-04-11T20:06:44+08:00</updated>
    <id>http://www.throne4j.com/15866068042885.html</id>
    <content type="html"><![CDATA[
<p>索引是帮助mysql高校获取数据的数据结构<br/>
在rdbms中，索引存储在硬盘中</p>

<p>为什么mysql要默认使用B+ tree而不是B树、AVL树</p>

<p>回表操作</p>

]]></content>
  </entry>
  
</feed>
