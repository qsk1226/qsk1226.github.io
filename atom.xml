<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-12-29T22:25:07+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[写时复制容器]]></title>
    <link href="http://www.throne4j.com/16092475446086.html"/>
    <updated>2020-12-29T21:12:24+08:00</updated>
    <id>http://www.throne4j.com/16092475446086.html</id>
    <content type="html"><![CDATA[
<ul>
<li>请先说说非并发集合中Fail-fast机制? </li>
<li>再为什么说ArrayList查询快而增删慢? 对比ArrayList说说</li>
<li>CopyOnWriteArrayList的增删改查实现原理? COW基于拷贝 </li>
<li>再说下弱一致性的迭代器原理是怎么样的? COWIterator<E> </li>
<li>CopyOnWriteArrayList为什么并发安全且性能比Vector好? </li>
<li>CopyOnWriteArrayList有何缺陷，说说其应用场景<br/>
## 写时复制容器 CopyOnWriteArrayList 分析</li>
</ul>

<h3 id="toc_0">内部类 COWIterator</h3>

<p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 UnsupportedOperationException。</p>

<pre><code class="language-java">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {
    /** Snapshot of the array */
    // 快照
    private final Object[] snapshot;
    /** Index of element to be returned by subsequent call to next.  */
    // 游标
    private int cursor;
    // 构造函数
    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }
    // 是否还有下一项
    public boolean hasNext() {
        return cursor &lt; snapshot.length;
    }
    // 是否有上一项
    public boolean hasPrevious() {
        return cursor &gt; 0;
    }
    // next项
    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() {
        if (! hasNext()) // 不存在下一项，抛出异常
            throw new NoSuchElementException();
        // 返回下一项
        return (E) snapshot[cursor++];
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() {
        if (! hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    }
    
    // 下一项索引
    public int nextIndex() {
        return cursor;
    }
    
    // 上一项索引
    public int previousIndex() {
        return cursor-1;
    }

    /**
        * Not supported. Always throws UnsupportedOperationException.
        * @throws UnsupportedOperationException always; {@code remove}
        *         is not supported by this iterator.
        */
    // 不支持remove操作
    public void remove() {
        throw new UnsupportedOperationException();
    }

    /**
        * Not supported. Always throws UnsupportedOperationException.
        * @throws UnsupportedOperationException always; {@code set}
        *         is not supported by this iterator.
        */
    // 不支持set操作
    public void set(E e) {
        throw new UnsupportedOperationException();
    }

    /**
        * Not supported. Always throws UnsupportedOperationException.
        * @throws UnsupportedOperationException always; {@code add}
        *         is not supported by this iterator.
        */
    // 不支持add操作
    public void add(E e) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void forEachRemaining(Consumer&lt;? super E&gt; action) {
        Objects.requireNonNull(action);
        Object[] elements = snapshot;
        final int size = elements.length;
        for (int i = cursor; i &lt; size; i++) {
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) elements[i];
            action.accept(e);
        }
        cursor = size;
    }
}

</code></pre>

<h3 id="toc_1">类的属性</h3>

<pre><code class="language-java">public class CopyOnWriteArrayList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {
    // 版本序列号
    private static final long serialVersionUID = 8673264195747942595L;
    // 可重入锁
    final transient ReentrantLock lock = new ReentrantLock();
    // 对象数组，用于存放元素
    private transient volatile Object[] array;
    // 反射机制
    private static final sun.misc.Unsafe UNSAFE;
    // lock域的内存偏移量
    private static final long lockOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&lt;?&gt; k = CopyOnWriteArrayList.class;
            lockOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;lock&quot;));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}

</code></pre>

<p>属性中有一个可重入锁，用来保证线程安全访问，还有一个Object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和CAS来保证原子性的修改lock域。</p>

<h3 id="toc_2">构造器</h3>

<pre><code class="language-java">public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) {
    Object[] elements;
    if (c.getClass() == CopyOnWriteArrayList.class) // 类型相同
        // 获取c集合的数组
        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();
    else { // 类型不相同
        // 将c集合转化为数组并赋值给elements
        elements = c.toArray();
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elements.getClass() != Object[].class) // elements类型不为Object[]类型
            // 将elements数组转化为Object[]类型的数组
            elements = Arrays.copyOf(elements, elements.length, Object[].class);
    }
    // 设置数组
    setArray(elements);
}

</code></pre>

<p>该构造函数的处理流程如下 </p>

<ul>
<li>判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组(Object[])，并且设置当前CopyOnWriteArrayList的数组(Object[]数组)，进入步骤③；否则，进入步骤② </li>
<li>将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型(toArray方法可能不会返回Object类型的数组)，若不是，则将elements转化为Object类型的数组。进入步骤③ </li>
<li>设置当前CopyOnWriteArrayList的Object[]为elements。 </li>
</ul>

<h3 id="toc_3">核心方法分析</h3>

<h4 id="toc_4">copyOf 方法</h4>

<pre><code class="language-java">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    @SuppressWarnings(&quot;unchecked&quot;)
    // 确定copy的类型(将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组
    // 否则,生成指定长度的新类型的数组)
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    // 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中(也从下标0开始)
    System.arraycopy(original, 0, copy, 0,
                        Math.min(original.length, newLength));
    return copy;
}

</code></pre>

<h4 id="toc_5">add 方法</h4>

<pre><code class="language-java">public boolean add(E e) {
    // 可重入锁
    final ReentrantLock lock = this.lock;
    // 获取锁
    lock.lock();
    try {
        // 元素数组
        Object[] elements = getArray();
        // 数组长度
        int len = elements.length;
        // 复制数组
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 存放元素e
        newElements[len] = e;
        // 设置数组
        setArray(newElements);
        return true;
    } finally {
        // 释放锁
        lock.unlock();
    }
}

</code></pre>

<p>此函数用于将指定元素添加到此列表的尾部，处理流程如下 </p>

<ul>
<li>获取锁(保证多线程的安全访问)，获取当前的Object数组，获取Object数组的长度为length，进入步骤②。 </li>
<li>根据Object数组复制一个长度为length+1的Object数组为newElements(此时，newElements[length]为null)，进入下一步骤。 </li>
<li>将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。</li>
</ul>

<h4 id="toc_6">addIfAbstract 方法</h4>

<pre><code class="language-java">private boolean addIfAbsent(E e, Object[] snapshot) {
    // 重入锁
    final ReentrantLock lock = this.lock;
    // 获取锁
    lock.lock();
    try {
        // 获取数组
        Object[] current = getArray();
        // 数组长度
        int len = current.length;
        if (snapshot != current) { // 快照不等于当前数组，对数组进行了修改
            // Optimize for lost race to another addXXX operation
            // 取较小者
            int common = Math.min(snapshot.length, len);
            for (int i = 0; i &lt; common; i++) // 遍历
                if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) // 当前数组的元素与快照的元素不相等并且e与当前元素相等
                    // 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在
                    // 返回
                    return false;
            if (indexOf(e, current, common, len) &gt;= 0) // 在当前数组中找到e元素
                    // 返回
                    return false;
        }
        // 复制数组
        Object[] newElements = Arrays.copyOf(current, len + 1);
        // 对数组len索引的元素赋值为e
        newElements[len] = e;
        // 设置数组
        setArray(newElements);
        return true;
    } finally {
        // 释放锁
        lock.unlock();
    }
}

</code></pre>

<p>该函数的流程如下:</p>

<ul>
<li>① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④ </li>
<li>② 不相等，表示在snapshot与current之间，对数组进行了修改(如进行了add、set、remove等操作)，获取长度(snapshot与current之间的较小者)，对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等(可能进行了set操作)，进入步骤⑤，否则，进入步骤③ </li>
<li>③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④ </li>
<li>④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤ ⑤ 释放锁，返回。</li>
</ul>

<h4 id="toc_7">set 方法</h4>

<p>此方法是用指定的元素替代此列表指定位置的元素，也是基于数组的复制来实现的。</p>

<pre><code class="language-java">public E set(int index, E element) {
    // 可重入锁
    final ReentrantLock lock = this.lock;
    // 获取锁
    lock.lock();
    try {
        // 获取数组
        Object[] elements = getArray();
        // 获取index索引的元素
        E oldValue = get(elements, index);

        if (oldValue != element) { // 旧值等于element
            // 数组长度
            int len = elements.length;
            // 复制数组
            Object[] newElements = Arrays.copyOf(elements, len);
            // 重新赋值index索引的值
            newElements[index] = element;
            // 设置数组
            setArray(newElements);
        } else {
            // Not quite a no-op; ensures volatile write semantics
            // 设置数组
            setArray(elements);
        }
        // 返回旧值
        return oldValue;
    } finally {
        // 释放锁
        lock.unlock();
    }
}

</code></pre>

<h4 id="toc_8">remove 方法</h4>

<p>用于移除此列表上指定位置上的元素</p>

<pre><code class="language-java">public E remove(int index) {
    // 可重入锁
    final ReentrantLock lock = this.lock;
    // 获取锁
    lock.lock();
    try {
        // 获取数组
        Object[] elements = getArray();
        // 数组长度
        int len = elements.length;
        // 获取旧值
        E oldValue = get(elements, index);
        // 需要移动的元素个数
        int numMoved = len - index - 1;
        if (numMoved == 0) // 移动个数为0
            // 复制后设置数组
            setArray(Arrays.copyOf(elements, len - 1));
        else { // 移动个数不为0
            // 新生数组
            Object[] newElements = new Object[len - 1];
            // 复制index索引之前的元素
            System.arraycopy(elements, 0, newElements, 0, index);
            // 复制index索引之后的元素
            System.arraycopy(elements, index + 1, newElements, index,
                                numMoved);
            // 设置索引
            setArray(newElements);
        }
        // 返回旧值
        return oldValue;
    } finally {
        // 释放锁
        lock.unlock();
    }
}

</code></pre>

<p>处理流程如下</p>

<ul>
<li>1、获取锁，获取数组 elements，数组长度为 length，获取索引的值 elements[index] ,计算需要移动的元素个数(length - index - 1) ,若个数为 0， 则表示移除的是数组的最后一个元素，复制 elements 数组， 复制长度为 length - 1，然后设置数组，进入步骤 3，否则进入步骤 2</li>
<li>2、先复制 index 索引前的元素，再复制 index 索引后的元素，然后设置数组</li>
<li>3、释放锁，返回旧值 </li>
</ul>

<h3 id="toc_9">示例</h3>

<pre><code class="language-java">import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;

class PutThread extends Thread {
    private CopyOnWriteArrayList&lt;Integer&gt; cowal;

    public PutThread(CopyOnWriteArrayList&lt;Integer&gt; cowal) {
        this.cowal = cowal;
    }

    public void run() {
        try {
            for (int i = 100; i &lt; 110; i++) {
                cowal.add(i);
                Thread.sleep(50);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class CopyOnWriteArrayListDemo {
    public static void main(String[] args) {
        CopyOnWriteArrayList&lt;Integer&gt; cowal = new CopyOnWriteArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; 10; i++) {
            cowal.add(i);
        }
        PutThread p1 = new PutThread(cowal);
        p1.start();
        Iterator&lt;Integer&gt; iterator = cowal.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + &quot; &quot;);
        }
        System.out.println();
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        iterator = cowal.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + &quot; &quot;);
        }
    }
}

</code></pre>

<h3 id="toc_10">CopyOnWriteArrayList 总结</h3>

<p>CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p>

<p>这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁， 因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思 想，读和写不同的容器。如果读的时候有多个线程正在向 CopyOnWriteArrayList 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>

<p>使用 CopyOnWriteMap 需要注意两件事情:</p>

<ul>
<li>减少扩容开销。根据实际需要，初始化 CopyOnWriteMap 的大小，<br/>
避免写时 CopyOnWriteMap 扩容的开销。</li>
<li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加<br/>
次数，可以减少容器的复制次数。</li>
</ul>

<h3 id="toc_11">写时复制容器的问题</h3>

<ul>
<li><p>性能问题<br/>
每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，可以想象，性能是很低的，而且内存开销会很大,可能导致 GC 。</p></li>
<li><p>数据一致性问题。<br/>
CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。 所以如果你希望写入的的数据，马上能读到，不要使用 CopyOnWrite 容器</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[epoll 高效的原理和底层机制]]></title>
    <link href="http://www.throne4j.com/16087370410844.html"/>
    <updated>2020-12-23T23:24:01+08:00</updated>
    <id>http://www.throne4j.com/16087370410844.html</id>
    <content type="html"><![CDATA[
<ul>
<li>问题1：CPU 操作系统如何知道接收了数据？</li>
<li>问题2：进程阻塞为什么不占用 cpu 资源？</li>
<li>问题3：阻塞的原理是什么?</li>
<li>问题4：操作系统如何知道网络数据对应于哪个 socket？</li>
<li>问题5：操作系统是如何同时监视多个 socket 的数据的？</li>
</ul>

<p>从事服务端开发，少不了要接触网络编程。epoll 作为 Linux 下高性能网络服务器的必备技术至关重要，nginx、Redis、Skynet 和大部分游戏服务器都使用到这一多路复用技术。</p>

<p>为了能探究epoll的原理，需要从网卡接收数据的流程开始，串联起 CPU 中断、操作系统进程调度等知识；再一步步分析阻塞接收数据、select 到 epoll 的进化过程；最后探究 epoll 的实现细节。</p>

<h2 id="toc_0">网卡接收数据</h2>

<p><a href="16073516476681.html">Linux 网络包接收过程</a></p>

<h3 id="toc_1">进程阻塞原理</h3>

<p>了解 epoll 本质，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件(如接收到网络数据)发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。</p>

<p>我们看下如下伪代码</p>

<pre><code class="language-java">//创建 socket
int s = socket(AF_INET, SOCK_STREAM, 0);
//绑定
bind(s, ...)
//监听
listen(s, ...) 
//接受客户端连接 
int c = accept(s, ...) 
//接收客户端数据 
recv(c, ...); 
//将数据打印出来 
printf(...)
</code></pre>

<p>这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen、accept， 最后调用 recv 接收数据。recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。</p>

<h4 id="toc_2">工作队列</h4>

<p>现代操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待” 等几种状态。运行状态是进程获得 cpu 使用权，正在执行代码的状态;等待状态是阻塞状态， 比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行 状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p>

<p>现在我们假设的计算机中运行着 A、B、C 三个进程，其中进程 A 执行着上述基础网络程序， 一开始，这 3 个进程都被操作系统的工作队列所引用，处于运行状态，分时执行。<br/>
<figure><img src="media/16087370410844/16087422186392.jpg" alt="操作系统工作队列"/><figcaption>操作系统工作队列</figcaption></figure></p>

<h4 id="toc_3">等待队列</h4>

<p>当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象。这个 socket 对象包含了发送缓冲区、接收缓冲区、等待队列等成员。</p>

<p>等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程</p>

<p>当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中 。由于工作队列只剩下了进程 B 和 C，依据进程调度，cpu 会轮流执行这两个进 程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 cpu 资源。</p>

<p><figure><img src="media/16087370410844/16087424294808.jpg" alt="等待队列"/><figcaption>等待队列</figcaption></figure></p>

<p>操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时 获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。</p>

<h4 id="toc_4">唤醒进程</h4>

<p>当 socket 接收到数据后，操作系统将该 socket 等待队列上的进程重新放回到工作队列， 该进程变成运行状态，继续执行代码。也由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p>

<h3 id="toc_5">内核接收网络数据全过程</h3>

<ul>
<li>1、进程在 recv 阻塞期间，计算机收到了对端传送的数据。</li>
<li>2、网卡将数据帧DMA到内存的RingBuffer中</li>
<li>3、网卡执行硬中断信号通知 cpu 有数据到达，然后cpu 执行中断程序，调用网卡启动时注册的中断处理函数，发起软中断请求，</li>
<li>4、内核线程ksoftirqd线程发现有软中断请求到来，先关闭硬中断，ksoftirqd线程开始调用驱动的poll函数收包，将网络数据包写入到对应 socket 的接收缓冲区里面， poll函数将收到的包送到协议栈注册的ip_rcv函数中，ip_rcv函数再讲包送到udp_rcv函数中（对于tcp包就送到tcp_rcv）</li>
<li>5、唤醒进程 A，重新将进程 A 放入工作队列中</li>
</ul>

<p><figure><img src="media/16073533164404/16073547682930.jpg" alt="Linux内核接收数据的过程"/><figcaption>Linux内核接收数据的过程</figcaption></figure></p>

<h4 id="toc_6">操作系统是怎么直到网络数据对应于哪个 socket 的呢？</h4>

<p>一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可 以通过端口号找到对应的 socket。当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</p>

<h4 id="toc_7">操作系统是如何同时监视多个 socket 的数据的呢？</h4>

<p>服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，因此码操作系统的大神们开始寻找监视多个 socket 的方法。epoll 的目的就是高效的监视多个socket，但是万事都有一个循序渐进的过程，我们就从最简陋的监视多个 socket 的方法开始了解</p>

<p>假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket 收到数据，将进程唤醒。这种方法很直接，也是 select 的设计思想。</p>

<p>为方便理解，我们先复习 select 的用法。</p>

<pre><code class="language-java">int s = socket(AF_INET, SOCK_STREAM, 0);  
bind(s, ...);
listen(s, ...);
int fds[] = 存放需要监听的 socket 
while(1){
    int n = select(..., fds, ...) 
    for(int i=0; i &lt; fds.count; i++) {
        if(FD_ISSET(fds[i], ...)) { 
            //fds[i]的数据处理
    
        }
    }
}
</code></pre>

<p>在上面的伪代码中，先准备一个数组(伪代码中的 fds)，让 fds 存放着所有需要监视的 socket。然后调用 select，如果 fds 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。用户 可以遍历 fds，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p>

<p>select 的实现思路很直接。假如程序同时监视 sock1、sock2 和 sock3 三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。<br/>
<figure><img src="media/16073533164404/16073578349616.jpg" alt="调用select之后"/><figcaption>调用select之后</figcaption></figure></p>

<p>当任何一个socket 接收到数据之后，中断程序将唤起进程。所唤起进程就是将进程从所有的等待队列中移除，加入到工作队列里面</p>

<p>经由这些步骤，当进程 A 被唤醒之后，它知道至少有一个 socket 接收了数据，程序只需要遍历一遍 socket 列表，就可以得到就绪的 socket。</p>

<p>这种 Select 方式比较简单且行之有效，几乎所有的操作系统都有对应的实现。</p>

<p>但是简单的方法通常是有不足之处的，主要不足如下：</p>

<ul>
<li><p>每次调用 select 都需要将进程加入到的所有被监视 socket 的等待队列，每次唤醒都需要从每个队列中移除，都必须进行遍历。而且每次都要将整个 fds 列表传递给内核，开销比较大。正式因为遍历操作开销比较大，才会规定 select 的最大监视数量，默认32位机器只能监视 1024 个 socket</p></li>
<li><p>进程被唤醒之后，程序并不知道哪些socket收到数据，还需要再次遍历一遍 fds</p></li>
</ul>

<p>那么，有没有减少遍历的方法?有没有保存就绪 socket 的方法?这两个问题便是 epoll 技术要解决的。</p>

<h2 id="toc_8">epoll 的设计思路</h2>

<p>epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll 的增强版本。 epoll 通过以下一些措施来改进效率。</p>

<h3 id="toc_9">措施一：功能分离</h3>

<p>select 低效的原因之一是将维护等待队列 和 阻塞队列 两步合二为一了，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。相比 select，epoll 拆分了功能。</p>

<p>为方便理解后续的内容，我们先复习下 epoll 的用法。</p>

<pre><code class="language-c">int epfd = epoll_create(...);
//将所有需要监听的 socket 添加到 epfd 中 
epoll_ctl(epfd, ...); 
while(1){
    int n = epoll_wait(...) 
    for(接收到数据的 socket) {
        //处理 
    }
}
</code></pre>

<p>在上面的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。epoll 的功能分离，使得 epoll 有了优化的可能。</p>

<h3 id="toc_10">就绪列表</h3>

<p>select 低效的另一个原因在于 程序不知道哪些 socket 收到了数据，只能一个个遍历。如果内核维护一个 就绪列表，引用收到数据的 socket， 就能避免遍历整个等待队列操作了</p>

<h2 id="toc_11">epoll 的原理和流程</h2>

<p>当某一进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体(也就是程序中 epfd 所代表的对象)，eventpoll 对象也是文件系统中的一员</p>

<p>在内核 cache 里会建一个红黑树结构，用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。</p>

<p>同时，所有添加到 epoll 中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做 ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p>

<p>当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll 对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist 链表不为空，则这里的事件复制到用户态内存(使用共享内存提高效率)中，同时将事件数量返回给用户。因此 epoll_wait 效率会非常高，可以轻易地处理百万级别的并发连接。</p>

<p>创建 epoll 对象后，用 epoll_ctl 添加或删除所要监听的 socket。以添加 socket 为例， 如果通过 epoll_ctl 添加 sock1、sock2 和 sock3 的监视，内核将会把 eventpoll 添加到 socket 的等待队列中</p>

<p><figure><img src="media/16073533164404/16073579818343.jpg" alt="epoll"/><figcaption>epoll</figcaption></figure></p>

<p>当 socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。</p>

<p><figure><img src="media/16073533164404/16073581194057.jpg" alt=""/></figure></p>

<p>eventpoll 对象相当于是 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p>

<p>当程序执行到 epoll_wait 时，如果 rdlist 已经引用了 socket，那么 epoll_wait 直接返回， 如果 rdlist 为空，阻塞进程。</p>

<p>现在我们假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。如 下图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</p>

<p><figure><img src="media/16073533164404/16073582227125.jpg" alt=""/></figure></p>

<p>当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化。</p>

<h2 id="toc_12">epoll 实现细节</h2>

<p>epoll 函数</p>

<pre><code class="language-c">int epoll_create(int size)；
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);

struct epoll_event {
    __uint32_t events;
    epoll_data_t data;
};
</code></pre>

<h3 id="toc_13">eventpoll</h3>

<p>上面我们看到 eventpoll 对象对于 epoll 来说是非常重要的<br/>
首先思考两个问题</p>

<ul>
<li>就绪队列应该应使用什么数据结构?</li>
<li>eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 socket?</li>
</ul>

<p>下面我们来看下 eventpoll 的数据结构</p>

<pre><code class="language-c">struct eventpoll {
    // 用于锁定这个eventpoll数据结构，
    // 在用户空间多线程操作这个epoll结构，比如调用epoll_ctl作add, mod, del时，用户空间不需要加锁保护
    // 内核用这个mutex帮你搞定
    struct mutex mtx;

    // 等待队列，epoll_wait时如果当前没有拿到有效的事件，将当前task加入这个等待队列后作进程切换，等待被唤醒
    wait_queue_head_t wq;

    /* Wait queue used by file-&gt;poll() */
    // eventpoll对象在使用时都会对应一个struct file对象，赋值到其private_data，
    // 其本身也可以被 poll， 那也就需要一个wait queue
    wait_queue_head_t poll_wait;

    // 所有有事件触发的被监控的fd都会加入到这个列表
    struct list_head rdllist;

    /* Lock which protects rdllist and ovflist */
    rwlock_t lock;

    // 所有被监控的 fd 使用红黑树来存储
    struct rb_root_cached rbr;

    //  当将ready的fd复制到用户进程中，会使用上面的 lock锁锁定rdllist,
    //  此时如果有新的ready状态fd, 则临时加入到 ovflist表示的单链表中
    struct epitem *ovflist;

    // 会autosleep准备的唤醒源
    struct wakeup_source *ws;

    /* The user that created the eventpoll descriptor */
    struct user_struct *user;

    // linux下一切皆文件，epoll实例被创建时，同时会创建一个file, file的private_data
    // 指向当前这个eventpoll结构
    struct file *file;

    /* used to optimize loop detection check */
    int visited;
    struct list_head visited_list_link;

#ifdef CONFIG_NET_RX_BUSY_POLL
    /* used to track busy poll napi_id */
    unsigned int napi_id;
#endif
};
</code></pre>

<p>rdllist就绪列表引用着就绪的 socket，所以它应能够快速的插入数据。</p>

<p>程序可能随时调用 epoll_ctl 添加监视 socket，也可能随时删除。当删除时，若该 socket已经存放在就绪列表中，它也应该被移除。</p>

<p>所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结 构，epoll 使用双向链表来实现就绪队列，也就是 Linux 源码中的 rdllist</p>

<p>既然 epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保 存监视的 socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一 种自平衡二叉查找树，搜索、插入和删除时间复杂度都是 O(log(N))，效率较好。epoll 使用 了红黑树作为索引结构，也就是 Linux 源码中的 rbr。</p>

<p>因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist 并非直接引用 socket， 而是通过 epitem 间接引用，红黑树的节点也是 epitem 对象。</p>

<h3 id="toc_14">epitem 结构</h3>

<p>每一个被 epoll监控的句柄都会保存在eventpoll内部的红黑树上（eventpoll-&gt;rbr），ready状态的句柄也会保存在eventpoll内部的一个链表上（eventpoll-&gt;rdllist）, 实现时会将每个句柄封装在一个结构中，这就是 epitem</p>

<pre><code class="language-c">struct epitem {
    // 用于构建红黑树
    union {
        //RB树节点将此结构链接到eventpoll RB树
        struct rb_node rbn;
        //用于释放结构体epitem
        struct rcu_head rcu;
    };

    // 用于将当前 epitem 链接到 eventpoll-&gt;rdllist中
    struct list_head rdllink;

    //用于将当前 epitem 链接到&quot;struct eventpoll&quot;-&gt;ovflist这个单链表中
    struct epitem *next;

    //此条目引用的文件描述符信息
    struct epoll_filefd ffd;

    //附加到poll轮询中的活跃等待队列数
    int nwait;

    /* List containing poll wait queues */
    struct list_head pwqlist;

    // 对应的eventpoll对象
    struct eventpoll *ep;

    /* List header used to link this item to the &quot;struct file&quot; items list */
    struct list_head fllink;

    /* wakeup_source used when EPOLLWAKEUP is set */
    struct wakeup_source __rcu *ws;

    // 需要关注的读，写事件等
    struct epoll_event event;
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 常用命令]]></title>
    <link href="http://www.throne4j.com/16087365812100.html"/>
    <updated>2020-12-23T23:16:21+08:00</updated>
    <id>http://www.throne4j.com/16087365812100.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">rpm -ivh  mysql-connector-odbc-5.1.5.rpm</h1>

<h1 id="toc_1">yum list  列出来所有可以安装的包</h1>

<h1 id="toc_2">yum search</h1>

<h1 id="toc_3">yum -y install     -y:yes</h1>

<h1 id="toc_4">yum -y install gcc</h1>

<h1 id="toc_5">rpm -p gcc</h1>

<h1 id="toc_6">yum -y update （包名）  远程千万不要要加包名</h1>

<h1 id="toc_7">yum -y remove （包名）卸载要添加包名</h1>

<h1 id="toc_8">yum grouplist</h1>

<h1 id="toc_9">uname -a # 查看内核/操作系统/CPU信息</h1>

<h1 id="toc_10">head -n 1 /etc/issue # 查看操作系统版本</h1>

<h1 id="toc_11">cat /proc/cpuinfo # 查看CPU信息</h1>

<h1 id="toc_12">hostname # 查看计算机名</h1>

<h1 id="toc_13">lspci -tv # 列出所有PCI设备</h1>

<h1 id="toc_14">lsusb -tv # 列出所有USB设备</h1>

<h1 id="toc_15">lsmod # 列出加载的内核模块</h1>

<h1 id="toc_16">env # 查看环境变量资源</h1>

<h1 id="toc_17">free -m # 查看内存使用量和交换区使用量</h1>

<h1 id="toc_18">df -h # 查看各分区使用情况</h1>

<h1 id="toc_19">du -sh &lt;目录名&gt; # 查看指定目录的大小</h1>

<h1 id="toc_20">grep MemTotal /proc/meminfo # 查看内存总量</h1>

<h1 id="toc_21">grep MemFree /proc/meminfo # 查看空闲内存量</h1>

<h1 id="toc_22">uptime # 查看系统运行时间、用户数、负载</h1>

<h1 id="toc_23">cat /proc/loadavg # 查看系统负载磁盘和分区</h1>

<h1 id="toc_24">mount | column -t # 查看挂接的分区状态</h1>

<h1 id="toc_25">fdisk -l # 查看所有分区</h1>

<h1 id="toc_26">swapon -s # 查看所有交换分区</h1>

<h1 id="toc_27">hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)</h1>

<h1 id="toc_28">dmesg | grep IDE # 查看启动时IDE设备检测状况网络</h1>

<h1 id="toc_29">ifconfig # 查看所有网络接口的属性</h1>

<h1 id="toc_30">iptables -L # 查看防火墙设置</h1>

<h1 id="toc_31">route -n # 查看路由表</h1>

<h1 id="toc_32">netstat -lntp # 查看所有监听端口</h1>

<h1 id="toc_33">netstat -antp # 查看所有已经建立的连接</h1>

<h1 id="toc_34">netstat -s # 查看网络统计信息进程</h1>

<h1 id="toc_35">ps -ef # 查看所有进程</h1>

<h1 id="toc_36">top # 实时显示进程状态用户</h1>

<h1 id="toc_37">w # 查看活动用户</h1>

<h1 id="toc_38">id &lt;用户名&gt; # 查看指定用户信息</h1>

<h1 id="toc_39">last # 查看用户登录日志</h1>

<h1 id="toc_40">cut -d: -f1 /etc/passwd # 查看系统所有用户</h1>

<h1 id="toc_41">cut -d: -f1 /etc/group # 查看系统所有组</h1>

<h1 id="toc_42">crontab -l # 查看当前用户的计划任务服务</h1>

<h1 id="toc_43">chkconfig –list # 列出所有系统服务</h1>

<h1 id="toc_44">chkconfig –list | grep on # 列出所有启动的系统服务程序</h1>

<h1 id="toc_45">rpm -qa # 查看所有安装的软件包</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring 框架去除 web.xml 实现 servlet 容器的初始化]]></title>
    <link href="http://www.throne4j.com/16082729328747.html"/>
    <updated>2020-12-18T14:28:52+08:00</updated>
    <id>http://www.throne4j.com/16082729328747.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">SpringServletContainerInitializer</h2>

<p>SpringServletContainerInitializer 继承自 Servlet3.0 包中的 ServletContainerInitializer 类，它借助 JAVA 中 SPI 思想进行调用，已达到去 web.xml 配置文件的容器初始化。</p>

<pre><code class="language-java">@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {

    public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext){
        
        // 将webAppInitializerClasses 存入 initializer 容器中
        
        ....
        
        for (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
        
    }
}
</code></pre>

<h2 id="toc_1">HandlesTypes 注解</h2>

<p>通过上面的代码 SpringServletContainerInitializer 被 @HandlesTypes 标注，这行的作用是将 WebApplicationInitializer 的实现类作为参数传递给 ServletContainerInitializer 的 onStartup 方法。</p>

<h2 id="toc_2">WebApplicationInitializer 接口</h2>

<p>WebApplicationInitializer 接口方便了以编程的方式配置 ServletContext</p>

<p>例如下面的这段配置</p>

<pre><code class="language-markup">&lt;servlet&gt;
 &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
 &lt;servlet-class&gt;
   org.springframework.web.servlet.DispatcherServlet
 &lt;/servlet-class&gt;
 &lt;init-param&gt;
   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
   &lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
  
&lt;servlet-mapping&gt;
 &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>将其通过代码实现的话如下所示：</p>

<pre><code class="language-java">public class MyWebAppInitializer implements WebApplicationInitializer {
  
  @Override
  public void onStartup(ServletContext container) {
    XmlWebApplicationContext appContext = new XmlWebApplicationContext();
    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);
  
    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  }
  
}
</code></pre>

<p>更进一步看怎么省去 dispatcher-config.xml 文件，将配置移交到 DispatherConfig 配置类中</p>

<pre><code class="language-java">public class MyWebAppInitializer implements WebApplicationInitializer {
  
  @Override
  public void onStartup(ServletContext container) {
    // Create the &#39;root&#39; Spring application context
    AnnotationConfigWebApplicationContext rootContext =
      new AnnotationConfigWebApplicationContext();
    rootContext.register(AppConfig.class);
  
    // Manage the lifecycle of the root application context
    container.addListener(new ContextLoaderListener(rootContext));
  
    // Create the dispatcher servlet&#39;s Spring application context
    AnnotationConfigWebApplicationContext dispatcherContext =
      new AnnotationConfigWebApplicationContext();
    dispatcherContext.register(DispatcherConfig.class);
  
    // Register and map the dispatcher servlet
    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(dispatcherContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  }
  
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ServletRequest、ServletResponse]]></title>
    <link href="http://www.throne4j.com/16082722990451.html"/>
    <updated>2020-12-18T14:18:19+08:00</updated>
    <id>http://www.throne4j.com/16082722990451.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统常用的调度算法总结]]></title>
    <link href="http://www.throne4j.com/16080888993841.html"/>
    <updated>2020-12-16T11:21:39+08:00</updated>
    <id>http://www.throne4j.com/16080888993841.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1 常见的批处理作业调度算法</h2>

<h3 id="toc_1">1.1 先来先服务调度算法（FCFS）:</h3>

<p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也用于进程调度</p>

<p>当在作业调度中采用该算法时，每次调度都是<strong>从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存</strong>，为它们分配资源、创建进程，然后放入就绪队列。</p>

<p>在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机</p>

<p>这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p>

<h3 id="toc_2">1.2 短作业优先调度算法(SPF)</h3>

<p>短作业优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。所谓短是指作业或进程的运行时间短。而在作业或进程未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值</p>

<p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p>

<h3 id="toc_3">1.3 最高响应比优先算法(HRN)</h3>

<p>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。</p>

<h3 id="toc_4">1.4 基于优先数调度算法(HPF)</h3>

<p>每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。<br/>
　　</p>

<h3 id="toc_5">1.5 均衡调度算法</h3>

<p>　　多级队列调度算法，基本概念：<br/>
　　作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)；<br/>
　　作业平均周转时间(T)＝周转时间/作业个数；<br/>
　　作业带权周转时间（Wi）＝周转时间/运行时间；<br/>
　　响应比＝（等待时间＋运行时间）/运行时间。</p>

<h2 id="toc_6">2 进程调度算法</h2>

<h3 id="toc_7">2.1 先进先出算法(FIFO):</h3>

<p>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。<br/>
　　<br/>
<strong>每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行</strong>。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。<br/>
　　</p>

<h3 id="toc_8">2.2 时间片轮转算法(RR):</h3>

<p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。<br/>
　　</p>

<h3 id="toc_9">2.3 最高优先级算法(HPF):</h3>

<p>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。</p>

<h3 id="toc_10">2.4 多级反馈队列调度算法</h3>

<p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：</p>

<ul>
<li><p>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p></li>
<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。</p></li>
<li><p>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即第i队列中某个正在运行的进程的时间片用完后，由调度程序选择优先权较高的队列中的那一个进程，把处理机分配给它。</p></li>
</ul>

<h2 id="toc_11">3 空闲分区分配算法</h2>

<h3 id="toc_12">3.1 首先适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。</p>

<h3 id="toc_13">3.2 最佳适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。</p>

<h3 id="toc_14">3.3 最坏适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p>

<h2 id="toc_15">4 虚拟页式存储管理中的页面置换算法</h2>

<h3 id="toc_16">4.1 理想页面置换算法(OPT):</h3>

<p>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</p>

<h3 id="toc_17">4.2 先进先出页面置换算法(FIFO)：</h3>

<p>选择最先进入内存的页面予以淘汰。</p>

<h3 id="toc_18">4.3 最近最久未使用算法（LRU）：</h3>

<p>选择在最近一段时间内最久没有使用过的页，把它淘汰。</p>

<h3 id="toc_19">4.4 少使用算法（LFU）：</h3>

<p>选择到当前时间为止被访问次数最少的页转换。</p>

<h2 id="toc_20">5 磁盘调度</h2>

<h3 id="toc_21">5.1 先来先服务（FCFS）：</h3>

<p>是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置。</p>

<h3 id="toc_22">5.2 最短寻道时间优先（SSTF）：</h3>

<p>让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题。</p>

<h3 id="toc_23">5.3 扫描算法（SCAN）或电梯调度算法：</h3>

<p>　　总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>

<h3 id="toc_24">5.4 循环扫描算法（CSCAN）：</h3>

<p>　　循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ResponseBodyAdvice]]></title>
    <link href="http://www.throne4j.com/16079180311610.html"/>
    <updated>2020-12-14T11:53:51+08:00</updated>
    <id>http://www.throne4j.com/16079180311610.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HandlerInterceptor]]></title>
    <link href="http://www.throne4j.com/16079177661857.html"/>
    <updated>2020-12-14T11:49:26+08:00</updated>
    <id>http://www.throne4j.com/16079177661857.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RequestContextHolder 类详解]]></title>
    <link href="http://www.throne4j.com/16078839880324.html"/>
    <updated>2020-12-14T02:26:28+08:00</updated>
    <id>http://www.throne4j.com/16078839880324.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebApplicationContext]]></title>
    <link href="http://www.throne4j.com/16078839202895.html"/>
    <updated>2020-12-14T02:25:20+08:00</updated>
    <id>http://www.throne4j.com/16078839202895.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ContextLoaderListener]]></title>
    <link href="http://www.throne4j.com/16078838973010.html"/>
    <updated>2020-12-14T02:24:57+08:00</updated>
    <id>http://www.throne4j.com/16078838973010.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpMessage]]></title>
    <link href="http://www.throne4j.com/16078835677518.html"/>
    <updated>2020-12-14T02:19:27+08:00</updated>
    <id>http://www.throne4j.com/16078835677518.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpMessageConverter]]></title>
    <link href="http://www.throne4j.com/16078834576798.html"/>
    <updated>2020-12-14T02:17:37+08:00</updated>
    <id>http://www.throne4j.com/16078834576798.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebApplicationContext]]></title>
    <link href="http://www.throne4j.com/16078833088880.html"/>
    <updated>2020-12-14T02:15:08+08:00</updated>
    <id>http://www.throne4j.com/16078833088880.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程经典题]]></title>
    <link href="http://www.throne4j.com/16078608737984.html"/>
    <updated>2020-12-13T20:01:13+08:00</updated>
    <id>http://www.throne4j.com/16078608737984.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">多线程的出现是要解决什么问题的?</a>
</li>
<li>
<a href="#toc_1">并发出现问题的根源</a>
</li>
<li>
<a href="#toc_2">java 线程状态</a>
</li>
<li>
<a href="#toc_3">并行和并发</a>
</li>
<li>
<a href="#toc_4">进程与线程的区别</a>
</li>
<li>
<a href="#toc_5">java中守护进程和本地进程的区别</a>
</li>
<li>
<a href="#toc_6">通常线程有哪几种使用方式?</a>
</li>
<li>
<a href="#toc_7">死锁和活锁的区别，死锁与饥饿的区别</a>
</li>
<li>
<a href="#toc_8">怎么唤醒一个阻塞的线程？</a>
</li>
<li>
<a href="#toc_9">不可变对象对多线程有什么帮助</a>
</li>
<li>
<a href="#toc_10">什么是线程的上下文切换</a>
</li>
<li>
<a href="#toc_11">java 中用到的线程调度算法是什么</a>
</li>
<li>
<a href="#toc_12">Thread.sleep(0)的作用是什么？</a>
</li>
<li>
<a href="#toc_13">Runnable接口和Callable接口的区别？</a>
</li>
<li>
<a href="#toc_14">什么是线程组，为什么在 Java 中不推荐使用?</a>
</li>
<li>
<a href="#toc_15">多线程同步和互斥有几种实现方法？</a>
</li>
<li>
<a href="#toc_16">什么是java内存模型？</a>
</li>
<li>
<a href="#toc_17">volatile 关键字的作用？</a>
</li>
<li>
<a href="#toc_18">什么是 CAS</a>
</li>
<li>
<a href="#toc_19">ThreadLocal 有什么作用</a>
</li>
<li>
<a href="#toc_20">为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面?</a>
<ul>
<li>
<a href="#toc_21">为什么 wait 和 notify 方法要在同步块中调用?</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">怎么检测一个线程是否持有对象监视器</a>
</li>
<li>
<a href="#toc_23">同步方法和同步块，哪个是更好的选择</a>
</li>
<li>
<a href="#toc_24">乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</a>
</li>
<li>
<a href="#toc_25">什么是线程安全</a>
</li>
<li>
<a href="#toc_26">线程类的构造方法、静态块是被哪个线程调用的？</a>
</li>
<li>
<a href="#toc_27">Java中如何获取到线程dump文件？</a>
</li>
<li>
<a href="#toc_28">一个线程如果出现了运行时异常会怎么样？</a>
</li>
<li>
<a href="#toc_29">如何在两个线程之间共享数据？</a>
</li>
<li>
<a href="#toc_30">sleep方法和wait方法有什么区别 ？</a>
</li>
<li>
<a href="#toc_31">Java中interrupted 和 isInterrupted方法的区别？</a>
</li>
<li>
<a href="#toc_32">单例模式的线程安全性？</a>
</li>
<li>
<a href="#toc_33">HashTable 的size()方法中明明只有一条语句&quot;return count&quot;，为什么还要做同步？</a>
</li>
<li>
<a href="#toc_34">介绍一下Executor 框架</a>
<ul>
<li>
<a href="#toc_35">为什么使用 Executor 框架</a>
</li>
</ul>
</li>
<li>
<a href="#toc_36">Java 线程池中 submit() 和 execute()方法有什么区别?</a>
</li>
<li>
<a href="#toc_37">如果你提交任务时，线程池队列已满，这时会发生什么？</a>
</li>
<li>
<a href="#toc_38">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</a>
</li>
<li>
<a href="#toc_39">什么是 FutureTask</a>
</li>
<li>
<a href="#toc_40">什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</a>
</li>
<li>
<a href="#toc_41">什么是 AQS</a>
</li>
<li>
<a href="#toc_42">CyclicBarrier和CountDownLatch的区别？</a>
</li>
<li>
<a href="#toc_43">Semaphore 有什么作用</a>
</li>
<li>
<a href="#toc_44">写时复制容器可以用于什么应用场景</a>
</li>
<li>
<a href="#toc_45">生产者消费者模型的作用是什么？</a>
</li>
<li>
<a href="#toc_46">什么是可重入锁(ReentrantLock)?谈谈它的实现</a>
</li>
<li>
<a href="#toc_47">synchronized 和 ReentrantLock 的对比</a>
</li>
<li>
<a href="#toc_48">说一下 synchronized 的实现原理</a>
</li>
<li>
<a href="#toc_49">什么是自旋？</a>
</li>
<li>
<a href="#toc_50">ReadWriteLock 是什么</a>
</li>
<li>
<a href="#toc_51">ConcurrentHashMap的并发度是什么？</a>
</li>
<li>
<a href="#toc_52">Linux环境下如何查找哪个线程使用CPU最长</a>
</li>
</ul>


<h2 id="toc_0">多线程的出现是要解决什么问题的?</h2>

<p>随着计算机硬件技术的发展，CPU、内存、IO等设备的速度差异有了极大的差异，为了充分的利用 CPU 资源，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献。</p>

<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异， 导致了 可见性问题 </li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致了原子性问题 </li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致了顺序性问题</li>
</ul>

<h2 id="toc_1">并发出现问题的根源</h2>

<p>结合上一个问题看这个问题<br/>
原子性、可见性、有序性：</p>

<ul>
<li><p>原子性<br/>
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。</p>
<p>最有代表性的示例就是银行转账问题了：比如从账户A 向账户B 转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 </p>
<p>如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。则只有 账户A 上面少了 1000元，而账户B 上却没有收到这笔钱，1000元就这样蒸发了，这种情况是不是很可怕，要是转账1000W的话，不知有多少人要跳楼喽。</p></li>
<li><p>可见性<br/>
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。</p>
<p>现在假设有两个线程，分别是 CPU1 和 CPU2, 现在要修改一个变量 count = 0，先是 CPU1 从主内存中加载到 CPU1 的高速缓冲区，并对 count 进行修改 count = 10，但是这时候，count = 10 还未刷新回主存，CPU2 从主内存中 读取count，这时候的 count 值仍然是 0，CPU2 未立即得到 CPU1 的计算结果 count = 10，这既是可见性问题</p></li>
<li><p>有序性<br/>
有序性，即程序的执行顺序按照代码的先后顺序来执行。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： </p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </li>
<li>内存系统的重排序。由于处理器使用缓存和 读/写 缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul></li>
</ul>

<h2 id="toc_2">java 线程状态</h2>

<p><figure><img src="media/16078608737984/16078815638754.jpg" alt=""/></figure></p>

<p>在Java中线程的状态一共被分成6种：</p>

<ul>
<li>初始态：</li>
</ul>

<p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p>

<ul>
<li><p>运行态：<br/>
在Java中，运行态包括就绪态和运行态。</p>
<ul>
<li>就绪态该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中。</li>
<li>运行态获得CPU执行权，正在执行的线程。由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li>
</ul></li>
<li><p>阻塞态：<br/>
当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在Java中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。PS：锁、IO、Socket等都资源。</p></li>
<li><p>等待态：<br/>
当前线程中调用wait、join、park 函数时，当前线程就会进入等待态。也有一个等待队列存放所有等待态的线程。线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p></li>
<li><p>超时等待态：<br/>
当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；进入该状态后释放CPU执行权 和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p></li>
<li><p>终止态：<br/>
线程执行结束后的状态。</p></li>
</ul>

<p><strong>注意</strong>：</p>

<ul>
<li>wait()方法会释放CPU执行权和占有的锁。</li>
<li>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li>
<li>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li>
<li>wait和notify必须配套使用，即必须使用同一把锁调用；</li>
<li>wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</li>
</ul>

<h2 id="toc_3">并行和并发</h2>

<p>并发:指应用能够交替执行不同的任务,比如单 CPU 核心下执行多线程并非是 同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不 断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太 快,我们无法察觉到而已.</p>

<p>并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话, 这两件事情可以同时执行</p>

<p>两者区别:一个是交替执行,一个是同时执行.</p>

<h2 id="toc_4">进程与线程的区别</h2>

<p>线程具有许多传统进程锁具有的特征，故又称为轻型进程，而把传统的进程成为重型进程，它相当于只有一个线程的任务。在引入线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>

<ul>
<li>根本区别：进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位</li>
<li>资源开销： 每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换开销较小</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多线程共同完成的；线程是进程的一部分，所以线程也被成为轻量进程</li>
<li>内存分配：同一个进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li>
<li>影响关系： 一个进程崩溃后，在保护模式下不会对其它进程产生影响，但是一个线程崩溃整个进程都会crash，所以多进程要比多线程健壮</li>
<li>执行过程：每个独立的进程有程序运行入口、顺序执行序列和程序出口，但是线程不能独立运行，必须依存在应用程序中，有应用程序提供多个线程执行控制，两者均可并发执行。</li>
</ul>

<h2 id="toc_5">java中守护进程和本地进程的区别</h2>

<p>java中线程分为两种：守护线程和用户线程</p>

<p>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolean on) true则把该线程设置为守护线程，反之则为用户线程(这个方法必须在线程 start 之前设置才会生效)</p>

<p>两者区别：</p>

<ul>
<li>当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。</li>
<li>在 Daemon 线程中产生的新线程也是 Daemon 的。</li>
<li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。</li>
</ul>

<h2 id="toc_6">通常线程有哪几种使用方式?</h2>

<ul>
<li>Runnable 不带返回值的任务</li>
<li>Callable 带返回值的任务</li>
<li>Thread</li>
</ul>

<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>

<h2 id="toc_7">死锁和活锁的区别，死锁与饥饿的区别</h2>

<p>死锁与活锁请参见 <a href="16017068710077.html">死锁与活锁</a></p>

<p>饥饿：一个或者多个线程因为种种原因无法获得所需的资源，导致一直无法执行的状态</p>

<p>java中导致饥饿的原因：</p>

<ul>
<li>高优先级的线程侵占所有低优先级线程的 CPU 时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续的对该同步代码块进行访问</li>
<li>线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的 wait 方法，因为其它线程总是被持续的获得唤醒</li>
</ul>

<h2 id="toc_8">怎么唤醒一个阻塞的线程？</h2>

<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>

<h2 id="toc_9">不可变对象对多线程有什么帮助</h2>

<p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步操作，提升了代码的执行效率</p>

<h2 id="toc_10">什么是线程的上下文切换</h2>

<p>多线程的上下文切换是指cpu控制权由一个正在运行的线程切换到另一个就绪并等待获取 cpu 执行权的线程的过程。cpu在切换线程的时候，要保留上一个线程的车祸现场，一遍下次轮到它的时候，可以恢复车祸线程方便警察叔叔执行公务。</p>

<h2 id="toc_11">java 中用到的线程调度算法是什么</h2>

<p>操作系统中线程调度是系统为线程分配 cpu 资源的过程，主要调度方式有两种</p>

<ul>
<li><p>协同式线程调度<br/>
使用协同式线程调度的多线程系统，线程执行的时间由线程本身来控制，线 程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。</p></li>
<li><p>抢占式线程调度<br/>
使用抢占式线程调度的多线程系统，每个线程执行的时间以及是否切换都由 系统决定。</p></li>
</ul>

<p>Java 中的线程是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，而操作系统级别，OS 是以抢占式调度线程，我们可以认为线程是抢占式的。Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。而且操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以 Java 优先级并不是特别靠谱。</p>

<h2 id="toc_12">Thread.sleep(0)的作用是什么？</h2>

<p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>

<h2 id="toc_13">Runnable接口和Callable接口的区别？</h2>

<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>

<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>

<h2 id="toc_14">什么是线程组，为什么在 Java 中不推荐使用?</h2>

<p>线程组 ThreadGroup 对象中比较有用的方法是 stop、resume、suspend 等 方法，由于这几个方法会导致线程的安全问题(主要是死锁问题)，已经被官方 废弃掉了，所以线程组本身的应用价值就大打折扣了。</p>

<p>线程组 ThreadGroup 不是线程安全的，这在使用过程中获取的信息并不全 是及时有效的，这就降低了它的统计使用价值。</p>

<h2 id="toc_15">多线程同步和互斥有几种实现方法？</h2>

<p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个 线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>

<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以 看成是一种特殊的线程同步。</p>

<p>线程间的同步方法大体可分为两类: 用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p>

<p>用户模式下的方法有: 原子操作(例如一个单一的全局变量)，临界区。内核模式下的方法有: 事件，信号量，互斥量。</p>

<h2 id="toc_16">什么是java内存模型？</h2>

<p>详情请参见 ：<a href="16019058386155.html">java 内存模型之初识</a><br/>
<a href="16020511412975.html">java内存模型之 volatile 同步原语详解</a><br/>
<a href="16082130374121.html">java内存模型之 final 同步原语详解</a><br/>
<a href="16005248987908.html">java内存模型之 Synchronized 同步原语详解</a></p>

<h2 id="toc_17">volatile 关键字的作用？</h2>

<p>理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见<a href="16019058386155.html">java 内存模型</a><br/><br/>
这里简要说明一下 volatile关键字的作用，主要有两个：</p>

<ul>
<li><p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p></li>
<li><p>代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是Java代码--&gt;字节码--&gt;根据字节码执行对应的C/C++代码--&gt;C/C++代码被编译成汇编语言--&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。</p></li>
</ul>

<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>

<h2 id="toc_18">什么是 CAS</h2>

<p>详情请参见 ：<a href="15874857577712.html">原子操作CAS 无锁操作</a></p>

<h2 id="toc_19">ThreadLocal 有什么作用</h2>

<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。详情请参见：<a href="ThreadLocal.html">ThreadLocal源码分析以及使用</a></p>

<h2 id="toc_20">为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面?</h2>

<p>JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获 得。如果线程需要等待某些锁那么调用对象中的 wait()方法就有意义了。如果 wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说， 由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中 因为锁属于对象。</p>

<h3 id="toc_21">为什么 wait 和 notify 方法要在同步块中调用?</h3>

<p>主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</p>

<h2 id="toc_22">怎么检测一个线程是否持有对象监视器</h2>

<p>Thread 类提供了一个 holdsLock(Object obj)方法，当且仅当对象obj的监视器被当前线程持有的时候才会返回true</p>

<h2 id="toc_23">同步方法和同步块，哪个是更好的选择</h2>

<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>

<p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁--&gt;解锁的次数，有效地提升了代码执行的效率。</p>

<h2 id="toc_24">乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h2>

<ul>
<li><p>悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所 以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。 Java 里面的同步原语 synchronized 关键字的实现是悲观锁。</p></li>
<li><p>乐观锁:顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改， 所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，可以使用版本号等机制。在 Java 中 j 原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 乐观锁的实现方式:</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交 后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程 都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以 再次尝试。</li>
</ul></li>
</ul>

<h2 id="toc_25">什么是线程安全</h2>

<p>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p>

<h2 id="toc_26">线程类的构造方法、静态块是被哪个线程调用的？</h2>

<p>线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>

<p>假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>

<ul>
<li>Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li>
<li>Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li>
</ul>

<h2 id="toc_27">Java中如何获取到线程dump文件？</h2>

<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p>

<ul>
<li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li>
<li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</li>
</ul>

<p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p>

<h2 id="toc_28">一个线程如果出现了运行时异常会怎么样？</h2>

<p>如果这个线程的异常没有被捕获的话，这个线程会停止执行，如果这个线程持有某个对象的监视器，那么这个对象监视器也会被立即释放</p>

<h2 id="toc_29">如何在两个线程之间共享数据？</h2>

<p>通过共享对象，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。</p>

<h2 id="toc_30">sleep方法和wait方法有什么区别 ？</h2>

<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>

<h2 id="toc_31">Java中interrupted 和 isInterrupted方法的区别？</h2>

<p>interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br/>
注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>

<p>interrupted查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。</p>

<p>isInterrupted仅仅是查询当前线程的中断状态</p>

<h2 id="toc_32">单例模式的线程安全性？</h2>

<p><a href="15896032913368.html">单例模式</a></p>

<h2 id="toc_33">HashTable 的size()方法中明明只有一条语句&quot;return count&quot;，为什么还要做同步？</h2>

<p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p>

<h2 id="toc_34">介绍一下Executor 框架</h2>

<p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务 的框架。它管理多个异步任务的执行，而无需程序员显式的管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>

<p>Executor主要有三种: </p>

<ul>
<li>CachedThreadPool: 一个任务创建一个线程； </li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程； </li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>

<h3 id="toc_35">为什么使用 Executor 框架</h3>

<ul>
<li>第一:降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二:提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立 即执行。</li>
<li>第三:提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>

<h2 id="toc_36">Java 线程池中 submit() 和 execute()方法有什么区别?</h2>

<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定 义在 Executor 接口中。<br/>
而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口</p>

<h2 id="toc_37">如果你提交任务时，线程池队列已满，这时会发生什么？</h2>

<p>这里区分一下：</p>

<p>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</p>

<p>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</p>

<h2 id="toc_38">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h2>

<p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p>

<p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>

<p>（2）并发不高、任务执行时间长的业务要区分开看：</p>

<p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p>

<p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>

<p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>

<h2 id="toc_39">什么是 FutureTask</h2>

<p>FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask 也可以放入线程池中。</p>

<h2 id="toc_40">什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2>

<p>阻塞队列是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>

<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>

<p>JDK7提供了7个阻塞队列。分别是：</p>

<ul>
<li><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p></li>
<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p></li>
<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p></li>
<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p></li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p></li>
<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p></li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p></li>
</ul>

<p>BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>

<p>阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析</p>

<h2 id="toc_41">什么是 AQS</h2>

<p>详情请参见 ： <a href="15867876320249.html">AQS--AbstractQueuedSynchronizer 详解</a></p>

<h2 id="toc_42">CyclicBarrier和CountDownLatch的区别？</h2>

<p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>

<ul>
<li><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p></li>
<li><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p></li>
<li><p>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></li>
</ul>

<h2 id="toc_43">Semaphore 有什么作用</h2>

<p>详情请参见 <a href="16017007365424.html">Semaphore</a></p>

<h2 id="toc_44">写时复制容器可以用于什么应用场景</h2>

<p>CopyOnWrite 并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>

<p>CopyOnWriteArrayList(免锁容器) 的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。</p>

<p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>

<ul>
<li><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；</p></li>
<li><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</p></li>
</ul>

<p>CopyOnWriteArrayList透露的思想：读写分离，读和写分开、最终一致性、使用另外开辟空间的思路，来解决并发冲突</p>

<h2 id="toc_45">生产者消费者模型的作用是什么？</h2>

<ul>
<li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</li>
<li>解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</li>
</ul>

<h2 id="toc_46">什么是可重入锁(ReentrantLock)?谈谈它的实现</h2>

<p>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块， synchronized、ReentrantLock 都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每释放一次锁， 进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p>

<h2 id="toc_47">synchronized 和 ReentrantLock 的对比</h2>

<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>

<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>

<h2 id="toc_48">说一下 synchronized 的实现原理</h2>

<p>详情请参见： <a href="16005248987908.html">Synchronized关键字解析</a></p>

<h2 id="toc_49">什么是自旋？</h2>

<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>

<h2 id="toc_50">ReadWriteLock 是什么</h2>

<p>首先我们得直到 ReentrantLock 的局限性。</p>

<p>如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>

<p>因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>

<h2 id="toc_51">ConcurrentHashMap的并发度是什么？</h2>

<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p>

<p>在JDK8后，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>

<h2 id="toc_52">Linux环境下如何查找哪个线程使用CPU最长</h2>

<ul>
<li>获取项目的pid，jps 或者 ps -ef | grep java</li>
<li>top -H -p pid，顺序不能改变</li>
</ul>

<p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。</p>

<p>注意这里打出的是LWP，也就是操作系统原生线程的线程号。</p>

<p>使用&quot;top -H -p pid&quot; + &quot;jps pid&quot; 可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p>

<p>最后提一点，&quot;top -H -p pid&quot;打出来的LWP是十进制的，&quot;jps pid&quot;打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring 面试题]]></title>
    <link href="http://www.throne4j.com/16078475422536.html"/>
    <updated>2020-12-13T16:19:02+08:00</updated>
    <id>http://www.throne4j.com/16078475422536.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是控制反转(IOC)？什么是依赖注入？</h2>

<h2 id="toc_1">BeanFactory 和 ApplicationContext 有什么区别？</h2>

<h2 id="toc_2">请解释 Spring Bean 的生命周期？</h2>

<h2 id="toc_3">请举例解释@Autowired 注解？</h2>

<h2 id="toc_4">Spring 框架中有哪些不同类型的事件？</h2>

<ul>
<li><p>1.上下文更新事件ContextRefreshedEvent： 该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。</p></li>
<li><p>2.上下文开始事件ContextStartedEvent： 当容器调用ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。</p></li>
<li><p>3.上下文停止事件ContextStoppedEvent： 当容器调用 ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。</p></li>
<li><p>4.上下文关闭事件ContextClosedEvent： 当 ApplicationContext 被 关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</p></li>
<li><p>5.请求处理事件RequestHandledEvent： 在 Web 应用中，当一个 http 请求（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是脏读、幻读、不可重复度]]></title>
    <link href="http://www.throne4j.com/16077870652991.html"/>
    <updated>2020-12-12T23:31:05+08:00</updated>
    <id>http://www.throne4j.com/16077870652991.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">隔离级别详解</h1>

<h1 id="toc_1">Mysql 存储引擎、行锁、表锁、隔离性关联</h1>

<h1 id="toc_2">Mysql LBCC （lock Model) 底层实现</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netty 之 Channel]]></title>
    <link href="http://www.throne4j.com/16075310570444.html"/>
    <updated>2020-12-10T00:24:17+08:00</updated>
    <id>http://www.throne4j.com/16075310570444.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/16075310570444/NioSocketChannel.jpg" alt="NioSocketChannel"/><figcaption>NioSocketChannel</figcaption></figure><br/>
<figure><img src="media/16075310570444/NioServerSocketChannel.jpg" alt="NioServerSocketChannel"/><figcaption>NioServerSocketChannel</figcaption></figure></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netty 之 EventLoop 相关源码分析]]></title>
    <link href="http://www.throne4j.com/16074361744050.html"/>
    <updated>2020-12-08T22:02:54+08:00</updated>
    <id>http://www.throne4j.com/16074361744050.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/16074361744050/NioEventLoop.jpg" alt="NioEventLoop"/><figcaption>NioEventLoop</figcaption></figure><br/>
<figure><img src="media/16074361744050/NioEventLoopGroup.jpg" alt="NioEventLoopGroup"/><figcaption>NioEventLoopGroup</figcaption></figure></p>

<h2 id="toc_0">EventLoopGroup 和 EventLoop 代码分析</h2>

<pre><code class="language-text">EventLoopGroup group = new NioEventLoopGroup();
</code></pre>

<p>执行这行代码时会发生什么?，由 NioEventLoopGroup 开始，一路调用，到达 MultithreadEventLoopGroup，如果没有指定创建的线程数量，则默认创建的线程个数为 DEFAULT_EVENT_LOOP_THREADS，该数值为:处理器数量 x2。</p>

<pre><code class="language-java">private static final int DEFAULT_EVENT_LOOP_THREADS;

static {
    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
            &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));
}

protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}
</code></pre>

<p>最终由 MultithreadEventExecutorGroup 实例化</p>

<p>由此可见，每个 NioEventLoop 的执行器为 ThreadPerTaskExecutor，ThreadPerTaskExecutor 实现了 Executor 接口，并会在 execute 方法中启动真正的线程，但是要和 NioEventLoop 的线 程挂钩则在 SingleThreadEventExecutor 的 doStartThread 方法里</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring AOP]]></title>
    <link href="http://www.throne4j.com/16073961967770.html"/>
    <updated>2020-12-08T10:56:36+08:00</updated>
    <id>http://www.throne4j.com/16073961967770.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">execution 表达式</h2>

<pre><code class="language-text">execution(* com.loongshawn.method..*.*(..))
</code></pre>

<p>execution 表达式主体</p>

<ul>
<li>第一个 * 表示任何返回对象</li>
<li>com.loongshawn.method 包</li>
<li>后来的 .. 表示当前包以及子包</li>
<li>第二个 * 表示类名</li>
<li>*.(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型</li>
</ul>

]]></content>
  </entry>
  
</feed>
