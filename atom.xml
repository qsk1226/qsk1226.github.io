<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-06-14T11:22:29+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://www.throne4j.com/15917994951575.html"/>
    <updated>2020-06-10T22:31:35+08:00</updated>
    <id>http://www.throne4j.com/15917994951575.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观察者模式]]></title>
    <link href="http://www.throne4j.com/15917825632729.html"/>
    <updated>2020-06-10T17:49:23+08:00</updated>
    <id>http://www.throne4j.com/15917825632729.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">观察者模式定义</a>
</li>
<li>
<a href="#toc_1">观察者模式结构</a>
<ul>
<li>
<a href="#toc_2">优点</a>
</li>
<li>
<a href="#toc_3">缺点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">代码示例</a>
</li>
<li>
<a href="#toc_5">使用场景</a>
</li>
</ul>


<h2 id="toc_0">观察者模式定义</h2>

<p>观察者模式是使用频率较高的设计模式之一。它定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。</p>

<p>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>

<p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p>

<h2 id="toc_1">观察者模式结构</h2>

<p>Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p>

<p>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p>

<p>Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p>

<p>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p>

<p><img src="media/15917825632729/15919534018048.jpg" alt=""/></p>

<h3 id="toc_2">优点</h3>

<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li>
<li>目标与观察者之间建立了一套触发机制</li>
<li>支持广播通信</li>
<li>符合“开闭原则”的要求</li>
</ul>

<h3 id="toc_3">缺点</h3>

<ul>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li>
</ul>

<h2 id="toc_4">代码示例</h2>

<pre><code class="language-java">
/**
 * 抽象观察者
 **/
public interface Observer {
    public void update(String message);
}

/**
 * 具体观察者
 **/
public class GuardianObserver implements Observer {

    private String name;

    public GuardianObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + &quot;-&quot; + message);
    }
}
</code></pre>

<pre><code class="language-java">
/**
 * 抽象被观察者
 **/
public interface Subject {
    /**
     * 增加订阅者
     */
    public void addObserver(Observer observer);

    /**
     * 删除订阅者
     */
    public void removeObserver(Observer observer);

    /**
     * 通知订阅者更新消息
     */
    public void notifyObserver(String message);
}

/**
 * 具体的被观察者
 **/
public class SubscriptionSubject implements Subject {
    
    private List&lt;Observer&gt; guardianObserver = new ArrayList&lt;&gt;();

    @Override
    public void addObserver(Observer observer) {
        guardianObserver.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        guardianObserver.remove(observer);
    }

    @Override
    public void notifyObserver(String message) {
        for (Observer observer : guardianObserver) {
            observer.update(message);
        }
    }
}
</code></pre>

<pre><code class="language-java">/**
 * 观察者模式客户端
 **/
public class Client {
    public static void main(String[] args) {
        SubscriptionSubject mSubscriptionSubject = new SubscriptionSubject();
        //创建监护人
        GuardianObserver user1 = new GuardianObserver(&quot;孩儿他爹&quot;);
        GuardianObserver user2 = new GuardianObserver(&quot;孩儿他娘&quot;);
        // 添加监护
        mSubscriptionSubject.addObserver(user1);
        mSubscriptionSubject.addObserver(user2);
        // 通知打架的通知
        mSubscriptionSubject.notifyObserver(&quot;孩儿又在学校打架了&quot;);
    }
}
</code></pre>

<h2 id="toc_5">使用场景</h2>

<ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://www.throne4j.com/15917825462034.html"/>
    <updated>2020-06-10T17:49:06+08:00</updated>
    <id>http://www.throne4j.com/15917825462034.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">装饰者模式定义</h2>

<p>动态地给一个对象增加一些额外的职责，增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>

<p>在装饰者模式中，为了让系统具有更好的灵活性和可扩展性，我们通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类</p>

<h2 id="toc_1">装饰者模式结构</h2>

<ul>
<li><p>Component（抽象构件）<br/>
它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p></li>
<li><p>ConcreteComponent（具体构件）<br/>
它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p></li>
<li><p>Decorator（抽象装饰类）<br/>
它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p></li>
<li><p>ConcreteDecorator（具体装饰类）<br/>
它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p></li>
</ul>

<p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>

<p>装饰模式的核心在于抽象装饰类的设计。</p>

<p><img src="media/15917825462034/15919264601093.jpg" alt="" style="width:2398px;"/></p>

<h2 id="toc_2">代码示例</h2>

<pre><code class="language-java">/**
 * 抽象车辆,组件间、装饰者、被装饰者的超类
 * 抽象构件
 **/
@Data
public abstract class AbsCar {
    /**
     * 车辆描述
     */
    public abstract String getDescription();

    /**
     * 价格
     */
    public abstract double cost();
}
</code></pre>

<pre><code class="language-java">/**
 * 被装饰的对象
 * 具体构件
 **/
public class NormalCar extends AbsCar{

    @Override
    public String getDescription() {
        return &quot;破车一两&quot;;
    }

    @Override
    public double cost() {
        return 100;
    }
}

</code></pre>

<pre><code class="language-java">
/**
 * 抽象装饰类
 **/
public abstract class AbsDecorator extends AbsCar {

    private AbsCar absCar;

    public AbsDecorator(AbsCar absCar) {
        this.absCar = absCar;
    }

    @Override
    public String getDescription() {
        return this.absCar.getDescription();
    }

    @Override
    public double cost() {
        return this.absCar.cost();
    }

    protected abstract void doSomething();

}


/**
 * 发动机装饰
 * 具体装饰类
 **/
public class EngineDecorator extends AbsDecorator {

    public EngineDecorator(AbsCar absCar) {
        super(absCar);
    }

    @Override
    protected void doSomething() {
        System.out.println(getDescription());
    }

    @Override
    public String getDescription() {
        return super.getDescription() +&quot; 更换V8发动机&quot;;
    }

    @Override
    public double cost() {
        return super.cost()+ 100000;
    }
}


/**
 * 外观装饰
 **/
public class OutWardDecorator extends AbsDecorator {
    public OutWardDecorator(AbsCar absCar) {
        super(absCar);
    }

    @Override
    public String getDescription() {
        return super.getDescription() +&quot; 重新喷漆&quot;;
    }

    @Override
    public double cost() {
        return super.cost()+10000;
    }

    @Override
    protected void doSomething() {
        System.out.println(getDescription());
    }
}

</code></pre>

<pre><code class="language-java">/**
 * 装饰者客户端
 **/
public class DecoratorClient {
    public static void main(String[] args) {
        NormalCar normalCar = new NormalCar();
        EngineDecorator engineDecorator = new EngineDecorator(normalCar);
        OutWardDecorator outWardDecorator = new OutWardDecorator(engineDecorator);
        outWardDecorator.doSomething();

    }
}
</code></pre>

<h2 id="toc_3">装饰者模式的类型</h2>

<p>装饰者模式有可分为 透明装饰模式 与 半透明装饰模式</p>

<p>(1) 透明装饰模式<br/>
在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。</p>

<p>(2) 半透明装饰模式<br/>
透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不 <strong>用具体装饰类型来定义装饰之后的对象</strong>，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。<br/>
上面的代码示例是一种半透明装饰模式。</p>

<h2 id="toc_4">装饰模式注意事项</h2>

<p>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</p>

<p>(2) 尽量保持具体构件类是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</p>

<p>(3) 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。</p>

<h2 id="toc_5">jdk IO中的装饰模式</h2>

<p><img src="media/15917825462034/15919491694110.jpg" alt=""/></p>

<p><img src="media/15917825462034/15919493101153.jpg" alt=""/><br/>
<img src="media/15917825462034/15919493357557.jpg" alt=""/><br/>
<img src="media/15917825462034/15919493571997.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[责任链模式]]></title>
    <link href="http://www.throne4j.com/15917825334671.html"/>
    <updated>2020-06-10T17:48:53+08:00</updated>
    <id>http://www.throne4j.com/15917825334671.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">责任链模式定义</h2>

<p>责任链模式是一种<strong>行为设计模式</strong>，使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系</p>

<p>允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>

<p>用图例来表示的话如下图所示：<br/>
<img src="media/15917825334671/15918442545791.jpg" alt=""/></p>

<h2 id="toc_1">责任链模式结构</h2>

<ul>
<li><p>Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p></li>
<li><p>ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p></li>
</ul>

<p><img src="media/15917825334671/15918572263532.jpg" alt=""/></p>

<p>纯的责任链模式：</p>

<ul>
<li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况</li>
<li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li>
</ul>

<p>不纯的责任链模式：</p>

<ul>
<li>允许某个请求被一个具体处理者部分处理后再向下传递</li>
<li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li>
<li>而且一个请求可以最终不被任何处理者对象所接收</li>
</ul>

<h3 id="toc_2">优缺点</h3>

<ul>
<li><p>职责链模式的主要优点</p>
<ul>
<li>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接</li>
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</li>
<li>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，符合 &quot;开闭原则&quot;</li>
</ul></li>
<li><p>职责链模式的主要缺点</p>
<ul>
<li>一个请求可能因职责链没有被正确配置而得不到处理</li>
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，且不方便调试</li>
<li>可能因为职责链创建不当，造成循环调用，导致系统陷入死循环</li>
</ul></li>
</ul>

<h2 id="toc_3">实例代码</h2>

<pre><code class="language-java">
/**
 * 抽象处理类
 **/
@Data
public abstract class Handler {
    protected String name; // 处理者姓名
    protected Handler nextHandler;  // 下一个处理者

    public Handler(String name) {
        this.name = name;
    }

    public Handler(String name, Handler nextHandler) {
        this.name = name;
        this.nextHandler = nextHandler;
    }

    public abstract boolean process(LeaveRequest leaveRequest); // 处理请假
}
</code></pre>

<pre><code class="language-java">
/**
 * 主管处理这
 **/
public class DirectorHandler extends Handler {
    public DirectorHandler(String name) {
        super(name);
    }

    public DirectorHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;主管&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        if (!result) {  // 不批准
            return false;
        } else if (leaveRequest.getNumOfDays() &lt; 3) { // 批准且天数小于3，返回true
            return true;
        }
        return nextHandler.process(leaveRequest);   // 批准且天数大于等于3，提交给下一个处理者处理
    }
}

</code></pre>

<pre><code class="language-java">/**
 * 经理
 **/
public class ManagerHandler extends Handler {
    public ManagerHandler(String name) {
        super(name);
    }

    public ManagerHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        if (!result) {  // 不批准
            return false;
        } else if (leaveRequest.getNumOfDays() &lt; 7) { // 批准且天数小于7
            return true;
        }
        return nextHandler.process(leaveRequest);   // 批准且天数大于等于7，提交给下一个处理者处理
    }
}
</code></pre>

<pre><code class="language-java">
/**
 * 总经理
 **/
public class TopManagerHandler extends Handler {
    public TopManagerHandler(String name) {
        super(name);
    }

    public TopManagerHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;总经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        // 总经理不批准
        return result;// 总经理最后批准
    }
}
</code></pre>

<pre><code class="language-java">/**
 * 请求
 **/
@Data
@AllArgsConstructor
public class LeaveRequest {
    private String name;    // 请假人姓名
    private int numOfDays;  // 请假天数
}
</code></pre>

<pre><code class="language-java">public class ChainClient {
    public static void main(String[] args) {
        Handler topManagerHandler = new TopManagerHandler(&quot;狗蛋&quot;);
        Handler managerHandler = new ManagerHandler(&quot;饭桶&quot;, topManagerHandler);
        Handler directorHandler = new DirectorHandler(&quot;事妈&quot;, managerHandler);
        directorHandler.process(new LeaveRequest(&quot;窦娥&quot;, 3));
    }
}
</code></pre>

<h2 id="toc_4">适用场景</h2>

<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何优雅的做数据校验-Hibernate Validator详细使用说明]]></title>
    <link href="http://www.throne4j.com/15910938991760.html"/>
    <updated>2020-06-02T18:31:39+08:00</updated>
    <id>http://www.throne4j.com/15910938991760.html</id>
    <content type="html"><![CDATA[
<p>数据校验是在平时的编码过程中常做的工作，在系统的各个层可能都要去实现一些校验逻辑，再去做业务处理。这些繁琐的校验与我们的业务代码在一块就会显得臃肿。而且这些校验通常是业务无关的。也是在工作中使用到Hibernate Validator，但却发现有人没有使用好它（竟然还能看到一些if else的校验代码...），所以在这里决定整理下关于Hibernate Validator的使用<br/>
Bean Validation 2.0（JSR 380）定义了用于实体和方法验证的元数据模型和API，Hibernate Validator是目前最好的实现，这篇主要是说Hibernate Validator的使用</p>

<h2 id="toc_0">Hibernate Validator的使用</h2>

<p>依赖<br/>
如果是Spring Boot项目，那么spring-boot-starter-web中就已经依赖hibernate-validator了</p>

<pre><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>如果是Spring Mvc，那可以直接添加hibernate-validator依赖</p>

<pre><code class="language-xml&lt;dependency&gt;">    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;6.0.17.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h2 id="toc_1">bean约束声明和验证，Validator</h2>

<p>先给我们的Java对象添加约束注解</p>

<pre><code class="language-java">@Data
@AllArgsConstructor
public class User {

    private String id;

    @NotBlank
    @Size(max = 20)
    private String name;

    @NotNull
    @Pattern(regexp = &quot;[A-Z][a-z][0-9]&quot;)
    private String password;
    
    @NotNull
    private Integer age;

    @Max(10)
    @Min(1)
    private Integer level;
}
</code></pre>

<p>验证实体实例需要先获取Validator实例</p>

<pre><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
validator = factory.getValidator();
</code></pre>

<p>Validator接口有三个方法，可用于验证整个实体或仅验证实体的单个属性</p>

<ul>
<li>Validator#validate()                   验证所有bean的所有约束</li>
<li>Validator#validateProperty()   验证单个属性</li>
<li>Validator#validateValue()         检查给定类的单个属性是否可以成功验证</li>
</ul>

<pre><code class="language-java">public class UserTest {
    private static Validator validator;
    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void validatorTest() {
        User user = new User(null, &quot;&quot;, &quot;!@#$&quot;, null, 11);

        // 验证所有bean的所有约束
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate(user);
        // 验证单个属性
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateProperty(user, &quot;name&quot;);
        // 检查给定类的单个属性是否可以成功验证
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, &quot;password&quot;, &quot;sa!&quot;);

        constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
        constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
        constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    }
}
</code></pre>

<p>测试结果</p>

<pre><code class="language-text">不能为空
最大不能超过10
需要匹配正则表达式&quot;[A-Z][a-z][0-9]&quot;
不能为null
不能为空
需要匹配正则表达式&quot;[A-Z][a-z][0-9]&quot;
</code></pre>

<h2 id="toc_2">方法约束声明和验证，ExecutableValidator</h2>

<p>从Bean Validation 1.1开始，约束不仅可以应用于JavaBean及其属性，而且可以应用于任何Java类型的方法和构造函数的参数和返回值，这里简单看一个例子</p>

<pre><code class="language-java">public class RentalStation {

    public RentalStation(@NotNull String name) {
        //...
    }

    public void rentCar(@NotNull @Future LocalDate startDate, @Min(1) int durationInDays) {
        //...
    }

    @NotNull
    @Size(min = 1)
    public List&lt;@NotNull String&gt; getCustomers() {
        //...
        return null;
    }
}
</code></pre>

<p>ExecutableValidator接口可以完成方法约束的验证</p>

<pre><code class="language-text">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();
</code></pre>

<p>该ExecutableValidator界面共有四种方法：</p>

<ul>
<li>validateParameters()和validateReturnValue()用于方法验证</li>
<li>validateConstructorParameters()和validateConstructorReturnValue()用于构造函数验证</li>
</ul>

<pre><code class="language-java">public class RentalStationTest {

    private static ExecutableValidator executableValidator;

    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        executableValidator = factory.getValidator().forExecutables();
    }

    @Test
    public void validatorTest() throws NoSuchMethodException {
        RentalStation rentalStation = new RentalStation(&quot;z&quot;);

        Method method = RentalStation.class.getMethod(&quot;rentCar&quot;, LocalDate.class, int.class);
        Object[] parameterValues = {LocalDate.now().minusDays(1), 0};
        Set&lt;ConstraintViolation&lt;RentalStation&gt;&gt; violations = executableValidator.validateParameters(
                rentalStation, method, parameterValues);

        violations.forEach(violation -&gt; System.out.println(violation.getMessage()));
    }
}
</code></pre>

<p>测试结果</p>

<pre><code class="language-text">需要是一个将来的时间
最小不能小于1
</code></pre>

<p>约束注解<br/>
validator-api-2.0的约束注解有22个，具体我们看下面表格</p>

<p><strong>空与非空检查</strong></p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Null</td>
<td>Object</td>
<td>为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>Object</td>
<td>不为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>CharSequence</td>
<td>不为null，且必须有一个非空格字符</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>CharSequence、Collection、Map、Array</td>
<td>不为null，且不为空（length/size&gt;0）</td>
</tr>
</tbody>
</table>

<p>Boolean值检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@AssertTrue</td>
<td>boolean、Boolean</td>
<td>为true</td>
<td>为null有效</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>boolean、Boolean</td>
<td>为false</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>日期检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Future</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@FutureOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Past</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之前</td>
<td>为null有效</td>
</tr>
<tr>
<td>@PastOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之前</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>数值检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Max</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Min</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Negative</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@NegativeOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Positive</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@PositiveOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Digits(integer = 3, fraction = 2)</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>整数位数和小数位数上限</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>其他</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Pattern</td>
<td>CharSequence</td>
<td>匹配指定的正则表达式</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Email</td>
<td>CharSequence</td>
<td>邮箱地址</td>
<td>为null有效，默认正则 &#39;.*&#39;</td>
</tr>
<tr>
<td>@Size</td>
<td>CharSequence、Collection、Map、Array</td>
<td>大小范围（length/size&gt;0）</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>hibernate-validator扩展约束（部分）</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>@LengthString</td>
<td>字符串长度范围</td>
<td></td>
</tr>
<tr>
<td>@Range</td>
<td>数值类型和String</td>
<td>指定范围</td>
</tr>
<tr>
<td>@URL</td>
<td>URL</td>
<td>地址验证</td>
</tr>
</tbody>
</table>

<p>自定义约束注解<br/>
除了以上提供的约束注解（大部分情况都是能够满足的），我们还可以根据自己的需求自定义自己的约束注解<br/>
定义自定义约束，有三个步骤</p>

<ul>
<li>创建约束注解</li>
<li>实现一个验证器</li>
<li>定义默认的错误信息<br/>
那么下面就直接来定义一个简单的验证手机号码的注解</li>
</ul>

<pre><code class="language-java">@Documented
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Constraint(validatedBy = {MobileValidator.class})
@Retention(RUNTIME)
@Repeatable(Mobile.List.class)
public @interface Mobile {

    /**
     * 错误提示信息，可以写死,也可以填写国际化的key
     */
    String message() default &quot;手机号码不正确&quot;;

    Class&lt;?&gt;[] groups() default {};
    
    Class&lt;? extends Payload&gt;[] payload() default {};

    String regexp() default &quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$&quot;;

    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Mobile[] value();
    }
}
</code></pre>

<p>关于注解的配置这里不说了，自定义约束需要下面3个属性</p>

<ul>
<li>message 错误提示信息，可以写死,也可以填写国际化的key</li>
<li>groups 分组信息，允许指定此约束所属的验证组（下面会说到分组约束）</li>
<li>payload 有效负载，可以通过payload来标记一些需要特殊处理的操作<br/>
@Repeatable注解和List定义可以让该注解在同一个位置重复多次，通常是不同的配置（比如不同的分组和消息）<br/>
@Constraint(validatedBy = {MobileValidator.class})该注解是指明我们的自定义约束的验证器，那下面就看一下验证器的写法，需要实现javax.validation.ConstraintValidator接口</li>
</ul>

<pre><code class="language-java">public class MobileValidator implements ConstraintValidator&lt;Mobile, String&gt; {

    /**
     * 手机验证规则
     */
    private Pattern pattern;

    @Override
    public void initialize(Mobile mobile) {
        pattern = Pattern.compile(mobile.regexp());
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }

        return pattern.matcher(value).matches();
    }
}
</code></pre>

<p>ConstraintValidator接口定义了在实现中设置的两个类型参数。第一个指定要验证的注解类（如Mobile），第二个指定验证器可以处理的元素类型（如String）；initialize()方法可以访问约束注解的属性值；isValid()方法用于验证，返回true表示验证通过<br/>
Bean验证规范建议将空值视为有效。如果null不是元素的有效值，则应使用@NotNull 显式注释<br/>
到这里我们自定义的约束就写好了，可以用个例子来测试一下</p>

<pre><code class="language-java">public class MobileTest {

    public void setMobile(@Mobile String mobile){
        // to do
    }

    private static ExecutableValidator executableValidator;

    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        executableValidator = factory.getValidator().forExecutables();
    }

    @Test
    public void manufacturerIsNull() throws NoSuchMethodException {
        MobileTest mobileTest = new MobileTest();

        Method method = MobileTest.class.getMethod(&quot;setMobile&quot;, String.class);
        Object[] parameterValues = {&quot;1111111&quot;};
        Set&lt;ConstraintViolation&lt;MobileTest&gt;&gt; violations = executableValidator.validateParameters(
                mobileTest, method, parameterValues);

        violations.forEach(violation -&gt; System.out.println(violation.getMessage()));
    }
}
</code></pre>

<p>分组约束<br/>
在上面的自定义约束中，有个groups属性是用来指定验证约束的分组，我们在为属性加上注解的时候，如果没有配置分组信息，那么默认会采用默认分组 javax.validation.groups.Default<br/>
分组是用接口定义的，用做标识，这里创建两个标识AddGroup和UpdateGroup，分别标识新增和修改<br/>
public interface AddGroup {<br/>
}</p>

<p>public interface UpdateGroup {<br/>
}<br/>
复制代码<br/>
然后对我们的User对象的id属性做分组标识</p>

<pre><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Null(groups = AddGroup.class)
    @NotBlank(groups = UpdateGroup.class)
    private String id;
    
    // ... 省略了其他属性
}    

我们看下如何使用
@Test
public void validatorGroupTest() {
    User user = new User();

    // 检查给定类的单个属性是否可以成功验证
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;, UpdateGroup.class);
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;);
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;, AddGroup.class);

    constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
}
</code></pre>

<p>上面的测试只有加了UpdateGroug分组才会验证，返回错误信息，而下面的constraintViolations2并不会去验证，因为默认会采用Default分组。如果想要不标记分组的时候，也会去验证Default分组，可以去继承默认分组</p>

<pre><code class="language-java">public interface AddGroup extends Default {
}
</code></pre>

<p>在Spring中使用Hibernate Validator<br/>
上面介绍了Validator的一些使用，还有注解的介绍，那么在Spring中我们怎么去使用Hibernate Validator做验证呢？或者说再Web项目中怎么使用Hibernate Validator？<br/>
spring-boot-starter-web中是添加了hibernate-validator依赖的，说明Spring Boot本身也是使用到了Hibernate Validator验证框架的<br/>
配置Validator</p>

<pre><code class="language-java">@Configuration
public class ValidatorConfig {

    /**
     * 配置验证器
     *
     * @return validator
     */
    @Bean
    public Validator validator() {
        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)
                .configure()
                // 快速失败模式
                .failFast(true)
                // .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )
                .buildValidatorFactory();
        return validatorFactory.getValidator();
    }
}
</code></pre>

<p>可以通过方法 failFast(true)或 addProperty(&quot;hibernate.validator.fail_fast&quot;, &quot;true&quot;)设置为快速失败模式，快速失败模式在校验过程中，当遇到第一个不满足条件的参数时就立即返回，不再继续后面参数的校验。否则会一次性校验所有参数，并返回所有不符合要求的错误信息<br/>
如果是Spring MVC的话，需要xml配置可参考下面的配置</p>

<pre><code class="language-markup">&lt;mvc:annotation-driven validator=&quot;validator&quot;/&gt;

&lt;!-- validator基本配置 --&gt;
&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;
    &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt;
    &lt;!-- 映射资源文件 --&gt;
    &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot; name=&quot;messageSource&quot;&gt;
    &lt;!--&lt;property name=&quot;basenames&quot;&gt;
                &lt;list&gt;
                    &lt;value&gt;classpath:messages/messages&lt;/value&gt;
                    &lt;value&gt;classpath:messages/ValidationMessages&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;--&gt;
    &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;false&quot; /&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
    &lt;property name=&quot;cacheSeconds&quot; value=&quot;60&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>请求参数bean验证<br/>
接口上的Bean验证，需要在参数前加上@Valid或Spring的 @Validated注解，这两种注释都会导致应用标准Bean验证。如果验证不通过会抛出BindException异常，并变成400（BAD_REQUEST）响应；或者可以通过Errors或BindingResult参数在控制器内本地处理验证错误。另外，如果参数前有@RequestBody注解，验证错误会抛出MethodArgumentNotValidException异常。</p>

<pre><code class="language-java">
@RestController
public class UserController {

    @PostMapping(&quot;/user&quot;)
    public R handle(@Valid @RequestBody User user, BindingResult result) {
        // 在控制器内本地处理验证错误
        if (result.hasErrors()) {
            result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage()));
             return R.fail(result.getAllErrors().get(0).getDefaultMessage());
        }
        // ...
        return R.success();
    }

    @PostMapping(&quot;/user2&quot;)
    public R handle2(@Valid User user, BindingResult result) {
        // 在控制器内本地处理验证错误
        if (result.hasErrors()) {
            result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage()));
             return R.fail(result.getAllErrors().get(0).getDefaultMessage());
        }
        // ...
        return R.success();
    }

    /**
     * 验证不通过抛出 `MethodArgumentNotValidException`
     */
    @PostMapping(&quot;/user3&quot;)
    public R handle3(@Valid @RequestBody User user) {
        // ...
        return R.success();
    }

    /**
     * 验证不通过抛出 `BindException`
     */
    @PostMapping(&quot;/user4&quot;)
    public R handle4(@Valid User user) {
        // ...
        return R.success();
    }
}
</code></pre>

<p>配合Spring的BindingResult参数，我们是可以在控制器中去处理验证错误，不过通常也是把验证错误的消息转成我们自己的返回格式，那么在每个方法中都去做这样的验证错误处理，显然是没有必要的。我们可以利用验证不通过的异常来做统一的错误处理</p>

<pre><code class="language-java">@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * hibernate validator 数据绑定验证异常拦截
     *
     * @param e 绑定验证异常
     * @return 错误返回消息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(BindException.class)
    public R validateErrorHandler(BindException e) {
        ObjectError error = e.getAllErrors().get(0);
        log.info(&quot;数据验证异常：{}&quot;, error.getDefaultMessage());
        return R.fail(error.getDefaultMessage());
    }

    /**
     * hibernate validator 数据绑定验证异常拦截
     *
     * @param e 绑定验证异常
     * @return 错误返回消息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public R validateErrorHandler(MethodArgumentNotValidException e) {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        log.info(&quot;数据验证异常：{}&quot;, error.getDefaultMessage());
        return R.fail(error.getDefaultMessage());
    }
}    
</code></pre>

<p>方法参数验证<br/>
配置</p>

<p>Hibernate Validator是可以在方法级验证参数的，Spring中当然也是有实现的。<br/>
我们在Validator的配置中，添加MethodValidationPostProcessorBean，在上面的ValidatorConfig.java中添加一下配置</p>

<pre><code class="language-java">/**
 * 设置方法参数验证器
 */
@Bean
public MethodValidationPostProcessor methodValidationPostProcessor() {
    MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor();
    // 设置validator模式为快速失败返回
    postProcessor.setValidator(validator());
    return postProcessor;
}
</code></pre>

<p>如果是Spring Mvc，那么要在spring-mvc.xml中声明bean信息，不然在Controller里面是无效的</p>

<pre><code class="language-markup">&lt;!-- 设置方法参数验证器 --&gt;
&lt;bean id=&quot;methodValidationPostProcessor&quot; class=&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;&gt;
    &lt;property name=&quot;validator&quot; ref=&quot;validator&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>使用</p>

<p>配置了上面的MethodValidationPostProcessor，我们就可以在方法参数或返回值使用约束注解了，要注意的是，在要使用参数验证的类上一定要加上@Validated注解，否则无效</p>

<pre><code class="language-java">/**
 * 一定要加上 `@Validated` 注解
 */
@Validated
@RestController
public class UserController {

    @GetMapping(&quot;/user&quot;)
    public R handle(@Mobile String mobile) {
        // ...
        return R.success();
    }
}
</code></pre>

<p>如果验证不通过，会抛出ConstraintViolationException异常，同样的，我们可以在全局的异常处理器里面处理验证错误，在GlobalExceptionHandler中添加一下代码</p>

<pre><code class="language-java">/**
 * spring validator 方法参数验证异常拦截
 *
 * @param e 绑定验证异常
 * @return 错误返回消息
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(ConstraintViolationException.class)
public R defaultErrorHandler(ConstraintViolationException e) {
    Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations();
    ConstraintViolation&lt;?&gt; violation = violations.iterator().next();
    log.info(&quot;数据验证异常：{}&quot;, violation.getMessage());
    return R.fail(violation.getMessage());
}
</code></pre>

<p>分组<br/>
Spring的@Validate注解是可以支持分组验证的</p>

<pre><code class="language-java">@PostMapping(&quot;/user&quot;)
public R handle(@Validated(AddGroup.class) @RequestBody User user) {
    // ...
    return R.success();
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存一致性问题如何解决]]></title>
    <link href="http://www.throne4j.com/15902913212619.html"/>
    <updated>2020-05-24T11:35:21+08:00</updated>
    <id>http://www.throne4j.com/15902913212619.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>数据实时同步更新<br/>
使用缓存工具或AOP，在更新数据库的同时更新缓存，这种方式数据一致性强，</p>
<ul>
<li>不会出现缓存雪崩的问题，</li>
<li>但是代码耦合、运行期耦合、影响正常业务、增加一次网络开销，</li>
<li>适用于写操作频繁的细粒度缓存数据，数据一致实时性要求比较高的场景，如银行业务、证券业务，对于写操作较少的粗粒度操作则不适合。</li>
</ul></li>
<li><p>数据准时更新</p>
<ul>
<li>准一致性，更新数据库后，异步更新缓存，使用AOP进行封装给予多线程或者mq实现</li>
<li>数据同步有短暂延迟，与业务解耦，不影响正常业务运行，不会出现缓存雪崩问题</li>
<li>有较短延迟，需要补偿机制</li>
<li>不适合写操作频繁并且数据一致实时性要求严格的场景</li>
</ul></li>
<li><p>缓存失效机制</p>
<ul>
<li>弱一致性，给予缓存本身的失效机制</li>
<li>实现简单，与业务完美解耦，不影响正常业务</li>
<li>有一定延迟，不保证强一致性，但保证最终一致性，存在缓存雪崩的问题</li>
<li>适合于读多写少的互联网场景，能接受一定的数据延时，比如电商业务、社交业务等</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis面试]]></title>
    <link href="http://www.throne4j.com/15902453905639.html"/>
    <updated>2020-05-23T22:49:50+08:00</updated>
    <id>http://www.throne4j.com/15902453905639.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>MyBatis 的好处是什么？</p>
<ul>
<li>MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写， 给程序的维护带来了很大便利。 </li>
<li>MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象，大大简化了 Java 数据库编程的重复工作。 </li>
<li>因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的 特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查 询效率，能够完成复杂查询</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？<br/>
答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集 合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询 关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映<br/>
射工具。</li>
</ul>

<hr/>

<ul>
<li>接口绑定有几种实现方式,分别是怎么实现的?<br/>
答：接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL 来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全 路径名。</li>
</ul>

<hr/>

<ul>
<li>resultType 和 resultMap 的区别？<br/>
答：resultType 和 resultMap 都是表示数据库表与 pojo 之间的映射规则的。类的名字和数据 库相同时，可以直接设置 resultType 参数为 Pojo 类。若不同或者有关联查询，需要设置 resultMap 将结果名字和 Pojo 名字进行转换；从编程的最佳实践来讲，强制使用resultMap, 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义； </li>
</ul>

<hr/>

<ul>
<li>在 MyBatis 中如何在 mapper 接口中传入多个参数？<br/>
答：MyBatis 的接口默认只支持一个入参，如果要传递多个参数有三种方式：
<ul>
<li>使用 map 传递参数  可读性差，导致可维护性和可扩展性差，杜绝使用</li>
<li>使用注解传递参数 直观明了，当参数较少一般小于 5 个的时候，建议使用</li>
<li>使用 Java Bean 的方 式传递参数</li>
</ul></li>
</ul>

<hr/>

<ul>
<li><p><code>问${}和#{}的区别是什么？</code><br/>
答：向 sql 语句中传递的可变参数,分为预编译#{}和传值${}两种 </p>
<ul>
<li>预编译 #{}：将传入的数据都当成一个字符串，会对自动传入的数据加一个单引号，能 够很大程度防止 sql 注入； </li>
<li> 传值\({}：传入的数据直接显示生成在 sql 中，无法防止 sql 注入；适用场景：动态报表， 表名、选取的列是动态的，orderby 和 in 操作， 可以考虑使用\)</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>通过 Mybatis 怎么样进行批量插入操作<br/>
答：有两种方式：
<ul>
<li>通过 foreach 动态拼装 SQL 语句 </li>
<li> 使用 BATCH 类型的 excutor； 而且这两种方式都能返回数据库主键字段；</li>
</ul></li>
</ul>

<hr/>

<ul>
<li><p>Mybatis 怎么样实现关联查询<br/>
答：有两种方式：</p>
<ul>
<li><p>嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。使用 join 查询，一部分<br/>
列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。 </p></li>
<li><p>嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型，在关联标签中配 置 select、fetchType 这样的属性实现，是通过发送多段 SQL 实现的；</p></li>
</ul></li>
</ul>

<hr/>

<ul>
<li>什么是 N+1 问题，怎么解决？<br/>
答：嵌套查询会导致“N+1 查询问题” ，导致该问题产生的原因: 
<ul>
<li>你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。 </li>
<li>对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。 这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。 <br/>
解决“N+1 查询问题”的办法就是开启懒加载、按需加载数据，开启懒加载配置： 在select 节点上配置“fetchType=lazy”，在 MyBatis 核心配置文件中加入如下配置：</li>
</ul></li>
</ul>

<pre><code class="language-text">&lt;!-- 开启懒加载 ，当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每 种属性将会按需要加载。默认：true --&gt; 
&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;
</code></pre>

<hr/>

<ul>
<li>什么是一级缓存？怎么理解二级缓存？<br/>
答：一级缓存存在于 SqlSession 的生命周期中，在同一个 SqlSession 中查询时使用。二级缓存 也叫应用缓存，存在于 SqlSessionFactory 的生命周期中，可以理解为跨 sqlSession；二级缓存是 以 namespace 为单位的，不同 namespace 下的操作互不影响。在项目中为了避免脏读的问题， 建议不适用二级缓存。</li>
</ul>

<hr/>

<ul>
<li>Mybatis 是如何进行分页的？分页插件的原理是什么？<br/>
答： 
<ul>
<li>Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。 </li>
<li>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql。 举例： select <em>from student，拦截 sql 后重写为： select t.</em> from（select * from student） t limit 0，10</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>简述 Mybatis 的插件运行原理，以及如何编写一个插件？<br/>
答： 
<ul>
<li>Mybatis 仅可以编写针对 ParameterHandler、 ResultSetHandler、 StatementHandler、 Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理 对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦 截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>
<li>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写 注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你 编写的插件。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br/>
答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace， 那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，如果没有 namespace，就剩下 id， 那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同， namespace+id 自然也就不同。</li>
</ul>

<hr/>

<ul>
<li>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？<br/>
答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
<ul>
<li>SimpleExecutor：Mybatis 的默认执行器，每执行一次 update 或 select，就开启一个 Statement 对 象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放 置于 Map3）BatchExecutor：完成批处理。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>使用 MyBatis 的 mapper 接口调用时有哪些要求？<br/>
答： 
<ul>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同； </li>
<li> Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的 类型相同； </li>
<li>  Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型 相同； </li>
<li>  Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>为什么使用 mapper 接口就能对数据库进行访问？<br/>
答：表面上我们在使用 mapper 接口访问数据库，实际 MyBatis 通过动态代理生成了 mapper 接 口的实现类，通过这个动态生成的实现类，将数据库的访问请求转发给 SqlSession。转发过程中 需要实现三个翻译： 
<ul>
<li>通过 sql 语句的类型和接口方法的返回参数确定调用 SqlSession 的哪个方法； </li>
<li>将 sql 语句在 MyBatis 中的两维坐标作为第一个参数，传入 SqlSession 的方法；</li>
<li> 将接口传入的参数封装成 map 后作为第二个参数，传入 SqlSession 的方法； 请求转发给 SqlSession 后实现对数据库的访问操作；</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 插件开发]]></title>
    <link href="http://www.throne4j.com/15902453903846.html"/>
    <updated>2020-05-23T22:49:50+08:00</updated>
    <id>http://www.throne4j.com/15902453903846.html</id>
    <content type="html"><![CDATA[
<p>插件是用来改变或者扩展 mybatis 的原有的功能，mybaits 的插件就是通过继承 Interceptor 拦截器实现的；注意：在没有完全理解插件之前禁止使用插件对 mybaits 进行扩 展，又可能会导致严重的问题；MyBatis 中能使用插件进行拦截的接口和方法如下： </p>

<ul>
<li>Executor（update、 query、 flushStatment、 commit、 rollback、 getTransaction、 close、 isClose）</li>
<li>StatementHandler（prepare、paramterize、batch、update 、query） </li>
<li>ParameterHandler（getParameterObject 、setParameters） </li>
<li>ResultSetHandler（handleResultSets、handleCursorResultSets 、handleOutputParameters）</li>
</ul>

<h2 id="toc_0">插件开发如何实现</h2>

<h3 id="toc_1">实现Interceptor接口</h3>

<p>MyBatis插件的实现必须实现Interceptor接口，该接口有3个方法</p>

<pre><code class="language-java">public interface Interceptor {
  // 插件对业务进行增强的核心方法
  Object intercept(Invocation invocation) throws Throwable;
  // target是配拦截的对象，它的作用就是给被拦截的对象生成一个代理对象
  default Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  // 读取在plugin中设置的参数
  default void setProperties(Properties properties) {
    // NOP
  }

}

</code></pre>

<h3 id="toc_2">确定拦截的签名</h3>

<p>注解 @Intercepts 和 @Signature就是用于表示插件拦截的位置，@Intercepts 其值是一个 @Signature 数组。 @Intercepts 用于表明当前的对象是一个Interceptor， 而@Signature 则表明要拦截的接口、方法以及对应的参数类型。<br/>
如下所示：</p>

<pre><code class="language-java">@Intercepts(
        {
                @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
                @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class}),
        }
)
public class PageInterceptor implements Interceptor {

}
</code></pre>

<h3 id="toc_3">插件模块源码分析</h3>

<p>插件模块的源码分析主要搞清楚初始化、插件加载以及插件如何调用三个问题；</p>

<h4 id="toc_4">插件初始化</h4>

<p>在MyBatis配置初始化的时候，对标签plugins进行解析的时候，对插件进行了初始化</p>

<pre><code class="language-java">private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
}
</code></pre>

<p>在 configuration 对象中，使用 interceptorChain 类属性保存所有的插件， interceptorChain 类中有个 List 用于顺序保存所有的插件；</p>

<h4 id="toc_5">插件加载</h4>

<p>为什么插件可以拦截 Executor、StatementHandler、ParameterHandler、ResultSetHandler 四个接口指定的方法呢？那是因为通过 configuration 对象创建这四大对象时，通过责任 链模式按插件的顺序对四大对象进行了增强</p>

<ul>
<li>Executor的添加拦截功能</li>
</ul>

<pre><code class="language-java">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
      executor = new CachingExecutor(executor);
    }
    // 通过interceptorChain遍历所有的插件为executor增强插件功能
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}
</code></pre>

<ul>
<li>为StatementHandler添加拦截功能</li>
</ul>

<pre><code class="language-java">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
}
</code></pre>

<ul>
<li>为ParameterHandler添加拦截功能</li>
</ul>

<pre><code class="language-java">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
    return parameterHandler;
}
</code></pre>

<ul>
<li>为ResultSetHandler添加拦截功能</li>
</ul>

<pre><code class="language-java">public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
      ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
}
</code></pre>

<h4 id="toc_6">插件调用</h4>

<p>插件加载是通过 ExamplePlugin.plugin(Object)来增强的，plugin 方法内部一般使用 Plugin.wrap(target,this)来对四大对象进行增强</p>

<pre><code class="language-java">public static Object wrap(Object target, Interceptor interceptor) {
    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);
    Class&lt;?&gt; type = target.getClass();
    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);
    if (interfaces.length &gt; 0) {
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());
      if (methods != null &amp;&amp; methods.contains(method)) {
        return interceptor.intercept(new Invocation(target, method, args));
      }
      return method.invoke(target, args);
    } catch (Exception e) {
      throw ExceptionUtil.unwrapThrowable(e);
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 与 Spring整合]]></title>
    <link href="http://www.throne4j.com/15902065220428.html"/>
    <updated>2020-05-23T12:02:02+08:00</updated>
    <id>http://www.throne4j.com/15902065220428.html</id>
    <content type="html"><![CDATA[
<p>Mybatis-Spring 用于帮助你将 MyBatis 代码无缝地整合到 Spring 中，集成过程中的增强主 要体现在如下四个方面：</p>

<ul>
<li>Spring 将会加载必要的 MyBatis 工厂类和 session 类 </li>
<li>提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean<br/>
中</li>
<li>方便集成 spring 事务</li>
<li>翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常(数据访问异常)中</li>
</ul>

<h2 id="toc_0">MyBatis-Spring 集成配置最佳实践</h2>

<ul>
<li>准备Mybatis-spring的maven项目</li>
<li>pom文件中添加mybatis-spring依赖</li>
<li>配置 SqlSessionFactoryBean，在 MyBatis-Spring 中， SqlSessionFactoryBean 用于创建 SqlSessionFactory，几个关键配置选项如下所示：
<ul>
<li>dataSource ：用于配置数据源，该属性为必选项，必须通过这个属性配置数 据源 ，这里使用了上一节中配置好的 dataSource 数据库连接池 。</li>
<li> mapper Locations ： 配置 SqlSessionFactoryBean 扫描 XML 映射文件的路径， 可以使用 Ant 风格的路径进行配置。</li>
<li> configLocation ： 用于配置mybatis config XML的路径，除了数据源外，对MyBatis 的各种配直仍然可以通过这种方式进行，并且配置 MyBatis settings 时只能使 用这种方式。但配置文件中任意环境,数据源 和 MyBatis 的事务管理器都会被 忽略；</li>
<li> typeAliasesPackage ： 配置包中类的别名，配置后，包中的类在 XML 映射文 件中使用时可以省略包名部分 ，直接使用类名。这个配置不支持 Ant 风格的 路径，当需要配置多个包路径时可以使用分号或逗号进行分隔 ；</li>
</ul></li>
<li>配置 MapperScannerConfigurer，通过 MapperScannerConfigurer 类自动扫描所有的 Mapper 接口，使用时可以直接注入接口。MapperScannerConfigurer 中常配置以下两个 属性 ：
<ul>
<li>basePackage ： 用于配置基本的包路径。可以使用分号或逗号作为分隔符设 置多于一个的包路径，每个映射器将会在指定的包路径中递归地被搜索到 。</li>
<li>annotationClass ： 用于过滤被扫描的接口，如果设置了该属性，那么 MyBatis 的接口只有包含该注解才会被扫描进去</li>
</ul></li>
<li>配置事务，让 Mybatis 集成 spring 的事务；</li>
</ul>

<p>项目GitHub地址： <a href="https://github.com/qsk1226/mybatis-spring-study">mybatis-spring-study</a></p>

<h2 id="toc_1">mybatis-spring 集成原理分析</h2>

<h3 id="toc_2">SqlSessionFactoryBean 源码分析</h3>

<p>它创建一个MyBatis SqlSessionFactory。这是在Spring应用程序上下文中设置共享MyBatis SqlSessionFactory的常用方法;然后，SqlSessionFactory可以通过依赖注入传递到基于mybatiso的dao。DataSourceTransactionManager或JtaTransactionManager都可以与SqlSessionFactory一起用于事务界定。JTA应该用于跨多个数据库的事务或正在使用容器管理事务(container managed transactions, CMT)的事务。</p>

<p>SqlSessionFactoryBean 来充当 SqlSessionFactory，这里我们要搞清楚的就是为什么 SqlSessionFactoryBean 为什么能在 Spring IOC 容器中以 SqlSessionFactory 的类型保存并被获 取？先来看看 SqlSessionFactoryBean 的定义是怎样的：</p>

<pre><code class="language-java">public class SqlSessionFactoryBean
    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; {

  private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class);

  private static final ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = new PathMatchingResourcePatternResolver();
  private static final MetadataReaderFactory METADATA_READER_FACTORY = new CachingMetadataReaderFactory();

  private Resource configLocation;

  private Configuration configuration;

  private Resource[] mapperLocations;

  private DataSource dataSource;

  private TransactionFactory transactionFactory;

  private Properties configurationProperties;

  private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();

  private SqlSessionFactory sqlSessionFactory;

  // EnvironmentAware requires spring 3.1
  private String environment = SqlSessionFactoryBean.class.getSimpleName();

  private boolean failFast;

  private Interceptor[] plugins;

  private TypeHandler&lt;?&gt;[] typeHandlers;

  private String typeHandlersPackage;

  private Class&lt;?&gt;[] typeAliases;

  private String typeAliasesPackage;

  private Class&lt;?&gt; typeAliasesSuperType;

  private LanguageDriver[] scriptingLanguageDrivers;

  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;

  // issue #19. No default provider.
  private DatabaseIdProvider databaseIdProvider;

  private Class&lt;? extends VFS&gt; vfs;

  private Cache cache;

  private ObjectFactory objectFactory;

  private ObjectWrapperFactory objectWrapperFactory;

}
</code></pre>

<h4 id="toc_3">SqlSessionFactoryBean 实现了 <strong><em>InitializingBean</em></strong> 接口，那么容器在初始化完成 SqlSessionFactoryBean 之后必然会调用 afterPropertiesSet()方法</h4>

<pre><code class="language-java"> @Override
  public void afterPropertiesSet() throws Exception {
notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);
notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);
state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),
    &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);
// 封装者MyBatis的配置初始化阶段
this.sqlSessionFactory = buildSqlSessionFactory();
}
</code></pre>

<h4 id="toc_4">SqlSessionFactoryBean 实现了 <strong><em>FactoryBean</em></strong> 接口，当在容器中配置 FactoryBean 的实现类时，并不是将该 FactoryBean 注入到容器，而是调用 FactoryBean 的 getObject 方法产生的实例对象注入容器</h4>

<pre><code class="language-java">/**
 * 将sqlSessionFactory对象注入spring容器
 */
public SqlSessionFactory getObject() throws Exception {
if (this.sqlSessionFactory == null) {
  afterPropertiesSet();
}

return this.sqlSessionFactory;
}
</code></pre>

<p>SqlSessionFactoryBean 就是将 sqlSessionFactory 注入容器， IOC 容器中的其他类型能拿到 SqlSession 实例了，就可以进行相关的 SQL 执行任务了；</p>

<h3 id="toc_5">MapperFactoryBean 源码分析</h3>

<p>在之前的所有配置中都没有出现过MapperFactoryBean，但实际上真正帮助Spring生成Mapper接口实现类的就是MapperFactoryBean</p>

<pre><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {

  private Class&lt;T&gt; mapperInterface;

  private boolean addToConfig = true;

  /**
   * 方法实际是封装了 MyBatis 的第二阶段,获取 Mapper 接口
   * getSqlSession():用户应该使用这个方法来获取一个SqlSession来调用它的语句方法，这个SqlSession是由spring管理的。用户不应该提交/回滚/关闭它，因为它将自动完成。
   * 
   * getMapper(this.mapperInterface)获取mapper接口
   */
  @Override
  public T getObject() throws Exception {
    return getSqlSession().getMapper(this.mapperInterface);
  }
}
</code></pre>

<p>MapperFactoryBean 实现了 FactoryBean 接口，getObject 方法实际是封装了 MyBatis 的第二阶段，注入容器的是 SqlSession 实例化的 Mapper 接口的实现类。</p>

<p>它是支持注入MyBatis映射器接口的BeanFactory，可以使用SqlSessionFactory或预先配置的SqlSessionTemplate进行设置，这个工厂只能注入接口，而不能注入具体的类。</p>

<h3 id="toc_6">MapperScannerConfigurer 源码分析</h3>

<p>MapperFactoryBean 用于帮助 Spring 生成 Mapper 接口，但我们很少直接配置 MapperFactoryBean 而是配置 MapperScannerConfigurer。</p>

<p>原因在于又可能工程中的 mapper 接口数量比较多，为每个 mapper 接口都配置 MapperFactoryBean，配置文件会变得非常庞大，所以才会使用 MapperScannerConfigurer 为 每个 mapper 接口一对一的生成 MapperFactoryBean，那 MapperScannerConfigurer 是怎么做 到的呢？先看看其源码：</p>

<pre><code class="language-java">/**
 * BeanDefinitionRegistryPostProcessor： spring容器的后置处理器的一种实现，可以将Bean的结构调整之后注入容器中
 * 
 */
public class MapperScannerConfigurer
    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {

  private String basePackage;

  private boolean addToConfig = true;

  private String lazyInitialization;

  private SqlSessionFactory sqlSessionFactory;

  private SqlSessionTemplate sqlSessionTemplate;

  private String sqlSessionFactoryBeanName;

  private String sqlSessionTemplateBeanName;

  private Class&lt;? extends Annotation&gt; annotationClass;

  private Class&lt;?&gt; markerInterface;

  private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass;

  private ApplicationContext applicationContext;

  private String beanName;

  private boolean processPropertyPlaceHolders;

  private BeanNameGenerator nameGenerator;
 
 
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    if (this.processPropertyPlaceHolders) {
      processPropertyPlaceHolders();
    }

    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.setAddToConfig(this.addToConfig);
    scanner.setAnnotationClass(this.annotationClass);
    scanner.setMarkerInterface(this.markerInterface);
    scanner.setSqlSessionFactory(this.sqlSessionFactory);
    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
    scanner.setResourceLoader(this.applicationContext);
    scanner.setBeanNameGenerator(this.nameGenerator);
    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
    if (StringUtils.hasText(lazyInitialization)) {
      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
    }
    scanner.registerFilters();
    scanner.scan(
        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
  
  // 省略一大堆代码
}
</code></pre>

<p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口， 因此可以对 Bean 的结构调整之后再注入容器。那 MapperScannerConfigurer 在扫描完这些 mapper 接口之后，主要是通过ClassPathMapperScanner将 Mapper 接口一个个的转换成 MapperFactoryBean 之后注入容器。</p>

<p>至此就完成了 MyBatis 与 Spring框架的整合。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程等待/通知机制]]></title>
    <link href="http://www.throne4j.com/15896322618729.html"/>
    <updated>2020-05-16T20:31:01+08:00</updated>
    <id>http://www.throne4j.com/15896322618729.html</id>
    <content type="html"><![CDATA[
<p>是指一个线程 A 调用了对象 X 的 wait()方法进入等待状态，<br/>
而另一个线程 B 调用了对象 X的 notify()或者 notifyAll()方法，<br/>
线程 A 收到通知后从对象 X 的 wait() 方法返回，进而执行后续操作。</p>

<p>上述两个线程通过对象 X 来完成交互，而对象 上的 wait()和 notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>

<p>notify()： 通知一个在对象上等待的线程,使其从 wait 方法返回,而返回的前提是该线程 获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。 </p>

<p>notifyAll()： 通知所有等待在该对象上的线程 </p>

<p>wait() 调用该方法的线程进入 WAITING 状态,只有等待另外线程的通知或被中断 才会返回.需要注意,调用 wait()方法后,会释放对象的锁 </p>

<p>wait(long) 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n 毫秒,如果没有 通知就超时返回 wait (long,int) 对于超时时间更细粒度的控制,可以达到纳秒</p>

<p>等待和通知的标准范式 等待方遵循如下原则:</p>

<p>1）获取对象的锁。 <br/>
2）如果条件不满足，那么调用对象的 wait()方法，被通知后仍要检查条件。 <br/>
3）条件满足则执行对应的逻辑。</p>

<pre><code class="language-text">synchronized(obj) {
    while(obj.isOk()) {
        obj.wait();
    }
}
</code></pre>

<p>通知方遵循如下原则: </p>

<p>1）获得对象的锁。 <br/>
2）改变条件。 <br/>
3）通知所有等待在对象上的线程。</p>

<pre><code class="language-text">synchronized(obj) {
    obj.notifyAll();
}
</code></pre>

<p>在调用 wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，<br/>
即只能在同步方法或同步块中调用 wait(）方法、notify()系列方法，进入 wait(）方法后，当前线程释放锁，在从 wait(）返回前，线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会 继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的 线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>

<p>Question: 调用 yield() 、sleep()、wait()、notify()等方法对锁有何影响？ </p>

<p>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。 </p>

<p>调用 wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行 wait 方法后面的代码。 </p>

<p>调用 notify()系列方法后，对锁无影响，线程只有在 syn 同步代码执行完后才 会自然而然的释放锁，所以 notify()系列方法一般都是 syn 同步代码的最后一行</p>

<p>使用wait、和notify实现一个连接池的实例如下：</p>

<pre><code class="language-java">public class DBPool {

    /*容器，存放连接*/
    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();

    /*限制了池的大小=20*/
    public DBPool(int initialSize) {
        if (initialSize &gt; 0) {
            for (int i = 0; i &lt; initialSize; i++) {
                pool.addLast(createConnection());
            }
        }
    }

    /*释放连接,通知其他的等待连接的线程*/
    public void releaseConnection(Connection connection) {
        if (connection != null) {
            synchronized (pool){
                pool.addLast(connection);
                //通知其他等待连接的线程
                pool.notifyAll();
            }
        }
    }

    /*获取*/
    // 在mills内无法获取到连接，将会返回null 1S
    public Connection fetchConnection(long mills)
            throws InterruptedException {
        synchronized (pool){
            //永不超时
            if(mills&lt;=0){
                while(pool.isEmpty()){
                    pool.wait();
                }
                return pool.removeFirst();
            }else{
                /*超时时刻*/
                long future = System.currentTimeMillis()+mills;
                /*等待时长*/
                long remaining = mills;
                while(pool.isEmpty()&amp;&amp;remaining&gt;0){
                    pool.wait(remaining);
                    /*唤醒一次，重新计算等待时长*/
                    remaining = future-System.currentTimeMillis();
                }
                Connection connection = null;
                if(!pool.isEmpty()){
                    connection = pool.removeFirst();
                }
                return connection;
            }
        }

    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis逆向工程]]></title>
    <link href="http://www.throne4j.com/15896298256850.html"/>
    <updated>2020-05-16T19:50:25+08:00</updated>
    <id>http://www.throne4j.com/15896298256850.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">配置文件</h2>

<p>generator.properties</p>

<pre><code class="language-properties">jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.connectionURL=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false
jdbc.user=root
jdbc.password=12345678
java.target.package=com.shengke.sbd.entity
example.target.package=com.shengke.sbd.entity.example
mapper.target.package=com.shengke.sbd.mapper
sql.mapper.target.package=mapper

</code></pre>

<p>generatorConfig.xml</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
    &lt;properties resource=&quot;generator/generator.properties&quot;/&gt;

    &lt;!--MyBatis3、 Mybatis3Simple（没有example这些个东西），defaultModelType推荐 flat， 可选值flat、conditional、hierarchical--&gt;
    &lt;context id=&quot;mysql&quot; targetRuntime=&quot;Mybatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
                   一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
                --&gt;
        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 生成的Java文件的编码 --&gt;
        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
        &lt;!-- 格式化java代码 --&gt;
        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
        &lt;!-- 格式化XML代码 --&gt;
        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;


        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;


        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;
        &lt;!--重新生成覆盖原mapper.XML文件--&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.OverIsMergeablePlugin&quot;/&gt;
        &lt;!-- Example和mapper类中文注释 --&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.CommentPlugin&quot;/&gt;
        &lt;!-- .Lombok插件 默认在实体类里增加@Data 不生成Get、Set方法 --&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.LombokPlugin&quot;&gt;
            &lt;property name=&quot;lombokAnnotations&quot; value=&quot;@Data&quot;/&gt;
        &lt;/plugin&gt;

        &lt;!-- 修改生成的Example类的类名和Mapper类中的方法名或参数名--&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.ExampleConfigPlugin&quot;&gt;
            &lt;!-- example包名 --&gt;
            &lt;property name=&quot;targetPackage&quot; value=&quot;${example.target.package}&quot;/&gt;
            &lt;property name=&quot;classMethodSearchString&quot; value=&quot;Example&quot;/&gt;
            &lt;property name=&quot;classMethodReplaceString&quot; value=&quot;Condition&quot;/&gt;
            &lt;property name=&quot;parameterSearchString&quot; value=&quot;example&quot;/&gt;
            &lt;property name=&quot;parameterReplaceString&quot; value=&quot;condition&quot;/&gt;
        &lt;/plugin&gt;
        &lt;!--生成中文注释--&gt;
        &lt;commentGenerator type=&quot;com.mybatis.generator.comment.MyCommentGenerator&quot;&gt;
            &lt;!-- 是否禁止显示日期 true：是 ： false:否 --&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;
            &lt;!-- 是否去除自动生成的所有注释 true：是 ： false:否 --&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt;
            &lt;!--注释是否包含数据库表的注释--&gt;
            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;!--数据库链接URL，用户名、密码 --&gt;
        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.connectionURL}&quot; userId=&quot;${jdbc.user}&quot;
                        password=&quot;${jdbc.password}&quot;&gt;
            &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- java类型处理器
            用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；
        --&gt;
        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;useJava8Time&quot; value=&quot;${jdk.use_jdk8_time}&quot;/&gt;
        &lt;/javaTypeResolver&gt;

        &lt;!-- 配置生成实体类的包名和位置 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;${java.target.package}&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!--  for MyBatis3/MyBatis3Simple
                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
             --&gt;
            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

            &lt;!-- for MyBatis3 / MyBatis3Simple
                是否创建一个不可变的类，如果为true，
                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
             --&gt;
            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

            &lt;!-- 设置一个根对象，
                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                    1，属性名相同，类型相同，有相同的getter/setter方法；
                比如BaseEntity中定义的createdTime、createUserId、createUserName等
             --&gt;
            &lt;!--&lt;property name=&quot;rootClass&quot; value=&quot;com.indexes.server.domain.BaseDomain&quot;/&gt;--&gt;

            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
        &lt;/javaModelGenerator&gt;


        &lt;!-- 生成SQL map的XML文件生成器，
            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
            targetPackage/targetProject:同javaModelGenerator
         --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;${sql.mapper.target.package}&quot; targetProject=&quot;src/main/resources&quot;&gt;
            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/sqlMapGenerator&gt;


        &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口
            targetPackage/targetProject:同javaModelGenerator
            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
        --&gt;
        &lt;javaClientGenerator targetPackage=&quot;${mapper.target.package}&quot; type=&quot;XMLMAPPER&quot;
                             targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

            &lt;!--可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查--&gt;
            &lt;property name=&quot;rootInterface&quot; value=&quot;com.shengke.sbd.mapper.BaseMapper&quot;/&gt;

        &lt;/javaClientGenerator&gt;


        &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
            选择的table会生成一下文件：
            1，SQL map文件
            2，生成一个主键类；
            3，除了BLOB和主键的其他字段的类；
            4，包含BLOB的类；
            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
            6，Mapper接口（可选）

            tableName（必要）：要生成对象的表名；
            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
                4，否则，使用指定的大小写格式查询；
            另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
            这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；

            可选：
            1，schema：数据库的schema；
            2，catalog：数据库的catalog；
            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
            5，enableInsert（默认true）：指定是否生成insert语句；
            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
            13，modelType：参考context元素的defaultModelType，相当于覆盖；
            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性

            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
         --&gt;
        &lt;!--
            &lt;table tableName=&quot;t_collection_order_approval&quot; domainObjectName=&quot;CollectionOrderApproval&quot;
                   enableSelectByExample=&quot;true&quot;
                   enableCountByExample=&quot;true&quot;
                   enableDeleteByExample=&quot;true&quot;
                   enableUpdateByExample=&quot;true&quot;&gt;
              &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
              &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
              &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
              &lt;columnOverride column=&quot;create_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;update_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;cancel_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;customer_type&quot; javaType=&quot;java.lang.Integer&quot;/&gt;
              &lt;columnOverride column=&quot;special_customer_reason&quot; javaType=&quot;java.lang.Integer&quot;/&gt;
            &lt;/table&gt;
        --&gt;
        &lt;!--&lt;table  tableName=&quot;%&quot;&gt;&lt;/table&gt;--&gt;

        &lt;table tableName=&quot;t_user&quot; domainObjectName=&quot;User&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_role_permission&quot; domainObjectName=&quot;RolePermission&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_health_report_female&quot; domainObjectName=&quot;HealthReportFemale&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_health_report_male&quot; domainObjectName=&quot;HealthReportMale&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_job_history&quot; domainObjectName=&quot;JobHistory&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_position&quot; domainObjectName=&quot;Position&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_role&quot; domainObjectName=&quot;Role&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_user_role&quot; domainObjectName=&quot;UserRole&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_user_test&quot; domainObjectName=&quot;UserTest&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;

&lt;/generatorConfiguration&gt;


</code></pre>

<h2 id="toc_1">maven关于mybatis反向工程的插件</h2>

<pre><code class="language-markup">&lt;plugin&gt;
    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.3.6&lt;/version&gt;
    &lt;configuration&gt;
        &lt;configurationFile&gt;src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;
        &lt;outputDirectory&gt;${project.build.directory}/generated/mybatis-generator&lt;/outputDirectory&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;overwrite&gt;true&lt;/overwrite&gt;
    &lt;/configuration&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.19&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mybatis.generator.plugin&lt;/groupId&gt;
            &lt;artifactId&gt;generator-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[享元模式]]></title>
    <link href="http://www.throne4j.com/15896298176989.html"/>
    <updated>2020-05-16T19:50:17+08:00</updated>
    <id>http://www.throne4j.com/15896298176989.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">享元模式的定义</h2>

<p>享元模式是一种<strong>结构性设计模式</strong>，它是考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>

<p>采用一个共享类来避免大量拥有相同内容的“小类”的开销。这种开销中最常见、直观的影响就是增加了内存的损耗。</p>

<p>享元模式以共享的方式高效地支持大量的细粒度对象，减少其带来的开销，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。其中：</p>

<ul>
<li>内部状态 是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li>
<li>外部状态 是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 </li>
</ul>

<h2 id="toc_1">享元模式结构</h2>

<p>单纯享元模式的结构。</p>

<ul>
<li>抽象享元角色: 为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式 通过此方法传入。在 Java 中可以由抽象类、接口来担当。</li>
<li>具体享元角色: 实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供 存储空间。</li>
<li>享元工厂角色: 负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关 键!</li>
<li>客户端角色: 维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。 来用类图来形象地表示出它们的关系吧。</li>
</ul>

<p><img src="media/15896298176989/15917826923765.jpg" alt=""/></p>

<h3 id="toc_2">优点</h3>

<p>1）它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；<br/>
2）享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p>

<h3 id="toc_3">缺点</h3>

<p>1）享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化；<br/>
2）为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</p>

<h2 id="toc_4">代码示例</h2>

<pre><code class="language-java">/**
 * 抽象享元角色类
 *
 **/
public interface Flyweight {
    /**
     * 一个示意性方法，参数state是外蕴状态
     */
    public void operation(String state);
}
</code></pre>

<pre><code class="language-java">/**
 * 具体享元角色类
 * &lt;p&gt;
 * 具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象
 * 被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，
 * 在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。
 *
 **/
public class ConcreteFlyweight implements Flyweight {
    private Character intrinsicState = null;

    /**
     * 构造函数，内蕴状态作为参数传入
     *
     * @param state
     */
    public ConcreteFlyweight(Character state) {
        this.intrinsicState = state;
    }


    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，但是并不改变对象的内蕴状态。
     *
     * @param state 外蕴状态
     */
    @Override
    public void operation(String state) {
        // TODO Auto-generated method stub
        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);
        System.out.println(&quot;Extrinsic State = &quot; + state);
    }

}
</code></pre>

<pre><code class="language-java">/**
 * 享元工厂角色类
 * &lt;p&gt;
 * 必须指出的是，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。
 * 一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。
 * 当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。
 **/
public class FlyweightFactory {
    private Map&lt;Character, Flyweight&gt; files = new HashMap&lt;&gt;();

    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;First Call&quot;);

        fly = factory.factory(&#39;b&#39;);
        fly.operation(&quot;Second Call&quot;);

        fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;Third Call&quot;);
    }

}
</code></pre>

<pre><code class="language-java">/**
 * 复合享元角色类
 * &lt;p&gt;
 * 复合享元对象是由单纯享元对象通过复合而成的，因此它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，
 * 这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。
 * 复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。
 * 一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；
 * 而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。
 **/
public class ConcreteCompositeFlyweight implements Flyweight {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 增加一个新的单纯享元对象到聚集中
     */
    public void add(Character key, Flyweight fly) {
        flyweightMap.put(key, fly);
    }

    /**
     * 外蕴状态作为参数传入到方法中
     */
    @Override
    public void operation(String state) {
        Flyweight fly = null;
        for (Object o : flyweightMap.keySet()) {
            fly = flyweightMap.get(o);
            fly.operation(state);
        }

    }

}
</code></pre>

<pre><code class="language-java">/**
 * 复合享元工厂角色类
 * &lt;p&gt;
 * 享元工厂角色提供两种不同的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。
 **/
public class CompositeFlyweightFactory {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 复合享元工厂方法
     */
    public Flyweight factory(List&lt;Character&gt; compositeState) {
        ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight();

        for (Character state : compositeState) {
            compositeFly.add(state, this.factory(state));
        }

        return compositeFly;
    }

    /**
     * 单纯享元工厂方法
     */
    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = flyweightMap.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            flyweightMap.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        List&lt;Character&gt; compositeState = new ArrayList&lt;&gt;();
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);
        compositeState.add(&#39;c&#39;);
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);

        CompositeFlyweightFactory flyFactory = new CompositeFlyweightFactory();
        Flyweight compositeFly1 = flyFactory.factory(compositeState);
        Flyweight compositeFly2 = flyFactory.factory(compositeState);
        compositeFly1.operation(&quot;Composite Call&quot;);

        System.out.println(&quot;---------------------------------&quot;);
        System.out.println(&quot;复合享元模式是否可以共享对象：&quot; + (compositeFly1 == compositeFly2));

        Character state = &#39;a&#39;;
        Flyweight fly1 = flyFactory.factory(state);
        Flyweight fly2 = flyFactory.factory(state);
        System.out.println(&quot;单纯享元模式是否可以共享对象：&quot; + (fly1 == fly2));
    }

}
</code></pre>

<h2 id="toc_5">适用场景</h2>

<p>在以下情况下可以使用享元模式：</p>

<ul>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中(细粒度对象)；</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li>
</ul>

<p><strong>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模板方法模式]]></title>
    <link href="http://www.throne4j.com/15896087713606.html"/>
    <updated>2020-05-16T13:59:31+08:00</updated>
    <id>http://www.throne4j.com/15896087713606.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">模板方法模式的定义</a>
</li>
<li>
<a href="#toc_1">模板方法模式结构</a>
<ul>
<li>
<a href="#toc_2">模板方法模式 UML</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">使用场景</a>
</li>
</ul>


<h2 id="toc_0">模板方法模式的定义</h2>

<p>模板方法(Template Method)模式: 定义一个操作中的算法的骨架，而将一些步骤延<br/>
迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<p>模板方法模式也是为了解决某些变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。</p>

<h2 id="toc_1">模板方法模式结构</h2>

<ul>
<li><p>抽象类</p>
<ul>
<li>定义了一到多个的抽象方法，以供具体的子类来实现它们</li>
<li>需要实现一个模板方法，来定义一个算法的骨架。该模板方法不仅调用前面的抽象方法，也可以调用其他的操作，只要能完成自身的使命。</li>
</ul></li>
<li><p>具体类<br/>
实现父类中的抽象方法以完成算法中与特定子类相关的步骤。</p></li>
</ul>

<h3 id="toc_2">模板方法模式 UML</h3>

<p><img src="media/15896087713606/15917532214702.jpg" alt=""/></p>

<h2 id="toc_3">使用场景</h2>

<p>模板方法适用于以下情况:</p>

<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>控制子类扩展。<br/>
模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做:一是在 API 中不体现出你的模板方法;或者将你的模板方法置为 final 就可以了。 可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。这样你在实现子类的时候，根本不需要对业务流程有太多的了解。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配器模式]]></title>
    <link href="http://www.throne4j.com/15896081275436.html"/>
    <updated>2020-05-16T13:48:47+08:00</updated>
    <id>http://www.throne4j.com/15896081275436.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">适配器定义</a>
</li>
<li>
<a href="#toc_1">适配器模式结构</a>
<ul>
<li>
<a href="#toc_2">对象适配器模式</a>
</li>
<li>
<a href="#toc_3">类适配器模式</a>
</li>
<li>
<a href="#toc_4">优点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">代码示例</a>
</li>
<li>
<a href="#toc_7">使用场景</a>
</li>
</ul>


<h2 id="toc_0">适配器定义</h2>

<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>

<h2 id="toc_1">适配器模式结构</h2>

<p>适配器模式角色：</p>

<ul>
<li>Target： 目标角色，客户端期待得到的接口</li>
<li>Adaptee: 适配者角色，被适配的接口</li>
<li>Adapter：适配器角色，将原接口转换成目标接口</li>
</ul>

<h3 id="toc_2">对象适配器模式</h3>

<p><img src="media/15896081275436/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="对象适配器模式"/></p>

<h3 id="toc_3">类适配器模式</h3>

<p><img src="media/15896081275436/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="类适配器模式"/></p>

<h3 id="toc_4">优点</h3>

<ul>
<li><p>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</p></li>
<li><p>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</p></li>
<li><p>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p></li>
<li><p>类适配器模式还具有如下优点：<br/>
由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p></li>
<li><p>对象适配器模式还具有如下优点：<br/>
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 </p>
<h3 id="toc_5">缺点</h3></li>
<li><p>类适配器模式的缺点如下：<br/>
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p></li>
<li><p>对象适配器模式的缺点如下：<br/>
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 </p></li>
</ul>

<h2 id="toc_6">代码示例</h2>

<pre><code class="language-java">
/**
 * 被适配接口--安卓传统方式充电接口
 */
public interface TraditionalCharge {

    /**
     * 传统充电
     */
    void chargeWithTraditional();
}

/**
 * 安卓传统方式充电实现--adaptee
 *
 **/
public class TraditionalChargeImpl implements TraditionalCharge {
    @Override
    public void chargeWithTraditional() {
        System.out.println(&quot;使用传统的安卓充电头进行充电&quot;);
    }
}


/**
 * typeC充电接口 target
 **/
public interface TypeCCharge {
    /**
     * type-C充电
     */
    void chargeWithTypeC();
}

</code></pre>

<p>对象适配器</p>

<pre><code class="language-java">/**
 * 对象适配器  --- adapter
 **/
public class ChargeAdapter implements TypeCCharge {
    /**
     * 被适配对象
     */
    private TraditionalCharge traditionalCharge;

    public ChargeAdapter(TraditionalCharge traditionalCharge) {
        this.traditionalCharge = traditionalCharge;
    }

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        traditionalCharge.chargeWithTraditional();
    }

    public static void main(String[] args) {
        ChargeAdapter chargeAdapter = new ChargeAdapter(new TraditionalChargeImpl());
        chargeAdapter.chargeWithTypeC();
    }
}
</code></pre>

<p>类适配器</p>

<pre><code class="language-java">/**
 * 类适配器  --- adapter
 **/
public class AndroidChargeAdapter extends TraditionalChargeImpl implements TypeCCharge{

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        chargeWithTraditional();
    }

    public static void main(String[] args) {
        AndroidChargeAdapter androidChargeAdapter = new AndroidChargeAdapter();
        androidChargeAdapter.chargeWithTypeC();
    }
}

</code></pre>

<h2 id="toc_7">使用场景</h2>

<ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式]]></title>
    <link href="http://www.throne4j.com/15896032913368.html"/>
    <updated>2020-05-16T12:28:11+08:00</updated>
    <id>http://www.throne4j.com/15896032913368.html</id>
    <content type="html"><![CDATA[
<p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>

<p>单例模式的要点有三个：</p>

<ul>
<li>是某个类只能有一个实例；</li>
<li>是它必须自行创建这个实例；</li>
<li>是它必须自行向整个系统提供这个实例。</li>
</ul>

<p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>

<h2 id="toc_0">单例模式结构</h2>

<p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<p>单例模式包含的角色只有一个，就是单例类——Singleton。</p>

<p>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。</p>

<p>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p>

<p>在单例模式的实现过程中，需要注意如下三点：</p>

<ul>
<li>单例类的构造函数为私有；</li>
<li>提供一个自身的静态私有成员变量；</li>
<li>提供一个公有的静态工厂方法。</li>
</ul>

<p><img src="media/15896032913368/15896221967721.jpg" alt=""/></p>

<h2 id="toc_1">常见的单例实现</h2>

<h3 id="toc_2">饿汉模式</h3>

<pre><code class="language-java">public class Singleton {  
     private static Singleton instance = new Singleton();  
     private Singleton (){
     }
     public static Singleton getInstance() {  
     return instance;  
     }  
 }  
</code></pre>

<h3 id="toc_3">懒汉模式</h3>

<pre><code class="language-java">public class Singleton {

    private Singleton(){} // 私有构造

    private static volatile Singleton instance = null; // 私有单例对象

    // 静态工厂
    public static Singleton getInstance(){
        if (instance == null) { // 双重检测机制
            synchronized (Singleton.class) { // 同步锁
                if (instance == null) { // 双重检测机制
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}

</code></pre>

<h3 id="toc_4">静态内部类实现方式</h3>

<pre><code class="language-java">/**
 * 从外部无法访问静态内部类 LazyHolder，只有当调用 Singleton.getInstance() 方法的时候，才能得到单例对象 INSTANCE。
* INSTANCE 对象初始化的时机并不是在单例类 Singleton 被加载的时候，而是在调用 getInstance 方法，使得静态内部类 LazyHolder 被加载的时候。
* 这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。
 */
public class Singleton {

    private static class LazyHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton (){}

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }

}

</code></pre>

<h3 id="toc_5">使用容器实现</h3>

<pre><code class="language-java">public class SingletonManager { 
　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();
　　private Singleton() { 
　　}
　　public static void registerService(String key, Object instance) {
　　　　if (!objMap.containsKey(key) ) {
　　　　　　objMap.put(key, instance) ;
　　　　}
　　}
　　public static Object getService(String key) {
　　　　return objMap.get(key) ;
　　}
}
</code></pre>

<h3 id="toc_6">枚举实现</h3>

<pre><code class="language-java">public enum Singleton {
    INSTANCE;
    
    public void doSomeThing() {
        //做点什么
    }  
}
</code></pre>

<h2 id="toc_7">使用场景</h2>

<p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>

<p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>

<p>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建造者模式]]></title>
    <link href="http://www.throne4j.com/15894404386842.html"/>
    <updated>2020-05-14T15:13:58+08:00</updated>
    <id>http://www.throne4j.com/15894404386842.html</id>
    <content type="html"><![CDATA[
<p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式，建造者模式又可以称为生成器模式。</p>

<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>

<h2 id="toc_0">建造者模式结构</h2>

<p>建造者模式包含如下角色：</p>

<ul>
<li>Builder 抽象建造者</li>
<li>BuilderImpl 具体建造者</li>
<li>Director 指挥者</li>
<li>Product 产品</li>
</ul>

<p><img src="media/15894404386842/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="建造者模式"/></p>

<p>抽象建造者类中定义了产品的创建方法和返回方法;</p>

<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>

<p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p>

<h2 id="toc_1">优点</h2>

<ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>

<h2 id="toc_2">代码示例（简化版的建造者模式）</h2>

<pre><code class="language-java">public class Race {
    private String name;
    private String feature;

    public Race(String name, String feature) {
        this.name = name;
        this.feature = feature;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getFeature() {
        return feature;
    }

    public void setFeature(String feature) {
        this.feature = feature;
    }

    public static RaceBuilder builder() {
        return new RaceBuilder();
    }

    public static class RaceBuilder {
        private String name;
        private String feature;

        public RaceBuilder name(String name) {
            this.name = name;
            return this;
        }

        public RaceBuilder feature(String feature) {
            this.feature = feature;
            return this;
        }

        public Race build() {
            return new Race(this.name, this.feature);
        }

    }
}
</code></pre>

<h2 id="toc_3">使用场景</h2>

<p>在以下情况下可以使用建造者模式：</p>

<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>

<h3 id="toc_4">注意</h3>

<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br/>
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# 阿里面试题]]></title>
    <link href="http://www.throne4j.com/15892642645497.html"/>
    <updated>2020-05-12T14:17:44+08:00</updated>
    <id>http://www.throne4j.com/15892642645497.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Java基础</h2>

<ul>
<li>List 和 Set 的区别<br/>
list是可以重复. 在遍历时按照插入顺序<br/>
set底层实现是hashMap. 是不可以重复的. 遍历的顺序页不是插入时的循序</li>
<li><p>HashSet 是如何保证不重复的<br/>
HashSet的add方法, 内部调用的是hashMap的put方法. <br/>
put方法的插入步骤如下:</p></li>
</ul>

<ol>
<li>检查table的数组是否为null或者length是否为0  true 初始化table</li>
<li>通过key的hash和length-1算出桶的位置i table[i] == null. newNode(hash, key , val, null) 直接插入, p</li>
<li>如果p的hash值和key都和当前待插入的key和hash值相等. 插入</li>
<li>如果p位置是treeNode, 调用红黑树的put方法插入</li>
<li>上述都不是. 那p一定是链表. 遍历整个链表. 如果能找到当期key相等的. 替换他的val 否则尾插法. 插入链表. 当链表的长度超过阈值时, 转换为treeNode</li>
<li>当size阈值的时候. 扩容.</li>
</ol>

<p>通过上述流程. 保证了HashSet是不会出现重复的.</p>

<ul>
<li>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</li>
</ul>

<p>HashMap是线程不安全的. 在扩容和计算map容量的时候, 添加链表修改指针的时候  没有进行同步操作. </p>

<ul>
<li>HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</li>
</ul>

<p>1.8的hashMap 将超过阈值的链表转化为红黑树. 这是一点优化. </p>

<ul>
<li>final finally finalize</li>
</ul>

<p>final关键字修饰的类. 表示类不可以被继承.<br/>
final关键字修饰的方法. 表示不可以被重写. <br/>
final修饰的成员变量. 表示必须要在构造器初始化.</p>

<p>final修饰的成员变量. 在java的内存模型中是有语义的. </p>

<p>构造函数对final属性的初始化, 和随后把这个被构造对象的引用赋值给一个引用对象. 是不能重排序的<br/>
初次读一个包含final域的对象.于随后初次读这个final域. 不能重排序</p>

<p>重排序是现代计算机在执行程序时，为了保证性能，处理器和编译器常常会对指令进行重排序. </p>

<p>而java内存模型会进制特定类型的重排序. <br/>
比如 一个锁的解锁, 和随后对这个锁的加锁. <br/>
对一个volatile域的写, 和随后对这个volatile的读. <br/>
线程A执行线程b.start()操作, 和随后线程b的任意操作. <br/>
线程A执行线程b.join返回成功. name线程b的所有操作和线程a执行b.join操作. 以上这些都是不可以重排序的. </p>

<p>禁止重排序是通过内存屏障完成的. </p>

<ul>
<li>强引用 、软引用、 弱引用、虚引用</li>
</ul>

<p>强 是通常我们new的对象. 只要对象是可达的. 就不会被回收<br/>
软 但内存紧张时会被回收  softReference可以和ReferenceQueue关联<br/>
弱 只能活到下次GC  weakReference可以和ReferenceQueue关联<br/>
虚 并不会影响执行object的声明周期. 但是在被回收时, 会将应引用对象放入队列中. phantomReference必须和ReferenceQueue管理</p>

<ul>
<li>Java反射</li>
</ul>

<p>获得实例的Class信息, Class信息包含类的方法 属性 构造器 父类 注解等信息.  也可以操作他们. 比如赋值什么的</p>

<ul>
<li>Arrays.sort 实现原理和 Collection 实现原理</li>
</ul>

<p>不同的数组大小 应用不同排序. </p>

<ul>
<li>LinkedHashMap的应用</li>
</ul>

<p>为了保证hashMap在遍历的时候. 按照插入顺序遍历. linked内部的entry拓展hashMap的Node节点, 添加了额外的指针 before和after. 来保存插入时表示的前后信息</p>

<ul>
<li>cloneable接口实现原理</li>
</ul>

<p>cloneable接口相当于标记, 表示该对象可以被克隆, 克隆的实现是直接复制对象二进制数据. 深拷贝和浅拷贝的问题</p>

<p>克隆不会执行构造函数</p>

<ul>
<li><p>异常分类以及处理机制</p></li>
<li><p>wait和sleep的区别<br/>
wait 必须要同步的情况才能使用 会释放锁. 语义是线程在加锁对象上等待. 可以被notify/all方法唤醒<br/>
sleep 不会释放锁. 语义是休眠当前线程</p></li>
</ul>

<h2 id="toc_1">Java 并发</h2>

<ul>
<li>synchronized 的实现原理以及锁优化？</li>
</ul>

<p>synchronized是锁的意思. </p>

<ol>
<li>锁放在那里. 对象的头部会有一个叫Mark Ward的结构. 存放着对象的hashcode 分代年龄 gc标记  锁信息, MW的数据结构是动态变化的. 比如偏向锁 就会保存线程ID. 轻量级锁则保存指向栈信息的指针, 重量级锁会保存一个指向Monitor的指针,</li>
<li>Monitor的数据结构可以简单描述为 WaitSet EntryList owner count 当线程在等待获得锁的时候 它在entryList中. 获得了锁 进入owner区域. count+1. 当调用wait()方法, owner会释放锁, 进入waitSet区域. count-1. 当线程被notify后. 会从waitset区域进入entryList区域. 等待获得锁. 重量级锁是性能低下的, 因为需要依赖系统的互斥体, 线程间的切换也需要从用户态到核心态的切换, 这都非常消耗性能. jvm在此基础上添加了偏向锁和轻量级锁.</li>
<li>偏向锁是基于一种大多数情况下是不存在竞争的, 都是一个线程多次获得. 思路是当线程获得了锁. 就会进入偏向模式, MW也会变为偏向结构. 记录线程ID, 线程加锁时会判断线程ID是否和自己相等. 如果相等直接进入同步块. 当线程ID不相等. 说明存在竞争了. 锁会膨胀为轻量级锁.</li>
<li>轻量级锁是基于一种 大多数情况都是多个线程交替获取. 这样对象的MW会转变为轻量级锁结构. 加锁实际上是将MW的部分信息CAS的放入栈中, 成功进入同步块. 失败 当期线程则尝试通过自旋来获得锁.  解锁, 是将栈的MW信息CAS的替换回对象头.成功释放锁, 失败了说明有其他线程在尝试获得锁,  则锁膨胀为重量级锁</li>
</ol>

<p>锁只能膨胀. 不能撤销,  自旋锁是为了防止用户态和和心态的切换. </p>

<ul>
<li>volatile 的实现原理？</li>
</ul>

<p>为了平衡cpu和硬盘效率的不一致. 所以引入了内存. 但是现代CPU越来越快. 还出现了多核心. 所以在cpu周围出现大量寄存器. 可称为缓存. 缓存和内存的信息同步. 内存和硬盘的信息同步. 都是问题.<br/>
Java内存模型描述为  线程的本地缓存  和  直接内存也可以叫共享内存</p>

<p>volatile的写入数据会直接同步到直接内存的. 这一点是通过lock前缀的命令实现的. </p>

<p>其他的缓存如何知道本地的缓存失效了呢, 是基于缓存一致性协议. 是通过嗅探总线上的指令来判定自己的缓存是否有效的. </p>

<p>基本流程是 volatile域的写入会直接写入直接内存. 其他本地缓存通过嗅探总线得知了自己本地缓存失效了, 下次再读取的时候, 回去直接内存读取. </p>

<p>volatile域只能保证可见性. </p>

<ul>
<li>Java 的信号灯？</li>
</ul>

<p>java并发包的信号量. 可以理解为许可证. 创建信号量的时候, 会初始化一定数量的许可证, 线程想要执行必须获得一定数量的许可证, 执行完成后释放许可证. </p>

<p>内部实现是基于AQS的共享锁实现的. 信号量分公平和非公平的区别. 默认是非公平的.  例如 Semaphore s = new Semaphore(2); TA.acquire(1) TB.acquire(2) TC.acquire(1) TA.release(1) TB.release(2) TC.release(1)</p>

<p>公平锁的流程:<br/>
TA.acquire(1) </p>

<ol>
<li>响应中断</li>
<li><p>tryAcquireShared(1)尝试获得state</p>
<ol>
<li>自旋 保证CAS成功</li>
<li>判断等待队列中是否存在等待的节点. 存在获得状态失败 结束自自旋返回 -1</li>
<li>不存在.int s =  getState - 1  s &lt; 0或者CAS将state更新为s失败 都会结束自旋 返回s</li>
</ol></li>
<li><p>这里会成功  state =1<br/>
TB.acquire(2) s=-1  &lt;0. 执行等待流程.</p></li>
<li><p>addWaiter()  将当期线程封装成共享Node. 加入等待队列尾部.</p></li>
<li><p>自旋. </p></li>
<li><p>获取当期节点的前置节点p, 如果p==head. 执行tryAcquireShared(2)  TB会失败, 因为1-2 =-1</p></li>
<li><p>shouldParkAfterFailedAcquire(p, node) 获得许可证失败后应该阻塞的前置方法</p>
<ol>
<li>检查p的waitStatus, ws  == SIGNAL(-1) 相等自己可以安心阻塞了 return</li>
<li>ws&gt;0 说明节点超时或者取消了, p开始向前遍历 直到找到节点的ws&lt;=0的, 将node节点添加在他的后面</li>
<li>CAS的更新p的ws为SIGNAL</li>
</ol></li>
<li><p>阻塞自己 lockSupport.park(this)      state =1</p></li>
</ol>

<p>TC.acquire(1)<br/>
因为是公平的缘故, 在执行tryAcquireShared(1)的时候 发现等待队列中存在等待的节点. 也会执行和TB相同的流程. 最后阻塞自己. </p>

<p>TA.release(1)</p>

<ol>
<li>tryReleaseShared(1) 
<ol>
<li>自旋 保证CAS一定能成功</li>
<li>获得当期状态int c = getState + 1 </li>
<li>CAS的将state更新为c. 成功返回true.</li>
</ol></li>
<li><p>执行唤醒操作</p>
<ol>
<li>自旋 </li>
<li>哨兵 head !=null &amp;&amp; head != tail</li>
<li>int ws = head.waitStatus. 获得head的等待状态</li>
<li>ws == signal  并且将成功用CAS将h的状态从-1改为0后 唤醒h.next
<ol>
<li>判断h节点的ws &lt; 0 将状态改为0</li>
<li>&gt;0 从tail节点开始向前遍历. 直到找到一个ws&lt;=0的s  唤醒s lockSupor</li>
</ol></li>
</ol></li>
</ol>

<ul>
<li><p>synchronized 在静态方法和普通方法的区别？</p></li>
<li><p>怎么实现所有线程在等待某个事件的发生才会去执行？</p></li>
<li><p>CAS？CAS 有什么缺陷，如何解决？</p></li>
<li><p>synchronized 和 lock 有什么区别？</p></li>
<li><p>Hashtable 是怎么加锁的 ？</p></li>
<li><p>HashMap 的并发问题？</p></li>
<li><p>ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？</p></li>
<li><p>AQS</p></li>
<li><p>如何检测死锁？怎么预防死锁？</p></li>
<li><p>Java 内存模型？</p></li>
<li><p>如何保证多线程下 i++ 结果正确？</p></li>
<li><p>线程池的种类，区别和使用场景？</p></li>
<li><p>分析线程池的实现原理和线程的调度过程？</p></li>
<li><p>线程池如何调优，最大数目如何确认？</p></li>
<li><p>ThreadLocal原理，用的时候需要注意什么</p></li>
<li><p>CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?</p></li>
<li><p>LockSupport工具</p></li>
<li><p>Condition接口及其实现原理</p></li>
<li><p>Fork/Join框架的理解</p></li>
<li><p>分段锁的原理,锁力度减小的思考</p></li>
<li><p>八种阻塞队列以及各个阻塞队列的特性</p></li>
</ul>

<h2 id="toc_2">Spring</h2>

<p>BeanFactory 和 FactoryBean<br/>
Spring IOC 的理解，其初始化过程？<br/>
BeanFactory 和 ApplicationContext？<br/>
Spring Bean 的生命周期，如何被管理的？Spring Bean 的加载过程是怎样的？<br/>
如果要你实现Spring AOP，请问怎么实现？<br/>
如果要你实现Spring IOC，你会注意哪些问题？<br/>
Spring 是如何管理事务的，事务管理机制？<br/>
Spring 的不同事务传播行为有哪些，干什么用的？<br/>
Spring 中用到了那些设计模式？<br/>
Spring MVC 的工作原理？<br/>
Spring 循环注入的原理？<br/>
Spring 如何保证 Controller 并发的安全？</p>

<h2 id="toc_3">分布式相关</h2>

<p>Dubbo的底层实现原理和机制<br/>
描述一个服务从发布到被消费的详细过程<br/>
分布式系统怎么做服务治理<br/>
接口的幂等性的概念<br/>
消息中间件如何解决消息丢失问题<br/>
Dubbo的服务请求失败怎么处理<br/>
重连机制会不会造成错误<br/>
对分布式事务的理解<br/>
如何实现负载均衡，有哪些算法可以实现？<br/>
Zookeeper的用途，选举的原理是什么？<br/>
数据的垂直拆分水平拆分。<br/>
zookeeper原理和适用场景<br/>
zookeeper watch机制<br/>
redis/zk节点宕机如何处理<br/>
分布式集群下如何做到唯一序列号<br/>
如何做一个分布式锁<br/>
用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗<br/>
MQ系统的数据如何保证不丢失<br/>
列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题<br/>
zookeeper的选举策略</p>

<h2 id="toc_4">数据库</h2>

<p>事务四大特性（ACID）原子性、一致性、隔离性、持久性？<br/>
事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？<br/>
MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？<br/>
MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？<br/>
查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？<br/>
什么是临时表，临时表什么时候删除?<br/>
MySQL B+Tree索引和Hash索引的区别？<br/>
sql查询语句确定创建哪种类型的索引？如何优化查询？<br/>
聚集索引和非聚集索引区别？<br/>
有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？<br/>
非关系型数据库和关系型数据库区别，优势比较？<br/>
数据库三范式，根据某个场景设计数据表？<br/>
数据库的读写分离、主从复制，主从复制分析的 7 个问题？<br/>
使用explain优化sql和索引？<br/>
MySQL慢查询怎么解决？<br/>
什么是 内连接、外连接、交叉连接、笛卡尔积等？<br/>
mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？<br/>
varchar和char的使用场景？<br/>
mysql 高并发环境解决方案？<br/>
数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？</p>

<h2 id="toc_5">Redis</h2>

<p>Redis用过哪些数据数据，以及Redis底层怎么实现<br/>
Redis缓存穿透，缓存雪崩<br/>
如何使用Redis来实现分布式锁<br/>
Redis的并发竞争问题如何解决<br/>
Redis持久化的几种方式，优缺点是什么，怎么实现的<br/>
Redis的缓存失效策略<br/>
Redis集群，高可用，原理<br/>
Redis缓存分片，Redis的数据淘汰策略</p>

<h2 id="toc_6">Netty</h2>

<p>BIO、NIO和AIO<br/>
Netty 的各大组件，Netty的线程模型<br/>
TCP 粘包/拆包的原因及解决方法<br/>
了解哪几种序列化协议？包括使用场景和如何去选择<br/>
Netty的零拷贝实现<br/>
Netty的高性能表现在哪些方面</p>

<h2 id="toc_7">JVM</h2>

<p>详细jvm内存模型<br/>
讲讲什么情况下回出现内存溢出，内存泄漏？<br/>
说说Java线程栈<br/>
JVM 年轻代到年老代的晋升过程的判断条件是什么呢？<br/>
JVM 出现 fullGC 很频繁，怎么去线上排查问题？<br/>
类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？<br/>
类的实例化顺序<br/>
JVM垃圾回收机制，何时触发MinorGC等操作<br/>
JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的<br/>
各种回收器，各自优缺点，重点CMS、G1<br/>
各种回收算法<br/>
OOM错误，stackoverflow错误，permgen space错误</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis执行流程分析]]></title>
    <link href="http://www.throne4j.com/15889543039853.html"/>
    <updated>2020-05-09T00:11:43+08:00</updated>
    <id>http://www.throne4j.com/15889543039853.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">MyBatis运行流程之配置初始化</h2>

<p>首先了解下大致流程<br/>
<img src="media/15889543039853/%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="配置初始化"/></p>

<p>在MyBatis中负责加载配置文件的核心类有三个:</p>

<ul>
<li>BaseBuilder：所有解析器的父类，包含配置文件实例，为解析文件提供的一些通用的方 法；</li>
<li>XMLConfigBuilder： 主要负责解析 mybatis-config.xml全局配置文件，将相关配置放入Configuration对象中； </li>
<li>XMLMapperBuilder： 主要负责解析映射配置 Mapper.xml 文件，填充Configuration的caches、resultMappings； </li>
<li>XMLStatementBuilder： 主要负责解析映射配置文件中的 INSERT、UPDATE、DELETE、SELECT 节点，填充Configuration的MappedStatement；</li>
</ul>

<p>UML类图如下所示：<br/>
<img src="media/15889543039853/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD.png" alt="配置文件加载继承关系"/></p>

<p>XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder 这三个类在配置文件加载过程中非常重要，另外MapperBuilderAssistant可辅助XMLMapperBuilder和XMLStatementBuilder完成配置工作。</p>

<h3 id="toc_1">Configuration对象</h3>

<p>实例化并初始化 Configuration 对象是第一个阶段的最终目的，所以熟悉 configuration 对象是理解这一阶段代码的核心；<br/>
看下Configuration对象中的关键属性：</p>

<ul>
<li>MapperRegistry：mapper 接口动态代理工厂类的注册中心。在 MyBatis 中，通过 mapperProxy 实现 InvocationHandler 接口，MapperProxyFactory 用于生成动态代理的实 例对象；</li>
<li>ResultMap：用于解析 mapper.xml 文件中的 resultMap 节点，使用 ResultMapping 来封装 id，result 等子元素； </li>
<li>MappedStatement：用于存储 mapper.xml 文件中的 select、 insert、 update 和 delete 节点， 同时还包含了这些节点的很多重要属性； </li>
<li>SqlSource：用于创建 BoundSql，mapper.xml 文件中的 sql 语句会被解析成 BoundSql 对象，经过解析 BoundSql 包含的语句最终仅仅包含？占位符，可以直接提交给数据库执行；</li>
</ul>

<pre><code class="language-java">public class Configuration {
   /*数据库环境**/
    protected Environment environment;
    /* 是否启用行内嵌套语句**/
    protected boolean safeRowBoundsEnabled;
    protected boolean safeResultHandlerEnabled = true;
    /* 是否启用数据组A_column自动映射到Java类中的驼峰命名的属性**/
    protected boolean mapUnderscoreToCamelCase;

    /*当对象使用延迟加载时 属性的加载取决于能被引用到的那些延迟属性,否则,按需加载(需要的是时候才去加载)**/
    protected boolean aggressiveLazyLoading;

    /*是否允许单条sql 返回多个数据集  (取决于驱动的兼容性) default:true **/
    protected boolean multipleResultSetsEnabled = true;

    /*-允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。  default:false**/
    protected boolean useGeneratedKeys;

    /* 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。**/
    protected boolean useColumnLabel = true;

    /*配置全局性的cache开关，默认为true**/
    protected boolean cacheEnabled = true;
    protected boolean callSettersOnNulls;
    protected boolean useActualParamName = true;
    protected boolean returnInstanceForEmptyRow;

    /* 日志打印所有的前缀 **/
    protected String logPrefix;

    /* 指定 MyBatis 所用日志的具体实现，未指定时将自动查找**/
    protected Class&lt;? extends Log&gt; logImpl;

    /*虚拟文件系统实现*/
    protected Class&lt;? extends VFS&gt; vfsImpl;

    /* 设置本地缓存范围，session：就会有数据的共享，statement：语句范围，这样不会有数据的共享**/
    protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;

    /* 设置但JDBC类型为空时,某些驱动程序 要指定值**/
    protected JdbcType jdbcTypeForNull = JdbcType.OTHER;
    /* 设置触发延迟加载的方法**/
    protected Set&lt;String&gt; lazyLoadTriggerMethods = new HashSet&lt;&gt;(Arrays.asList(&quot;equals&quot;, &quot;clone&quot;, &quot;hashCode&quot;, &quot;toString&quot;));
    /* 设置驱动等待数据响应超时数**/
    protected Integer defaultStatementTimeout;
    /* 设置驱动返回结果数的大小**/
    protected Integer defaultFetchSize;

    protected ResultSetType defaultResultSetType;
    /* 执行类型，有simple、resue及batch**/
    protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;

    /*指定 MyBatis 应如何自动映射列到字段或属性*/
    protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;
    protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;
    // 在&lt;properties&gt;标签下的属性以及
    protected Properties variables = new Properties();

    protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();

    /*MyBatis每次创建结果对象的新实例时，它都会使用对象工厂（ObjectFactory）去构建POJO*/
    protected ObjectFactory objectFactory = new DefaultObjectFactory();
    protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();

    /*延迟加载的全局开关*/
    protected boolean lazyLoadingEnabled = false;

    /*指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具*/
    protected ProxyFactory proxyFactory = new JavassistProxyFactory(); // #224 Using internal Javassist instead of OGNL

    protected String databaseId;
    /**
     * 创建用于加载反序列化未读属性的配置。
     */
    protected Class&lt;?&gt; configurationFactory;


    /*插件集合，plugins标签容器*/
    protected final InterceptorChain interceptorChain = new InterceptorChain();

    /*TypeHandler注册中心*/
    protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry(this);

    /*TypeAlias注册中心*/
    protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();

    protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();

    /*mapper接口的动态代理注册中心*/
    protected final MapperRegistry mapperRegistry = new MapperRegistry(this);
    /*mapper文件中增删改查操作的注册中心*/
    protected final Map&lt;String, MappedStatement&gt; mappedStatements = new StrictMap&lt;MappedStatement&gt;(&quot;Mapped Statements collection&quot;)
            .conflictMessageProducer((savedValue, targetValue) -&gt; &quot;. please check &quot; + savedValue.getResource() + &quot; and &quot; + targetValue.getResource());

    /*mapper文件中配置cache节点的 二级缓存*/
    protected final Map&lt;String, Cache&gt; caches = new StrictMap&lt;&gt;(&quot;Caches collection&quot;);

    /*mapper文件中配置的所有resultMap对象  key为命名空间+ID*/
    protected final Map&lt;String, ResultMap&gt; resultMaps = new StrictMap&lt;&gt;(&quot;Result Maps collection&quot;);

    /*mapper文件中配置所有的parameterMap对象，key为命名空间+ID*/
    protected final Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap&lt;&gt;(&quot;Parameter Maps collection&quot;);

    /*mapper文件中配置KeyGenerator的insert和update节点，key为命名空间+ID*/
    protected final Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap&lt;&gt;(&quot;Key Generators collection&quot;);

    /*加载到的所有*mapper.xml文件*/
    protected final Set&lt;String&gt; loadedResources = new HashSet&lt;&gt;();

    /*mapper文件中配置的sql元素，key为命名空间+ID*/
    protected final Map&lt;String, XNode&gt; sqlFragments = new StrictMap&lt;&gt;(&quot;XML fragments parsed from previous mappers&quot;);

    protected final Collection&lt;XMLStatementBuilder&gt; incompleteStatements = new LinkedList&lt;&gt;();
    protected final Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = new LinkedList&lt;&gt;();
    protected final Collection&lt;ResultMapResolver&gt; incompleteResultMaps = new LinkedList&lt;&gt;();
    protected final Collection&lt;MethodResolver&gt; incompleteMethods = new LinkedList&lt;&gt;();

    /*
     * key: 在哪个namespace中声明
     * value: 引用哪个namespace中的cache
     */
    protected final Map&lt;String, String&gt; cacheRefMap = new HashMap&lt;&gt;();
}
</code></pre>

<h3 id="toc_2">配置加载过程</h3>

<p>MyBatis配置加载的过程大致可如下图所示：<br/>
<img src="media/15889543039853/Mysql%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="Mysql初始化"/></p>

<p>现在看下配置加载的核心代码：</p>

<h4 id="toc_3">通过 SqlSessionFactoryBuilder 建造 SqlSessionFactory，并创建 XMLConfigBuilder 对象读取 MyBatis 核心配置文件，</h4>

<pre><code class="language-java">public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
    try {
        //1、读取配置文件
        XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
        //1.1、解析配置文件得到configuration对象，并返回SqlSessionFactory的实现DefaultSqlSessionFactory
        return build(parser.parse());
    } catch (Exception e) {
        throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
        ErrorContext.instance().reset();
        try {
            // 关闭输入流
            reader.close();
        } catch (IOException e) {
            // Intentionally ignore. Prefer previous error.
        }
    }
}
</code></pre>

<p>XMLConfigBuilder 的 parseConfiguration 方法，对 MyBatis 核心配置文件的各个 元素进行解析，读取元素信息后填充到 configuration 对象</p>

<pre><code class="language-java">/**
 * 解析mybatis-config.xml文档
 *
 * @param root mybatis-config.xml的root节点configuration
 */
private void parseConfiguration(XNode root) {
    try {
        // issue #117 read properties first
        /* 解析&lt;properties&gt;节点,填充configuration的variables属性*/
        propertiesElement(root.evalNode(&quot;properties&quot;));
        /* 解析&lt;settings&gt;节点*/
        Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
        /*VFS含义是虚拟文件系统；主要是通过程序能够方便读取本地文件系统、FTP文件系统等系统中的文件资源。*/
        loadCustomVfs(settings);
        loadCustomLogImpl(settings);
        /*解析&lt;typeAliases&gt;节点，填充Configuration的typeAliasRegistry属性*/
        typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
        /*解析&lt;plugins&gt;节点*，填充Configuration的interceptorChain属性/
        pluginElement(root.evalNode(&quot;plugins&quot;));
        /*解析ObjectFactory*/
        objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
        /*解析&lt;objectWrapperFactory&gt;节点*/
        objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
        /*解析&lt;reflectorFactory&gt;节点*/
        reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));

        /*将settings填充到configuration*/
        settingsElement(settings);

        /*解析&lt;environments&gt;节点，填充Configuration的environment*/
        environmentsElement(root.evalNode(&quot;environments&quot;));
        //解析&lt;databaseIdProvider&gt;节点
        databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
        /*解析&lt;typeHandlers&gt;节点，填充Configuration的typeHandlerRegistry*/
        typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
        /*解析mapper节点*/
        mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
        throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre>

<p>XMLMapperBuilder 的核心方法为 configurationElement（XNode），该方法对 mapper.xml 配置文件的各个元素进行解析，读取元素信息后填充到 configuration 对象。</p>

<pre><code class="language-java">/**
 * 解析Mapper.xml文件
 **/
private void configurationElement(XNode context) {
    try {
        // 获取mapper.xml 的 namespace 名字
        String namespace = context.getStringAttribute(&quot;namespace&quot;);
        if (namespace == null || namespace.isEmpty()) {
            throw new BuilderException(&quot;Mapper&#39;s namespace cannot be empty&quot;);
        }
        //设置builderAssistant的namespace属性
        builderAssistant.setCurrentNamespace(namespace);

        cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
        /* 1. 分析缓存cache节点，二级缓存  configuration.addCache(cache);*/
        cacheElement(context.evalNode(&quot;cache&quot;));
        parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
        /* 2. 分析 ：解析resultMap节点，填充Configuration的 resultMap*/
        resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
        /* 3. 解析sql节点*/
        sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
        /* 4. 解析select、insert、update、delete节点 ，填充Configuration的 MappedStatement*/
        buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    } catch (Exception e) {
        throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is &#39;&quot; + resource + &quot;&#39;. Cause: &quot; + e, e);
    }
}
</code></pre>

<p>在 XMLStatmentBuilder 的 parseStatementNode()方法中，对 Mapper.xml 中 select、 insert、update、delete 节点进行解析，并调用 MapperBuilderAssistant 负责将信息填充到 configuration。在理解 parseStatementNod()方法之前，有必要了解 MappedStatement，这个类用于封装 select 、insert 、update 、delete 节点的信息 </p>

<pre><code class="language-java">/**
 * 封装mapper.xml文件信息的select 、insert 、update 、delete 节点的信息
 * id、sqlSource、parameterMap、ResultMaps、keyGenerator 
 **/
public final class MappedStatement {

    private String resource;//节点的完整的id属性，包括命名空间
    private Configuration configuration;
    private String id;//节点的id属性
    private Integer fetchSize;//节点的fetchSize属性,查询数据的条数
    private Integer timeout;//节点的timeout属性，超时时间
    private StatementType statementType;//节点的statementType属性,默认值：StatementType.PREPARED
    private ResultSetType resultSetType;//节点的resultSetType属性,jdbc知识
    private SqlSource sqlSource;//节点中sql语句信息
    private Cache cache;//对应的二级缓存
    private ParameterMap parameterMap;
    private List&lt;ResultMap&gt; resultMaps;//节点的resultMaps属性
    private boolean flushCacheRequired;//节点的flushCache属性是否刷新缓存
    private boolean useCache;//节点的useCache属性是否使用二级缓存
    private boolean resultOrdered;
    private SqlCommandType sqlCommandType;//sql语句的类型，包括：INSERT, UPDATE, DELETE, SELECT
    private KeyGenerator keyGenerator;//节点keyGenerator属性
    private String[] keyProperties;
    private String[] keyColumns;
    private boolean hasNestedResultMaps;//是否有嵌套resultMap
    private String databaseId;
    private Log statementLog;
    private LanguageDriver lang;
    private String[] resultSets;//多结果集使用
}
</code></pre>

<h2 id="toc_4">mybatis运行流程之代理封装</h2>

<p>在经过第一阶段之后，MyBatis的Configuration已经初始化完毕，接下来进入第二阶段，获取SqlSessijon和Mapper接口代理类。</p>

<p>其执行的过程如下图所示：</p>

<p><img src="media/15889543373179/mybatis%E8%8E%B7%E5%8F%96mapper%E4%BB%A3%E7%90%86.jpg" alt="mybatis获取mapper代理"/></p>

<h3 id="toc_5">MyBatis的接口层</h3>

<h4 id="toc_6">SqlSession</h4>

<p>第一个对象就是 SqlSession，SqlSession 是 MyBaits 对外提供的最关键的核心接口，通过它可以执行数据库读写命令、获取映射器、管理事务等；SqlSession 也 意味着客户端与数据库的一次连接，客户端对数据库的访问请求都是由SqlSession来处理的， SqlSession 由 SqlSessionFactory 创建，每个 SqlSession 都会引用 SqlSessionFactory 中全局唯一单例存在的 configuration 对象；</p>

<p>SqlSession 默认实现类为 org.apache.ibatis.session.defaults.DefaultSqlSession,是 MyBatis 对外提供数据访问的主要 API。如下图所示，sqlSession是围绕着Executor在运转的。</p>

<p><img src="media/15889543373179/SqlSession.png" alt="SqlSession"/></p>

<h3 id="toc_7">SqlSessionFactory</h3>

<p>SqlSessionFactory 使用工厂模式创建 SqlSession，其默认的实现类为 DefaultSqlSessionFactory ，其中获取 SqlSession 的核心方法为openSessionFromDataSource(ExecutorType, TransactionIsolationLevel, boolean)，在这个方法中从 configuration 中获取的 TransactionFactory 是典 型的策略模式的应用。运行期，TransactionFactory 接口的实现，是由配置文件配置决定的，可配置选项包括： JDBC、Managed, 可根据需求灵活的替换 TransactionFactory 的实现。</p>

<pre><code class="language-java">private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;

    try {
        //获取mybatis配置文件中的environment对象
        final Environment environment = configuration.getEnvironment();
        //从environment获取transactionFactory工厂对象
        final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
        //创建事务对象
        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
        //根据配置创建executor
        final Executor executor = configuration.newExecutor(tx, execType);
        //创建DefaultSqlSession
        return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
        closeTransaction(tx); // may have fetched a connection so lets call close()
        throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
        ErrorContext.instance().reset();
    }
}
</code></pre>

<h3 id="toc_8">Mapper接口</h3>

<p>在使用 Mapper 接口编程的时候，实际上 MyBatis 的内部，将对 Mapper 接口的调用转发给了 SqlSession，这个请求的转发是建立在 配置文件解读、动态代理增强的基础之上实现的，实现的过程有三个关键要素： </p>

<ul>
<li>找到 SqlSession 中对应的方法执行； </li>
<li>找到命名空间和方法名（两维坐标）</li>
<li>传递参数 </li>
</ul>

<h4 id="toc_9">如何获取Mapper接口</h4>

<p>了解binding模块中如下几个关键类：</p>

<ul>
<li>MapperRegistry<br/>
mapper 接口和对应的代理对象工厂的注册中心； </li>
</ul>

<pre><code class="language-java">/**
 * mapper 接口动态代理工厂类的注册中心。
 */
public class MapperRegistry {

    private final Configuration config;
    // 存放MapperProxyFactory
    private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();

    public MapperRegistry(Configuration config) {
        this.config = config;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
        final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
        if (mapperProxyFactory == null) {
            throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
        }
        try {
            return mapperProxyFactory.newInstance(sqlSession);
        } catch (Exception e) {
            throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
        }
    }

    public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) {
        return knownMappers.containsKey(type);
    }

    public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
        if (type.isInterface()) {
            if (hasMapper(type)) {
                throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);
            }
            boolean loadCompleted = false;
            try {
                knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));
                MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                parser.parse();
                loadCompleted = true;
            } finally {
                if (!loadCompleted) {
                    knownMappers.remove(type);
                }
            }
        }
    }
    
    public Collection&lt;Class&lt;?&gt;&gt; getMappers() {
        return Collections.unmodifiableCollection(knownMappers.keySet());
    }

    
    public void addMappers(String packageName, Class&lt;?&gt; superType) {
        ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();
        resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
        Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();
        for (Class&lt;?&gt; mapperClass : mapperSet) {
            addMapper(mapperClass);
        }
    }

    public void addMappers(String packageName) {
        addMappers(packageName, Object.class);
    }

}
</code></pre>

<ul>
<li>MapperProxyFactory<br/>
用于生成 mapper 接口动态代理的实例对象；保证 Mapper 实例对象是局部变量；</li>
</ul>

<pre><code class="language-java">public class MapperProxyFactory&lt;T&gt; {

    private final Class&lt;T&gt; mapperInterface;

    private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();

    public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {
        this.mapperInterface = mapperInterface;
    }

    public Class&lt;T&gt; getMapperInterface() {
        return mapperInterface;
    }

    public Map&lt;Method, MapperMethodInvoker&gt; getMethodCache() {
        return methodCache;
    }

    protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy);
    }

    public T newInstance(SqlSession sqlSession) {
        final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
        return newInstance(mapperProxy);
    }

}
</code></pre>

<ul>
<li> MapperProxy<br/>
实现了 InvocationHandler 接口，它是增强 mapper 接口的实现；</li>
</ul>

<pre><code class="language-java">public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {

    private static final long serialVersionUID = -4724728412955527868L;
    private static final int ALLOWED_MODES = MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED
            | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;
    private static final Constructor&lt;Lookup&gt; lookupConstructor;
    private static final Method privateLookupInMethod;
    //记录关联的sqlsession对象
    private final SqlSession sqlSession;
    //mapper接口对应的class对象；
    private final Class&lt;T&gt; mapperInterface;
    //key是mapper接口中的某个方法的method对象，value是对应的MapperMethodInvoker，封装了MapperMethod，MapperMethod对象不记录任何状态信息，所以它可以在多个代理对象之间共享
    private final Map&lt;Method, MapperMethodInvoker&gt; methodCache;

    public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethodInvoker&gt; methodCache) {
        this.sqlSession = sqlSession;
        this.mapperInterface = mapperInterface;
        this.methodCache = methodCache;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            } else {
                return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
            }
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
    }

    private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
        try {
            return methodCache.computeIfAbsent(method, m -&gt; {
                if (m.isDefault()) {
                    try {
                        if (privateLookupInMethod == null) {
                            return new DefaultMethodInvoker(getMethodHandleJava8(method));
                        } else {
                            return new DefaultMethodInvoker(getMethodHandleJava9(method));
                        }
                    } catch (IllegalAccessException | InstantiationException | InvocationTargetException
                            | NoSuchMethodException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
                }
            });
        } catch (RuntimeException re) {
            Throwable cause = re.getCause();
            throw cause == null ? re : cause;
        }
    }

    interface MapperMethodInvoker {
        Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable;
    }

    private static class PlainMethodInvoker implements MapperMethodInvoker {
        private final MapperMethod mapperMethod;

        public PlainMethodInvoker(MapperMethod mapperMethod) {
            super();
            this.mapperMethod = mapperMethod;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {
            return mapperMethod.execute(sqlSession, args);
        }
    }

    private static class DefaultMethodInvoker implements MapperMethodInvoker {
        private final MethodHandle methodHandle;

        public DefaultMethodInvoker(MethodHandle methodHandle) {
            super();
            this.methodHandle = methodHandle;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {
            return methodHandle.bindTo(proxy).invokeWithArguments(args);
        }
    }
}
</code></pre>

<ul>
<li> MapperMethod<br/>
封装了 Mapper 接口中对应方法的信息，以及对应的 sql 语句的信息； 它是 mapper 接口与映射配置文件中 sql 语句的桥梁； MapperMethod 对象不记录任何 状态信息，所以它可以在多个代理对象之间共享；MapperMethod 内几个关键数据结构： 
<ul>
<li> SqlCommand 从 configuration 中获取方法的命名空间.方法名以及 SQL 语句的类型；
<code>
//sql节点的id： namespace+方法名<br/>
private final String name;<br/>
//是什么类型的sql（UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH）<br/>
private final SqlCommandType type;
</code></li>
<li> MethodSignature：封装 mapper 接口方法的相关信息（入参，返回类型）和ParamNameResolver信息(解析 mapper 接口方法中的入参，将多个参数转成 Map)</li>
</ul></li>
</ul>

<p>看下MapperMethod的关键代码</p>

<pre><code class="language-java">
public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    //判断是那种类型的SQL语句
    switch (command.getType()) {
        case INSERT: {
           //解析参数
            Object param = method.convertArgsToSqlCommandParam(args);
            result = rowCountResult(sqlSession.insert(command.getName(), param));
            break;
        }
        case UPDATE: {
            Object param = method.convertArgsToSqlCommandParam(args);
            result = rowCountResult(sqlSession.update(command.getName(), param));
            break;
        }
        case DELETE: {
            Object param = method.convertArgsToSqlCommandParam(args);
            result = rowCountResult(sqlSession.delete(command.getName(), param));
            break;
        }
        case SELECT:
            if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
                executeWithResultHandler(sqlSession, args);
                result = null;
            } else if (method.returnsMany()) {
                result = executeForMany(sqlSession, args);
            } else if (method.returnsMap()) {
                result = executeForMap(sqlSession, args);
            } else if (method.returnsCursor()) {
                result = executeForCursor(sqlSession, args);
            } else {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = sqlSession.selectOne(command.getName(), param);
                if (method.returnsOptional()
                        &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) {
                    result = Optional.ofNullable(result);
                }
            }
            break;
        case FLUSH:
            result = sqlSession.flushStatements();
            break;
        default:
            throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
        throw new BindingException(&quot;Mapper method &#39;&quot; + command.getName()
                + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
    }
    return result;
}
</code></pre>

<h2 id="toc_10">mybatis运行流程之数据访问阶段</h2>

<p>在了解数据访问源码之前，先看下数据访问的时序图，如下图所示：</p>

<p><img src="media/15889543782019/MyBatis%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E9%98%B6%E6%AE%B5.jpg" alt="MyBatis数据访问阶段"/></p>

<h3 id="toc_11">ExeCutor组件</h3>

<p>从图中看到访问数据是从SqlSession开始的，SqlSession的功能是给予ExeCutor来实现的，Executor是MyBatis的核心接口之一，定义了数据库操作的基本方法，遵循JDBC规范完成对数据库的访问，Executor类的继承关系如下图所示：<br/>
<img src="media/15889543039853/Executor.png" alt="Executo"/></p>

<ul>
<li>ExeCutor<br/>
MyBatis核心接口之一，定义了数据库操作的基本方法</li>
<li>CachingExecutor<br/>
使用装饰者模式，对真正提供数据库查询功能的Executor增强了二级缓存的能力，二级缓存在DefaultSqlSessionFactory.openSession()方法中完成初始化</li>
<li>BaseExector<br/>
实现了Executor接口大部分方法的抽象类，主要提供了缓存管理和事务管理能力，其它子类需要实现的抽象方法为doUpdate、doQuery等方法</li>
<li>BatchExeCutor<br/>
批量执行所有更新语句，在doQuery方法中实现批量执行多条SQL语句的能力，基于JDBC的batch操作实现批处理</li>
<li>SimpleExecutor<br/>
默认执行器，在doQuery方法中使用PrepareStatement对象访问数据库，每次执行都会创建一个statement，用完后关闭。</li>
<li>ReuseExecutor<br/>
可重用执行器，在doQuery方法中使用PrepareStatement对象访问数据库，将statement存入map中，操作map中的statement儿不会重复创建statement。</li>
</ul>

<h3 id="toc_12">Executor依赖的三个重要类</h3>

<p>通过对SimpleExecutor.doQuery方法的解读发现，Executor负责调度3个类来完成数据库的访问工作，这3个类如下：</p>

<ul>
<li>StatementHandler<br/>
使用数据库的Statement或PrepareStatement执行操作。</li>
<li>ParameterHandler<br/>
对预编译的sql语句进行参数设置，sql语句中的占位符 &#39;?&#39; 对对应BoundSql.parameterMappings集合中的一个元素，在该对象中记录了对应的参数名称一级该参数的相关属性</li>
<li>ResultSetHandler<br/>
对数据库返回的结果及ResultSet进行封装，返回用户指定的实体类型</li>
</ul>

<p><img src="media/15889543039853/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="数据访问执行流程"/></p>

<h3 id="toc_13">StatementHandler</h3>

<p>StatementHandler完成MyBatis最核心的工作，功能包括创建statement对象，为sql语句绑定参数，执行增删改查等sql语句、将结果集映射进行转化等。</p>

<p><img src="media/15889543039853/StatementHandler.png" alt="StatementHandle"/></p>

<ul>
<li>BaseStatementHandler<br/>
所有子类的抽象父类，定义了初始化 statement 的操作顺序，由 子类实现具体的实例化不同的 statement（模板模式）； </li>
<li>RoutingStatementHandler<br/>
Executor 组件真正实例化的子类，使用静态代理模式，根据上下文决定创建哪个具体实体类
<ul>
<li>RoutingStatementHandler 是在 Configuration 的 newStatementHandler 中创建的</li>
<li> RoutingStatementHandler 在构造方法中， 根据上下文（配置）决定创建具体实现类</li>
</ul></li>
</ul>

<pre><code class="language-java">public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {

    switch (ms.getStatementType()) {
        case STATEMENT:
            delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
        case PREPARED:
            delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
        case CALLABLE:
            delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
            break;
        default:
            throw new ExecutorException(&quot;Unknown statement type: &quot; + ms.getStatementType());
    }

}
</code></pre>

<ul>
<li> SimpleStatmentHandler ：使用 statement 对象访问数据库，无须参数化； </li>
<li> PreparedStatmentHandler ：使用预编译 PrepareStatement 对象访问数据库； </li>
<li> CallableStatmentHandler ：调用存储过程；</li>
</ul>

<h3 id="toc_14">ResultHandler</h3>

<p>映射规则匹配<br/>
反射实例化对象<br/>
根据规则填充属性值</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mybatis反射模块分析]]></title>
    <link href="http://www.throne4j.com/15889540064384.html"/>
    <updated>2020-05-09T00:06:46+08:00</updated>
    <id>http://www.throne4j.com/15889540064384.html</id>
    <content type="html"><![CDATA[
<p>反射是 Mybatis 模块中类最多的模块，通过反射实现了 POJO 对象的实例化和 POJO 的属性赋 值，相对 JDK 自带的反射功能，MyBatis 的反射模块功能更为强大，性能更高；反射模块关 键的几个类如下：</p>

<ul>
<li>ObjectFactory：MyBatis 每次创建结果对象的新实例时，它都会使用对象工厂 （ObjectFactory）去构建 POJO； </li>
<li>ReflectorFactory：创建 Reflector 的工厂类，Reflector 是 MyBatis 反射模块的基础，每个 Reflector 对象都对应一个类，在其中缓存了反射操作所需要的类元信息；</li>
<li>ObjectWrapper：对对象的包装，抽象了对象的属性信息，他定义了一系列查询对象属 性信息的方法，以及更新属性的方法； </li>
<li>ObjectWrapperFactory： ObjectWrapper 的工厂类，用于创建 ObjectWrapper ； </li>
<li>MetaObject：封装了对象元信息，包装了 MyBatis 中五个核心的反射类。也是提供给外 部使用的反射工具类，可以利用它可以读取或者修改对象的属性信息；</li>
</ul>

<pre><code class="language-java">public final class SystemMetaObject {
  // 默认的ObjectFactory
    public static final ObjectFactory DEFAULT_OBJECT_FACTORY = new DefaultObjectFactory();
    // 默认的ObjectWrapperFactory
    public static final ObjectWrapperFactory DEFAULT_OBJECT_WRAPPER_FACTORY = new DefaultObjectWrapperFactory();
    public static final MetaObject NULL_META_OBJECT = MetaObject.forObject(NullObject.class, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, new DefaultReflectorFactory());

    private SystemMetaObject() {
        // Prevent Instantiation of Static Class
    }

    private static class NullObject {
    }

    public static MetaObject forObject(Object object) {
        return MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY, new DefaultReflectorFactory());
    }

}

@Data
public class RichType {
    private RichType richType;
    private String richField;
    private String richProperty;
    private Map richMap = new HashMap();
}

@Test
void shouldGetAndSetField() {
    RichType rich = new RichType();
    MetaObject meta = SystemMetaObject.forObject(rich);
    meta.setValue(&quot;richField&quot;, &quot;foo&quot;);
    assertEquals(&quot;foo&quot;, meta.getValue(&quot;richField&quot;));
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[myBatis缓存模块分析]]></title>
    <link href="http://www.throne4j.com/15889539937027.html"/>
    <updated>2020-05-09T00:06:33+08:00</updated>
    <id>http://www.throne4j.com/15889539937027.html</id>
    <content type="html"><![CDATA[
<p>在 Web 应用中，缓存是必不可少的组件。通常我们都会用 Redis 或 memcached 等缓存中间件，拦截大量奔向数据库的请求，以减轻数据库压力。</p>

<h2 id="toc_0">MyBatis缓存实现</h2>

<p>MyBatis 缓存模块需满足如下需求： </p>

<ol>
<li>MyBatis 缓存的实现是基于 Map 的，从缓存里面读写数据是缓存模块的核心基础功能；</li>
<li>除核心功能之外，有很多额外的附加功能，如：防止缓存击穿，添加缓存清空策略（fifo、 lru）、序列化功能、日志能力、定时清空能力等；</li>
<li>附加功能可以以任意的组合附加到核心基础功能之上； </li>
</ol>

<p>基于 Map 核心缓存能力，将阻塞、清空策略、序列化、日志等等能力以任意组合的方式优 雅的增强是 Mybatis 缓存模块实现最大的难题。MyBatis采用了装饰者模式()巧妙的对缓存功能进行了可自由组合的功能增强。</p>

<p>在 MyBatis 中，缓存接口 Cache，定义了一些基本的缓存操作，所有缓存类都应该实现该接口。</p>

<p>MyBatis 实现缓存模块的过程中，使用了装饰模式，提供了丰富的缓存实现类</p>

<ul>
<li>PerpetualCache 基础缓存能力</li>
<li>LruCache 增强LRU策略的缓存</li>
<li>LoggingCache 增强日志功能的缓存</li>
<li>ScheduledCache 定时清空的缓存</li>
<li>BlockingCache<br/>
阻塞版本的缓存装饰器，保证只有一个线程到数据库 去查找指定的 key 对应的数据(可以作为防止缓存雪崩造成恶劣影响一种方式，可以考虑使用具有细颗粒度锁的方式提升阻塞缓存的性能)</li>
<li>SynchronizedCache 线程安全的缓存</li>
</ul>

<h3 id="toc_1">Cache接口</h3>

<pre><code class="language-java">public interface Cache {

    String getId();

    void putObject(Object key, Object value);

    Object getObject(Object key);

    Object removeObject(Object key);

    void clear();

    int getSize();

    default ReadWriteLock getReadWriteLock() {
        return null;
    }

}
</code></pre>

<h3 id="toc_2">具有基本缓存功能的 PerpetualCache</h3>

<pre><code class="language-java">public class PerpetualCache implements Cache {

    private final String id;
    
    private final Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;();
        public PerpetualCache(String id) {
        this.id = id;
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public int getSize() {
        return cache.size();
    }

    @Override
    public void putObject(Object key, Object value) {
        cache.put(key, value);
    }

    @Override
    public Object getObject(Object key) {
        return cache.get(key);
    }

    @Override
    public Object removeObject(Object key) {
        return cache.remove(key);
    }

    @Override
    public void clear() {
        cache.clear();
    }
}
</code></pre>

<p>这里看到缓存的实现使用了线程不安全的HashMap，那么使用mybatis缓存的时候会不会出现并发安全的问题呢？</p>

<p>我们已知mybatis的缓存分为一级缓存和二级缓存。</p>

<ul>
<li><p>一级缓存是会话独享的，存在于SqlSession的生命周期中，不会出现多个线程同时操作缓存数据的场景，因此一级缓存也不存在并发安全的问题，系统默认是开启状态，要想关闭一级缓存可以在select标签上配置flushCache=&quot;true&quot;进行关闭。如果同一个SqlSession中执行的方法和参数完全一致，那么通过算法会生成相同的缓存key值，当map缓存对象中已经存在该键值key是，则会返回缓存中的对象; INSERT、UPDATE、DELETE操作会清空一级缓存</p></li>
<li><p>二级缓存也叫做应用缓存，存在于SqlSessionFactory生命周期中，是多个SqlSession共享的缓存；缓存是一namespace为单位划分的，不同的namespace下的操作相互独立；在MyBatis的核心配置文件中cacheEnabled参数是二级缓存的全局开关，默认值是true，如果把这个参数设置为false，即使在mapper.xml文件中配置了二级缓存也不会生效。在使用二级缓存的时候，由于是跨SqlSession的缓存，它可能存在并发安全的问题，因此MyBatis默认会给它加上SynchronizedCache装饰器进行增强,对共享数据的HashMap的操作会进行同步，因此二级缓存也不存在并发安全问题。</p></li>
</ul>

<p>在mapper.xml文件中增加如下配置，在此mapper的namespace配置二级缓存：</p>

<pre><code class="language-text">&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;60000&quot; size=&quot;1024&quot; readOnly=&quot;true&quot;&gt;

此句语义如下：
1、映射语句文件中的所有 select 语句将会被缓存。 
2、映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。
3、缓存会使用 LeastRecently Used(LRU,最近最少使用的)算法来收回。 
4、根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 
5、缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 
6、缓存会被视为是 read/write(可读/可写)的缓存；

</code></pre>

<p><strong><em>二级缓存需注意问题</em></strong>： 使用二级缓存容易出现脏读，建议避免使用二级缓存，在业务层使用可控制的缓存代替更好；</p>

<h2 id="toc_3">缓存使用过程</h2>

<ol>
<li>每次与数据库连接会有限从缓存中获取数据</li>
<li>先查询二级缓存，二级缓存查不到再查一级缓存</li>
<li>二级缓存一namespace为单位划分，是SqlSession共享的,容易出现脏读，建议避免使用</li>
<li>一级缓存是SqlSession独享的，建议开启</li>
</ol>

<h2 id="toc_4">缓存的唯一标识 CacheKey</h2>

<p>􏽱􏸔􏽲􏽳􏲽􏽴􏽵􏱡􏲰􏱙􏳬􏽱􏸔􏽲􏽳􏲽􏽴􏽵􏱡􏲰􏱙􏳬<br/>
mybatis 中涉及到动态sql的原因，缓存项的key不能仅仅通过一个String来表示，所以通过CacheKey来封装缓存的key值，CacheKey可以封装多个影响缓存项的因素，构成CacheKey对象的要素包括：</p>

<ul>
<li>mappedStatement的id</li>
<li>指定查询结果集的范围（分页信息）</li>
<li>查询所使用的的sql语句</li>
<li>用户传递给sql语句的实际参数值</li>
</ul>

<pre><code class="language-java">public class CacheKey implements Cloneable, Serializable { 

    private static final int DEFAULT_MULTIPLYER = 37;
    private static final int DEFAULT_HASHCODE = 17;
    // 􏳮􏳆􏱙􏸭􏸮􏳐乘子，默认是37
    private final int multiplier;
    // 综合各种影响因子
    private int hashcode;
    // 校验和
    private long checksum;
    //影响因子个数
    private int count;
    // 影响因子集合
    private List&lt;Object&gt; updateList;
    
    public CacheKey() {
        this.hashcode = DEFAULT_HASHCODE; this.multiplier = DEFAULT_MULTIPLYER; this.count = 0;
        this.updateList = new ArrayList&lt;Object&gt;();
    } 

}
</code></pre>

<h2 id="toc_5">一级缓存源码分析</h2>

<p>一级缓存是数据库的最后一道屏障，如果一级缓存未命中，查询请求将落到数据库上。一级缓存是在BaseExecutor被初始化的，我们看下代码</p>

<pre><code class="language-java">
public abstract class BaseExecutor implements Executor {
    //一级缓存的实现，PerpetualCache
    protected PerpetualCache localCache;

    protected BaseExecutor(Configuration configuration, Transaction transaction) {
        this.transaction = transaction;
        this.deferredLoads = new ConcurrentLinkedQueue&lt;&gt;();
        this.localCache = new PerpetualCache(&quot;LocalCache&quot;);
        this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);
        this.closed = false;
        this.configuration = configuration;
        this.wrapper = this;
    }
    
    // 省略其它代码
}

</code></pre>

<p>􏴓􏸵􏴕􏴖􏴀􏴆􏶉􏴜 一级缓存的类型是PerpetualCache􏳅􏶳􏶴􏽠􏵌􏸾􏴕􏴖􏴆􏴗􏴘􏶶，没有被其它缓存类修饰过。一级缓存锁存储从查询结果会在MyBatis执行更新操作(insert/update/delete)，以及提交和回滚事务时被清空。</p>

<pre><code class="language-java">@Override
    public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)
            throws SQLException {
    //获取sql语句信息，包括占位符，参数等信息
    BoundSql boundSql = ms.getBoundSql(parameter);
    // 获取缓存的key键
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);

    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
}

@SuppressWarnings(&quot;unchecked&quot;)
@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,
                         CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    if (closed) {
        throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //非嵌套查询，并且FlushCache配置为true，则需要清空一级缓存
    if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
        clearLocalCache();
    }
    List&lt;E&gt; list;
    try {
       //查询层次加 1
        queryStack++;
        // 查询一级缓存
        list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
        if (list != null) {
           // 针对调用存储过程的结果处理
            handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
        } else {
          // 缓存未命中，从数据库中查询
            list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
        }
    } finally {
        queryStack--;
    }
    if (queryStack == 0) {
       //延迟加载处理
        for (DeferredLoad deferredLoad : deferredLoads) {
            deferredLoad.load();
        }
        deferredLoads.clear();
        if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
            clearLocalCache();
        }
    }
    return list;
}
/* mybatis的增删改最终调用这个方法 */
@Override
public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());
    if (closed) {
        throw new ExecutorException(&quot;Executor was closed.&quot;);
    }
    //清除一级缓存
    clearLocalCache();
    return doUpdate(ms, parameter);
}
</code></pre>

<h3 id="toc_6">二级缓存源码分析</h3>

<p>收到查询请求时，mybatis会先查询二级缓存，若二级缓存未命中，再去查询一级缓存。二级缓存和具体的命名空间进行绑定，一级缓存则是和SqlSession绑定。</p>

<pre><code class="language-java">/** CachingExecutor */
// 委托执行器，BatchExecutor、ReuseExecutor、SimpleExecutor
private final Executor delegate;
TransactionalCacheManager tcm = new TransactionalCacheManager();
@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    //获取sql语句信息，包括占位符，参数等信息
    BoundSql boundSql = ms.getBoundSql(parameterObject);
    //拼装缓存的key值
    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);
    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}

@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
        throws SQLException {
    //从MappedStatement中获取二级缓存,如果mapper配置文件中没有开启二级缓存，Cache则为空
    Cache cache = ms.getCache();
    if (cache != null) {
        flushCacheIfRequired(ms);
        
        if (ms.isUseCache() &amp;&amp; resultHandler == null) {
            ensureNoOutParams(ms, boundSql);
            //从二级缓存中获取数据
            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);
            if (list == null) {
                //二级缓存为空，才会调用BaseExecutor.query
                list = delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
                tcm.putObject(cache, key, list); 
            }
            return list;
        }
    }
    return delegate.&lt;E&gt;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}

</code></pre>

<p>二级缓存是从MappedStatement中获取的，由于MappedStatement存在于全局配置中，可以被多个CachingExecutor获取到，这样就会出现线程安全问题，除此之外，若不加以控制，多个事务共用一个缓存实例，会导致脏读问题。</p>

<p>线程安全问题可以通过SynchronizedCache装饰类解决，该装饰类会在Cache实例构造期间被添加上。至于脏读问题，需要接祖其它类来处理，也就是上面代码中的 tcm 变量对应的类型。<br/>
TransactionalCacheManager持有了cache，transactionalCache的关系，transactionalCache是一个缓存装饰器，为缓存提供事务能力。</p>

<pre><code class="language-java">public class TransactionalCacheManager {

    private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;&gt;();

    public void clear(Cache cache) {
        getTransactionalCache(cache).clear();
    }

    public Object getObject(Cache cache, CacheKey key) {
        return getTransactionalCache(cache).getObject(key);
    }

    public void putObject(Cache cache, CacheKey key, Object value) {
        getTransactionalCache(cache).putObject(key, value);
    }

    public void commit() {
        for (TransactionalCache txCache : transactionalCaches.values()) {
            txCache.commit();
        }
    }

    public void rollback() {
        for (TransactionalCache txCache : transactionalCaches.values()) {
            txCache.rollback();
        }
    }

    private TransactionalCache getTransactionalCache(Cache cache) {
        return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new);
    }
    
  /*
   上面getTransactionalCache(Cache cache) 相当于下面的方法，如果cache的value为null，则新建一个TransactionalCache并放如map集合中
  private TransactionalCache getTransactionalCache(Cache cache) {
        return transactionalCaches.computeIfAbsent(cache, new Function&lt;Cache, TransactionalCache&gt;() {
            @Override
            public TransactionalCache apply(Cache delegate) {
                return new TransactionalCache(delegate);
            }
        });
    }*/
    
}

</code></pre>

<p>TransactionalCache 事务缓存装饰器。</p>

<pre><code class="language-java">public class TransactionalCache implements Cache {

    private static final Log log = LogFactory.getLog(TransactionalCache.class);

    private final Cache delegate;

    private boolean clearOnCommit;
    // 在事务提交之前所有从数据库读取到的结果都将存在此集合中
    private final Map&lt;Object, Object&gt; entriesToAddOnCommit;
    // 在事务提交之前，所有缓存未命中的CacheKey都将存放于此集合中。
    private final Set&lt;Object&gt; entriesMissedInCache;

    public TransactionalCache(Cache delegate) {
        this.delegate = delegate;
        this.clearOnCommit = false;
        this.entriesToAddOnCommit = new HashMap&lt;&gt;();
        this.entriesMissedInCache = new HashSet&lt;&gt;();
    }

    @Override
    public String getId() {
        return delegate.getId();
    }

    @Override
    public int getSize() {
        return delegate.getSize();
    }

    @Override
    public Object getObject(Object key) {
        // 查询delegate缓存，缓存中未命中key，放入entriesMissedInCache集合
        Object object = delegate.getObject(key);
        if (object == null) {
            entriesMissedInCache.add(key);
        }
        // issue #146
        if (clearOnCommit) {
            return null;
        } else {
            return object;
        }
    }

    @Override
    public void putObject(Object key, Object object) {
        entriesToAddOnCommit.put(key, object);
    }

    @Override
    public Object removeObject(Object key) {
        return null;
    }

    /**
     * 清除缓存
     */
    @Override
    public void clear() {
        clearOnCommit = true;
        entriesToAddOnCommit.clear();
    }

    public void commit() {
        if (clearOnCommit) {
            delegate.clear();
        }
        flushPendingEntries();
        reset();
    }

    public void rollback() {
        unlockMissedEntries();
        reset();
    }
    /**
     * 重置entriesToAddOnCommit和entriesMissedInCache
     **/
    private void reset() {
        clearOnCommit = false;
        entriesToAddOnCommit.clear();
        entriesMissedInCache.clear();
    }

    private void flushPendingEntries() {
        for (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) {
            delegate.putObject(entry.getKey(), entry.getValue());
        }
        for (Object entry : entriesMissedInCache) {
            if (!entriesToAddOnCommit.containsKey(entry)) {
                delegate.putObject(entry, null);
            }
        }
    }

    private void unlockMissedEntries() {
        // 将二级缓存未命中的key从二级缓存中移除
        for (Object entry : entriesMissedInCache) {
            try {
                delegate.removeObject(entry);
            } catch (Exception e) {
                //log
            }
        }
    }

}

</code></pre>

]]></content>
  </entry>
  
</feed>
