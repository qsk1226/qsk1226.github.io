<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大爷来玩儿啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.throne4j.com/"/>
  <updated>2019-06-02T16:53:52.514Z</updated>
  <id>http://www.throne4j.com/</id>
  
  <author>
    <name>我跟人飙车来着</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty权威指南学习（二）</title>
    <link href="http://www.throne4j.com/2019/06/02/netty/netty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.throne4j.com/2019/06/02/netty/netty权威指南学习（二）/</id>
    <published>2019-06-02T13:38:43.000Z</published>
    <updated>2019-06-02T16:53:52.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-NIO-入门"><a href="#第二章-NIO-入门" class="headerlink" title="第二章 NIO 入门"></a>第二章 NIO 入门</h1><p>在本章中，我们会分别对JDK的BIO、NIO、NIO2.0的使用进行详细说明。本章主要内容包括：</p><ul><li>传统的同步阻塞式IO编程</li><li>基于NIO的非阻塞编程</li><li>基于NIO2.0的异步非阻塞(AIO)编程</li><li>为什么使用NIO编程</li><li>为什么使用Netty</li></ul><h2 id="2-1传统的BIO编程"><a href="#2-1传统的BIO编程" class="headerlink" title="2.1传统的BIO编程"></a>2.1传统的BIO编程</h2><p>　　网络编程的基本模型是client/server，也就是client进程与server进程通过3次握手之后建立连接，进而实现相互通信。</p><h3 id="2-1-1-BIO通信模型"><a href="#2-1-1-BIO通信模型" class="headerlink" title="2.1.1 BIO通信模型"></a>2.1.1 BIO通信模型</h3><p>　　BIO服务端通信模型（见下图）通常由一个Acceptor 负责接收客户端的请求，它接收到客户端请求之后，为每一个请求新建一个新的线程进行链路处理，处理完成之后，将处理结果数据，以流的方式发送给客户端，然后销毁线程。这就是典型的一请求一应答的通信模式。<br>　　该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量上来之后，服务端的线程和客户访问量呈1:1的关系增加，当服务端线程过多消耗java虚拟机的资源后，导致性能急剧下降，甚至将导致服务端宕机、僵死而无法提供服务。</p><p><img src="/2019/06/02/netty/netty权威指南学习（二）/BIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="BIO通信模型">　　</p><h3 id="2-1-2-同步阻塞式IO创建的TimeServer源码分析"><a href="#2-1-2-同步阻塞式IO创建的TimeServer源码分析" class="headerlink" title="2.1.2 同步阻塞式IO创建的TimeServer源码分析"></a>2.1.2 同步阻塞式IO创建的TimeServer源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinshengke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-06-02 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"The server is started in port:"</span> + port);</span><br><span class="line">            <span class="comment">// 获取server接待的socket</span></span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"The time server close"</span>);</span><br><span class="line">                server.close();</span><br><span class="line">                server = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinshengke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-06-02 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServerHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取socket 输入流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">this</span>.socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(<span class="keyword">this</span>.socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            String currentTime = <span class="keyword">null</span>;</span><br><span class="line">            String body = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                body = in.readLine();</span><br><span class="line">                <span class="keyword">if</span> (body == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(<span class="string">"The time server receive order :"</span> + body);</span><br><span class="line">                currentTime = <span class="string">"QUERY TIME ORDER"</span>.equalsIgnoreCase(body) ? <span class="keyword">new</span> Date(System.currentTimeMillis()).toString() : <span class="string">"BAD ORDER"</span>;</span><br><span class="line">                out.println(currentTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengke.netty.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinshengke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-06-02 22:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, port);</span><br><span class="line">            in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            out.println(<span class="string">"QUERY TIME ORDER"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Send order 2 server succeed."</span>);</span><br><span class="line">            String resp = in.readLine();</span><br><span class="line">            System.out.println(<span class="string">"Now is :"</span> + resp);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　BIO主要问题在于每当有一个新的客户端请求接入时，服务端都必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接。试想一下，当成千上万甚至百万的客户端请求接入时，对服务器来说无异于灾难来临。　　</p><h2 id="2-2-伪异步IO编程"><a href="#2-2-伪异步IO编程" class="headerlink" title="2.2  伪异步IO编程"></a>2.2  伪异步IO编程</h2><p>为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题，后来有人对他的线程模型进行了优化–后端通过线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N。</p><h3 id="2-2-1伪异步IO模型"><a href="#2-2-1伪异步IO模型" class="headerlink" title="2.2.1伪异步IO模型"></a>2.2.1伪异步IO模型</h3><p>　　采用线程池或者任务队列实现一种伪异步的IO通信框架，它的模型如下图所示:<br><img src="/2019/06/02/netty/netty权威指南学习（二）/%E4%BC%AA%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt><br>　　当有新的客户请求接入的时候，将客户端的socket封装为一个task投递到后端的线程池中进行处理,java线程池维护一个任务队列和N个活跃的线程，因此它消耗资源是可控的，不会造成资源的耗尽。由于伪异步通信模型底层实现依然使用BIO，无法从根本上解决同步阻塞IO的问题。<br>　　下面我们结合代码，了解一下伪异步通信模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengke.netty.bio.fake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.shengke.netty.bio.TimeServerHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinshengke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-06-02 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"The server is started in port:"</span> + port);</span><br><span class="line">            <span class="comment">// 获取server接待的socket</span></span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            TimeServerHandlerExecutePool executePool = <span class="keyword">new</span> TimeServerHandlerExecutePool(<span class="number">50</span>, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                socket = server.accept();</span><br><span class="line">                executePool.execute(<span class="keyword">new</span> TimeServerHandler(socket));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"The time server close"</span>);</span><br><span class="line">                server.close();</span><br><span class="line">                server = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shengke.netty.bio.fake;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> qinshengke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016-06-02 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandlerExecutePool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServerHandlerExecutePool</span><span class="params">(<span class="keyword">int</span> maxPoolSize, <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize,</span><br><span class="line">                <span class="number">120L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queueSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executorService.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码没有什么变化，使用2.1.2章节中的 TimeClient。</p><h3 id="2-2-3-伪异步通信模型的弊端"><a href="#2-2-3-伪异步通信模型的弊端" class="headerlink" title="2.2.3 伪异步通信模型的弊端"></a>2.2.3 伪异步通信模型的弊端</h3><p>首先我们看下InputStream的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads some number of bytes from the input stream and stores them into</span></span><br><span class="line"><span class="comment">     * the buffer array &lt;code&gt;b&lt;/code&gt;. The number of bytes actually read is</span></span><br><span class="line"><span class="comment">     * returned as an integer.  This method blocks until input data is</span></span><br><span class="line"><span class="comment">     * available, end of file is detected, or an exception is thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If the length of &lt;code&gt;b&lt;/code&gt; is zero, then no bytes are read and</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;0&lt;/code&gt; is returned; otherwise, there is an attempt to read at</span></span><br><span class="line"><span class="comment">     * least one byte. If no byte is available because the stream is at the</span></span><br><span class="line"><span class="comment">     * end of the file, the value &lt;code&gt;-1&lt;/code&gt; is returned; otherwise, at</span></span><br><span class="line"><span class="comment">     * least one byte is read and stored into &lt;code&gt;b&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The first byte read is stored into element &lt;code&gt;b[0]&lt;/code&gt;, the</span></span><br><span class="line"><span class="comment">     * next one into &lt;code&gt;b[1]&lt;/code&gt;, and so on. The number of bytes read is,</span></span><br><span class="line"><span class="comment">     * at most, equal to the length of &lt;code&gt;b&lt;/code&gt;. Let &lt;i&gt;k&lt;/i&gt; be the</span></span><br><span class="line"><span class="comment">     * number of bytes actually read; these bytes will be stored in elements</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;b[0]&lt;/code&gt; through &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;-1]&lt;/code&gt;,</span></span><br><span class="line"><span class="comment">     * leaving elements &lt;code&gt;b[&lt;/code&gt;&lt;i&gt;k&lt;/i&gt;&lt;code&gt;]&lt;/code&gt; through</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;b[b.length-1]&lt;/code&gt; unaffected.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * has the same effect as: &lt;pre&gt;&lt;code&gt; read(b, 0, b.length) &lt;/code&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      b   the buffer into which the data is read.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>     the total number of bytes read into the buffer, or</span></span><br><span class="line"><span class="comment">     *             &lt;code&gt;-1&lt;/code&gt; if there is no more data because the end of</span></span><br><span class="line"><span class="comment">     *             the stream has been reached.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  IOException  If the first byte cannot be read for any reason</span></span><br><span class="line"><span class="comment">     * other than the end of the file, if the input stream has been closed, or</span></span><br><span class="line"><span class="comment">     * if some other I/O error occurs.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  NullPointerException  if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.io.InputStream#read(byte[], int, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStream的API中有一段是这样描述<br><strong><em>This method blocks until input data is available, end of file is detected, or an exception is thrown</em></strong><br>当对socket的输入流进行读取的时候，它会一直阻塞下去，知道发生以下三件事：</p><ul><li>有数据可读</li><li>可用数据已经读取完毕</li><li>发生空指针或者IO异常</li></ul><p>这意味着当对方发送请求或者响应比较慢，或者网络延迟，读取输入流的一方的通信线程将会一直阻塞，在此期间，其他接入消息只能在任务队列中排队等待</p><p>下面我们对输出流OutputStream进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Writes &lt;code&gt;b.length&lt;/code&gt; bytes from the specified byte array</span></span><br><span class="line"><span class="comment">     * to this output stream. The general contract for &lt;code&gt;write(b)&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * is that it should have exactly the same effect as the call</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;write(b, 0, b.length)&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      b   the data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  IOException  if an I/O error occurs.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        java.io.OutputStream#write(byte[], int, int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用OutputStream的write方法写入输出流的时候，它将被阻塞，知道所有要发送的数据发送完毕，或发生异常。当数据的接收方数据处理能力低下时，将不能及时的从TCP缓冲区读取数据，这将会导致数据发送方的TCP windows size不断变小，直到为0，双方处于Keep-Alive状态，数据发送方将不能再向TCP缓冲区写入数据，这是如果采用同步阻塞IO，write操作将会被无限期阻塞，知道TCP windows size大于 0 或者发生异常为止。</p><p>下面我们就简单分析下通信对方返回应答时间过长引起的级联故障：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章-NIO-入门&quot;&gt;&lt;a href=&quot;#第二章-NIO-入门&quot; class=&quot;headerlink&quot; title=&quot;第二章 NIO 入门&quot;&gt;&lt;/a&gt;第二章 NIO 入门&lt;/h1&gt;&lt;p&gt;在本章中，我们会分别对JDK的BIO、NIO、NIO2.0的使用进行详细说明
      
    
    </summary>
    
      <category term="netty" scheme="http://www.throne4j.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://www.throne4j.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>netty权威指南学习（一）</title>
    <link href="http://www.throne4j.com/2019/06/01/netty/netty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.throne4j.com/2019/06/01/netty/netty权威指南学习（一）/</id>
    <published>2019-06-01T13:38:43.000Z</published>
    <updated>2019-06-02T15:20:26.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先感谢作者李林锋给我们提供出这本关于异步非阻塞通信领域的经典之作，本书基于Netty 5.0编写。Netty如今已经在如下几个领域得到了大规模的商业应用:</p><ul><li>互联网领域</li><li>电信领域</li><li>大数据领域</li><li>银行、证券等金融领域</li><li>游戏行业</li><li>电力等企业市场</li></ul></blockquote><blockquote><p>看到Netty如火如荼的发展，有心能够深入学习，希望通过此书，站在前辈的肩膀上走出属于自己的路，猿类崛起！</p></blockquote><h1 id="netty-基础篇"><a href="#netty-基础篇" class="headerlink" title="netty 基础篇"></a>netty 基础篇</h1><pre><code>**走进Java  NIO**</code></pre><h2 id="第一章-java的I-O演进之路"><a href="#第一章-java的I-O演进之路" class="headerlink" title="第一章.java的I/O演进之路"></a><code>第一章.java的I/O演进之路</code></h2><p>在开始学习Netty之前，我们首先对UNIX系统常用的I/O模型进行介绍，然后对Java的I/O历史演进进行简单的说明。</p><h3 id="1-1-I-O基础入门"><a href="#1-1-I-O基础入门" class="headerlink" title="1.1  I/O基础入门"></a>1.1  I/O基础入门</h3><p>传统的BIO 在高性能领域一直被业界所诟病，主要有如下问题：</p><ul><li>没有数据缓冲区，I/O性能存在问题</li><li>没有C 或 C++中的Channel概念，只有输入和输出流</li><li>同步阻塞IO通常会导致通信或线程被长时间阻塞</li><li>支持的字符集有限，硬件可移植性不好</li></ul><h4 id="1-1-1-Linux-网络I-O模型简介"><a href="#1-1-1-Linux-网络I-O模型简介" class="headerlink" title="1.1.1  Linux 网络I/O模型简介"></a>1.1.1  Linux 网络I/O模型简介</h4><p>（1） 阻塞I/O 模型</p><p>　　最常用的I/O模型就是阻塞I/O模型，缺省情况下，所有的文件操作都是I/O阻塞的。在系统的进程空间中调用recvfrom，当访问文件系统的时候，其系统调用直到文件到达且被复制到系统的缓冲区或者发生错误异常的时候才会返回，在此期间，系统会一直等待，进程从开始到结束一直处于阻塞状态，因此被称为阻塞I/O模型。</p><p>（2） 非阻塞I/O 模型</p><p>　　recvfrom从应用层到内核，如果该缓冲区中没有数据的话，则直接返回一个EWOULDBLOCK错误，一般对非阻塞I/O模型进行轮询检查这个状态，看内核是否有数据到来.</p><p>（3） I/O复用模型</p><p>　　Linux 提供select/poll，进程通过一个或多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮助我们侦测多个fd是否处于就绪状态。select/poll 系统是瞬息扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些限制。Linux系统还提供了一个epoll系统，它采用事件驱动方式来代替顺序扫描，因此性能更高，当fd就绪的时候，立即回调rollback函数</p><p>（4） 信号I/O复用模型</p><p>　　首先开启套接口信号驱动I/O功能,并通过系统调用sigaction执行一个信号处理函数(此操作是非阻塞的),当数据准备就绪的时候,就为该进程生成一个sigio信号，通过信号回调通知应用程序调用recvform来读取数据，并通知主循环函数处理数据。</p><p>（5） 异步IO</p><p>　　告知内核启动某个操作，并让内核在整个操作完成是通知我们。这种模型和信号I/O模型的区别是：信号I/O模型是告知我们和是可以开始I/O操作，异步I/O告知我们I/O操作何时已经完成。<br><img src="/2019/06/01/netty/netty权威指南学习（一）/15590935389763.jpg" alt><br><img src="/2019/06/01/netty/netty权威指南学习（一）/15590937479358.jpg" alt></p><h4 id="1-1-2-I-O-多路复用技术"><a href="#1-1-2-I-O-多路复用技术" class="headerlink" title="1.1.2   I/O 多路复用技术"></a>1.1.2   I/O 多路复用技术</h4><p>在IO编程过程中，当需要同事处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，IO多路复用的最大优势是系统开销小，IO多路复用技术的主要应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或多个连接状态的套接字；</li><li>服务器需要同时处理多种网络协议的套接字。</li></ul><p>目前支持IO多路复用的系统调用有select、pselect、poll、epoll，在linux网络编程过程中，很长时间都在使用select做<strong><em>轮询和网络事件通知</em></strong>，然而select的固有缺陷迫使Linux寻找替代方案，最终Linux选择了epoll，epoll与select的原理类似，单做了很大改进，总结如下：</p><p>（1） 支持一个进程打开的socket描述符（FD）不受限制（金受限于操作系统的最大文件句柄数）</p><pre><code>select的最大缺陷就是单个进程打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。我们可以通过修改这个宏修改并重新编译内核，但这样也给操作系统造成性能的损耗，另外进程间的数据交换非常麻烦，由于java没有共享内存，需要通过Socket通信或者其他方式进行数据同步，这样带来了额外的性能损耗，增加了程序的复杂度，也不是一种很好的解决方案。epoll并没有这个最大文件句柄数的限制，epoll的处理能力和内存的关系比较大，内存越大，epoll的处理能力越强。</code></pre><p>（2） IO效率不会随着FD数目的增加而线性下降</p><pre><code>epoll只会对活跃的socket进行操作，这是因为在内核实现中epoll是根据每个fd上面的额callback函数实现的。</code></pre><p>（3） 使用mmap加速内核与用户控件的消息传递</p><pre><code>无论是select、poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存实现的</code></pre><p>（4） epoll的API更加简单</p><h3 id="1-2-Java的IO演进"><a href="#1-2-Java的IO演进" class="headerlink" title="1.2 Java的IO演进"></a>1.2 Java的IO演进</h3><p>在JDK 1.4 推出Java  NIO 之前，java的所有socket通信都采用了同步阻塞模式（BIO），这种已请求一应答的通信模型简化了上层的应用开发，但是在性能可可靠性方面却存在这巨大的瓶颈。Java 1.4 NIO以 JSR-51 的身份正式随JDK 发布，它新增了java.nio包，同乐很多进行异步IO开发的API和类库，主要的类和接口如下：</p><ul><li>进行异步IO操作的缓冲区 <em>ByteBuffer</em> 等</li><li>进行异步IO操作的管道Pipe</li><li>进行各种IO操作（异步或同步）的<em>Channel</em>，包括<em>ServerSocketChannel</em>和<em>SocketChannel</em></li><li>多种字符集的编码和解码能力</li><li>实现非阻塞IO操作的多路复用器<em>Selector</em></li><li>基于流行的Perl实现的额正则表达式类库</li><li>文件通道<em>FileChannel</em></li></ul><p>新的NIO类库促进了Java 异步非阻塞编程的发展和应用，但是他还有不完善的地方，特别是对文件系统的处理能力不足，主要问题如下</p><ul><li>没有同意的文件属性（例如读写权限）</li><li>API能力较弱，例如目录的级联创建和递归遍历，往往需要自己实现</li><li>所有的文件操作都是同步阻塞调用，不支持异步文件读写操作</li><li>底层存储系统的一些高级API无法使用</li></ul><p>2017年7月28日JDK1.7发布，将原来的NIO类库进行了升级，被称为NIO2.0，NIO2.0由JSR-203演进而来，它主要提供了如下三个方面的改进：</p><ul><li>提供能够批量获取文件属性的API，这些API具有平台无关性，不与特性的文件系统耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现</li><li>提供AIO功能，支持基于文件的异步IO操作和针对网络套接字的异步操作</li><li>完成JSR-51 定义的通道功能，包括对配置和多波数据报的支持</li></ul><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p>通过此章了解了UNIX 的网络编程的5种IO模型，学习IO多路复用的基础知识。对java IO 的演进有了一些直观认识，下章对阻塞IO和非阻塞IO进行详细讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;首先感谢作者李林锋给我们提供出这本关于异步非阻塞通信领域的经典之作，本书基于Netty 5.0编写。Netty如今已经在如下几个领域得到了大规模的商业应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互联网领域&lt;/li&gt;
&lt;li&gt;电信领域&lt;/li&gt;
&lt;li&gt;大数据
      
    
    </summary>
    
      <category term="netty" scheme="http://www.throne4j.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://www.throne4j.com/tags/netty/"/>
    
  </entry>
  
</feed>
