<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大爷来玩儿啊</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.throne4j.com/"/>
  <updated>2019-06-01T18:40:23.362Z</updated>
  <id>http://www.throne4j.com/</id>
  
  <author>
    <name>我跟人飙车来着</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty权威指南学习（二）</title>
    <link href="http://www.throne4j.com/2016/06/02/netty/netty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.throne4j.com/2016/06/02/netty/netty权威指南学习（二）/</id>
    <published>2016-06-02T13:38:43.000Z</published>
    <updated>2019-06-01T18:40:23.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是NIO"><a href="#什么是NIO" class="headerlink" title="什么是NIO"></a>什么是NIO</h2><p>　　NIO 是 JAVA NON-BLOCK IO 的简称，在 jdk1.4 里提供的新 api 。<br>JAVA NIO是为了弥补传统I/O工作模式的不足而研发的，可以实现并发的非阻塞型I/O能力。</p><h2 id="NIO的工作原理是什么？"><a href="#NIO的工作原理是什么？" class="headerlink" title="NIO的工作原理是什么？"></a>NIO的工作原理是什么？</h2><p>　　JAVA NIO 内部实现是通过事件驱动模型来实现的，在并发型服务器程序中使用NIO，实际上是通过网络事件驱动模型实现的。我们应用Select机制，不用为每一个客户端连接新启线程处理，而是将其注册到特定的Selector对象上，这就可以在单线程中利用Selector对象管理大量并发的网络连接，更好的利用了系统资源；采用非阻塞I/O的通信方式，不要求阻塞等待I/O操作完成即可返回，从而减少了管理I/O连接导致的系统开销，大幅度提高了系统性能。</p><p>　　当有读或写等注册事件发生时，可以从Selector中获得相应的SelectionKey，从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。由于在非阻塞网络I/O中采用了事件触发机制，处理程序可以得到系统的主动通知，从而可以实现底层网络I/O无阻塞、流畅地读写，而不像在原来的阻塞模式下处理程序需要不断循环等待。使用NIO，可以编写出性能更好、更易扩展的并发型服务器程序。</p><p>　　并发型服务器程序的实现代码：应用NIO工具包，基于非阻塞网络I/O设计的并发型服务器程序与以往基于阻塞I/O的实现程序有很大不同，在使用非阻塞网络I/O的情况下，程序读取数据和写入数据的时机不是由程序员控制的，而是Selector决定的。</p><p>使用非阻塞型I/O进行并发型服务器程序设计分三个部分：<br>　　1. 向Selector对象注册感兴趣的事件；<br>　　2.从Selector中获取所感兴趣的事件；<br>　　3. 根据不同的事件进行相应的处理。</p><p>　　在进行并发型服务器程序设计时，通过合理地使用NIO工具包，就可以达到一个或者几个Socket线程就可以处理N多个Socket的连接，大大降低我们对服务器程序的预算压力。同时我们利用它更好地提高系统的性能，使我们的工作得到更加有效地开展.　　</p><h2 id="NIO特性"><a href="#NIO特性" class="headerlink" title="NIO特性"></a>NIO特性</h2><p>Sun 官方标榜的特性如下：</p><ul><li>为所有的原始类型提供 (Buffer) 缓存支持。</li><li>字符集编码解码解决方案。</li><li>Channel ：一个新的原始 I/O 抽象。</li><li>支持锁和内存映射文件的文件访问接口。</li><li>提供多路 (non-bloking) 非阻塞式的高伸缩性网络 I/O</li></ul><h2 id="JAVA-NIO-提供的java-nio-包，提供了很多进行异步I-O开发的API-和类库。"><a href="#JAVA-NIO-提供的java-nio-包，提供了很多进行异步I-O开发的API-和类库。" class="headerlink" title="JAVA NIO 提供的java.nio 包，提供了很多进行异步I/O开发的API 和类库。"></a>JAVA NIO 提供的java.nio 包，提供了很多进行异步I/O开发的API 和类库。</h2><p>主要类和接口如下：</p><ul><li>进行异步IO操作的缓冲区ByteBuffer等</li><li>进行异步IO操作的管道Pipe</li><li>进行各种IO操作的channel，包括ServerSocketChannel 和SocketChannel</li><li>多种字符的编码和解码能力</li><li>实现非阻塞I/O操作的多路复用器Selector</li><li>基于流行的perl实现的正则表达式类库</li><li>文件管道FileChannel</li></ul><h1 id="3-1传统的BIO编程"><a href="#3-1传统的BIO编程" class="headerlink" title="3.1传统的BIO编程"></a>3.1传统的BIO编程</h1><p>　　网络编程的基本模型是client/server，也就是client进程与server进程通过3次握手之后建立连接，进而实现相互通信。<br>　　BIO服务端通信模型通常由一个Acceptor 负责接收客户端的请求，它接收到客户端请求之后，为每一个请求新建一个新的线程进行链路处理，处理完成之后，将处理结果数据，以流的方式发送给客户端，然后销毁线程。这就是典型的一请求一应答的通信模式。<br>　　该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量上来之后，服务端的线程和客户访问量呈1:1的关系增加，当服务端线程过多消耗java虚拟机的资源后，导致性能急剧下降，甚至将导致服务端宕机、僵死而无法提供服务。　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是NIO&quot;&gt;&lt;a href=&quot;#什么是NIO&quot; class=&quot;headerlink&quot; title=&quot;什么是NIO&quot;&gt;&lt;/a&gt;什么是NIO&lt;/h2&gt;&lt;p&gt;　　NIO 是 JAVA NON-BLOCK IO 的简称，在 jdk1.4 里提供的新 api 。&lt;br&gt;
      
    
    </summary>
    
      <category term="netty" scheme="http://www.throne4j.com/categories/netty/"/>
    
    
      <category term="netty,nio,java" scheme="http://www.throne4j.com/tags/netty-nio-java/"/>
    
  </entry>
  
  <entry>
    <title>netty权威指南学习（一）</title>
    <link href="http://www.throne4j.com/2016/06/01/netty/netty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.throne4j.com/2016/06/01/netty/netty权威指南学习（一）/</id>
    <published>2016-06-01T13:38:43.000Z</published>
    <updated>2019-06-02T04:09:17.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先感谢作者李林锋给我们提供出这本关于异步非阻塞通信领域的经典之作，本书基于Netty 5.0编写。Netty如今已经在如下几个领域得到了大规模的商业应用:</p><ul><li>互联网领域</li><li>电信领域</li><li>大数据领域</li><li>银行、证券等金融领域</li><li>游戏行业</li><li>电力等企业市场</li></ul></blockquote><blockquote><p>看到Netty如火如荼的发展，有心能够深入学习，希望通过此书，站在前辈的肩膀上走出属于自己的路，猿类崛起！</p></blockquote><h1 id="netty-基础篇"><a href="#netty-基础篇" class="headerlink" title="netty 基础篇"></a>netty 基础篇</h1><pre><code>**走进Java  NIO**</code></pre><h2 id="第一章-java的I-O演进之路"><a href="#第一章-java的I-O演进之路" class="headerlink" title="第一章.java的I/O演进之路"></a><code>第一章.java的I/O演进之路</code></h2><p>在开始学习Netty之前，我们首先对UNIX系统常用的I/O模型进行介绍，然后对Java的I/O历史演进进行简单的说明。</p><h3 id="1-1-I-O基础入门"><a href="#1-1-I-O基础入门" class="headerlink" title="1.1  I/O基础入门"></a>1.1  I/O基础入门</h3><p>传统的BIO 在高性能领域一直被业界所诟病，主要有如下问题：</p><ul><li>没有数据缓冲区，I/O性能存在问题</li><li>没有C 或 C++中的Channel概念，只有输入和输出流</li><li>同步阻塞IO通常会导致通信或线程被长时间阻塞</li><li>支持的字符集有限，硬件可移植性不好</li></ul><h4 id="1-1-1-Linux-网络I-O模型简介"><a href="#1-1-1-Linux-网络I-O模型简介" class="headerlink" title="1.1.1  Linux 网络I/O模型简介"></a>1.1.1  Linux 网络I/O模型简介</h4><p>（1） 阻塞I/O 模型</p><p>　　最常用的I/O模型就是阻塞I/O模型，缺省情况下，所有的文件操作都是I/O阻塞的。在系统的进程空间中调用recvfrom，当访问文件系统的时候，其系统调用直到文件到达且被复制到系统的缓冲区或者发生错误异常的时候才会返回，在此期间，系统会一直等待，进程从开始到结束一直处于阻塞状态，因此被称为阻塞I/O模型。</p><p>（2） 非阻塞I/O 模型</p><p>　　recvfrom从应用层到内核，如果该缓冲区中没有数据的话，则直接返回一个EWOULDBLOCK错误，一般对非阻塞I/O模型进行轮询检查这个状态，看内核是否有数据到来.</p><p>（3） I/O复用模型</p><p>　　Linux 提供select/poll，进程通过一个或多个fd传递给select或者poll系统调用，阻塞在select操作上，这样select/poll可以帮助我们侦测多个fd是否处于就绪状态。select/poll 系统是瞬息扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些限制。Linux系统还提供了一个epoll系统，它采用事件驱动方式来代替顺序扫描，因此性能更高，当fd就绪的时候，立即回调rollback函数</p><p>（4） 信号I/O复用模型</p><p>　　首先开启套接口信号驱动I/O功能,并通过系统调用sigaction执行一个信号处理函数(此操作是非阻塞的),当数据准备就绪的时候,就为该进程生成一个sigio信号，通过信号回调通知应用程序调用recvform来读取数据，并通知主循环函数处理数据。</p><p>（5） 异步IO</p><p>　　告知内核启动某个操作，并让内核在整个操作完成是通知我们。这种模型和信号I/O模型的区别是：信号I/O模型是告知我们和是可以开始I/O操作，异步I/O告知我们I/O操作何时已经完成。<br><img src="/2016/06/01/netty/netty权威指南学习（一）/15590935389763.jpg" alt><br><img src="/2016/06/01/netty/netty权威指南学习（一）/15590937479358.jpg" alt></p><h4 id="1-1-2-I-O-多路复用技术"><a href="#1-1-2-I-O-多路复用技术" class="headerlink" title="1.1.2   I/O 多路复用技术"></a>1.1.2   I/O 多路复用技术</h4><p>在IO编程过程中，当需要同事处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型相比，IO多路复用的最大优势是系统开销小，IO多路复用技术的主要应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或多个连接状态的套接字；</li><li>服务器需要同时处理多种网络协议的套接字。</li></ul><p>目前支持IO多路复用的系统调用有select、pselect、poll、epoll，在linux网络编程过程中，很长时间都在使用select做<strong><em>轮询和网络事件通知</em></strong>，然而select的固有缺陷迫使Linux寻找替代方案，最终Linux选择了epoll，epoll与select的原理类似，单做了很大改进，总结如下：</p><p>（1） 支持一个进程打开的socket描述符（FD）不受限制（金受限于操作系统的最大文件句柄数）</p><pre><code>select的最大缺陷就是单个进程打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。我们可以通过修改这个宏修改并重新编译内核，但这样也给操作系统造成性能的损耗，另外进程间的数据交换非常麻烦，由于java没有共享内存，需要通过Socket通信或者其他方式进行数据同步，这样带来了额外的性能损耗，增加了程序的复杂度，也不是一种很好的解决方案。epoll并没有这个最大文件句柄数的限制，epoll的处理能力和内存的关系比较大，内存越大，epoll的处理能力越强。</code></pre><p>（2） IO效率不会随着FD数目的增加而线性下降</p><pre><code>epoll只会对活跃的socket进行操作，这是因为在内核实现中epoll是根据每个fd上面的额callback函数实现的。</code></pre><p>（3） 使用mmap加速内核与用户控件的消息传递</p><pre><code>无论是select、poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存复制就显得非常重要，epoll是通过内核和用户空间mmap同一块内存实现的</code></pre><p>（4） epoll的API更加简单</p><h3 id="1-2-Java的IO演进"><a href="#1-2-Java的IO演进" class="headerlink" title="1.2 Java的IO演进"></a>1.2 Java的IO演进</h3><p>在JDK 1.4 推出Java  NIO 之前，java的所有socket通信都采用了同步阻塞模式（BIO），这种已请求一应答的通信模型简化了上层的应用开发，但是在性能可可靠性方面却存在这巨大的瓶颈。Java 1.4 NIO以 JSR-51 的身份正式随JDK 发布，它新增了java.nio包，同乐很多进行异步IO开发的API和类库，主要的类和接口如下：</p><ul><li>进行异步IO操作的缓冲区 <em>ByteBuffer</em> 等</li><li>进行异步IO操作的管道Pipe</li><li>进行各种IO操作（异步或同步）的<em>Channel</em>，包括<em>ServerSocketChannel</em>和<em>SocketChannel</em></li><li>多种字符集的编码和解码能力</li><li>实现非阻塞IO操作的多路复用器<em>Selector</em></li><li>基于流行的Perl实现的额正则表达式类库</li><li>文件通道<em>FileChannel</em></li></ul><p>新的NIO类库促进了Java 异步非阻塞编程的发展和应用，但是他还有不完善的地方，特别是对文件系统的处理能力不足，主要问题如下</p><ul><li>没有同意的文件属性（例如读写权限）</li><li>API能力较弱，例如目录的级联创建和递归遍历，往往需要自己实现</li><li>所有的文件操作都是同步阻塞调用，不支持异步文件读写操作</li><li>底层存储系统的一些高级API无法使用</li></ul><p>2017年7月28日JDK1.7发布，将原来的NIO类库进行了升级，被称为NIO2.0，NIO2.0由JSR-203演进而来，它主要提供了如下三个方面的改进：</p><ul><li>提供能够批量获取文件属性的API，这些API具有平台无关性，不与特性的文件系统耦合，另外它还提供了标准文件系统的SPI，供各个服务提供商扩展实现</li><li>提供AIO功能，支持基于文件的异步IO操作和针对网络套接字的异步操作</li><li>完成JSR-51 定义的通道功能，包括对配置和多波数据报的支持</li></ul><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><p>通过此章了解了UNIX 的网络编程的5种IO模型，学习IO多路复用的基础知识。对java IO 的演进有了一些直观认识，下章对阻塞IO和非阻塞IO进行详细讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;首先感谢作者李林锋给我们提供出这本关于异步非阻塞通信领域的经典之作，本书基于Netty 5.0编写。Netty如今已经在如下几个领域得到了大规模的商业应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互联网领域&lt;/li&gt;
&lt;li&gt;电信领域&lt;/li&gt;
&lt;li&gt;大数据
      
    
    </summary>
    
      <category term="netty" scheme="http://www.throne4j.com/categories/netty/"/>
    
    
      <category term="netty" scheme="http://www.throne4j.com/tags/netty/"/>
    
  </entry>
  
</feed>
