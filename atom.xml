<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-08-28T00:28:19+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[linux和macOS下top命令区别]]></title>
    <link href="http://www.throne4j.com/15983681960215.html"/>
    <updated>2020-08-25T23:09:56+08:00</updated>
    <id>http://www.throne4j.com/15983681960215.html</id>
    <content type="html"><![CDATA[
<p>top命令是常用的性能分析工具，被广泛用于监视服务器的负载，能够实时显示系统中各个进程的资源占用情况。</p>

<p>前言<br/>
开发环境使用Mac后，经常使用 活动监视器 查看所有进程CPU、内存等。top命令的快捷键在Mac下的快捷键不生效。一直这样用下来，感觉不是很顺手。整理记录。</p>

<h2 id="toc_0">1、linux top</h2>

<pre><code class="language-text">P 键 按照cpu使用率排序
M 键 按照内存使用率排序
l 键 切换显示平均负载和启动时间信息
m 键 切换显示内存信息
t 键 切换显示进程和cpu状态信息
c 键 切换显示命令名称和完成命令行信息
</code></pre>

<pre><code class="language-text">top - 11:15:45 up 14 min,  1 user,  load average: 0.74, 0.58, 0.31
Tasks: 143 total,   1 running, 142 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.4 us,  2.2 sy,  0.0 ni, 95.3 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
</code></pre>

<h2 id="toc_1">2、Mac top</h2>

<p>先输入 o 键 ,再输入 cpu 则按cpu使用量排序，输入 rsize 按内存使用量排序。</p>

<h2 id="toc_2">3、 字符含义</h2>

<pre><code class="language-shell">top - 11:25:56 up 25 min,  1 user,  load average: 0.22, 0.36, 0.31
Tasks: 144 total,   1 running, 143 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.2 us,  1.7 sy,  0.0 ni, 95.9 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
KiB Mem :  1863088 total,    97124 free,   934460 used,   831504 buff/cache
KiB Swap:        0 total,        0 free,        0 used.   767876 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  2383 root      20   0  481976 274180  39152 S   3.3 14.7   0:48.03 kube-apiserver --advertise-address=172.16.65.134 --allow-privileged=true --authorization-mode=Node,RBAC --client-ca-file=/etc/kubernetes/pki/ca.crt --enable-admission-plugins=NodeRestriction --enabl+
   738 root      20   0 1225828  73716  34748 S   2.0  4.0   0:32.22 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --cgroup-driver=systemd --network-plugi+
  1002 root      20   0  566956  87928  26144 S   1.0  4.7   0:15.37 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
  2384 root      20   0   10.1g  50352  12152 S   1.0  2.7   0:18.25 etcd --advertise-client-urls=https://172.16.65.134:2379 --cert-file=/etc/kubernetes/pki/etcd/server.crt --client-cert-auth=true --data-dir=/var/lib/etcd --initial-advertise-peer-urls=https://172.16.+
  2429 root      20   0  221900  65236  30152 S   1.0  3.5   0:18.03 kube-controller-manager --allocate-node-cidrs=true --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf --bind-addre+
   442 root      20   0       0      0      0 S   0.3  0.0   0:01.02 [xfsaild/dm-0]
  1000 root      20   0 1155792  44968  14332 S   0.3  2.4   0:00.95 /usr/bin/containerd
  2188 root      20   0  107688   6524   2700 S   0.3  0.4   0:00.04 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/4cbd4244ccf55f156b620e442678e20a85fc2f28c4edb5e7f517c3539b5fdea1 -address /run/containerd/containerd.+
  
</code></pre>

<p>l 键 切换显示平均负载和启动时间信息:</p>

<table>
<thead>
<tr>
<th>top - 11:12:47</th>
<th>up 11 min,</th>
<th>1 user,</th>
<th>load average: 0.17, 0.23, 0.15</th>
</tr>
</thead>

<tbody>
<tr>
<td>当前系统时间</td>
<td>系统已运行时间</td>
<td>在线用户，包含系统用户</td>
<td>系统负载。分别是1，5，15分钟前到潜在的平均值</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Tasks</th>
<th>227 total</th>
<th>1 running</th>
<th>225 sleeping</th>
<th>1 stopped</th>
<th>0 zombie</th>
</tr>
</thead>

<tbody>
<tr>
<td>-</td>
<td>总进程数</td>
<td>正在运行的进程数</td>
<td>正在睡眠的进程数</td>
<td>停止的进程数</td>
<td>僵死进程数</td>
</tr>
</tbody>
</table>

<p>t键，cpu信息：</p>

<table>
<thead>
<tr>
<th>%Cpu(s)</th>
<th>0.8 us</th>
<th>1.0 sy</th>
<th>0.0 ni</th>
<th>98.2 id</th>
<th>0.0 wa</th>
<th>0.0 hi</th>
<th>0.0 si</th>
<th>0.0 st</th>
</tr>
</thead>

<tbody>
<tr>
<td>-</td>
<td>cpu占用率(%)，用户进程占用cpu百分率</td>
<td>系统占用cpu百分率</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
<td>cpu空闲率</td>
<td>等待IO的CPU时间百分比</td>
<td>硬中断（Hardware IRQ）占用CPU的百分比</td>
<td>软中断（Software Interrupts）占用CPU的百分比</td>
<td>虚拟机占用百分比</td>
</tr>
</tbody>
</table>

<p>m键 内存信息：</p>

<table>
<thead>
<tr>
<th>KiB Mem</th>
<th>8175028 total</th>
<th>635844 free</th>
<th>3024460 used</th>
<th>4514724 buff/cache</th>
</tr>
</thead>

<tbody>
<tr>
<td>-</td>
<td>内存总量</td>
<td>内存空闲量</td>
<td>内存使用量</td>
<td>缓存的内存量</td>
</tr>
</tbody>
</table>

<p>交换区信息：</p>

<table>
<thead>
<tr>
<th>KiB Swap</th>
<th>15624016 total</th>
<th>15606756 free</th>
<th>17260 used</th>
<th>4678020 avail Mem</th>
</tr>
</thead>

<tbody>
<tr>
<td>-</td>
<td>交换区总量</td>
<td>交换区空闲量</td>
<td>交换区使用量</td>
<td>缓冲交换区总量</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>PID</th>
<th>USER</th>
<th>PR</th>
<th>NI</th>
<th>VIRT</th>
<th>RES</th>
<th>SHR</th>
<th>S</th>
<th>%CPU</th>
<th>%MEM</th>
<th>TIME+</th>
<th>COMMAND</th>
</tr>
</thead>

<tbody>
<tr>
<td>进程号</td>
<td>进程创建者</td>
<td>进程优先级</td>
<td>nice值</td>
<td>进程使用的虚拟内存总量</td>
<td>进程使用的、未被换出的物理内存大小</td>
<td>共享内存大小</td>
<td>进程状态</td>
<td>进程占用cpu百分比</td>
<td>进程占用内存百分比</td>
<td>进程运行时间</td>
<td>进程名称</td>
</tr>
</tbody>
</table>

<ul>
<li>NI nice值。越小优先级越高，最小-20，最大20（用户设置最大19）</li>
<li>VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>
<li>RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>
<li>SHR 共享内存大小，单位kb</li>
<li>S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一致性Hash]]></title>
    <link href="http://www.throne4j.com/15983668905198.html"/>
    <updated>2020-08-25T22:48:10+08:00</updated>
    <id>http://www.throne4j.com/15983668905198.html</id>
    <content type="html"><![CDATA[
<p>01.分布式与集群</p>

<p>分布式：把一个系统拆分为多个子系统，每个子系统负责各自功能实现，独立部署，各司其职。体现的是对系统的拆分。<br/>
集群：体现的是多个实例共同工作，最简单/常见的集群即一个应用复制多份部署，实现高可用。<br/>
分布式一定是集群，但集群不一定是分布式。（因为集群就是多个实例一起工作，分布式将一个系统拆分之后就是多个实例，所以分布式一定是集群，而集群并不一定是分布式，因为复制型的集群不是拆分而是复制）。</p>

<h2 id="toc_0">一致性 Hash 算法</h2>

<p>Hash 算法常见应用场景<br/>
    比如在安全加密领域MD5、SHA等加密算法，在数据存储和查找方面有 hash 表，Java中的hashcode等都应用到了 Hash 算法。<br/>
    Hash 算法在很多分布式集群产品中都有应用，比如分布式集群架构 Redis、Hadoop、ElasticSearch，MySQL 分库分表，Nginx 负载均衡等。Hash 算法等使用主要场景分为两个：<br/>
请求的负载均衡（比如 Nginx 的 ip_hash 策略）。</p>

<p>Nginx 的 IP_hash 策略可以在客户端 IP 不变的情况下，将其发出的请求始终路由到同一个目标服务器上，实现会话粘滞，避免处理 session 共享问题。</p>

<p>如果没有 IP_hash 策略，又想实现会话粘滞，可以维护一个映射表，存储客户端 ip 或者 sessionid 与具体目标服务器的映射关系。缺点：1、在客户端很多的情况下，映射表非常大，浪费内存空间；2、客户端上下线、目标服务器上下线，都会导致重新维护映射表。</p>

<p>分布式存储。通过 Hash 算法将不同服务器的请求路由到不同的服务器，进而将数据存储到不同的服务器中。</p>

<p>为什么需要使用 Hash 算法<br/>
    Hash 算法较多的应用在数据存储和查找领域，最经典的 Hash 表，其查询效率非常高，如果 Hash 算法设计的比较好的话，那么 Hash 表的数据查询时间复杂度可以接近于O(1)。<br/>
    比如：判断一个结合中是否包含某个元素，例如集合数据：1、3、6、4、8、2、9、12、7 中是否包含数字 4 ，最普通的方法是循环遍历数组，逐个进行判断，或者使用二分查找（需要对元素进行排序）。<br/>
直接寻址法<br/>
    首先创建一个数组，数组的长度根据集合中元素的最大值来确定，数组长度要大于等于集合中的最大值 +1 ，然后将数组中的数据根据下标进行存放入数组中，比如元素 1 存放到数组下标为 1 的位置，元素 3 存放在数组下标为 3 的位置，依次类推，如下图：</p>

<pre><code class="language-text">只需根据数组下标进行判断，当前位置是否有值即可。
优点：查询速度快，只需一次查找即可确定。
缺点：
</code></pre>

<p>浪费内存空间。比如图中的 0、5、10、11 内存位置，并没有存放任何数据，但是需要预留内存空间。更夸张的是，如果集合中元素跨度很大，比如集合中增加元素 12306，其余都不变，那么数组长度将是 12307，数组中 13～12306 的下标位置都将浪费。</p>

<p>集合中的元素要求无重复，否则无法存放集合中所有元素。例如将集合元素修改为：1、3、6、4、8、2、9、12、7、4、2 ，那么数组长度变成了15，但是最大值还是 12 ，存放时，元素 2 和 4 要么被覆盖，要么无法存放。</p>

<p>除留余数法</p>

<pre><code class="language-text">数组的长度可以任意，集合中元素的存放位置通过对数组长度求模后对值来确定：存放位置 = 集合中元素值 % 数组长度 。



这种方式算是一种简单的 Hash 算法，也可以提高查询效率，但是会导致 Hash 冲突。即不同的元素求模之后存放的数组位置是相同的。
</code></pre>

<p>开放寻址法</p>

<pre><code class="language-text">哈希冲突时向前或向后占用空闲位置，数据比较混乱，这种方式一般不会使用。而且，当数组的长度确定，且小于集合中数据元素个数时，无论是否发生 hash 冲突，都无法存放集合中所有元素。
</code></pre>

<p>拉链法</p>

<pre><code class="language-text">为了解决在除留余数法中产生的 Hash 冲突问题，当有两个元素求模后存放在相同下标位置时， 通过链表结构，将不同元素存放在相同的下标位置。
使用拉链法之后，查询效率相比直接寻址法会稍有逊色，但是如果 Hash 算法设计的好的话，元素在数组中存放比较均匀，Hash 冲突机率比较低，其查询效率依然很高，且节省了内存空间。
</code></pre>

<p>普通 Hash 算法存在的问题<br/>
    普通 hash 算法通过取模来定位请求的具体服务器地址，这种情况下，增减服务器数量，影响到 hash 结果，导致会话失效。<br/>
一致性 Hash 算法</p>

<p>原理<br/>
首先将 0 ~ 2<sup>32-1</sup> 按照顺指针方向放在一个圆环中，这个环称为 Hash 环。</p>

<p>假设当前集群中有4个服务器节点，分别是 node1、node2、node3、node4，根据这 4 个服务器节点的 IP (也可以是其他属性) 计算出一个 Hash 值，分别对应 Hash 环中的某个位置，这里假设 4 个服务器节点经过 Hash 算法之后分别对应 Hash 环中的1、2、3、4 的位置。</p>

<p>当请求到达时，再通过 Hash 算法，计算出当前请求在 Hash 环中对应的位置，根据对请求计算出的 Hash 值，顺时针查找最近的一个服务器节点，该节点就是处理当前请求的节点。比如：如果请求通过 Hash 算法之后，在 Hash 环中对应的位置落在 4～1 之间，那么处理当前请求的服务器节点就是 node1，如果请求通过 Hash 算法之后，在 Hash 环中对应的位置落在 1～2 之间，那么处理当前请求的服务器节点就是 node2，依次类推。</p>

<p>缩容</p>

<pre><code class="language-text">当有服务器下线时，比如 node3 节点下线，原来路由到 node3 的客户端，重新路由到了 node4，对于其他客户端没有影响，请求的迁移达到了最小，这样的算法对于分布式集群来说非常合适，避免了大量请求的迁移。
</code></pre>

<p>扩容</p>

<pre><code class="language-text">当新增一个服务器节点5之后，原来路由到 node3 的部分客户端路由到了新增服务器 node5 上，受影响的只有新增节点与其前一个节点之间的请求，其他请求也不会收到影响。请求的迁移达到了最小，这样的算法对于分布式集群来说非常合适，避免了大量请求的迁移。

每台服务器负责一部分客户端的请求，一致性 Hash 算法对于服务器节点的增减都只需要定位环空间中的一小部分数据，具有较好的容错性和可扩展性。
</code></pre>

<p>虚拟节点方式</p>

<pre><code class="language-text">对于一致性 Hash 算法，在服务器节点太少时，容易因为节点分布不均匀而导致数据倾斜问题。例如系统中只有两台服务器，节点2只能负责很小的一部分请求，大量的客户端请求落在了节点1上。

为了解决这种数据倾斜问题，一致性 Hash 算法引入了虚拟节点机制。即对每一个服务节点计算多个 Hash，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器 IP 或主机名后面增加编号来实现。比如，可以为每台服务器计算三个虚拟节点，于是可以分别计算“节点1的ip#1”、“节点1的ip#2”、“节点1的ip#3”、“节点2的ip#1”、“节点2的ip#2”、“节点2的ip#3”的 Hash 值，于是形成 6 个虚拟节点，当客户端被路由到虚拟节点的时候其实是被路由到该虚拟节点对应的真实节点。
</code></pre>

<p>Nginx 配置一致性 Hash 负载均衡策略<br/>
    ngx_http_upstream_consistent_hash 模块是一个负载均衡器，使用一个内部一致性 Hash 算法来选择合适的后端节点，  Nginx 默认并没有安装一致性 Hash 模块，需要自己手动安装。</p>

<pre><code class="language-text">该模块可以根据不同的配置参数采取不同的方式将请求映射到后端机器：
</code></pre>

<p>consistent_hash $remote_addr：可以根据客户端的 ip 映射</p>

<p>consistent_hash $request_uri：根据客户端请求的 uri 映射</p>

<p>consistent_hash $args：根据客户端携带的参数进行映射</p>

<p>安装一致性 Hash 负载均衡器<br/>
下载并上传至云服务器</p>

<p>下载地址：<a href="https://github.com/replay/ngx_http_consistent_hash">https://github.com/replay/ngx_http_consistent_hash</a></p>

<p>以压缩包的形式将其下载到本地，并通过 FTP 工具上传至云服务器，此处上传到服务器的 /soft/ 目录下。</p>

<p>在此之前已经编译并安装过 Nginx ，此时进入 Nginx 源码目录，执行一下命令进行安装：</p>

<h1 id="toc_1">进入 Nginx 源码目录</h1>

<p>cd /soft/nginx-1.18.0</p>

<h1 id="toc_2">配置添加一致性 Hash 负载均衡器模块</h1>

<p>./configure --add-module=/soft/ngx_http_consistent_hash-master # 配置<br/>
make # 编译<br/>
make install # 安装</p>

<pre><code class="language-text">此时，Nginx 一致性 Hash 负载均衡器已经安装完成。
</code></pre>

<p>使用 Nginx 一致性 Hash 负载均衡器<br/>
    安装完成后，只需要在 nginx.conf 文件中添加如下配置即可使用一致性 Hash 负载均衡策略：</p>

<pre><code class="language-text">cd /usr/local/nginx/conf
vim nginx.conf
</code></pre>

<pre><code class="language-text">upstream testServer {
  consistent_hash $request_uri;
  server 127.0.0.1:8080;
  server 127.0.0.1:8081;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程]]></title>
    <link href="http://www.throne4j.com/15981846149666.html"/>
    <updated>2020-08-23T20:10:14+08:00</updated>
    <id>http://www.throne4j.com/15981846149666.html</id>
    <content type="html"><![CDATA[
<p>java 线程的本质--Thread--jvm--os</p>

<p>java 线程模型</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[幂等方案]]></title>
    <link href="http://www.throne4j.com/15979251824377.html"/>
    <updated>2020-08-20T20:06:22+08:00</updated>
    <id>http://www.throne4j.com/15979251824377.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arthas]]></title>
    <link href="http://www.throne4j.com/15978529329852.html"/>
    <updated>2020-08-20T00:02:12+08:00</updated>
    <id>http://www.throne4j.com/15978529329852.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>Arthas 是 Alibaba 开源的 Java 诊断工具,在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p>

<p><a href="https://alibaba.github.io/arthas/">官方文档参考</a><br/>
<a href="https://arthas.aliyun.com/doc/quick-start.html">快速入门</a></p>

<p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p>

<p>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？<br/>
我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？<br/>
遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？<br/>
线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！<br/>
是否有一个全局视角来查看系统的运行状况？<br/>
有什么办法可以监控到JVM的实时运行状态？<br/>
怎么快速定位应用的热点，生成火焰图？</p>

<h2 id="toc_1">下载和安装</h2>

<p>不需要安装，就是一个 jar 包</p>

<pre><code class="language-text">curl -O https://alibaba.github.io/arthas/arthas-boot.jar 

java -jar arthas-boot.jar
</code></pre>

<p>启动 arthas 的 jar 包是 arthas-boot.jar</p>

<p>直接 java -jar arthas-boot.jar。选择 attach 的进程绑定<br/>
<figure><img src="media/15773440983590/15976833500370.jpg" alt=""/></figure></p>

<h2 id="toc_2">arthas 命令</h2>

<p>输入help查看 arthas 支持的命令</p>

<pre><code class="language-shell">[arthas@29087]$ help
 NAME         DESCRIPTION
 help         Display Arthas Help
 keymap       Display all the available keymap for the specified connection.
 sc           Search all the classes loaded by JVM
 sm           Search the method of classes loaded by JVM
 classloader  Show classloader info
 jad          Decompile class
 getstatic    Show the static field of a class
 monitor      Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc.
 stack        Display the stack trace for the specified class and method
 thread       Display thread info, thread stack
 trace        Trace the execution time of specified method invocation.
 watch        Display the input/output parameter, return object, and thrown exception of specified method invocation
 tt           Time Tunnel
 jvm          Display the target JVM information
 perfcounter  Display the perf counter infornation.
 ognl         Execute ognl expression.
 mc           Memory compiler, compiles java files into bytecode and class files in memory.
 redefine     Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...)
 dashboard    Overview of target jvm&#39;s thread, memory, gc, vm, tomcat info.
 dump         Dump class byte array from JVM
 heapdump     Heap dump
 options      View and change various Arthas options
 cls          Clear the screen
 reset        Reset all the enhanced classes
 version      Display Arthas version
 session      Display current session information
 sysprop      Display, and change the system properties.
 sysenv       Display the system env.
 vmoption     Display, and update the vm diagnostic options.
 logger       Print logger info, and update the logger level
 history      Display command history
 cat          Concatenate and print files
 echo         write arguments to the standard output
 pwd          Return working directory name
 mbean        Display the mbean information
 grep         grep command for pipes.
 tee          tee command for pipes.
 profiler     Async Profiler. https://github.com/jvm-profiling-tools/async-profiler
 stop         Stop/Shutdown Arthas server and exit the console.
</code></pre>

<h3 id="toc_3">dashboard</h3>

<p><figure><img src="media/15773440983590/15976836704891.jpg" alt="" style="width:1891px;"/></figure></p>

<h3 id="toc_4">thread</h3>

<p>这个命令和 jstack 很相似，但是功能更加强大，主要是查看当前 JVM 的线程堆栈信息 同时可以结合使用 thread –b 来进行死锁的排查死锁。</p>

<p>参数说明:</p>

<pre><code class="language-text">-n 指定最忙的前 n 个线程并打印堆栈
-b 找出阻塞当前线程的线程
-i 指定 cpu 占比统计的采样间隔，单位为毫秒
</code></pre>

<pre><code class="language-text">[arthas@29087]$ thread -b
&quot;Thread-0&quot; Id=11 BLOCKED on java.lang.Object@602bace6 owned by &quot;Thread-1&quot; Id=12
    at com.goddess.base.concurrent.SynchronizedObjDeadLock.lambda$deadLock$0(SynchronizedObjDeadLock.java:27)
    -  blocked on java.lang.Object@602bace6
    -  locked java.lang.Object@12487489 &lt;---- but blocks 1 other threads!
    at com.goddess.base.concurrent.SynchronizedObjDeadLock$$Lambda$1/122883338.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>

<p>thread -i 1000 -n 3 每过 1000 毫秒进行采样，显示最占 CPU 时间的前 3 个线程</p>

<p>thread --state WAITING 查看处于等待状态的线程</p>

<h3 id="toc_5">jvm</h3>

<p>查看jvm信息<br/>
<figure><img src="media/15773440983590/15976840064874.jpg" alt=""/></figure></p>

<h3 id="toc_6">jad 反编译指定已加载类的源码</h3>

<p><figure><img src="media/15773440983590/15976841522972.jpg" alt="" style="width:1293px;"/></figure></p>

<h3 id="toc_7">trace</h3>

<p>使用 trace 命令可以跟踪统计方法耗时。</p>

<p>例如：trace com.goddess.base.controller.UserController get</p>

<h3 id="toc_8">monitor 方法监控</h3>

<p>监控的维度说明：</p>

<table>
<thead>
<tr>
<th>监控项</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>timestamp</td>
<td>时间戳</td>
</tr>
<tr>
<td>class</td>
<td>Java类</td>
</tr>
<tr>
<td>method</td>
<td>方法（构造方法、普通方法）</td>
</tr>
<tr>
<td>total</td>
<td>调用次数</td>
</tr>
<tr>
<td>success</td>
<td>成功次数</td>
</tr>
<tr>
<td>fail</td>
<td>失败次数</td>
</tr>
<tr>
<td>rt</td>
<td>平均RT</td>
</tr>
<tr>
<td>fail-rate</td>
<td>失败率</td>
</tr>
</tbody>
</table>

<p>每 5 秒统计一次 com.goddess.base.controller.UserController 类的 get 方法执行情况</p>

<pre><code class="language-text">&gt; monitor -c 5 com.goddess.base.controller.UserController get
timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate
-----------------------------------------------------------------------------------------------
 2018-12-03 19:06:38  demo.MathGame  primeFactors  5      1        4     1.15        80.00%
</code></pre>

<h3 id="toc_9">watch</h3>

<p>让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。</p>

<p>参数说明：</p>

<ul>
<li>class-pattern 类名表达式</li>
<li>method-pattern 方法名表达式匹配</li>
<li>express 观察表达式</li>
<li>condition-express 条件表达式</li>
<li>b 在方法调用之前观察</li>
<li>e 在方法调用之后观察,异常抛出时才触发</li>
<li>s 在方法返回之后观察</li>
<li>f 在方法结束之后观察</li>
<li>E 开启正则表达式匹配，默认为通配符匹配</li>
<li>[x:] 指定输出结果的属性遍历深度，默认为1</li>
</ul>

<p>特别说明：</p>

<ul>
<li><p>watch 命令定义了4个观察事件点，即 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后</p></li>
<li><p>4个观察事件点 -b、-e、-s 默认关闭，-f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</p></li>
<li><p>这里要注意方法入参和方法出参的区别，有可能在中间被修改导致前后不一致，除了 -b 事件点 params 代表方法入参外，其余事件都代表方法出参</p></li>
<li><p>当使用 -b 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</p></li>
</ul>

<p>变量说明：</p>

<table>
<thead>
<tr>
<th>变量名</th>
<th>变量解释</th>
</tr>
</thead>

<tbody>
<tr>
<td>loader</td>
<td>本次调用类所在的 ClassLoader</td>
</tr>
<tr>
<td>clazz</td>
<td>本次调用类的 Class 引用</td>
</tr>
<tr>
<td>method</td>
<td>本次调用方法反射引用</td>
</tr>
<tr>
<td>target</td>
<td>本次调用类的实例</td>
</tr>
<tr>
<td>params</td>
<td>本次调用参数列表，这是一个数组，如果方法是无参方法则为空数组</td>
</tr>
<tr>
<td>returnObj</td>
<td><code>本次调用返回的对象。当且仅当 isReturn==true 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 void，则值为 null</code></td>
</tr>
<tr>
<td>throwExp</td>
<td><code>本次调用抛出的异常。当且仅当 isThrow==true 成立时有效，表明方法调用是以抛出异常的方式结束。</code></td>
</tr>
<tr>
<td>isBefore</td>
<td><code>辅助判断标记，当前的通知节点有可能是在方法一开始就通知，此时 isBefore==true 成立，同时 isThrow==false 和 isReturn==false，因为在方法刚开始时，还无法确定方法调用将会如何结束。</code></td>
</tr>
<tr>
<td>isThrow</td>
<td>辅助判断标记，当前的方法调用以抛异常的形式结束。</td>
</tr>
<tr>
<td>isReturn</td>
<td>辅助判断标记，当前的方法调用以正常返回的形式结束。</td>
</tr>
</tbody>
</table>

<pre><code class="language-shell"># 查看get方法的入参和出参
&gt; watch com.goddess.base.controller.UserController get &#39;{params[0],returnObj}&#39; -x 2

# 按照耗时进行过滤,#cost&gt;200(单位是ms)表示只有当耗时大于200ms时才会输出，过滤掉执行时间小于200ms的调用
&gt; watch com.goddess.base.controller.UserController get &#39;{params[0],returnObj}&#39; &#39;#cost&gt;200&#39; -x 2
&gt; 
</code></pre>

<h3 id="toc_10">stack 输出当前方法被调用的调用路径</h3>

<p>参数说明：</p>

<ul>
<li>class-pattern 类名表达式匹配</li>
<li>method-pattern 方法名表达式匹配</li>
<li>condition-express 条件表达式</li>
<li>[n:] 执行次数限制</li>
<li>[E] 开启正则表达式匹配，默认为通配符匹配</li>
</ul>

<p>据执行时间来过滤：<br/>
stack demo.MathGame primeFactors &#39;#cost&gt;5&#39;</p>

<h3 id="toc_11">tt</h3>

<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>

<h3 id="toc_12">vmoption 查看，更新JVM 诊断相关参数</h3>

<p>查看JVM诊断相关参数：</p>

<pre><code class="language-shell">[arthas@56963]$ vmoption
 KEY                    VALUE                   ORIGIN                 WRITEABLE
---------------------------------------------------------------------------------------------
 HeapDumpBeforeFullGC   false                   DEFAULT                true
 HeapDumpAfterFullGC    false                   DEFAULT                true
 HeapDumpOnOutOfMemory  false                   DEFAULT                true
 Error
 HeapDumpPath                                   DEFAULT                true
 CMSAbortablePrecleanW  100                     DEFAULT                true
 aitMillis
 CMSWaitDuration        2000                    DEFAULT                true
 CMSTriggerInterval     -1                      DEFAULT                true
 PrintGC                false                   DEFAULT                true
 PrintGCDetails         true                    MANAGEMENT             true
 PrintGCDateStamps      false                   DEFAULT                true
 PrintGCTimeStamps      false                   DEFAULT                true
 PrintGCID              false                   DEFAULT                true
 PrintClassHistogramBe  false                   DEFAULT                true
 foreFullGC
 PrintClassHistogramAf  false                   DEFAULT                true
 terFullGC
 PrintClassHistogram    false                   DEFAULT                true
 MinHeapFreeRatio       0                       DEFAULT                true
 MaxHeapFreeRatio       100                     DEFAULT                true
 PrintConcurrentLocks   false                   DEFAULT                true
</code></pre>

<p>查看指定option</p>

<pre><code class="language-shell">[arthas@56963]$ vmoption PrintGCDetails
 KEY                    VALUE                   ORIGIN                 WRITEABLE
---------------------------------------------------------------------------------------------
 PrintGCDetails         false                   MANAGEMENT             true

</code></pre>

<p>更新指定option：</p>

<pre><code class="language-shell">[arthas@56963]$ vmoption PrintGCDetails true
Successfully updated the vm option.
PrintGCDetails=true
</code></pre>

<h3 id="toc_13">sc 查看jvm已加载的类信息</h3>

<p>参数说明：<br/>
<figure><img src="media/15773440983590/15978503405145.jpg" alt=""/></figure></p>

<pre><code class="language-text">#模糊搜索
$ sc demo.*
demo.MathGame
Affect(row-cnt:1) cost in 55 ms.

</code></pre>

<h3 id="toc_14">sm 查看已加载类的方法信息</h3>

<h3 id="toc_15">classloader 查看 classloader的继承树，urls，类加载信息</h3>

<h3 id="toc_16">heapdum 类似jmap命令的heap dump功能</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[InnoDB 存储引擎]]></title>
    <link href="http://www.throne4j.com/15973328663419.html"/>
    <updated>2020-08-13T23:34:26+08:00</updated>
    <id>http://www.throne4j.com/15973328663419.html</id>
    <content type="html"><![CDATA[
<p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。</p>

<p>其特点是</p>

<ul>
<li>行锁设计</li>
<li>支持外检- 支持外键</li>
<li>非锁定读（默认读取操作不会产生锁）</li>
</ul>

<p>InnoDB存储引擎将数据放在一个逻辑的表空间中，这块空间有它自己进行管理。</p>

<p>InnoDB使用多版本并发控制（MVCC）来获得高并发性，并且实现了sql的标准的4中隔离级别，默认 repeatable级别。</p>

<p>使用一种被称为next-key locking的策略来避免幻读现象的产生。</p>

<p>InnoDB关键特性提供高性能和高可用性：</p>

<ul>
<li>插入缓冲 </li>
<li>二次写</li>
<li>自适应哈希索引</li>
<li>异步IO</li>
<li>刷新临近页</li>
<li>预读</li>
</ul>

<p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。</p>

<p>InnoDB的整体架构包括多个内存组成的多个后台线程和缓冲池。</p>

<h2 id="toc_0">InnoDB 多后台线程</h2>

<p>InnoDB存储引擎是多线程模型，其后台线程执行不同的任务</p>

<ul>
<li>Master Thread：负责将缓冲池中的数据异步刷新到硬盘</li>
<li>IO Thread：负责InnoDB存储引擎中的大量的AIO的请求回调处理</li>
<li>Purge thread：事务提交后，其所使用的的undolog可能不在需要，此线程是回收已经使用并分配的undo页</li>
<li>Page cleaner thread：刷新脏页</li>
</ul>

<h2 id="toc_1">缓冲池</h2>

<p>InnoDB是基于磁盘存储的，为了提高数据库的整体性能，引入了缓冲池技术。</p>

<p>在数据库中进行读取页的操作首先将从磁盘读取到的页存放在缓冲池中，这个过程称为“FIX”在缓冲池中，下次读取相同页的时候，首先判断页是否在缓冲池中，若在，称该页在缓冲池中被命中，否则从磁盘上读取该页数据。</p>

<p>对数据库中的页进行修改操作，首先修改缓冲池中的页，在以一定频路刷新到磁盘，但是并不是每次页发生改变的时候就进行刷新，而是通过一种称为 Checkpoint的机制刷新回磁盘。</p>

<p>因此缓冲池的大小直接影响着数据库的整体性能。</p>

<p>缓冲池中缓冲的数据页类型主要有如下几种：</p>

<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo页</li>
<li>插入缓冲页（insert buffer）</li>
<li>自适应哈希索引（adaptive hash index）</li>
<li>InnoDB 存储的锁信息（lock info）</li>
<li>数据字典信息</li>
</ul>

<p>允许有多个缓冲池实例，每个页根据hash值平均分派到不同的缓冲池实例中，可以减少数据库内部资源的竞争，增加数据库的并发处理能力。</p>

<p>缓冲池中的页通过LRU（Latest recent used，最近最少使用）算法来进行管理的。使用最频繁的页放在 LRU 列表的前端。</p>

<p>缓冲池的默认大小是16KB,也可能将页进行压缩然后存放到unzip_LRU列表进行管理。</p>

<p>在LRU列表中的页被修改后，称该页为 脏页，即缓冲池中的页和磁盘中的页数据不一致了。这是数据库通过checkpoint机制将脏页刷新会磁盘。Flush列表中的页即为脏页列表。</p>

<p>通过 show engine innodb status命令查看innodb的状态</p>

<pre><code class="language-text">&gt; show engine innodb status;
.....
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137363456
Dictionary memory allocated 415854
Buffer pool size   8191  缓冲池大小
Free buffers       6922  剩余缓存
Database pages     1264 页数量
Old database pages 486  
Modified db pages  0    脏页数量
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 1122, created 142, written 150
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 1264, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]

</code></pre>

<h3 id="toc_2">重做日志缓冲</h3>

<p>InnoDB 存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。innodb存储引擎首先将重做日志信息放入这个缓冲区，然后按照一定频率将其刷新到重做日志文件。这个区域不用设置很大，基本是每秒产生的事务量在这个缓冲大小之内即可(innodb_log_buffer_size参数设置其大小，通常8MB可以满足大部分应用)。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识 MySql数据库]]></title>
    <link href="http://www.throne4j.com/15973285844161.html"/>
    <updated>2020-08-13T22:23:04+08:00</updated>
    <id>http://www.throne4j.com/15973285844161.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">MySql 体系结构</h2>

<p>要了解 MySql 必须牢牢记住器体系结构，如下图所示</p>

<p><figure><img src="media/15973285844161/15973287823877.jpg" alt=""/></figure></p>

<p>从上图中发现，MySql 有一下几部分组成：</p>

<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li>插件式存储引擎</li>
<li>物理文件</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[八、java内存模型]]></title>
    <link href="http://www.throne4j.com/15972869856630.html"/>
    <updated>2020-08-13T10:49:45+08:00</updated>
    <id>http://www.throne4j.com/15972869856630.html</id>
    <content type="html"><![CDATA[
<p>MMU：虚拟地址映射<br/>
MMAP：</p>

<p>大小端存储</p>

<p>偏向延迟</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[七、 JVM 性能调优]]></title>
    <link href="http://www.throne4j.com/15962980278783.html"/>
    <updated>2020-08-02T00:07:07+08:00</updated>
    <id>http://www.throne4j.com/15962980278783.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1、调优需要考虑的内容</h2>

<p>业务场景的设定，计算内存需求，选定cpu，选择合适垃圾回收器，设定新生代大小、分代年龄，设定日志参数</p>

<h2 id="toc_1">2、apache bench 压测工具进行接口优化</h2>

<p>ab -c 10 -n 100 url<br/>
其中－n表示请求数，－c表示并发数</p>

<pre><code class="language-shell">&gt; ab -c 10 -n 100 https://www.baidu.com

....

Server Software:        BWS/1.1
Server Hostname:        www.baidu.com
Server Port:            443
SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128
Server Temp Key:        ECDH P-256 256 bits
TLS Server Name:        www.baidu.com

Document Path:          /
Document Length:        227 bytes

# 并发请求数
Concurrency Level:      100
# 整个测试持续的时间
Time taken for tests:   0.849 seconds
# 完成的请求数
Complete requests:      100
# 失败的请求数
Failed requests:        0
# 整个场景中的网络传输量
Total transferred:      108197 bytes
# 整个场景中的HTML内容传输量
HTML transferred:       22700 bytes
# 吞吐率
Requests per second:    117.76 [#/sec] (mean)
# 用户平均请求等待时间
Time per request:       849.153 [ms] (mean)
# 服务器平均请求处理时间
Time per request:       8.492 [ms] (mean, across all concurrent requests)
# 平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题
Transfer rate:          124.43 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       62  541 150.3    662     666
Processing:    15  148 120.4     61     295
Waiting:       11  146 118.8     61     291
Total:         76  689  66.5    704     773

Percentage of the requests served within a certain time (ms)
  50%    704
  66%    710
  75%    714
  80%    716
  90%    723
  95%    725
  98%    731
  99%    773
 100%    773 (longest request)
</code></pre>

<p>性能指标：</p>

<ul>
<li><p>吞吐率（Requests per second）<br/>
概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br/>
计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br/>
Request per second = Complete requests / Time taken for tests</p></li>
<li><p>用户平均请求等待时间（Time per request）<br/>
计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br/>
Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p></li>
<li><p>服务器平均请求等待时间（Time per request: across all concurrent requests）<br/>
计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br/>
Time taken for / testsComplete requests<br/>
可以看到，它是吞吐率的倒数。<br/>
同时，它也=用户平均请求等待时间/并发用户数，即<br/>
Time per request / Concurrency Level</p></li>
</ul>

<h2 id="toc_2">3、gc优化</h2>

<p>首先把优化策略发出来：</p>

<ul>
<li><p>新生代大小选择</p>
<ul>
<li>响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择)。在此种情况下,新生代收集发生的频率也是最小的。同时,减少到达老年代的对象。</li>
<li>吞吐量优先的应用:尽可能的设置大,可能到达 Gbit 的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合 8CPU 以上的应用。</li>
<li>避免设置过小.当新生代设置过小时会导致:1.MinorGC 次数更加频繁 2.可能导致 MinorGC 对象直接进入老年代,如果此时老年代满了,会触发FullGC. </li>
</ul></li>
<li><p>老年代大小选择</p>
<ul>
<li>响应时间优先的应用:老年代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可能会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式; 如果堆大了,则需要较长的收集时间。<br/>
最优化的方案,一般需要参考以下数据获得:并发垃圾收集信息、持久代并发收集次数、传统 GC 信息、花在新生代和老年代回收上的时间比例。</li>
<li>吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的新生代和一个较小的老年代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而 老年代尽存放长期存活对象。</li>
</ul></li>
</ul>

<h3 id="toc_3">3.1、gc性能指标</h3>

<ul>
<li><p>吞吐量:这里的衡量吞吐量是指应用程序所花费的时间和系统总运行时间的比值。<br/>
我们可以按照这个公式来计算 GC 的吞吐量:系统总运行时间 = 应用程序耗时 +GC 耗时。如果系统运行了 100 分钟，GC 耗时 1 分钟，则系统吞吐量为 99%。GC 的吞吐量一般不能低于 95%。</p></li>
<li><p>停顿时间: 指垃圾回收器正在运行时，应用程序的暂停时间。<br/>
对于串行回收器而言，停顿时间可能会比较长;而使用并发回收器，由于垃圾收集器和应用程序交替 运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾收集器，系统的吞吐量也很可能会降低。</p></li>
<li><p>垃圾回收频率: 通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿 时间。所以我们需要适当地增大堆内存空间，保证正常的垃圾回收频率即可。</p></li>
</ul>

<h3 id="toc_4">3.2、GC 调优策略</h3>

<h4 id="toc_5">3.2.1、降低 Minor GC 频率</h4>

<p>由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此我们可以通过增大新生代空间来降低 Minor GC 的频率。 单次 Minor GC 时间是由两部分组成:T1(扫描新生代)和 T2(复制存活对象)。</p>

<p>情况 1: 假设一个对象在 Eden 区的存活时间为 500ms，Minor GC 的时间间隔是 300ms，因为这个对象存活时间 &gt; 间隔时间，那么正常情况下，Minor GC 的时间为 :T1+T2。</p>

<p>情况 2:当我们增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不 存在复制存活对象了，所以再发生 Minor GC 的时间为:即 <code>T1*2(空间大了)+T2*0</code><br/>
可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。</p>

<p>在 JVM 中，复制对象的成本要远高于扫描成本。如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如 果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。</p>

<h4 id="toc_6">3.2.2、降低 Full GC 的频率</h4>

<p>由于堆内存空间不足或老年代对象太多，会触发 Full GC，频繁的 Full GC 会带来上下文切换，增加系统的性能开销。 </p>

<p>减少创建大对象: 在平常的业务场景中，我们一次性从数据库中查询出一个大对象用于 web 端显示。比如，一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代; 即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。</p>

<p>这种大对象很容易产生较多的 Full GC。 增大堆内存空间:在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 Full GC 的频率。</p>

<h2 id="toc_7">4、问题排查</h2>

<h3 id="toc_8">4.1、CPU占用过高排查</h3>

<p>使用top命令查看进程各种运行状况，请参考<a href="15983681960215.html">linux和macOS下top命令区别</a></p>

<p>1、先通过 top 命令找到消耗 cpu 很高的进程 PID<br/>
<figure><img src="media/15962980278783/15983692600595.jpg" alt="" style="width:1008px;"/></figure></p>

<p>2、执行 top -p PID 单独监控该进程<br/>
3、在第 2 步的监控界面输入 H，获取当前进程下的所有线程信息<br/>
4、找到消耗 cpu 特别高的线程编号，假设是 2734(要等待一阵)<br/>
5、执行 jstack PID 对当前的进程做 dump，输出所有的线程信息<br/>
6、将第 4 步得到的线程编号 PID 转成 16 进制是 0x???<br/>
7、根据第 6 步得到的 0x??? 在第 5 步的线程信息里面去找对应线程内容<br/>
8、解读线程信息，定位具体代码位置，此处可能并不是代码问题引起的cpu占用过高，可能由于 GC 引起频繁的垃圾回收，可使用jstat -gc 250 10查看gc统计情况<a href="%5B%E5%9B%9B%E3%80%81JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%5D(15773440983590.html)"></a></p>

<h3 id="toc_9">4.2、内存占用过高</h3>

<p>可以使用jmap命令来查看堆空间信息<br/>
打印出排名前20的对象<br/>
jmap –histo JVM_ID | head -20</p>

<p><figure><img src="media/15962980278783/15983702156050.jpg" alt=""/></figure></p>

<p>从此命令的返回结果中可以看出排名前几的可能就是引发内存占用过高的对象，进而找出那部分代码出了问题</p>

<h3 id="toc_10">4.3、总结</h3>

<p>在 JVM 出现性能问题的时候。(表现上是 CPU100%，内存一直占用)<br/>
1、 如果 CPU 的 100%，要从两个角度出发，一个有可能是业务线程疯狂运行，比如说想很多死循环。还有一种可能性，就是 GC 线程在疯狂的回收，因<br/>
为 JVM 中垃圾回收器主流也是多线程的，所以很容易导致 CPU 的 100%<br/>
2、 在遇到内存溢出的问题的时候，一般情况下我们要查看系统中哪些对象占用得比较多，我的是一个很简单的代码，在实际的业务代码中，找到对应的<br/>
对象，分析对应的类，找到为什么这些对象不能回收的原因，就是我们前面讲过的可达性分析算法，JVM 的内存区域，还有垃圾回收器的基础，当然， 如果遇到更加复杂的情况，你要掌握的理论基础远远不止这些(JVM 很多理论都是排查问题的关键)</p>

<h2 id="toc_11">5、常见问题</h2>

<h3 id="toc_12">5.1、超大对象</h3>

<p>代码中创建了很多大对象 , 且一直因为被引用不能被回收，这些大对象会进入老年代，导致内存一直被占用，很容易引发 GC 甚至是 OOM</p>

<h3 id="toc_13">5.2、内存泄漏</h3>

<p>大量对象引用没有释放，JVM 无法对其自动回收。</p>

<p>内存泄漏和内存溢出辨析：<br/>
内存溢出:实实在在的内存空间不足导致; 内存泄漏:该释放的对象没有释放，常见于使用容器保存元素的情况下。 </p>

<p>如何避免:<br/>
内存溢出:检查代码以及设置足够的空间 内存泄漏:一定是代码有问题 往往很多情况下，内存溢出往往是内存泄漏造成的。</p>

<h3 id="toc_14">5.3、长生命周期的对象持有短生命周期对象的引用</h3>

<p>例如将 HashMap 设置为静态变量，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏</p>

<h3 id="toc_15">5.4、连接未关闭</h3>

<p>如数据库连接、网络连接和 IO 连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象。</p>

<h3 id="toc_16">5.5、变量作用域不合理</h3>

<p>例如，1.一个变量的定义的作用范围大于其使用范围，2.如果没有及时地把对象设置为 null</p>

<h2 id="toc_17">6、MAT Analyzer(TODO)</h2>

<p>MAT(Memory Analyzer Tool)工具是eclipse的一个插件(MAT也可以单独使用)，使用起来非常方便，尤其是在分析大内存的dump文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用OQL对象查询，以及可以很方便的找出对象GC Roots的相关信息，当然最吸引人的还是能够快速为开发人员生成内存泄露报表，方便定位问题和分析问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[五、深入理解JVM---垃圾回收机制]]></title>
    <link href="http://www.throne4j.com/15960948965127.html"/>
    <updated>2020-07-30T15:41:36+08:00</updated>
    <id>http://www.throne4j.com/15960948965127.html</id>
    <content type="html"><![CDATA[
<p>对java的垃圾回收机制来说，我们需要考虑3个问题</p>

<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>

<p>引用计数算法</p>

<p>给对象添加一个引用计数器，当一个地方引用它，则计数器加1，引用失效，计数器减1，任何时候 计数器为0 的对象就是不可在此使用的对象。<br/>
它很难解决对象直减的相互循环引用的问题。  </p>

<pre><code class="language-text">
/**
 * 这个示例展示两个对象相互引用，程序计数器不会为0的，
 * 如果gc采用引用计数算法，这两个对象将不会得到回收。
 * 但实际情况是，这两个对象得到了回收，hospital jvm采用的不是引用计数垃圾回收算法。
 * -XX:+PrintGCDetails -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
 *
 * @author qinshengke
 * @since 2020/1/9
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }


    public static void main(String[] args) {
        testGC();
    }
}
垃圾回收结果
[GC (System.gc()) [PSYoungGen: 8028K-&gt;624K(76288K)] 8028K-&gt;632K(251392K), 0.0016257 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 624K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;418K(175104K)] 632K-&gt;418K(251392K), [Metaspace: 3153K-&gt;3153K(1056768K)], 0.0134161 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 76288K, used 1966K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)
  eden space 65536K, 3% used [0x000000076ab00000,0x000000076aceb9e0,0x000000076eb00000)
  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)
  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
 ParOldGen       total 175104K, used 418K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)
  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0068b30,0x00000006cab00000)
 Metaspace       used 3173K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 356K, capacity 388K, committed 512K, reserved 1048576K
</code></pre>

<p>根搜索算法 GC Roots Tracing <br/>
可作为GC Roots的对象包括下面几种：</p>

<ul>
<li>虚拟机栈(栈帧中的本地变量表)中的引用对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法中JNI引用的对象</li>
</ul>

<p>方法区主要回收两部分的内容： 废弃常量和无用类。<br/>
类回收需要满足如下3个条件：</p>

<ul>
<li>该类所有的实例都已经别GC,也就是JVM中不存在该Class的任何实例</li>
<li>加载该类的ClassLoader已经被GC</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。</li>
</ul>

<p>常见的垃圾收集算法(gc)</p>

<ul>
<li>标记-清除算法 mark-sweep</li>
<li>标记整理算法 mark-compact</li>
<li>复制算法 copying</li>
<li>分代算法 generational</li>
</ul>

<p>年轻代</p>

<ul>
<li>新生成的对象都放在新生代，<strong>年轻代用复制算法进行gc</strong>(理论上，年轻代对象的生命周期非常短，是和复制算法)</li>
<li>年轻代分为3个区域，Eden区、from survivor、 to survivor，Eden区满的时候，还存活的对象将被复制到一个from survivor，当from survivor区域满了之后，依然存活的对象被移动到to survivor 区域，to survivor区域满了之后，依然存活的对象会被复制到老年代。</li>
<li>Eden和两个survivor的缺省比例是8:1:1</li>
</ul>

<p>老年代</p>

<ul>
<li>存放了经过一个或多次GC还存活的对象</li>
<li>一般采用Mark-Sweep或者Mark-Compact算法进行GC</li>
<li>有多种垃圾收集器可以选择。每种垃圾收集器可以看做一个GC算法的具体实现。可以根据具体应用的需求选用何时的垃圾收集器(追求吞吐量还是追求最短的湘阴那个时间？)</li>
</ul>

<p>大对象在内存中会直接分配到老年代上<br/>
原子类型的内存分批是分配在java虚拟机栈上</p>

<h2 id="toc_0">垃圾回收</h2>

<p>GC要做的是将那些死亡(没有被引用对象)的对象所占用的内存回收掉。在进行full gc的时候会对Reference类型的应用那个进行特殊处理。<br/>
无论是引用计数算法还是根搜索算法，都和对象的引用有关，那么我们看一下java中的引用概念，java将引用分为强引用、软引用、弱引用、虚引用四种</p>

<ul>
<li>强引用是通过new关键字创建的对象，只要存在强引用，则垃圾回收机制不能对此对象进行回收；</li>
<li>软引用是用来描述非必须对象的，它通过SoftReference类实现的，软引用在JVM将要发生内存溢出时或者长期没有被使用的会将此类引用纳入可回收的范围内进行回收</li>
<li>弱引用 也是藐视非必须对象的，它通过WeekReference类实现，但是它的地位要比软引用还要低，它存活于下一次垃圾回收之前，当下一次垃圾回收发生时，弱引用也会被回收掉。</li>
<li>虚引用，它是最弱的一种引用关系，一个对象是否有序引用的存在，完全不会影响其生存时间，一万五发通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望在这个对象被收集器回收时收到一个系统通知。</li>
</ul>

<p>在根算法中不可达的对象，这个对象至少要经历两次标记过程，算法得出对象不可达后，第一次标记并进行一次筛选(根据对象是否有必要执行finalize()</p>

<ul>
<li>如果对象没有覆写finalize()方法</li>
<li>finalize()方法已经被虚拟机调用过<br/>
以上两种情况被视为没有必要执行回收操作</li>
</ul>

<p>如果对象被判定有必要执行finalize()方法，那么这个对象会被放置在一个名为F-Queue的队列之中，稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。</p>

<p>年轻代的垃圾收集算法有 Serial、ParNew、Parallel Scavenge<br/>
老年代的垃圾收集算法有 CMS、Serial Old(MSC)、Parallel Old</p>

<p>[GC (Allocation Failure) [PSYoungGen: 2615K-&gt;663K(9216K)] 9783K-&gt;7839K(19456K), 0.0017269 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </p>

<p>(Allocation Failure)  gc触发原因<br/>
2615K: 新生代gc时存活的对象<br/>
663K： 新生代gc后存活的对象大小<br/>
9216K: 新生代中总大小</p>

<p>9783K: 堆中存活的对象大小<br/>
7839K:</p>

<h3 id="toc_1">GC的时机</h3>

<ul>
<li>在分代模型的基础上，GC从时机上分为两种: Scavenge GC和Full GC</li>
<li>Scavenge GC(Minor GC)
<ul>
<li>触发时机: 新对象生成时，Eden空间满了</li>
<li>理论上Eden区域大多数对象会在Scavenge GC 回收，复制算法的执行效率会非常高，Scavenge GC时间比较短。</li>
</ul></li>
<li>Full GC 
<ul>
<li>对整个JVM进行整理吗，包括Young、old和Perm/MetaSpace</li>
<li>主要的触发时机: <br/>
a) Old满了 <br/>
b) Perm/MetaSpace满了<br/>
c) System.gc()</li>
<li>效率低，尽量减少Full GC。</li>
</ul></li>
</ul>

<h4 id="toc_2">垃圾回收器</h4>

<h5 id="toc_3">Serial</h5>

<p>单线程收集器，收集时会暂停所有的工作线程</p>

<ul>
<li>最早的收集器，单线程执行</li>
<li>New和Old Generation都可以使用</li>
<li>在新生代采用复式算法；在老年代使用Mark-Compact算法</li>
<li>虚拟机运行在client模式时的默认新生代垃圾收集器。</li>
</ul>

<h5 id="toc_4">ParNew收集器</h5>

<ul>
<li>ParNew收集器是Serial收集器的多线程版本</li>
<li>虚拟机运行在Server模式的默认新生代收集器</li>
<li>通过-XX:ParallelGCThreads来控制GC线程数的多少</li>
</ul>

<h5 id="toc_5">Parallel Scavenge 收集器</h5>

<ul>
<li>多线程收集器</li>
<li>采用复制算法</li>
<li>实现以吞吐量最大化为目标(允许较长时间内的STOP THE WORLD)</li>
</ul>

<h5 id="toc_6">CMS (Concurrent mark sweep)</h5>

<ul>
<li>以最短停顿时间为目标的垃圾收集器</li>
<li>采用 标记-清除算法 mark-sweep</li>
</ul>

<p>缺点：</p>

<ul>
<li>以牺牲CPU资源为代价来提高gc吞吐量</li>
<li>会产生内存碎片，可能导致频繁的Full GC操作<br/>
##### Serial Old(MSC)、</li>
<li>采用Mark-compact算法</li>
</ul>

<h5 id="toc_7">Parallel Old</h5>

<ul>
<li>Parallel Scavenge 在老年代的实现</li>
<li>采用Mark-compact算法</li>
<li>更注重吞吐量</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP/IP协议]]></title>
    <link href="http://www.throne4j.com/15957430515176.html"/>
    <updated>2020-07-26T13:57:31+08:00</updated>
    <id>http://www.throne4j.com/15957430515176.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/15955594725422/15955601439229.jpg" alt=""/></figure></p>

<h2 id="toc_0">1、计算机网络体系结构分层</h2>

<p><figure><img src="media/15955594725422/15955601585104.jpg" alt=""/></figure></p>

<p><figure><img src="media/15955594725422/15955601789832.jpg" alt=""/></figure><br/>
TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</p>

<h2 id="toc_1">2、 TCP/IP基础</h2>

<h3 id="toc_2">2.1、TCP/IP 的具体含义</h3>

<p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p>

<p><figure><img src="media/15955594725422/15955738573555.jpg" alt=""/></figure></p>

<h3 id="toc_3">2.2、数据包</h3>

<p>包、帧、数据包、段、消息以上五个术语都用来表述数据的单位，大致区分如下：</p>

<ul>
<li>包可以说是全能性术语；</li>
<li>帧用于表示数据链路层中包的单位；</li>
<li>数据包是 IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段则表示 TCP 数据流中的信息；</li>
<li>消息是指应用协议中数据的单位。</li>
</ul>

<p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>

<p><figure><img src="media/15955594725422/15955739013238.jpg" alt=""/></figure></p>

<p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。</p>

<h3 id="toc_4">2.3、 数据处理流程</h3>

<p>下图以用户a 向 用户b 发送邮件为例子<br/>
<figure><img src="media/15955594725422/15955739368710.jpg" alt=""/></figure></p>

<p>① 应用程序处理首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。<br/>
② TCP 模块的处理TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。<br/>
③ IP 模块的处理IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。<br/>
④ 网络接口（以太网驱动）的处理从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。<br/>
⑤ 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。<br/>
⑥ IP 模块的处理IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。<br/>
⑦ TCP 模块的处理在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。<br/>
⑧ 应用程序的处理接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>

<h2 id="toc_5">3、传输层中的 TCP 和 UDP</h2>

<p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>

<ul>
<li>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</li>
<li>UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</li>
<li>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</li>
</ul>

<h3 id="toc_6">3.1、端口号</h3>

<p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP  网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>

<h4 id="toc_7">3.1.1、根据端口号识别应用</h4>

<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>

<p><figure><img src="media/15955594725422/15955776803707.jpg" alt=""/></figure></p>

<h4 id="toc_8">3.1.2、通过IP地址、端口号、协议号进行通信识别</h4>

<p>仅凭目标端口好识别某一个通信是远远不够的。</p>

<p><figure><img src="media/15955594725422/15955782698920.jpg" alt=""/></figure></p>

<p><figure><img src="media/15955594725422/15955782793025.jpg" alt="通过源IP地址、目标IP地址、协议号、源端口号以及目标端口号这五个元素识别一个通信"/><figcaption>通过源IP地址、目标IP地址、协议号、源端口号以及目标端口号这五个元素识别一个通信</figcaption></figure></p>

<p>① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。<br/>
③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。<br/>
此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</p>

<h4 id="toc_9">3.1.3、 端口号的确定</h4>

<ul>
<li><p>标准既定的端口号<br/>
这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</p></li>
<li><p>时序分配法<br/>
服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</p></li>
</ul>

<h4 id="toc_10">3.1.4、端口号与协议</h4>

<ul>
<li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。<br/>
此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li>
</ul>

<h3 id="toc_11">3.2、UDP</h3>

<p>UDP 不提供复杂的控制机制，利用IP提供面向无连接的通信服务，并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。此外，传输途中出现丢包，UDP 也不负责重发。甚至当包的到达顺序出现乱序时也没有纠正的功能。如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</p>

<p>UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。</p>

<h3 id="toc_12">3.3、TCP</h3>

<p>TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>

<p>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信，主要通过一下机制来保证：</p>

<ul>
<li>检验和<br/>
TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>序列号</li>
<li>确认应答</li>
<li>重发控制</li>
<li>连接管理</li>
<li>窗口控制</li>
</ul>

<h4 id="toc_13">3.3.1、三次握手</h4>

<p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</p>

<p>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>

<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>

<p>下面来看看三次握手的流程图：</p>

<p><figure><img src="media/15955594725422/15956910155926.jpg" alt=""/></figure></p>

<ul>
<li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>
<li>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>
<li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>

<h4 id="toc_14">3.3.2、四次挥手</h4>

<p>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>

<p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>

<p>下面来看看四次挥手的流程图：</p>

<p><figure><img src="media/15955594725422/15956917850227.jpg" alt=""/></figure></p>

<p>中断连接端可以是客户端，也可以是服务器端。</p>

<ul>
<li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说&quot;我客户端没有数据要发给你了&quot;，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li>第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</li>
<li>第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。</li>
<li>第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>

<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况：<br/>
<figure><img src="media/15955594725422/15956918440314.jpg" alt=""/></figure></p>

<h4 id="toc_15">3.3.3、 通过序列号与确认应答提高可靠性</h4>

<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p>

<p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>

<p>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>

<p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>

<p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。<br/>
序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>

<p><figure><img src="media/15955594725422/15956919436214.jpg" alt=""/></figure></p>

<h4 id="toc_16">3.3.4、 重发超时的确定</h4>

<p>重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</p>

<p>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>

<p>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</p>

<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>

<p>此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>

<h4 id="toc_17">3.3.5、 以段为单位发送数据</h4>

<p>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</p>

<p>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS  为单位。</p>

<p>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS  选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>

<h4 id="toc_18">3.3.6、利用窗口控制提高速度</h4>

<p>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</p>

<p>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：<br/>
<figure><img src="media/15955594725422/15956920512186.jpg" alt=""/></figure></p>

<p>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</p>

<h4 id="toc_19">3.3.7、滑动窗口控制</h4>

<p><figure><img src="media/15955594725422/15957306505366.jpg" alt=""/></figure></p>

<p>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>

<p>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>

<p>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</p>

<h4 id="toc_20">3.3.8、窗口控制中的重发控制</h4>

<p>在使用窗口控制中， 出现丢包一般分为两种情况：</p>

<ul>
<li><p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：<br/>
<figure><img src="media/15955594725422/15957353198269.jpg" alt=""/></figure></p></li>
<li><p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。<br/>
<figure><img src="media/15955594725422/15957353491515.jpg" alt=""/></figure></p></li>
</ul>

<h2 id="toc_21">4、网络层的IP协议</h2>

<p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。</p>

<p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p>

<p>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</p>

<h3 id="toc_22">4.1、IP地址</h3>

<p>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。<br/>
作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。<br/>
不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。<br/>
IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：<br/>
<figure><img src="media/15955594725422/15957356769851.jpg" alt=""/></figure></p>

<h4 id="toc_23">4.1.1、 IP 地址由网络和主机两部分标识组成</h4>

<p>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。<br/>
<figure><img src="media/15955594725422/15957356923189.jpg" alt="IP地址的主机标识"/><figcaption>IP地址的主机标识</figcaption></figure></p>

<p>如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。<br/>
<figure><img src="media/15955594725422/15957357130579.jpg" alt="IP地址的网络标识"/><figcaption>IP地址的网络标识</figcaption></figure></p>

<h4 id="toc_24">4.1.2、 IP 地址的分类</h4>

<p>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。<br/>
A 类 IP 地址是首位以 “0” 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。<br/>
B 类 IP 地址是前两位 “10” 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。<br/>
C 类 IP 地址是前三位为 “110” 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。<br/>
D 类 IP 地址是前四位为 “1110” 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。<br/>
在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</p>

<h4 id="toc_25">4.1.3、 广播地址</h4>

<p>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。<br/>
广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</p>

<h4 id="toc_26">4.1.4、 IP 多播</h4>

<p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p>

<p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：IP 多播<br/>
<figure><img src="media/15955594725422/15957357583375.jpg" alt=""/></figure></p>

<p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。<br/>
x<br/>
此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p>

<h4 id="toc_27">4.1.5、 子网掩码</h4>

<p>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。<br/>
子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。<br/>
对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：<br/>
<figure><img src="media/15955594725422/15957358144400.jpg" alt=""/></figure></p>

<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</p>

<p><figure><img src="media/15955594725422/15957358402864.jpg" alt=""/></figure></p>

<p>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</p>

<h3 id="toc_28">4.2、 路由</h3>

<p>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</p>

<p>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</p>

<p>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</p>

<h4 id="toc_29">4.2.1、 IP 地址与路由控制</h4>

<p>IP 地址的网络地址部分用于进行路由控制。<br/>
路由控制表中记录着网络地址与下一步应该发送至路由器的地址。<br/>
在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。<br/>
<figure><img src="media/15955594725422/15957359215309.jpg" alt="路由控制表与 IP 包发送"/><figcaption>路由控制表与 IP 包发送</figcaption></figure></p>

<h3 id="toc_30">4.3、 IP 分包与组包</h3>

<p>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</p>

<p>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</p>

<p>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>

<h4 id="toc_31">4.3.1、 路径 MTU 发现</h4>

<p>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。<br/>
为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。<br/>
进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>

<h3 id="toc_32">4.4、 IPv6</h3>

<p>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</p>

<h4 id="toc_33">4.4.1、 IPv6 的特点</h4>

<p>IP 得知的扩大与路由控制表的聚合。<br/>
性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。<br/>
支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。<br/>
采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。<br/>
多播、Mobile IP 成为扩展功能。</p>

<h4 id="toc_34">4.4.2、 IPv6 中 IP 地址的标记方法</h4>

<p>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。<br/>
而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>

<h4 id="toc_35">4.4.3、 IPv6 地址的结构</h4>

<p>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。<br/>
在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>

<p><figure><img src="media/15955594725422/15957360738922.jpg" alt=""/></figure></p>

<h4 id="toc_36">4.4.4、 全局单播地址</h4>

<p>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。<br/>
格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。<br/>
<figure><img src="media/15955594725422/15957360990321.jpg" alt="全局单播地址"/><figcaption>全局单播地址</figcaption></figure></p>

<h4 id="toc_37">4.4.5、 链路本地单播地址</h4>

<p>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。<br/>
<figure><img src="media/15955594725422/15957361211675.jpg" alt="链路本地单播地址"/><figcaption>链路本地单播地址</figcaption></figure></p>

<h4 id="toc_38">4.4.6、 唯一本地地址</h4>

<p>唯一本地地址是不进行互联网通信时所用的地址。<br/>
唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。<br/>
L 通常被置为 1 <br/>
全局 ID 的值随机决定<br/>
子网 ID 是指该域子网地址<br/>
接口 ID 即为接口的 ID<br/>
<figure><img src="media/15955594725422/15957361414840.jpg" alt="唯一本地地址"/><figcaption>唯一本地地址</figcaption></figure></p>

<h4 id="toc_39">4.4.7、 IPv6 分段处理</h4>

<p>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。<br/>
IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</p>

<h2 id="toc_40">5、 IP 协议相关技术</h2>

<p>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p>

<h3 id="toc_41">5.1、 DNS</h3>

<p>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。<br/>
这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>

<h3 id="toc_42">5.2、 ARP</h3>

<p>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。<br/>
ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。<br/>
RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>

<h3 id="toc_43">5.3、 ICMP</h3>

<p>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。<br/>
IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</p>

<h3 id="toc_44">5.4、 DHCP</h3>

<p>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。<br/>
于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。<br/>
DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>

<h3 id="toc_45">5.5、 NAT</h3>

<p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。<br/>
除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。<br/>
NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</p>

<h3 id="toc_46">5.6、 IP 隧道夹着 IPv4 网络的两个 IPv6 网络</h3>

<p><figure><img src="media/15955594725422/15957362138379.jpg" alt=""/></figure></p>

<p>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。<br/>
IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。<br/>
一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议（六）-- 与 HTTP 协作的 Web 服务器]]></title>
    <link href="http://www.throne4j.com/15957418105856.html"/>
    <updated>2020-07-26T13:36:50+08:00</updated>
    <id>http://www.throne4j.com/15957418105856.html</id>
    <content type="html"><![CDATA[
<p>HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：代理、缓存、网关、隧道、Agent 代理。</p>

<p>1.代理<br/>
<figure><img src="media/15955168840534/15957390472021.jpg" alt="代理"/><figcaption>代理</figcaption></figure></p>

<p>HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。<br/>
出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。</p>

<ol>
<li>缓存<br/>
浏览器第一次请求：
<figure><img src="media/15955168840534/15957390923745.jpg" alt="浏览器第一次请求"/><figcaption>浏览器第一次请求</figcaption></figure></li>
</ol>

<p>浏览器再次请求：<br/>
<figure><img src="media/15955168840534/15957391037011.jpg" alt="浏览器再次请求"/><figcaption>浏览器再次请求</figcaption></figure></p>

<p>Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p>

<ol>
<li>网关
<figure><img src="media/15955168840534/15957391163572.jpg" alt="HTTP / FTP 网关"/><figcaption>HTTP / FTP 网关</figcaption></figure></li>
</ol>

<p>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。</p>

<ol>
<li>隧道
<figure><img src="media/15955168840534/15957391265275.jpg" alt="HTTP/SSL 隧道"/><figcaption>HTTP/SSL 隧道</figcaption></figure></li>
</ol>

<p>隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。</p>

<p>HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p>

<ol>
<li>Agent 代理
<figure><img src="media/15955168840534/15957391378461.jpg" alt="自动搜索引擎“网络蜘蛛”"/><figcaption>自动搜索引擎“网络蜘蛛”</figcaption></figure></li>
</ol>

<p>Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议（五）-- 响应状态码]]></title>
    <link href="http://www.throne4j.com/15957408756364.html"/>
    <updated>2020-07-26T13:21:15+08:00</updated>
    <id>http://www.throne4j.com/15957408756364.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">HTTP 响应状态码（重点分析）</h2>

<h3 id="toc_1">1. 状态码概述</h3>

<p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p>

<p>HTTP 状态码如 200 OK ，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。</p>

<p>不少返回的响应状态码都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK。</p>

<h3 id="toc_2">2. 状态码类别</h3>

<table>
<thead>
<tr>
<th>响应码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>

<tbody>
<tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error(客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>

<p>我们可以自行改变 RFC2616 中定义的状态码或者服务器端自行创建状态码，只要遵守状态码的类别定义就可以了。</p>

<h3 id="toc_3">3. 常用状态码解析</h3>

<p>HTTP 状态码种类繁多，数量达几十种。其中最常用的有以下 14 种，一起来看看。</p>

<h4 id="toc_4">3.1 、200 OK</h4>

<p>表示从客户端发来的请求在服务器端被正常处理了。</p>

<h4 id="toc_5">3.2、 204 No Content</h4>

<p>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。<br/>
一般在只需要从客户端向服务器端发送消息，而服务器端不需要向客户端发送新消息内容的情况下使用。</p>

<h4 id="toc_6">3.3、 206 Partial Content</h4>

<p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 首部字段指定范围的实体内容。</p>

<h4 id="toc_7">3.4、 301 Moved Permanently</h4>

<p>永久性重定向。表示请求的资源已被分配了新的 URI。以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p>

<h4 id="toc_8">3.5、 302 Found</h4>

<p>临时性重定向。表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</p>

<p>和 301 Moved Permanently 状态码相似，但 302 Found 状态码代表资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</p>

<h4 id="toc_9">3.6、 303 See Other</h4>

<p>表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>

<p>303 See Other 和 302 Found 状态码有着相同的功能，但 303 See Other 状态码明确表示客户端应采用 GET 方法获取资源，这点与 302 Found 状态码有区别。</p>

<h4 id="toc_10">3.7、 304 Not Modified</h4>

<p>表示客户端发送附带条件的请求时，服务器端允许请求访问的资源，但未满足条件的情况。</p>

<p>304 Not Modified 状态码返回时，不包含任何响应的主体部分。</p>

<p>304 Not Modified 虽然被划分到 3xx 类别中，但和重定向没有关系。</p>

<h4 id="toc_11">3.8、 307 Temporary Redirect</h4>

<p>临时重定向。该状态码与 302 Found 有着相同的含义。</p>

<h4 id="toc_12">3.9、 400 Bad Request</h4>

<p>表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。<br/>
另外，浏览器会像 200 OK 一样对待该状态码。</p>

<h4 id="toc_13">3.10、 401 Unauthorized</h4>

<p>表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。<br/>
另外，若之前已进行过 1 次请求，则表示用户认证失败。<br/>
返回含有 401 Unauthorized 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。</p>

<h4 id="toc_14">3.11、 403 Forbidden</h4>

<p>表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出详细的拒绝理由，当然也可以在响应报文的实体主体部分对原因进行描述。</p>

<h4 id="toc_15">3.12、 404 Not Found</h4>

<p>表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由的时候使用。</p>

<h4 id="toc_16">3.13、 500 Internal Server Error</h4>

<p>表明服务器端在执行请求时发生了错误。也可能是 Web 应用存在的 bug 或某些临时的故障。</p>

<h4 id="toc_17">3.14、 503 Service Unavailable</h4>

<p>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议(四)--HTTP 报文实体]]></title>
    <link href="http://www.throne4j.com/15957408714359.html"/>
    <updated>2020-07-26T13:21:11+08:00</updated>
    <id>http://www.throne4j.com/15957408714359.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1. HTTP 报文实体概述</h2>

<p><figure><img src="media/15955168840534/15957385627780.jpg" alt="HTTP 报文结构"/><figcaption>HTTP 报文结构</figcaption></figure></p>

<p>大家请仔细看看上面示例中，各个组成部分对应的内容。<br/>
接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</p>

<ul>
<li><p>报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p></li>
<li><p>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）</p></li>
</ul>

<p>我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。<br/>
通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>

<h2 id="toc_1">2. 内容编码</h2>

<p>HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</p>

<p>这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。<br/>
内容编码类型：</p>

<table>
<thead>
<tr>
<th>编码方式</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>gzip</td>
<td>表明实体采用 GNU zip 编码</td>
</tr>
<tr>
<td>compress</td>
<td>表明实体采用 Unix 的文件压缩程序</td>
</tr>
<tr>
<td>deflate</td>
<td>表明实体采用 zlib 的格式压缩的</td>
</tr>
<tr>
<td>identity</td>
<td>表明没有对实体进行编码，当没有 Content-Encoding 首部字段时，默认采用此编码方式</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">3. 传输编码</h2>

<p>内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。<br/>
传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p>

<p><figure><img src="media/15955168840534/15957385792865.jpg" alt="内容编码和传输编码的对比"/><figcaption>内容编码和传输编码的对比</figcaption></figure></p>

<h2 id="toc_3">4. 分块编码</h2>

<p>分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。</p>

<p>分块编码与持久连接<br/>
若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。<br/>
当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。<br/>
分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。<br/>
来看看一个分块编码的报文示例：<br/>
<figure><img src="media/15955168840534/15957390124186.jpg" alt=""/></figure></p>

<p>分块编码的报文</p>

<h2 id="toc_4">5.多部分媒体类型</h2>

<p>MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。<br/>
相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。<br/>
多部分对象集合包含的对象如下：</p>

<p>multipart/form-data：在 Web 表单文件上传时使用。<br/>
multipart/byteranges：状态码 206 Partial Content 响应报文包含了多个范围的内容时使用。</p>

<h2 id="toc_5">6. 范围请求</h2>

<p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。<br/>
有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：</p>

<pre><code class="language-text">GET  /bigfile.html  HTTP/1.1
Host: www.sample.com
Range: bytes=20224-
···
</code></pre>

<p><figure><img src="media/15955168840534/15957390372242.jpg" alt=""/></figure></p>

<p>实体范围请求示例<br/>
上面示例中，客户端请求的是文档开头20224字节之后的部分。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议(三)--HTTP 报文详析]]></title>
    <link href="http://www.throne4j.com/15957408699075.html"/>
    <updated>2020-07-26T13:21:09+08:00</updated>
    <id>http://www.throne4j.com/15957408699075.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一、http 首部字段</h2>

<h3 id="toc_1">1.首部字段概述</h3>

<p>先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。<br/>
在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p>

<h3 id="toc_2">2.首部字段结构</h3>

<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。<br/>
另外，字段值对应单个 HTTP 首部字段可以有多个值。<br/>
当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</p>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>字段值</th>
</tr>
</thead>

<tbody>
<tr>
<td>Content-Type</td>
<td>text/html</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>timeout=30, max=120</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">3.首部字段类型</h3>

<p>首部字段根据实际用途被分为以下4种类型：</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>通用首部字段</td>
<td>请求报文和响应报文两方都会使用的首部</td>
</tr>
<tr>
<td>请求首部字段</td>
<td>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td>
</tr>
<tr>
<td>响应首部字段</td>
<td>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td>
</tr>
<tr>
<td>实体首部字段</td>
<td>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">4.通用首部字段（HTTP/1.1）</h3>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐挑首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>

<h4 id="toc_5">4.1 Cache-Control</h4>

<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>

<h5 id="toc_6">4.1.1 可用的指令一览</h5>

<p>可用的指令按请求和响应分类如下：<br/>
缓存请求指令</p>

<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>no-cache</td>
<td>无</td>
<td>强制向服务器再次验证</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>max-age = [秒]</td>
<td>必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td>max-stale( =[秒])</td>
<td>可省略</td>
<td>接收已过期的响应</td>
</tr>
<tr>
<td>min-fresh = [秒]</td>
<td>必需</td>
<td>期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>从缓存获取资源</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>

<p>缓存响应指令：</p>

<table>
<thead>
<tr>
<th>指令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>public</td>
<td>无</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td>private</td>
<td>可省略</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td>no-cache</td>
<td>可省略</td>
<td>缓存前必须先确认其有效性</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>无</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>无</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age = [秒]</td>
<td>必需</td>
<td>响应的最大Age值</td>
</tr>
<tr>
<td>s-maxage = [秒]</td>
<td>必需</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td>cache-extension</td>
<td>-</td>
<td>新指令标记（token）</td>
</tr>
</tbody>
</table>

<h5 id="toc_7">4.1.2 表示能否缓存的指令</h5>

<ul>
<li><p>public 指令<br/>
Cache-Control: public<br/>
当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p></li>
<li><p>private 指令<br/>
Cache-Control: private<br/>
当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p></li>
<li><p>no-cache 指令<br/>
Cache-Control: no-cache</p></li>
</ul>

<p>使用 no-cache 指令是为了防止从缓存中返回过期的资源。<br/>
客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。<br/>
如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>

<p>Cache-Control: no-cache=Location</p>

<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p>

<ul>
<li>no-store 指令<br/>
Cache-Control: no-store<br/>
当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br/>
注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</li>
</ul>

<h4 id="toc_8">4.1.3 指定缓存期限和认证的指令</h4>

<ul>
<li>s-maxage 指令<br/>
Cache-Control: s-maxage=604800（单位：秒）</li>
</ul>

<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。<br/>
另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</p>

<ul>
<li>max-age 指令<br/>
Cache-Control: max-age=604800（单位：秒）</li>
</ul>

<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。<br/>
当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。<br/>
应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</p>

<ul>
<li><p>min-fresh 指令<br/>
Cache-Control: min-fresh=60（单位：秒）<br/>
min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p></li>
<li><p>max-stale 指令<br/>
Cache-Control: max-stale=3600（单位：秒）</p></li>
</ul>

<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br/>
如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p>

<ul>
<li><p>only-if-cached 指令<br/>
Cache-Control: only-if-cached<br/>
表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p></li>
<li><p>must-revalidate 指令<br/>
Cache-Control: must-revalidate<br/>
使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p></li>
<li><p>proxy-revalidate 指令<br/>
Cache-Control: proxy-revalidate<br/>
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p></li>
<li><p>no-transform 指令<br/>
Cache-Control: no-transform<br/>
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p></li>
</ul>

<h5 id="toc_9">4.1.4 Cache-Control 扩展</h5>

<p>Cache-Control: private, community=&quot;UCI&quot;<br/>
通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p>

<h4 id="toc_10">4.2 Connection</h4>

<p>Connection 首部字段具备以下两个作用：</p>

<h5 id="toc_11">控制不再转发的首部字段</h5>

<p>Connection: Upgrade<br/>
在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p>

<h5 id="toc_12">管理持久连接</h5>

<p>Connection: close<br/>
HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。<br/>
Connection: Keep-Alive<br/>
HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p>

<h4 id="toc_13">4.3 Date</h4>

<p>表明创建 HTTP 报文的日期和时间。<br/>
Date: Mon, 10 Jul 2017 15:50:06 GMT<br/>
HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p>

<h4 id="toc_14">4.4 Pragma</h4>

<p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br/>
Pragma: no-cache</p>

<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。</p>

<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字</p>

<pre><code class="language-text">Cache-Control: no-cache
Pragma: no-cache
</code></pre>

<h4 id="toc_15">4.5 Trailer</h4>

<p>Trailer: Expires</p>

<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p>

<h4 id="toc_16">4.6 Transfer-Encoding</h4>

<p>Transfer-Encoding: chunked</p>

<p>规定了传输报文主体时采用的编码方式。<br/>
HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>

<h4 id="toc_17">4.7 Upgrade</h4>

<p>Upgrade: TSL/1.0<br/>
用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>

<h4 id="toc_18">4.8 Via</h4>

<p>Via: 1.1 a1.sample.com(Squid/2.7)<br/>
为了追踪客户端和服务器端之间的请求和响应报文的传输路径。<br/>
报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。<br/>
首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</p>

<h4 id="toc_19">4.9 Warning</h4>

<p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br/>
Warning 首部字段的格式如下：<br/>
Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])<br/>
最后的日期时间可省略。<br/>
HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p>

<table>
<thead>
<tr>
<th>警告码</th>
<th>警告内容</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>110</td>
<td>Response is stale(响应已过期)</td>
<td>代理返回已过期的资源</td>
</tr>
<tr>
<td>111</td>
<td>Revalidation failed(再验证失败)</td>
<td>代理再验证资源有效性时失败（服务器无法到达等原因）</td>
</tr>
<tr>
<td>112</td>
<td>Disconnection operation(断开连接操作)</td>
<td>代理与互联网连接被故意切断</td>
</tr>
<tr>
<td>113</td>
<td>Heuristic expiration(试探性过期)</td>
<td>响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td>
</tr>
<tr>
<td>199</td>
<td>Miscellaneous warning(杂项警告)</td>
<td>任意的警告内容</td>
</tr>
<tr>
<td>214</td>
<td>Transformation applied(使用了转换)</td>
<td>代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td>299</td>
<td>Miscellaneous persistent warning(持久杂项警告)</td>
<td>任意的警告内容</td>
</tr>
</tbody>
</table>

<h2 id="toc_20">二、  请求首部字段（HTTP/1.1）</h2>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Macth 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间(与 If-Modified-Since 相反)</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP</td>
</tr>
</tbody>
</table>

<h3 id="toc_21">1 Accept</h3>

<pre><code class="language-text">Accept: text/html, application/xhtml+xml, application/xml; q=0.5
</code></pre>

<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。<br/>
若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</p>

<h3 id="toc_22">2 Accept-Charset</h3>

<pre><code class="language-text">Accept-Charset: iso-8859-5, unicode-1-1; q=0.8
</code></pre>

<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。</p>

<h3 id="toc_23">3 Accept-Encoding</h3>

<pre><code class="language-text">Accept-Encoding: gzip, deflate
</code></pre>

<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p>

<h3 id="toc_24">4 Accept-Language</h3>

<pre><code class="language-text">Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3
</code></pre>

<p>告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。</p>

<h3 id="toc_25">5 Authorization</h3>

<pre><code class="language-text">Authorization: Basic ldfKDHKfkDdasSAEdasd==
</code></pre>

<p>告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p>

<h3 id="toc_26">6 Expect</h3>

<pre><code class="language-text">Expect: 100-continue
</code></pre>

<p>告知服务器客户端期望出现的某种特定行为。</p>

<h3 id="toc_27">7 From</h3>

<pre><code class="language-text">From: Deeson_Woo@163.com
</code></pre>

<p>告知服务器使用用户代理的电子邮件地址。</p>

<h3 id="toc_28">8 Host</h3>

<pre><code class="language-text">Host: www.jianshu.com
</code></pre>

<p>告知服务器，请求的资源所处的互联网主机和端口号。<br/>
Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。<br/>
若服务器未设定主机名，那直接发送一个空值即可 Host: 。</p>

<h3 id="toc_29">9 If-Match</h3>

<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>

<pre><code class="language-text">If-Match: &quot;123456&quot;
</code></pre>

<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。<br/>
服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。<br/>
还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p>

<h3 id="toc_30">10 If-Modified-Since</h3>

<pre><code class="language-text">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT
</code></pre>

<p>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。<br/>
它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>

<h3 id="toc_31">11 If-None-Match</h3>

<pre><code class="language-text">If-None-Match: &quot;123456&quot;
</code></pre>

<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>

<h3 id="toc_32">12 If-Range</h3>

<pre><code class="language-text">If-Range: &quot;123456&quot;
</code></pre>

<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>

<p>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p>

<h3 id="toc_33">13 If-Unmodified-Since</h3>

<pre><code class="language-text">If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT
</code></pre>

<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>

<h3 id="toc_34">14 Max-Forwards</h3>

<pre><code class="language-text">Max-Forwards: 10
</code></pre>

<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>

<h3 id="toc_35">15 Proxy-Authorization</h3>

<pre><code class="language-text">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5
</code></pre>

<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。<br/>
这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</p>

<h3 id="toc_36">16 Range</h3>

<pre><code class="language-text">Range: bytes=5001-10000
</code></pre>

<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。<br/>
接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>

<h3 id="toc_37">17 Referer</h3>

<pre><code class="language-text">Referer: http://www.sample.com/index.html
</code></pre>

<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>

<h3 id="toc_38">18 TE</h3>

<pre><code class="language-text">TE: gzip, deflate; q=0.5
</code></pre>

<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。<br/>
首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers</p>

<h3 id="toc_39">19 User-Agent</h3>

<pre><code class="language-text">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101
</code></pre>

<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>

<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>

<h2 id="toc_40">三、 响应首部字段（HTTP/1.1）</h2>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>

<h3 id="toc_41">1 Accept-Ranges</h3>

<p>Accept-Ranges: bytes</p>

<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。<br/>
可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>

<h3 id="toc_42">2 Age</h3>

<p>Age: 1200</p>

<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。<br/>
若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</p>

<h3 id="toc_43">3 ETag</h3>

<p>ETag: &quot;usagi-1234&quot;</p>

<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>

<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。</p>

<p>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/&quot;usagi-1234&quot;。</p>

<h3 id="toc_44">4 Location</h3>

<p>Location: <a href="http://www.sample.com/sample.html">http://www.sample.com/sample.html</a></p>

<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。<br/>
基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。<br/>
几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>

<h3 id="toc_45">5 Proxy-Authenticate</h3>

<p>Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</p>

<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。<br/>
它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</p>

<h3 id="toc_46">6 Retry-After</h3>

<p>Retry-After: 180</p>

<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。<br/>
字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</p>

<h3 id="toc_47">7 Server</h3>

<p>Server: Apache/2.2.6 (Unix) PHP/5.2.5<br/>
首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>

<h3 id="toc_48">8 Vary</h3>

<p>Vary: Accept-Language</p>

<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。<br/>
从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>

<h3 id="toc_49">9 WWW-Authenticate</h3>

<p>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;<br/>
首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p>

<h2 id="toc_50">四、 实体首部字段（HTTP/1.1）</h2>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>

<h3 id="toc_51">1 Allow</h3>

<p>Allow: GET, HEAD</p>

<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。<br/>
当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>

<h3 id="toc_52">2 Content-Encoding</h3>

<p>Content-Encoding: gzip</p>

<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。<br/>
主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</p>

<h3 id="toc_53">3 Content-Language</h3>

<p>Content-Language: zh-CN<br/>
首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>

<h3 id="toc_54">4 Content-Length</h3>

<p>Content-Length: 15000<br/>
首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p>

<h3 id="toc_55">5 Content-Location</h3>

<p>Content-Location: <a href="http://www.sample.com/index.html">http://www.sample.com/index.html</a><br/>
首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>

<h3 id="toc_56">6 Content-MD5</h3>

<p>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==<br/>
首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>

<h3 id="toc_57">7 Content-Range</h3>

<p>Content-Range: bytes 5001-10000/10000<br/>
针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>

<h3 id="toc_58">8 Content-Type</h3>

<p>Content-Type: text/html; charset=UTF-8<br/>
首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p>

<h3 id="toc_59">9 Expires</h3>

<p>Expires: Mon, 10 Jul 2017 15:50:06 GMT</p>

<p>首部字段 Expires 会将资源失效的日期告知客户端。<br/>
缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。<br/>
源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p>

<h3 id="toc_60">10 Last-Modified</h3>

<p>Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT<br/>
首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间</p>

<h2 id="toc_61">五、  Cookie 服务的首部字段</h2>

<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>首部类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的 Cookie 信息</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的 Cookie 信息</td>
<td>请求首部字段</td>
</tr>
</tbody>
</table>

<h3 id="toc_62">1 Set-Cookie</h3>

<p>Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</p>

<p>下面的表格列举了 Set-Cookie 的字段值。</p>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>NAME=VALUE</td>
<td>赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td>expires=DATE</td>
<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td>path=PATH</td>
<td>将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td>domain=域名</td>
<td>作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td>
</tr>
<tr>
<td>Secure</td>
<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td>HttpOnly</td>
<td>加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>

<h4 id="toc_63">1.1 expires 属性</h4>

<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。<br/>
当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。<br/>
另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>

<h4 id="toc_64">1.2 path 属性</h4>

<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p>

<h4 id="toc_65">1.3 domain 属性</h4>

<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。</p>

<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p>

<h4 id="toc_66">1.4 secure 属性</h4>

<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>

<h4 id="toc_67">1.5 HttpOnly 属性</h4>

<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>

<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>

<h3 id="toc_68">2 Cookie</h3>

<p>Cookie: status=enable<br/>
首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>

<h2 id="toc_69">六、 其他首部字段</h2>

<p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br/>
以下是最为常用的首部字段。</p>

<h3 id="toc_70">1 X-Frame-Options</h3>

<p>X-Frame-Options: DENY<br/>
首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p>

<ul>
<li>DENY：拒绝</li>
<li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://sample.com/sample.html">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</li>
</ul>

<h3 id="toc_71">2 X-XSS-Protection</h3>

<p>X-XSS-Protection: 1<br/>
首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p>

<ul>
<li>0 ：将 XSS 过滤设置成无效状态</li>
<li><p>1 ：将 XSS 过滤设置成有效状态</p>
<h3 id="toc_72">3 DNT</h3>
<p>DNT: 1<br/>
首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p></li>
<li><p>0 ：同意被追踪<br/>
1-  ：拒绝被追踪<br/>
由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p></li>
</ul>

<h3 id="toc_73">4 P3P</h3>

<pre><code class="language-text">P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND
</code></pre>

<p>首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br/>
要进行 P3P 的设定，需按以下操作步骤进行：</p>

<ul>
<li>步骤 1：创建 P3P 隐私</li>
<li>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li>
<li>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议（二）-- HTTP 协议报文结构]]></title>
    <link href="http://www.throne4j.com/15955594725422.html"/>
    <updated>2020-07-24T10:57:52+08:00</updated>
    <id>http://www.throne4j.com/15955594725422.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1.HTTP 报文</h2>

<p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>

<h2 id="toc_1">2.HTTP 报文结构</h2>

<p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。如下：</p>

<p><figure><img src="media/15955168840534/15957370382069.jpg" alt="HTTP 报文结构"/><figcaption>HTTP 报文结构</figcaption></figure></p>

<p><figure><img src="media/15955168840534/15957373454385.jpg" alt=""/></figure></p>

<h3 id="toc_2">2.1请求报文结构</h3>

<p><figure><img src="media/15955168840534/15957373620655.jpg" alt="请求报文结构"/><figcaption>请求报文结构</figcaption></figure></p>

<p>请求报文的首部内容由以下数据组成：</p>

<ul>
<li>请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本。</li>
<li>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）<br/>
请求报文的示例，如下：
<figure><img src="media/15955168840534/15957373766248.jpg" alt="请求报文示例"/><figcaption>请求报文示例</figcaption></figure></li>
</ul>

<h3 id="toc_3">2.2响应报文结构</h3>

<p><figure><img src="media/15955168840534/15957373975954.jpg" alt="响应报文结构"/><figcaption>响应报文结构</figcaption></figure></p>

<p>响应报文的首部内容由以下数据组成：</p>

<ul>
<li>状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。</li>
<li>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）<br/>
响应报文的示例，如下：
<figure><img src="media/15955168840534/15957375812162.jpg" alt=""/></figure></li>
</ul>

<h2 id="toc_4">HTTP 报文首部之请求行、状态行</h2>

<h3 id="toc_5">1.请求行</h3>

<p>举个栗子，下面是一个 HTTP 请求的报文：</p>

<pre><code class="language-text">GET  /index.htm  HTTP/1.1
Host: sample.com
</code></pre>

<p>其中，下面的这行就是请求行，</p>

<pre><code class="language-text">GET  /index.htm  HTTP/1.1
</code></pre>

<ul>
<li>开头的 GET 表示请求访问服务器的类型，称为方法；</li>
<li>随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI；</li>
<li>最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。<br/>
综合来看，大意是请求访问某台 HTTP 服务器上的 /index.htm 页面资源。</li>
</ul>

<h3 id="toc_6">2.状态行</h3>

<p>同样举个栗子，下面是一个 HTTP 响应的报文：</p>

<pre><code class="language-text">HTTP/1.1  200  OK
Date: Mon, 10 Jul 2017 15:50:06 GMT
Content-Length: 256
Content-Type: text/html
    
&lt;html&gt;
...
</code></pre>

<p>其中，下面的这行就是状态行，</p>

<pre><code class="language-text">HTTP/1.1  200  OK
</code></pre>

<p>开头的 HTTP/1.1 表示服务器对应的 HTTP 版本；<br/>
紧挨着的 200 OK 表示请求的处理结果的状态码和原因短语。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP协议（一）-- HTTP协议概述]]></title>
    <link href="http://www.throne4j.com/15955168840534.html"/>
    <updated>2020-07-23T23:08:04+08:00</updated>
    <id>http://www.throne4j.com/15955168840534.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/15955168840534/15957366995368.jpg" alt=""/></figure></p>

<h2 id="toc_0">一、概述</h2>

<h3 id="toc_1">1.计算机网络体系结构分层</h3>

<p><figure><img src="media/15955168840534/15957367250846.jpg" alt="网络体系结构分层"/><figcaption>网络体系结构分层</figcaption></figure></p>

<h3 id="toc_2">2.TCP/IP 通信传输流</h3>

<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。如下：<br/>
<figure><img src="media/15955168840534/15957367734847.jpg" alt="TCP/IP 通信传输流"/><figcaption>TCP/IP 通信传输流</figcaption></figure></p>

<p>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>

<p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。<br/>
在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>

<p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>

<p>如下图所示：<br/>
<figure><img src="media/15955168840534/15957367985192.jpg" alt="HTTP 请求"/><figcaption>HTTP 请求</figcaption></figure></p>

<p>在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP/1.1版本）展开。</p>

<p><code>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br/>
HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br/>
我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。<br/>
</code></p>

<h2 id="toc_3">二、HTTP 工作过程</h2>

<p><figure><img src="media/15955168840534/15957369027873.jpg" alt="HTTP请求响应模型"/><figcaption>HTTP请求响应模型</figcaption></figure></p>

<p>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</p>

<ul>
<li><p>建立 TCP 连接<br/>
在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</p></li>
<li><p>客户端向服务器发送请求命令<br/>
一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br/>
例如：GET/sample/hello.jsp HTTP/1.1</p></li>
<li><p>客户端发送请求头信息<br/>
客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</p></li>
<li><p>服务器应答<br/>
客户端向服务器发出请求后，服务器会客户端返回响应；<br/>
例如： HTTP/1.1 200 OK<br/>
响应的第一部分是协议的版本号和响应状态码</p></li>
<li><p>服务器返回响应头信息<br/>
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</p></li>
<li><p>服务器向客户端发送数据<br/>
服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</p></li>
<li><p>服务器关闭 TCP 连接<br/>
一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p></li>
</ul>

<h2 id="toc_4">三、HTTP 协议基础</h2>

<h3 id="toc_5">1.通过请求和响应的交换达成通信</h3>

<p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>

<h3 id="toc_6">2.HTTP 是不保存状态的协议</h3>

<p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br/>
可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>

<h3 id="toc_7">3.使用 Cookie 的状态管理</h3>

<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>

<p><figure><img src="media/15955168840534/15957369673190.jpg" alt="Cookie 的流程"/><figcaption>Cookie 的流程</figcaption></figure></p>

<h3 id="toc_8">4.请求 URI 定位资源</h3>

<p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>

<h3 id="toc_9">5.告知服务器意图的 HTTP 方法（HTTP/1.1）</h3>

<p><figure><img src="media/15955168840534/15957369934248.jpg" alt="HTTP 方法"/><figcaption>HTTP 方法</figcaption></figure></p>

<h3 id="toc_10">6.持久连接</h3>

<p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br/>
为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</p>

<h3 id="toc_11">7.管线化</h3>

<p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。<br/>
比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[# HTTP访问控制（CORS）]]></title>
    <link href="http://www.throne4j.com/15955163850122.html"/>
    <updated>2020-07-23T22:59:45+08:00</updated>
    <id>http://www.throne4j.com/15955163850122.html</id>
    <content type="html"><![CDATA[
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>

<p>比如，站点 <a href="http://domain-a.com">http://domain-a.com</a> 的某 HTML 页面又去请求 <a href="http://domain-b.com/xxx%E9%A1%B5%E9%9D%A2%E3%80%82%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84%E8%AE%B8%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%83%BD%E4%BC%9A%E5%8A%A0%E8%BD%BD%E6%9D%A5%E8%87%AA%E4%B8%8D%E5%90%8C%E5%9F%9F%E7%9A%84CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%EF%BC%8C%E5%9B%BE%E5%83%8F%E5%92%8C%E8%84%9A%E6%9C%AC%E7%AD%89%E8%B5%84%E6%BA%90%E3%80%82">http://domain-b.com/xxx页面。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</a></p>

<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</p>

<p><figure><img src="media/15955111272689/15955114749443.jpg" alt=""/></figure></p>

<p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p>

<hr/>

<h2 id="toc_0">什么情况下需要 CORS ？</h2>

<p>跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</p>

<ul>
<li>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</li>
<li>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li>
<li>WebGL 贴图</li>
<li>使用 drawImage 将 Images/video 画面绘制到 canvas<br/>
本文概述了跨域资源共享机制及其所涉及的 HTTP 头。</li>
</ul>

<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p>

<p>CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。</p>

<hr/>

<h2 id="toc_1">HTTP 响应 header 字段</h2>

<p>使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。</p>

<ul>
<li><p>Access-Control-Allow-Origin: <origin> | *<br/>
服务端设置 Access-Control-Allow-Origin 就是告诉浏览器允许向服务端请求资源的域名，浏览器通过 Response 中的 Access-Control-Allow-Origin 就可以知道能不能把数据吐出来。<br/>
例如：</p>
<pre><code class="language-text">Access-Control-Allow-Origin: http://mozilla.com
</code></pre>
<p>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容</p></li>
<li><p>Access-Control-Expose-Headers : 让服务器把允许浏览器访问的头放入白名单<br/>
在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。<br/>
例如：</p>
<pre><code class="language-text">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header
</code></pre>
<p>这样浏览器就能够通过getResponseHeader访问X-My-Custom-Header和 X-Another-Custom-Header 响应头了。</p></li>
<li><p>Access-Control-Max-Age: <delta-seconds> <br/>
指定了preflight请求的结果能够被缓存多久，delta-seconds 参数表示preflight请求的结果在多少秒内有效。</p></li>
<li><p>Access-Control-Allow-Credentials: true|false <br/>
指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容</p></li>
<li><p>Access-Control-Allow-Methods: <method>[, <method>]* <br/>
指明实际请求所允许使用的 HTTP 方法</p></li>
<li><p>Access-Control-Allow-Headers: <field-name>[, <field-name>]* <br/>
指明实际请求中允许携带的首部字段</p></li>
</ul>

<h2 id="toc_2">HTTP 请求header字段</h2>

<ul>
<li>Origin  表明预检请求或实际请求的源站 URI,不管是否跨域ORIGIN 字段总是被发送</li>
<li>Access-Control-Request-Method 将实际请求所使用的 HTTP 方法告诉服务器</li>
<li>Access-Control-Request-Headers  将实际请求所携带的首部字段告诉服务器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redission 防止用户请求重复提交]]></title>
    <link href="http://www.throne4j.com/15955096929534.html"/>
    <updated>2020-07-23T21:08:12+08:00</updated>
    <id>http://www.throne4j.com/15955096929534.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text">package com.rongdu.cashloan.core.redisson;
 
import org.apache.commons.lang3.StringUtils;
import org.redisson.Redisson;
import org.redisson.api.*;
import org.redisson.config.Config;
import org.redisson.config.SingleServerConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
 
/***
 * Redis client的辅助工具类
 * 用于连接Redis服务器 创建不同的Redis Server对应的客户端对象
 * @author wangnian
 * 博客地址：http://my.oschina.net/wangnian
 */
public class RedisUtils {
 
   private static  Logger logger= LoggerFactory.getLogger(RedisUtils.class);
 
   private static RedisUtils redisUtils;
 
   private static RedissonClient redissonClient;
 
   private RedisUtils(){}
 
   /**
    * 提供单例模式
    * @return
    */
   public static RedisUtils getInstance(){
      if(redisUtils==null) {
         synchronized (RedisUtils.class) {
            if(redisUtils==null){
               redisUtils=new RedisUtils();
            }
         }
      }
      return redisUtils;
   }
 
 
   /**
    * 使用config创建Redisson
    * Redisson是用于连接Redis Server的基础类
    * @param config
    * @return
    */
   public RedissonClient getRedisson(Config config){
      if(redissonClient==null){
         synchronized (RedisUtils.class) {
            if(redissonClient==null){
               redissonClient=Redisson.create(config);
            }
         }
      }
      return redissonClient;
   }
 
   /**
    * 使用ip地址和端口创建Redisson
    * @param ip
    * @param port
    * @return
    */
   public RedissonClient getRedisson(String ip,String port,String passwd){
 
      if(!ip.startsWith(&quot;http://&quot;)){
         ip = &quot;http://&quot;+ip;
      }
 
      logger.info(&quot;RedisUtils-getRedisson-传入参数-ip：&quot;+ip+&quot;-port:&quot;+port+&quot;-passwd:&quot;+passwd);
      Config config=new Config();
 
      SingleServerConfig singleServerConfig = config.useSingleServer();
 
      singleServerConfig.setAddress(ip+&quot;:&quot;+port).
              setTimeout(200000).
              setRetryAttempts(10).
              // .setIdleConnectionTimeout(10000)
                      setRetryInterval(2000).
              //.setFailedAttempts(20)
                      setSubscriptionsPerConnection(5).
              setSubscriptionConnectionPoolSize(10).
              setConnectionPoolSize(64).
              setDatabase(0);
 
      if(StringUtils.isNotBlank(passwd)){
         singleServerConfig.setPassword(passwd);
      }
 
      if(redissonClient==null){
         synchronized (RedisUtils.class) {
            if(redissonClient==null){
               redissonClient=Redisson.create(config);
            }
         }
      }
      return redissonClient;
   }
 
   /**
    * 关闭Redisson客户端连接
    * @param redisson
    */
   public void closeRedisson(RedissonClient redisson){
      redisson.shutdown();
   }
 
   /**
    * 获取字符串对象
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;T&gt; RBucket&lt;T&gt; getRBucket(RedissonClient redisson, String objectName){
      RBucket&lt;T&gt; bucket=redisson.getBucket(objectName);
      return bucket;
   }
 
   /**
    * 获取Map对象
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;K,V&gt; RMap&lt;K, V&gt; getRMap(RedissonClient redisson, String objectName){
      RMap&lt;K, V&gt; map=redisson.getMap(objectName);
      return map;
   }
 
   /**
    * 获取有序集合
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;V&gt; RSortedSet&lt;V&gt; getRSortedSet(RedissonClient redisson, String objectName){
      RSortedSet&lt;V&gt; sortedSet=redisson.getSortedSet(objectName);
      return sortedSet;
   }
 
   /**
    * 获取集合
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;V&gt; RSet&lt;V&gt; getRSet(RedissonClient redisson, String objectName){
      RSet&lt;V&gt; rSet=redisson.getSet(objectName);
      return rSet;
   }
 
   /**
    * 获取列表
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;V&gt; RList&lt;V&gt; getRList(RedissonClient redisson,String objectName){
      RList&lt;V&gt; rList=redisson.getList(objectName);
      return rList;
   }
 
   /**
    * 获取队列
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;V&gt; RQueue&lt;V&gt; getRQueue(RedissonClient redisson,String objectName){
      RQueue&lt;V&gt; rQueue=redisson.getQueue(objectName);
      return rQueue;
   }
 
   /**
    * 获取双端队列
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;V&gt; RDeque&lt;V&gt; getRDeque(RedissonClient redisson,String objectName){
      RDeque&lt;V&gt; rDeque=redisson.getDeque(objectName);
      return rDeque;
   }
 
   /**
    * 此方法不可用在Redisson 1.2 中 
    * 在1.2.2版本中 可用
    * @param redisson
    * @param objectName
    * @return
    */
   /**
    public &lt;V&gt; RBlockingQueue&lt;V&gt; getRBlockingQueue(RedissonClient redisson,String objectName){
    RBlockingQueue rb=redisson.getBlockingQueue(objectName);
    return rb;
    }*/
 
   /**
    * 获取锁
    * @param redisson
    * @param objectName
    * @return
    */
   public RLock getRLock(RedissonClient redisson,String objectName){
      RLock rLock=redisson.getLock(objectName);
      return rLock;
   }
 
   /**
    * 获取原子数
    * @param redisson
    * @param objectName
    * @return
    */
   public RAtomicLong getRAtomicLong(RedissonClient redisson,String objectName){
      RAtomicLong rAtomicLong=redisson.getAtomicLong(objectName);
      return rAtomicLong;
   }
 
   /**
    * 获取记数锁
    * @param redisson
    * @param objectName
    * @return
    */
   public RCountDownLatch getRCountDownLatch(RedissonClient redisson,String objectName){
      RCountDownLatch rCountDownLatch=redisson.getCountDownLatch(objectName);
      return rCountDownLatch;
   }
 
   /**
    * 获取消息的Topic
    * @param redisson
    * @param objectName
    * @return
    */
   public &lt;M&gt; RTopic&lt;M&gt; getRTopic(RedissonClient redisson,String objectName){
      RTopic&lt;M&gt; rTopic=redisson.getTopic(objectName);
      return rTopic;
   }
 
 
}
</code></pre>

<pre><code class="language-text">public void commitUserReq(HttpServletRequest request){
        final RedissonClient redisson = RedisUtils.getInstance().getRedisson(redisIp,redisPort,redisPasswd);
        // 防重复提交锁
        RLock lock = redisson.getLock(orderId + &quot;COMMIT_ORDER&quot; + userId);
        try {
            boolean res = lock.tryLock(0, 10, TimeUnit.SECONDS);
            if (!res){
                throw new SimpleMessageException(&quot;操作太频繁！&quot;);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 防止正在请求过程再发起请求
        boolean isBack = false;
        RLock lock2 = redisson.getLock(orderId + &quot;LOCK_BUTTON&quot; + userId);
        lock2.lock(10,TimeUnit.SECONDS);
        if (redisClient.exists(&quot;BUTTON_PAY_&quot;+ userId)){
            isBack = true;
        }else{
            redisClient.setObject(&quot;BUTTON_PAY_&quot;+ userId,borrowId,20*60);
        }
        lock2.unlock();
        if (isBack){
            logger.info(&quot;系统提交已经开始&quot;);
            throw new SimpleMessageException(&quot;你有请求正在处理，请20分钟后再试！&quot;);
        }
        System.out.println(&quot;处理业务代码==========正常执行&quot;);
        
        }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[十三、过期键的删除策略]]></title>
    <link href="http://www.throne4j.com/15952588914829.html"/>
    <updated>2020-07-20T23:28:11+08:00</updated>
    <id>http://www.throne4j.com/15952588914829.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">redis过期键删除策略</h2>

<p>一个键过期了，它什么时候被删除呢？</p>

<p>Redis 服务器采用惰性删除策略和定期删除两种策略，通过分配使用这两种删除策略，redis服务器可以很好的利用cpu时间和避免内存浪费之间取得一个较好的平衡</p>

<ul>
<li>定时删除:在设置键的过期时间的同时,创建一个定时器( timer),让定时器在键的过期时间来临时,立即执行对键的删除操作。</li>
<li>惰性删除:放任键过期不管,但是每次从键空间中获取健时,都检查取得的键是否过期,如果过期的话,就删除该键;如果没有过期,就返回该键。</li>
<li>定期删除:每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键。至于要删除多少过期键,以及要检査多少个数据库,则由算法决定。<br/>
在这三种策略中,第一种和第三种为主动删除策略,而第二种则为被动删除策略。</li>
</ul>

<h2 id="toc_1">定时删除策略</h2>

<p>定时删除策略，设置键过期时间的同时，创建定时器，让定时器在键的过期时间来来临时立即执行对键的删除操作。</p>

<p>优点是：可以保证过期键会尽可能快的被删除，并释放过期键所占用的内存，</p>

<p>但缺点也很明显：会占用一定的cpu时间，影响服务器的响应时间和吞吐量，</p>

<p>除此之外，创建定时器需要用到 redis 服务器的时间事件，而当前时间事件的实现方式是无序链表，查找一个时间的时间复杂度为 O(N)，并不能高效的处理大量的时间事件。</p>

<h2 id="toc_2">惰性删除策略</h2>

<p>惰性删除策略，访问数据库键时，校验该键是否过期，如果过期则删除</p>

<p>优点是：对cpu时间来说最友好，程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在费做不可的情况下进行，并且删除过期键的操作仅限当前处理的键，</p>

<p>但是此种策略非常占用内存，有内存泄漏的风险，已过期的键不会立马删除，占着内存直到下次访问时才会释放内存空间。</p>

<h2 id="toc_3">定期删除策略</h2>

<p>定期删除策略，周期性删除过期键，redisServer启动过程最后一步(开启事件循环，会触发Redis的定时任务的时间事件，查看 <a href="15934396305281.html">三、redis命令处理生命周期</a>) </p>

<ul>
<li>每个一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响</li>
<li>通过定期删除过期键，有效的减少了过期键带来的内存损耗。</li>
</ul>

<p>定期删除策略的难点是确定删除操作执行的时长和频率：</p>

<ul>
<li>如果删除操作执行得太频繁,或者执行的时间太长,定期删除策略就会退化成定时除策略,以至于将CPU时间过多地消耗在删除过期键上面。</li>
<li>如果删除操作执行得太少,或者执行的时间太短,定期删除策略又会和惰性删除策略一样,出现浪费内存的情况。</li>
</ul>

<h2 id="toc_4">AOF、RDB和复制功能对过期键的处理</h2>

<h3 id="toc_5">RDB 文件生成</h3>

<p>在执行SAⅣE命令或者 BGSAVE命令创建一个新的RDB文件时,程序会对数据库中的键进行检查,已过期的键不会被保存到新创建的RDB文件中。</p>

<h3 id="toc_6">载入RDB文件</h3>

<p>在启动 Redis服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行载人: </p>

<ul>
<li>如果服务器以主服务器模式运行,那么在载入RDB文件时,程序会对文件中保存的键进行检查,未过期的键会被载入到数据库中,而过期键则会被忽略,所以过期键对载入RDB文件的主服务器不会造成影响</li>
<li>如果服务器以从服务器模式运行,那么在载入RDB文件时,文件中保存的所有键, 不论是否过期,都会被载人到数据库中。不过,因为主从服务器在进行数据同步的时候,从服务器的数据库就会被清空,所以一般来讲,过期键对载人RDB文件的从服务器也不会造成影响。</li>
</ul>

<h3 id="toc_7">AOF 文件写入</h3>

<p>当服务器以AOF持久化模式运行时,如果数据库中的某个键已经过期,但它还没有被惰性删除或者定期删除,那么AOF文件不会因为这个过期键而产生任何影响。</p>

<p>当过期键被惰性删除或者定期删除之后, 程序会向AOF文件迫加( append)一条DEL 命令,来显式地记录该键已被删除。</p>

<p>举个例子,如果客户端使用 GET message命令,试图访向问过期的 message键,那么服务器将执行以下三个动作: </p>

<p>1)从数据库中删除 message键。<br/>
2)追加一条 DEL message命令到AOF文件。<br/>
3)向执行GET命令的客户端返回空回复。</p>

<p>和生成RDB文件时类似,在执行AOF重写的过程中,程序会对数据库中的键进行检査,已过期的键不会被保存到重写后的AOF文件中。</p>

<h2 id="toc_8">复制</h2>

<p>当服务器运行在复制模式下时,从服务器的过期键删除动作由主服务器控制</p>

<ul>
<li>主服务器在删除一个过期键之后,会显式地向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时,即使碰到过期键也不会将过期健删除,而是继续像处理未过期的键一样来处理过期键。</li>
<li>从服务器只有在接到主服务器发来的DEL命令之后,才会删除过期键。</li>
</ul>

<p>通过由主服务器来控制从服务器统一地删除过期键,可以保证主从服务器数据的一致性,也正是因为这个原因,当一个过期键仍然存在于主服务器的数据库时,这个过期键在从服务器里的复制品也会继续存在。</p>

<p>如果这时有客户端向从服务器发送命令 GET message,那么从服务器将发现 message 键已经过期,但从服务器并不会删除 message键,而是继续将 message键的值返回给客户端,就好像 message健并没有过期一样。</p>

<p>假设在此之后,有客户端向主服务器发送命令 GET message,那么主服务器将发现键message已经过期，主服务器会删除 message键,向客户端返回空回复,并向从服务器发送 DEL message命令。</p>

<p>从服务器在接收到主服务器发来的DEL message命令之后,也会从数据库中删除 message键,在这之后,主从服务器都不再保存过期键 message了。</p>

<h2 id="toc_9">总结</h2>

<p>Redis使用惰性删除和定期删除两种策略来删除过期的键:惰性删除策略只在碰到过期键时才进行删除操作,定期删除策略则每隔一段时间主动査找并删除过期键。</p>

<p>执行SAVE命令或者 BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</p>

<p>执行 BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</p>

<p>当一个过期键被删除之后,服务器会追加一条DEL命令到现有AOF文件的末尾, 显式地删除过期键。</p>

<p>当主服务器删除一个过期键之后,它会向所有从服务器发送一条DEL命令,显式地删除过期键。</p>

<p>从服务器即使发现过期键也不会自作主张地删除它,而是等待主节点发来DEL命令, 这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</p>

<p>当 Redis命令对数据库进行修改之后,服务器会根据配置向客户端发送数据库通知。</p>

]]></content>
  </entry>
  
</feed>
