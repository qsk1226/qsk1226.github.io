<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-04-23T01:35:56+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[CAS 无锁操作]]></title>
    <link href="http://www.throne4j.com/15874857577712.html"/>
    <updated>2020-04-22T00:15:57+08:00</updated>
    <id>http://www.throne4j.com/15874857577712.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TODO 细说JDK之 Future 模式]]></title>
    <link href="http://www.throne4j.com/15867858130748.html"/>
    <updated>2020-04-13T21:50:13+08:00</updated>
    <id>http://www.throne4j.com/15867858130748.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解java序列化]]></title>
    <link href="http://www.throne4j.com/java%E5%BA%8F%E5%88%97%E5%8C%96.html"/>
    <updated>2020-04-11T14:47:08+08:00</updated>
    <id>http://www.throne4j.com/java%E5%BA%8F%E5%88%97%E5%8C%96.html</id>
    <content type="html"><![CDATA[
<p>如果你只知道实现Serializable接口的对象，可以序列化为本地文件。那你最好再阅读该篇文章，文章对序列化进行了更深一步的讨论，用实际的例子代码讲述了序列化的高级认识，包括父类序列化的问题、静态变量问题、transient关键字的影响、序列化ID问题。在笔者实际开发过程中，就多次遇到序列化的问题，在该文章中也会与读者分享。</p>

<h2 id="toc_0">引言</h2>

<p>将Java对象序列化为二进制文件的Java序列化技术是Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与Java序列化相关，通过分析情境出现的原因，使读者轻松牢记<br/>
Java 序列化中的一些高级认识。</p>

<h2 id="toc_1">序列化 ID 问题</h2>

<ul>
<li><p><strong>情境</strong>：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C序列化为二进制数据再传给 B，B 反序列化得到 C。</p></li>
<li><p><strong>问题</strong>：C 对象的全类路径假设为 com.inout.Test，在 A 和 B端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable接口，但是反序列化时总是提示不成功。</p></li>
<li><p><strong>解决</strong>：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p></li>
</ul>

<pre><code class="language-text">package com.inout; 
import java.io.Serializable; 
public class A implements Serializable { 

    private static final long serialVersionUID = 1L; 
    private String name; public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
    }
}

package com.inout;
import java.io.Serializable;
public class A implements Serializable {
    private static final long serialVersionUID = 2L;
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
} 
</code></pre>

<p>序列化ID在Eclipse下提供了两种生成策略，一个是固定的1L，一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。</p>

<h3 id="toc_2">特性使用案例</h3>

<p>　　读者应该听过Façade模式，它是为应用程序提供统一的访问接口，案例程序中的Client客户端使用了该模式，案例程序结构图如图1所示。<br/>
<img src="media/15865876286788/image.png" alt="image"/></p>

<p>　　Client端通过FaçadeObject才可以与业务逻辑对象进行交互。而客户端的FaçadeObject不能直接由Client生成，而是需要Server端生成，然后序列化后通过网络将二进制对象数据传给Client，Client负责反序列化得到Façade对象。该模式可以使得Client端程序的使用需要服务器端的许可,同时Client端和服务器端的FaçadeObject类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的FaçadeObject类的序列化ID再次生成，当Client端反序列化FaçadeObject就会失败，也就是强制Client端从服务器端获取最新程序。</p>

<h2 id="toc_3">静态变量序列化</h2>

<ul>
<li><strong>情境</strong>：查看清单 2 的代码。</li>
</ul>

<p>清单 2. 静态变量序列化问题代码</p>

<pre><code class="language-text">public class Test implements Serializable {
    private static final long serialVersionUID = 1L;
    public static int staticVar = 5;
    public static void main(String[] args) {
        try {
            //初始时staticVar为5
            ObjectOutputStream out = new ObjectOutputStream(
                    new FileOutputStream(&quot;result.obj&quot;));
            out.writeObject(new Test());
            out.close();

            //序列化后修改为10
            Test.staticVar = 10;
 
            ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
            Test t = (Test) oin.readObject();
            oin.close();
             
            //再读取，通过t.staticVar打印新的值
            System.out.println(t.staticVar);
             
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>　　清单2中的main方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单2，这个System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？最后的输出是10，对于无法理解的读者认为，打印的 staticVar是从读取的对象里获得的，应该是保存时的状态才对。之所以打印10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。</p>

<h2 id="toc_4">父类的序列化与 Transient 关键字</h2>

<ul>
<li><p><strong>情境</strong>：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p></li>
<li><p><strong>解决</strong>：要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p></li>
</ul>

<p>　　Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int 型的是 0，对象型的是 null。</p>

<h3 id="toc_5">特性使用案例</h3>

<p>　　我们熟悉使用Transient关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</p>

<p><img src="media/15865876286788/%E6%A1%88%E4%BE%8B%E7%A8%8B%E5%BA%8F%E5%9B%BE.png" alt="案例程序图"/></p>

<p>　　上图中可以看出，attr1、attr2、attr3、attr5都不会被序列化，放在父类中的好处在于当有另外一个Child类时，attr1、attr2、attr3依然不会被序列化，不用重复抒写transient，代码简洁。</p>

<h2 id="toc_6">对敏感字段加密</h2>

<ul>
<li><strong>情境</strong>：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
<li><strong>解决</strong>：在序列化过程中，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单3展示了这个过程。</li>
</ul>

<pre><code class="language-text">private static final long serialVersionUID = 1L;
private String password = &quot;pass&quot;;
public String getPassword() {
    return password;
}
public void setPassword(String password) {
    this.password = password;
}

private void writeObject(ObjectOutputStream out) {
    try {
        PutField putFields = out.putFields();
        System.out.println(&quot;原密码:&quot; + password);
        password = &quot;encryption&quot;;//模拟加密
        putFields.put(&quot;password&quot;, password);
        System.out.println(&quot;加密后的密码&quot; + password);
        out.writeFields();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void readObject(ObjectInputStream in) {
    try {
        GetField readFields = in.readFields();
        Object object = readFields.get(&quot;password&quot;, &quot;&quot;);
        System.out.println(&quot;要解密的字符串:&quot; + object.toString());
        password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    try {
        ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream(&quot;result.obj&quot;));
        out.writeObject(new Test());
        out.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                &quot;result.obj&quot;));
        Test t = (Test) oin.readObject();
        System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());
        oin.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}  
</code></pre>

<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对<br/>
password进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单<br/>
3后控制台输出如图 3 所示:</p>

<p><img src="/qsk/java/understand_java_serial/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/><img src="media/15865876286788/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/></p>

<h3 id="toc_7">特性使用案例</h3>

<p>　　RMI 技术是完全基于 Java序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及RMI的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>

<h3 id="toc_8">序列化存储规则</h3>

<pre><code class="language-text">ObjectOutputStream out = new ObjectOutputStream(
                   new FileOutputStream(&quot;result.obj&quot;));
   Test test = new Test();
   //试图将对象两次写入文件
   out.writeObject(test);
   out.flush();
   System.out.println(new File(&quot;result.obj&quot;).length());
   out.writeObject(test);
   out.close();
   System.out.println(new File(&quot;result.obj&quot;).length());

   ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
           &quot;result.obj&quot;));
   //从文件依次读出两个文件
   Test t1 = (Test) oin.readObject();
   Test t2 = (Test) oin.readObject();
   oin.close();

   //判断两个引用是否指向同一个对象
   System.out.println(t1 == t2);
</code></pre>

<p>　　清单 3中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入false 才对，但是最后结果输出如图 4 所示。</p>

<p><img src="/qsk/java/understand_java_serial/image.png" alt="image"/><img src="media/15865876286788/image.png" alt="image"/></p>

<p>　　我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？</p>

<ul>
<li><strong>解答</strong>：Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</li>
</ul>

<h3 id="toc_9">特性案例分析</h3>

<pre><code class="language-text">
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));
Test test = new Test();
test.i = 1;
out.writeObject(test);
out.flush();
test.i = 2;
out.writeObject(test);
out.close();
ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
Test t1 = (Test) oin.readObject();
Test t2 = (Test) oin.readObject();
System.out.println(t1.i);
System.out.println(t2.i);
</code></pre>

<p>　　清单 4 的目的是希望将 test 对象两次保存到result.obj文件中，写入一次以后修改对象属性值再次保存第二次，然后从result.obj中再依次读出两个对象，输出这两个对象的i属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。结果两个输出的都是 1，原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次writeObject 需要特别注意这个问题。</p>

<h2 id="toc_10">小结</h2>

<p>本文通过几个具体的情景，介绍了Java序列化的一些高级知识，虽说高级，并不是说读者们都不了解，希望用笔者介绍的情景让读者加深印象，能够更加合理的利用Java序列化技术，在未来开发之路上遇到序列化问题时，可以及时的解决。由于本人知识水平有限，文章中倘若有错误的地方，欢迎联系我批评指正。</p>

<h1 id="toc_11">转载自  <a href="https://www.cnblogs.com/wxgblogs/p/5849951.html">读书使人进步</a></h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kubenetes 在 CentOS 7 上的安装]]></title>
    <link href="http://www.throne4j.com/15856577150075.html"/>
    <updated>2020-03-31T20:28:35+08:00</updated>
    <id>http://www.throne4j.com/15856577150075.html</id>
    <content type="html"><![CDATA[
<p>swapoff -a 关闭<br/>
getenforce 关闭<br/>
vim /etc/sysconfig/selinux 关闭</p>

<p>vim /proc/sys/net/ipv4/ip_forward   ---&gt;1  开启</p>

<p>Docker <br/>
kubeadm<br/>
kubelet<br/>
kubectl<br/>
kube-flannel</p>

<pre><code class="language-text">kubeadm join 172.16.65.134:6443 --token jw3hog.3eoi736vivuje486     --discovery-token-ca-cert-hash sha256:4ff0b56297567aa67ef7511927fa39c6af8654c6709b444182b839f1e0449149
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker.  swarm]]></title>
    <link href="http://www.throne4j.com/15856442943422.html"/>
    <updated>2020-03-31T16:44:54+08:00</updated>
    <id>http://www.throne4j.com/15856442943422.html</id>
    <content type="html"><![CDATA[
<p>swarm: 一组 docker 引擎的集群<br/>
node: 单个 docker 引擎的实例，可以在一个物理机上，也可以在多个物理机上<br/>
application: 应用<br/>
Manager Node : 部署应用的时候会有一个 manager node 节点<br/>
Worker Nodes: <br/>
Service: 一堆被 worker 执行的任务<br/>
replicated services: 负载均衡节点<br/>
global service： 在所有节点上都会执行的一个服务<br/>
task： 一个 task 就是一台 docker 容器，是 swarm 的工作单元</p>

<p>sodcker swarm init --advertise-addr   manager_ip</p>

<p>/lib/systemd/system/docker.service</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker-compose]]></title>
    <link href="http://www.throne4j.com/15856304975372.html"/>
    <updated>2020-03-31T12:54:57+08:00</updated>
    <id>http://www.throne4j.com/15856304975372.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-text"> curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
</code></pre>

<p>uname -m   ---&gt;  x86_64</p>

<p><img src="media/15856304975372/15856400125972.jpg" alt="" style="width:657px;"/></p>

<p>version: &#39;3&#39;：   表示使用第三代语法<br/>
services:  表示 compose 需要启动的服务<br/>
container_name: 容器名称<br/>
environment:  容器环境变量<br/>
ports:  对外开放的端口<br/>
restart: always  如果服务启动不成功一直尝试。<br/>
volumes:  加载本地目录到容器目标路径<br/>
depends_on： 依赖服务，先启动 depends_on 服务<br/>
command: mvn clean spring-boot:run :  表示以这个命令来启动项目</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerfile]]></title>
    <link href="http://www.throne4j.com/15855754851859.html"/>
    <updated>2020-03-30T21:38:05+08:00</updated>
    <id>http://www.throne4j.com/15855754851859.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">FROM 指定基础镜像</h2>

<h2 id="toc_1">RUN</h2>

<ul>
<li><p>shell 格式：<br/>
RUN &lt;命令行命令&gt;<br/>
&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</p></li>
<li><p>exec 格式： RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br/>
例如： RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</p></li>
</ul>

<h2 id="toc_2">CMD 执行命令</h2>

<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>

<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。<br/>
作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li>
</ul>

<p>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>

<p>格式：</p>

<pre><code class="language-text">CMD &lt;shell 命令&gt; 
CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供
默认参数
</code></pre>

<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh</p>

<h2 id="toc_3">ADD 复制指定的文件到容器中（压缩包会自动解压）</h2>

<h2 id="toc_4">COPY 复制</h2>

<p>复制指令，同 ADD 从上下文目录中复制文件或者目录到容器里指定路径。<br/>
格式：</p>

<pre><code class="language-text">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]
</code></pre>

<p>[--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>

<p>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>

<pre><code class="language-text">COPY hom* /mydir/
COPY hom?.txt /mydir/
</code></pre>

<h2 id="toc_5">WORKDIR 指定工作空间</h2>

<p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>

<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>

<h2 id="toc_6">VOLUME 为容器创建一个本地主机或其他容器的挂载点</h2>

<h2 id="toc_7">EXPOSE 容器需要暴露的端口</h2>

<h2 id="toc_8">USER 指定运行容器时的用户名，后续的 RUN 也会指定该用户</h2>

<h2 id="toc_9">ENTRYPOINT</h2>

<p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>

<p>但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>

<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>

<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>

<p>格式：</p>

<p>ENTRYPOINT [&quot;<executeable>&quot;,&quot;<param1>&quot;,&quot;<param2>&quot;,...]<br/>
可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>

<p>示例：</p>

<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>

<p>FROM nginx</p>

<p>ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参<br/>
CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 <br/>
1、不传参运行</p>

<p>$ docker run  nginx:test<br/>
容器内会默认运行以下命令，启动主进程。</p>

<p>nginx -c /etc/nginx/nginx.conf<br/>
2、传参运行</p>

<p>$ docker run  nginx:test -c /etc/nginx/new.conf<br/>
容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>

<p>nginx -c /etc/nginx/new.conf</p>

<h2 id="toc_10">ENV 环境变量</h2>

<p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>

<p>格式：</p>

<p>ENV <key> <value><br/>
ENV <key1>=<value1> <key2>=<value2>...<br/>
以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>

<p>ENV NODE_VERSION 7.2.0</p>

<p>RUN curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz</a>&quot; \<br/>
  &amp;&amp; curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc</a>&quot;</p>

<h2 id="toc_11">MAINTAINER 维护者信息</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux 普通用户添加 sudo 免密码执行权限]]></title>
    <link href="http://www.throne4j.com/sudo%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C.html"/>
    <updated>2020-03-30T02:40:49+08:00</updated>
    <id>http://www.throne4j.com/sudo%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C.html</id>
    <content type="html"><![CDATA[
<p>在使用普通用户登录的时候，会经常使用sudo指令执行一些操作，有时候感觉输入密码比较繁琐，特别是需要设置一些开机启动的时候操作，而这些操作往往就需要sudo指令，如果没有免密的话，在使用普通用户登录的时候就无法执行，这个时候给普通用户添加免密码sudo功能就非常的必要了  </p>

<p>注意：sudo面密码只是在执行sudo指令的时候不需要输入密码，并不是普通用户拥有超级用户的权限，需要root才有的权限不加sudo 一样执行不了 ，所以这一点也保证了使用免密码的安全性 ，只是在使用sudo的时候不需要输入密码</p>

<p>很简单，在命令行输入：</p>

<p>sudo vim /etc/sudoers  </p>

<p>在代码的最后加上：</p>

<p>yourusername   ALL=(ALL)NOPASSWD:ALL      </p>

<p>username是指定的普通用户名称，这样就是保证在指定用户使用sudo的时候不需要输入密码，如果想给执行命令添加免密而已，只需要把最后的ALL替换为命令的绝对路径即可，</p>

<p>如下：</p>

<p>username   ALL=(ALL)NOPASSWD:/bin/hello</p>

<p>这样就为指定用户在执行/bin目录下的hello目录的时候 不需输入密码</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker 命令]]></title>
    <link href="http://www.throne4j.com/15855064473314.html"/>
    <updated>2020-03-30T02:27:27+08:00</updated>
    <id>http://www.throne4j.com/15855064473314.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">容器生命周期管理</h2>

<ul>
<li>run  创建一个新的容器并运行一个命令</li>
</ul>

<p>eg: docker run -d --name nginx -p 80:80 -v /docker/nginx:/etc/nginx/conf.d nginx:latest </p>

<p>说明： 使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/docker/nginx/conf.d 映射到容器的 /etc/nginx/conf.d</p>

<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</p>

<pre><code class="language-text">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-P: 随机端口映射，容器内部端口随机映射到主机的高端口
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h &quot;mars&quot;: 指定容器的hostname；
-e username=&quot;ritchie&quot;: 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；
--volume , -v: 绑定一个卷
</code></pre>

<p>注意： 关于容器的输出以及配置的文件一定要挂载到宿主机上<br/>
配置文件<br/>
日志文件<br/>
业务数据</p>

<p>数据卷容器：<br/>
创建数据卷容器 data<br/>
docker run -d --name data -v /home/godson/docker/nginx/conf.d:/etc/nginx/conf.d -v /home/godson/docker/mysql/conf:/etc/mysql hello-world</p>

<p>创建容器挂载到 data 容器数据卷上 (volumes-from参数)<br/>
docker run -d --name nginx -p 80:80 --volumes-from data nginx</p>

<ul>
<li>start/stop/restart</li>
</ul>

<pre><code class="language-text">start： 启动一个或多个已被停止的容器
stop： 停止一个或多个运行中的容器
restart: 重启一个或多个容器
</code></pre>

<ul>
<li><p>kill 杀掉一个运行中的容器</p></li>
<li><p>rm 删除一个或多个容器</p></li>
</ul>

<pre><code class="language-text">-f :通过SIGKILL信号强制删除一个运行中的容器
-l :移除容器间的网络连接，而非容器本身
-v :-v 删除与容器关联的卷
</code></pre>

<ul>
<li><p>docker rm -fv 删除容器服务</p></li>
<li><p>pause/unpause  暂停/恢复 容器中的所有进程</p></li>
<li><p>create 创建一个新容器，但是不启动它<br/>
语法同 run</p></li>
<li><p>exec</p></li>
</ul>

<pre><code class="language-text">&gt; docker exec -it nginx /bin/bash
-d :分离模式: 在后台运行
-i :即使没有附加也保持STDIN 打开
-t :分配一个伪终端
</code></pre>

<h2 id="toc_1">容器操作</h2>

<ul>
<li>ps  列出容器</li>
</ul>

<pre><code class="language-text">-a :显示所有的容器，包括未运行的。
-f :根据条件过滤显示的内容。
--format :指定返回值的模板文件。
-l :显示最近创建的容器。
-n :列出最近创建的n个容器。
--no-trunc :不截断输出。
-q :静默模式，只显示容器编号。
-s :显示总的文件大小。
</code></pre>

<ul>
<li>inspect 获取容器/镜像的元数据。<br/>
docker inspect -f &#39;{{.NetworkSettings.IPAddress}}&#39; nginx</li>
</ul>

<pre><code class="language-text">-f :指定返回值的模板文件。
-s :显示总的文件大小。
--type :为指定类型返回JSON。
</code></pre>

<ul>
<li>top</li>
<li>attach</li>
<li>events</li>
<li>logs</li>
</ul>

<pre><code class="language-text">-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail :仅列出最新N条容器日志
</code></pre>

<ul>
<li>wait</li>
<li>export</li>
<li>port  列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</li>
</ul>

<pre><code class="language-text">&gt; docker port nginx
80/tcp -&gt; 0.0.0.0:8080
</code></pre>

<h2 id="toc_2">容器rootfs命令</h2>

<ul>
<li>commit  从容器创建一个新的镜像。<br/>
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br/>
docker commit -a &quot;作者&quot; -m &quot;描述&quot; nginx  mynginx:v1</li>
<li>cp<br/>
容器和宿主机的文件传输 nginx:表示了容器目录<br/>
docker cp nginx:/etc/nginx/conf.ddefault.conf ./</li>
<li>diff</li>
</ul>

<h2 id="toc_3">镜像仓库</h2>

<ul>
<li>login</li>
<li>pull</li>
<li>push</li>
<li>search</li>
</ul>

<h2 id="toc_4">本地镜像管理</h2>

<ul>
<li>images  列出本地镜像。</li>
</ul>

<pre><code class="language-text">-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；
--digests :显示镜像的摘要信息；
-f :显示满足条件的镜像；
--format :指定返回值的模板文件；
--no-trunc :显示完整的镜像信息；
-q :只显示镜像ID。
</code></pre>

<ul>
<li>rmi</li>
<li>tag  标记本地镜像，将其归入某一仓库。</li>
</ul>

<pre><code class="language-text">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]

将镜像ubuntu:15.10标记为 w3cschool/ubuntu:v3 镜像

docker tag nginx w3cschool/ubuntu:v3
</code></pre>

<ul>
<li>build   使用Dockerfile创建镜像。</li>
</ul>

<pre><code class="language-text">&gt; docker build -t w3cschool/ubuntu:v1 ./
&gt; docker build -f /home/user/Dockerfile ./

--build-arg=[] :设置镜像创建时的变量；
--cpu-shares :设置 cpu 使用权重；
--cpu-period :限制 CPU CFS周期；
--cpu-quota :限制 CPU CFS配额；
--cpuset-cpus :指定使用的CPU id；
--cpuset-mems :指定使用的内存 id；
--disable-content-trust :忽略校验，默认开启；
-f :指定要使用的Dockerfile路径； -f /path/to/a/Dockerfile .
--force-rm :设置镜像过程中删除中间容器；
--isolation :使用容器隔离技术；
--label=[] :设置镜像使用的元数据；
-m :设置内存最大值；
--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；
--no-cache :创建镜像的过程不使用缓存；
--pull :尝试去更新镜像的新版本；
-q :安静模式，成功后只输出镜像ID；
--rm :设置镜像成功后删除中间容器；
--shm-size :设置/dev/shm的大小，默认值是64M；
--ulimit :Ulimit配置。
--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
--network: 默认 default。在构建期间设置RUN指令的网络模式
</code></pre>

<p>history<br/>
save<br/>
import</p>

<h2 id="toc_5">info|version</h2>

<p>info<br/>
version</p>

<p>获取 selinux 是否关闭<br/>
getenforce<br/>
暂时关闭<br/>
setenforce 1</p>

<p>vi /etc/sysconfig/selinux</p>

<p><img src="media/15855064473314/15855732599905.jpg" alt="" style="width:620px;"/></p>

<p>SELINUX=disable</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac vmware fusion 设置静态 IP 地址]]></title>
    <link href="http://www.throne4j.com/vm_fusion.html"/>
    <updated>2020-03-30T00:59:39+08:00</updated>
    <id>http://www.throne4j.com/vm_fusion.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">配置静态IP</h2>

<h3 id="toc_1">把网络配置改成nat模式</h3>

<h3 id="toc_2">通过Mac终端进入VMware Fusion的vmnet8目录</h3>

<pre><code class="language-text">cd /Library/Preferences/VMware Fusion/vmnet8
</code></pre>

<ul>
<li>查看nat.conf内容</li>
</ul>

<p><img src="media/15855011797141/15855038592835.jpg" alt=""/></p>

<ul>
<li>查看cat dhcpd.conf</li>
</ul>

<p><img src="media/15855011797141/15855037846968.jpg" alt=""/></p>

<p>注意range 这个是虚拟机允许选择的静态ip地址范围，自定义的静态ip地址必须要在这个范围内</p>

<h3 id="toc_3">登录虚拟机 CentOS7</h3>

<p>进入虚拟机的network-scripts目录</p>

<pre><code class="language-text">cd /etc/sysconfig/network-scripts
</code></pre>

<p>找到ifcfg-en开头的文件,上图中我的是ifcfg-ens33<br/>
修改前：</p>

<pre><code class="language-text">&gt; cd /etc/sysconfig/network-scripts
&gt; vim ifcfg-ens33

TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
</code></pre>

<p>我们将它改成如下配置:</p>

<pre><code class="language-text">TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=no
IPV6_DEFROUTE=no
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
IPADDR=172.16.65.134
GATEWAY=172.16.65.2
NETMASK=255.255.255.0
DNS1=114.114.114.114
</code></pre>

<p>保存之后，重启服务使修改生效</p>

<p>service network restart<br/>
ping一下百度看看，成功Ping到</p>

<p>接下来我们就可以通过SecureCRT等工具远程连接了，有一点请记住，如果你换了一个地方上网的话，可能会发现你的虚拟机有不通了，那是因为DNS地址发生了变化，此时只需要再次编辑ifcfg-enxxx文件，然后加上你现在网络的DNS地址即可</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 7 主机名的修改]]></title>
    <link href="http://www.throne4j.com/hostnamectl.html"/>
    <updated>2020-03-30T00:32:37+08:00</updated>
    <id>http://www.throne4j.com/hostnamectl.html</id>
    <content type="html"><![CDATA[
<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如godson）。</p>

<p>在CentOS 7中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>

<ol>
<li>要查看主机名相关的设置：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl 
   Static hostname: localhost.localdomain
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 50565701419746a08905ba05b882cd40
           Boot ID: a599742730414a448408e1d7a9bbf9d3
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-957.el7.x86_64
      Architecture: x86-64
</code></pre>

<ol>
<li>只查看静态、瞬态或灵活主机名，分别使用“--static”，“--transient”或“--pretty”选项。</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl --static
localhost.localdomain
[[godson@localhost ~]$ hostnamectl --transient
localhost.localdomain
[godson@localhost ~]$ hostnamectl --pretty
</code></pre>

<ol>
<li>要同时修改所有三个主机名：静态、瞬态和灵活主机名：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ se
[godson@localhost ~]$ hostnamectl --pretty
godson
[godson@localhost ~]$ hostnamectl --static
godson
[godson@localhost ~]$ hostnamectl --transient
godson
</code></pre>

<p>就像上面展示的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。一旦修改了静态主机名，/etc/hostname 将被自动更新。然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS 7。否则系统再启动时会很慢。</p>

<ol>
<li>手动更新/etc/hosts</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ vim /etc/hosts
127.0.0.1      godson
#127.0.0.1  localhost localhost.localdomain localhost4 localhost4.localdomain
::1        localhost localhost.localdomain localhost6 localhost6.localdomain
</code></pre>

<ol>
<li>重启CentOS 7 之后</li>
</ol>

<pre><code class="language-text">[godson@godson ~]# hostname
godson
[godson@godson ~]# hostnamectl --transient
godson
[godson@godson ~]# hostnamectl --static
godson
[godson@godson ~]# hostnamectl --pretty
godson
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ssh 免密登录服务器]]></title>
    <link href="http://www.throne4j.com/SSH.html"/>
    <updated>2020-03-30T00:02:55+08:00</updated>
    <id>http://www.throne4j.com/SSH.html</id>
    <content type="html"><![CDATA[
<p>现在有服务器 Server-A,用户名: jetty, ip: 172.16.65.133, 现在希望从本地能够免密访问 Server-A。<br/>
这里我们需要 ssh-keygen 命令来帮我们完成这项任务。</p>

<p>ssh-keygen: 为了让两个linux机器之间使用ssh不需要用户名和密码。<br/>
采用了数字签名RSA或者DSA来完成这个操作。</p>

<h2 id="toc_0">生成本地公钥和私钥</h2>

<pre><code class="language-text">&gt; ssh-keygen -t rsa -C &#39;注释&#39;
</code></pre>

<p>本地机器 .ssh 目录下生成文件 :  id_rsa  id_rsa.pub</p>

<h2 id="toc_1">将本地生成的id_rsa.pub(公钥)追加到 Server-A 的目录~/.ssh/authorized_keys文件中</h2>

<pre><code class="language-text">&gt; ssh-copyid jetty@172.16.65.133
</code></pre>

<p>上传文件方式：</p>

<ul>
<li>cat ~/.ssh/id_rsa.pub | ssh -p 22 jetty@172.16.65.133 &#39;cat &gt;&gt; ~/.ssh/authorized_keys&#39;</li>
<li>ssh-copyid jetty@172.16.65.133</li>
<li>scp -P 22 ~/.ssh/id_rsa.pub jetty@172.16.65.133:~/。<br/>
注意： Server-A 服务器上.ssh 目录的权限为700，其下文件authorized_keys和私钥的权限为600。否则会因为权限问题导致无法免密码登录。</li>
</ul>

<p>上面步骤做完之后我们就可以免密登录 Server-A 了</p>

<pre><code class="language-text">&gt; ssh jetty@172.16.65.133
Last login: Sun Mar 29 12:17:53 2020 from 172.16.65.1
-bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory
&gt; [jetty@jetty ~]$ 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初见 Docker]]></title>
    <link href="http://www.throne4j.com/15854879924872.html"/>
    <updated>2020-03-29T21:19:52+08:00</updated>
    <id>http://www.throne4j.com/15854879924872.html</id>
    <content type="html"><![CDATA[
<p>Docker官方网址: <a href="https://docs.docker.com/">https://docs.docker.com/</a> 英文地址<br/>
Docker中文网址: <a href="http://www.docker.org.cn/">http://www.docker.org.cn/</a> 中文地址</p>

<h2 id="toc_0">docker 架构</h2>

<p>Images </p>

<p>Container</p>

<p>Client</p>

<p>Host</p>

<p>Registry</p>

<p>Machine</p>

<h2 id="toc_1">docker 组件</h2>

<ol>
<li><p>镜像 image<br/>
Docker运行容器之前需要本地存在对应的镜像。镜像是用来创建Docker容器的。一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序，在Docker Hub里面有大量现成的镜像提供下载，Docker的镜像是只读的，一个镜像可以创建多个容器。</p></li>
<li><p>容器 Container<br/>
Docker利用容器来进行开发，运行应用。容器是镜像创建的实列，它可以启动，开始，停止，删除，每个容器都是相互隔离的，保证安全的平台。</p></li>
<li><p>仓库 Repository<br/>
仓库是集中存放镜像文件的地方。每个仓库中又包含了多个镜像，每个镜像有不同的标签(TAG)</p></li>
</ol>

<h2 id="toc_2">docker 安装</h2>

<p>1、删除 Linux 机器上已存在的 docker 程序</p>

<pre><code class="language-text">&gt; sudo yum list installed | grep docker
&gt; sudo yum  -y remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
</code></pre>

<p>删除 docker 老的镜像</p>

<pre><code class="language-text">&gt; rm -rf /var/lib/docker
</code></pre>

<p>2、安装 docker 程序</p>

<ul>
<li>安装基本的系统工具<br/>
sudo yum install -y yum-utils device-mapper-persistent-data lvm2</li>
<li><p>配置 yum 源<br/>
yum-config-manager --add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></li>
<li><p>查看可安装的 docker 版本<br/>
yum list docker-ce --showduplicates | sort -r</p></li>
<li><p>安装 docker</p></li>
</ul>

<pre><code class="language-text">sudo yum install docker-ce(最新版)

sudo yum install -y containerd.io-1.2.13-3.1.el7 docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9-3.el7(指定版本)
</code></pre>

<ul>
<li><p>配置 docker 开机启动<br/>
sudo systemctl start docker<br/>
sudo systemctl enable docker</p></li>
<li><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)<br/>
docker version</p></li>
<li><p>更换 docker 镜像仓库为国内仓库<br/>
修改或创建daemon.json文件：<br/>
vim /etc/docker/daemon.json<br/>
内容如下：<br/>
{<br/>
&quot;registry-mirrors&quot;:[&quot;<a href="https://registry.docker-cn.com%22">https://registry.docker-cn.com&quot;</a>]<br/>
}</p></li>
<li><p>加载 daemon.json 文件<br/>
sudo systemctl daemon-reload</p></li>
<li><p>重启 docker<br/>
systemctl restart docker</p></li>
<li><p>验证 docker 是否完成安装<br/>
执行 sudo docker verxion,完成安装如下图所示<br/>
<img src="media/15854879924872/15855354770652.jpg" alt="" style="width:484px;"/></p></li>
</ul>

<p>用非 root 账户安装完 docker 之后会,执行 docker 命令会遇到这样一个问题：</p>

<pre><code class="language-text">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied
</code></pre>

<p>原因： docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p>

<p>解决方法：</p>

<pre><code class="language-text">&gt; sudo groupadd docker     #添加docker用户组
&gt; sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中
&gt; newgrp docker     #更新用户组
&gt; docker ps    #测试docker命令是否可以使用sudo正常使用
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说Reactor模式]]></title>
    <link href="http://www.throne4j.com/15586898110083.html"/>
    <updated>2019-05-24T17:23:31+08:00</updated>
    <id>http://www.throne4j.com/15586898110083.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概念</h2>

<p>reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，其他框架都或多或少地用到了Reactor框架。 </p>

<p>在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 </p>

<p>reactor模式与外观模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>

<h2 id="toc_1">优点</h2>

<p>  1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的； <br/>
  2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； <br/>
  3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； <br/>
  4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>

<h2 id="toc_2">缺点</h2>

<p> 1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 <br/>
 2）Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 <br/>
 3） Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。<br/>
 </p>

<h2 id="toc_3">架构模式</h2>

<h3 id="toc_4">1、架构图</h3>

<p> <img src="media/15586898110083/15590230630201.jpg" alt="" style="width:556px;"/></p>

<h3 id="toc_5">2、构成</h3>

<p>Handles ：表示操作系统管理的资源，我们可以理解为fd。</p>

<p>Synchronous Event Demultiplexer ：同步事件分离器，阻塞等待Handles中的事件发生。</p>

<p>Initiation Dispatcher ：初始分派器，作用为添加Event handler（事件处理器）、删除Event handler以及分派事件给Event handler。也就是说，Synchronous Event Demultiplexer负责等待新事件发生，事件发生时通知Initiation Dispatcher，然后Initiation Dispatcher调用event handler处理事件。</p>

<p>Event Handler ：事件处理器的接口<br/>
Concrete Event Handler ：事件处理器的实际实现，而且绑定了一个Handle。因为在实际情况中，我们往往不止一种事件处理器，因此这里将事件处理器接口和实现分开，与C++、Java这些高级语言中的多态类似。</p>

<h3 id="toc_6">3、模块交互</h3>

<p> 1）我们注册Concrete Event Handler到Initiation Dispatcher中。 <br/>
 2）Initiation Dispatcher调用每个Event Handler的get_handle接口获取其绑定的Handle。 <br/>
 3）Initiation Dispatcher调用handle_events开始事件处理循环。在这里，Initiation Dispatcher会将步骤2获取的所有Handle都收集起来，使用Synchronous Event Demultiplexer来等待这些Handle的事件发生。 <br/>
 4）当某个（或某几个）Handle的事件发生时，Synchronous Event Demultiplexer通知Initiation Dispatcher。 <br/>
 5）Initiation Dispatcher根据发生事件的Handle找出所对应的Handler。 <br/>
 6）Initiation Dispatcher调用Handler的handle_event方法处理事件。</p>

<pre><code class="language-text">import java.io.IOException;  
import java.net.InetAddress;  
import java.net.InetSocketAddress;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.ServerSocketChannel;  
import java.util.Iterator;  
import java.util.Set;  

/** 
 * 反应器模式 
 * 用于解决多用户访问并发问题 
 *  
 * 举个例子：餐厅服务问题 
 *  
 * 传统线程池做法：来一个客人(请求)去一个服务员(线程) 
 * 反应器模式做法：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员” 
 *  
 * @author linxcool 
 */  
public class Reactor implements Runnable{  
    public final Selector selector;  
    public final ServerSocketChannel serverSocketChannel;  

    public Reactor(int port) throws IOException{  
        selector=Selector.open();  
        serverSocketChannel=ServerSocketChannel.open();  
        InetSocketAddress inetSocketAddress=new InetSocketAddress(InetAddress.getLocalHost(),port);  
        serverSocketChannel.socket().bind(inetSocketAddress);  
        serverSocketChannel.configureBlocking(false);  

        //向selector注册该channel    
        SelectionKey selectionKey=serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);  

        //利用selectionKey的attache功能绑定Acceptor 如果有事情，触发Acceptor   
        selectionKey.attach(new Acceptor(this));  
    }  

    @Override  
    public void run() {  
        try {  
            while(!Thread.interrupted()){  
                selector.select();  
                Set&lt;SelectionKey&gt; selectionKeys= selector.selectedKeys();  
                Iterator&lt;SelectionKey&gt; it=selectionKeys.iterator();  
                //Selector如果发现channel有OP_ACCEPT或READ事件发生，下列遍历就会进行。  
                while(it.hasNext()){  
                    //来一个事件 第一次触发一个accepter线程    
                    //以后触发SocketReadHandler  
                    SelectionKey selectionKey=it.next();  
                    dispatch(selectionKey);  
                    selectionKeys.clear();  
                }  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 运行Acceptor或SocketReadHandler 
     * @param key 
     */  
    void dispatch(SelectionKey key) {  
        Runnable r = (Runnable)(key.attachment());    
        if (r != null){    
            r.run();  
        }    
    }    

} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.channels.SocketChannel;  

public class Acceptor implements Runnable{  
    private Reactor reactor;  
    public Acceptor(Reactor reactor){  
        this.reactor=reactor;  
    }  
    @Override  
    public void run() {  
        try {  
            SocketChannel socketChannel=reactor.serverSocketChannel.accept();  
            if(socketChannel!=null)//调用Handler来处理channel  
                new SocketReadHandler(reactor.selector, socketChannel);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
} 
</code></pre>

<pre><code class="language-text">import java.io.IOException;  
import java.nio.ByteBuffer;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.SocketChannel;  

public class SocketReadHandler implements Runnable{  
    private SocketChannel socketChannel;  
    public SocketReadHandler(Selector selector,SocketChannel socketChannel) throws IOException{  
        this.socketChannel=socketChannel;  
        socketChannel.configureBlocking(false);  

        SelectionKey selectionKey=socketChannel.register(selector, 0);  

        //将SelectionKey绑定为本Handler 下一步有事件触发时，将调用本类的run方法。    
        //参看dispatch(SelectionKey key)    
        selectionKey.attach(this);  

        //同时将SelectionKey标记为可读，以便读取。    
        selectionKey.interestOps(SelectionKey.OP_READ);    
        selector.wakeup();  
    }  

    /** 
     * 处理读取数据 
     */  
    @Override  
    public void run() {  
        ByteBuffer inputBuffer=ByteBuffer.allocate(1024);  
        inputBuffer.clear();  
        try {  
            socketChannel.read(inputBuffer);  
            //激活线程池 处理这些request  
            //requestHandle(new Request(socket,btt));   
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
</code></pre>

<h2 id="toc_7">总结</h2>

<p>reactor模式是javaNIO非堵塞技术的实现原理，我们不仅要知道其原理流程，还要知道其代码实现，当然这个reactor模式不仅仅在NIO中实现，而且在redies等其他地方也出现过，说明这个模式还是比较实用的，尤其是在多线程高并发的情况下使用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[熔断模式]]></title>
    <link href="http://www.throne4j.com/15586676190905.html"/>
    <updated>2019-05-24T11:13:39+08:00</updated>
    <id>http://www.throne4j.com/15586676190905.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">一 问题的产生</h2>

<p>在大型的分布式系统中，通常需要调用或操作远程的服务或者资源，这些远程的服务或者资源由于调用者不可以控的原因比如网络连接缓慢，资源被占用或者暂时不可用等原因，导致对这些远程资源的调用失败。这些错误通常在稍后的一段时间内可以恢复正常。</p>

<p>但是，在某些情况下，由于一些无法预知的原因导致结果很难预料，远程的方法或者资源可能需要很长的一段时间才能修复。这种错误严重到系统的部分失去响应甚至导致整个服务的完全不可用。在这种情况下，采用不断地重试可能解决不了问题，相反，应用程序在这个时候应该立即返回并且报告错误。</p>

<p>通常，如果一个服务器非常繁忙，那么系统中的部分失败可能会导致 “连锁失效”（cascading failure）。比如，某个操作可能会调用一个远程的WebService，这个service会设置一个超时的时间，如果响应时间超过了该时间就会抛出一个异常。但是这种策略会导致并发的请求调用同样的操作会阻塞，一直等到超时时间的到期。这种对请求的阻塞可能会占用宝贵的系统资源，如内存，线程，数据库连接等等，最后这些资源就会消耗殆尽，使得其他系统不相关的部分所使用的资源也耗尽从而拖累整个系统。在这种情况下，操作立即返回错误而不是等待超时的发生可能是一种更好的选择。只有当调用服务有可能成功时我们再去尝试。</p>

<h2 id="toc_1">解决之道</h2>

<p>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>

<p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。<br/>
<img src="media/15586676190905/15586775537030.jpg" alt=""/><br/>
熔断器可以使用状态机来实现，内部模拟以下几种状态。</p>

<ul>
<li>闭合（closed）状态： 对应用程序的请求能够直接引起方法的调用。代理类维护了最近调用失败的次数，如果某次调用失败，则使失败次数加1。如果最近失败次数超过了在给定时间内允许失败的阈值，则代理类切换到断开(Open)状态。此时代理开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误。</li>
<li>断开(Open)状态：在该状态下，对应用程序的请求会立即返回错误响应。</li>
<li>半断开（Half-Open）状态：允许对应用程序的一定数量的请求可以去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态(并且将错误计数器重置)；如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开方式，然后开始重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。<br/>
各个状态之间的转换如下图：
<img src="media/15586676190905/15586778712353.jpg" alt=""/></li>
</ul>

<p>在Close状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。触发熔断器进入断开状态的失败阈值只有在特定的时间间隔内，错误次数达到指定错误次数的阈值才会产生。在Half-Open状态中使用的连续成功次数计数器记录调用的成功次数。当连续调用成功次数达到某个指定值时，切换到闭合状态，如果某次调用失败，立即切换到断开状态，连续成功调用次数计时器在下次进入半断开状态时归零。</p>

<p>实现熔断器模式使得系统更加稳定和有弹性，在系统从错误中恢复的时候提供稳定性，并且减少了错误对系统性能的影响。它通过快速的拒绝那些试图有可能调用会导致错误的服务，而不会去等待操作超时或者永远不会不返回结果来提高系统的响应事件。如果熔断器设计模式在每次状态切换的时候会发出一个事件，这种信息可以用来监控服务的运行状态，能够通知管理员在熔断器切换到断开状态时进行处理。</p>

<p>可以对熔断器模式进行定制以适应一些可能会导致远程服务失败的特定场景。比如，可以在熔断器中对超时时间使用不断增长的策略。在熔断器开始进入断开状态的时候，可以设置超时时间为几秒钟，然后如果错误没有被解决，然后将该超时时间设置为几分钟，依次类推。在一些情况下，在断开状态下我们可以返回一些错误的默认值，而不是抛出异常。</p>

<h2 id="toc_2">要考虑的因素</h2>

<p>在实现熔断器模式的时候，以下这些因素需可能需要考虑：</p>

<ul>
<li>异常处理：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li>
<li>异常的类型：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li>
<li>日志：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。</li>
<li>测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li>
<li>手动重置：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。</li>
<li>并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。</li>
<li>资源的差异性：使用单个熔断器时，一个资源如果​​有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li>
<li>加快熔断器的熔断操作:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么可以断定出不建议立即重试，而是应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li>
<li>重复失败请求：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li>
</ul>

<h2 id="toc_3">使用场景</h2>

<p>应该使用该模式来：</p>

<ul>
<li>防止应用程序直接调用那些很可能会调用失败的远程服务或共享资源。</li>
</ul>

<p>不适合的场景</p>

<ul>
<li>对于应用程序中的直接访问本地私有资源，比如内存中的数据结构，如果使用熔断器模式只会增加系统额外开销。</li>
<li>不适合作为应用程序中业务逻辑的异常处理替代品</li>
</ul>

<p>根据上面的状态切换图，我们很容易实现一个基本的熔断器，只需要在内部维护一个状态机，并定义好状态转移的规则，可以使用State模式来实现。首先，我们定义一个表示状态转移操作的抽象类CircuitBreakerState：</p>

<pre><code class="language-java">public abstract class CircuitBreakerState
{
    //熔断器
    protected static CircuitBreaker circuitBreaker;
    
    protected CircuitBreakerState(CircuitBreaker circuitBreaker) {
        this.circuitBreaker = circuitBreaker;
    }
    // 调用受保护方法之前处理的操作
    public void protectedCodeIsAboutToBeCalled() {
        //如果是断开状态，直接返回,然后坐等超时转换到半断开状态
        if (circuitBreaker.isOpen) {
            throw new OpenCircuitException();
        }
    }

    // 受熔断器保护的方法调用成功之后的操作
    public virtual void protectedCodeHasBeenCalled() {
        circuitBreaker.IncreaseSuccessCount();
    }

    //受熔断器保护的方法调用发生异常操作后的操作
    public virtual void actUponException(Exception e) {
        //增加失败次数计数器，并且保存错误信息
        circuitBreaker.increaseFailureCount(e);
        //重置连续成功次数
        circuitBreaker.resetConsecutiveSuccessCount();
    }
}
</code></pre>

<p>抽象类中，状态机CircuitBreaker通过构造函数注入；当发生错误时，我们增加错误计数器，并且重置连续成功计数器，在增加错误计数器操作中，同时也记录了出错的异常信息。</p>

<p>然后在分别实现表示熔断器三个状态的类。首先实现闭合状态CloseState：</p>

<pre><code class="language-java">public class ClosedState extends CircuitBreakerState {
    public ClosedState(CircuitBreaker circuitBreaker) {
        super(circuitBreaker)
        //重置失败计数器
        circuitBreaker.resetFailureCount();
    }
    
    @override
    public void actUponException(Exception e) {
        super.actUponException(e);
        //如果失败次数达到阈值，则切换到断开状态
        if (circuitBreaker.failureThresholdReached()){
            circuitBreaker.moveToOpenState();
        }
    }
}
</code></pre>

<p>在闭合状态下，如果发生错误，并且错误次数达到阈值，则状态机切换到断开状态。断开状态OpenState的实现如下：</p>

<pre><code class="language-java">public class OpenState extends CircuitBreakerState {
    private final static Timer timer;

    public OpenState(CircuitBreaker circuitBreaker) {
        timer = new Timer(circuitBreaker.Timeout.TotalMilliseconds);
        timer.Elapsed += TimeoutHasBeenReached;
        timer.AutoReset = false;
        timer.Start();
    }

    // 断开超过设定的阈值，自动切换到半断开状态
    private void timeoutHasBeenReached(object sender, ElapsedEventArgs e) {
        circuitBreaker.moveToHalfOpenState();
    }

    public void protectedCodeIsAboutToBeCalled() {
        super.protectedCodeIsAboutToBeCalled();
        throw new OpenCircuitException();
    }
}
</code></pre>

<p>断开状态内部维护一个计数器，如果断开达到一定的时间，则自动切换到版断开状态，并且，在断开状态下，如果需要执行操作，则直接抛出异常。</p>

<p>最后半断开Half-Open状态实现如下：</p>

<pre><code class="language-java">public class HalfOpenState extends CircuitBreakerState {
    public HalfOpenState(CircuitBreaker circuitBreaker)  {
        // 重置连续成功计数
        circuitBreaker.resetConsecutiveSuccessCount();
    }

    public override void actUponException(Exception e) {
        super.ActUponException(e);
        //只要有失败，立即切换到断开模式
        circuitBreaker.moveToOpenState();
    }
    
    public void protectedCodeHasBeenCalled() {
        super.ProtectedCodeHasBeenCalled();
        //如果连续成功次数达到阈值，切换到闭合状态
        if (circuitBreaker.consecutiveSuccessThresholdReached()) {
            circuitBreaker.moveToClosedState();
        }
    }
}
</code></pre>

<p>切换到半断开状态时，将连续成功调用计数重置为0，当执行成功的时候，自增改字段，当达到连读调用成功次数的阈值时，切换到闭合状态。如果调用失败，立即切换到断开模式。</p>

<p>有了以上三种状态切换之后，我们要实现CircuitBreaker类了:</p>

<pre><code class="language-java">@data
public class CircuitBreaker {
    private final static object monitor = new object();
    private CircuitBreakerState state;
    private int failureCount;
    public int consecutiveSuccessCount;
    public int failureThreshold;
    public int consecutiveSuccessThreshold;
    public TimeSpan Timeout;
    public Exception LastException;

    public CircuitBreaker(int failedThreshold, int consecutiveSuccessThreshold, TimeSpan timeout) {
        if (failedThreshold &lt; 1 || consecutiveSuccessThreshold &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;threshold&quot;, &quot;Threshold should be greater than 0&quot;);
        }

        if (timeout.TotalMilliseconds &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;timeout&quot;, &quot;Timeout should be greater than 0&quot;);
        }

        failureThreshold = failedthreshold;
        consecutiveSuccessThreshold = consecutiveSuccessThreshold;
        timeout = timeout;
        moveToClosedState();
    }
    
    public bool IsClosed {
        return state is ClosedState; 
    }

    public bool IsOpen {
        return state == OpenState; 
    }

    public bool IsHalfOpen {
       return state is HalfOpenState; }
    }

   public void moveToClosedState() {
        state = new ClosedState(this);
    }

   public void moveToOpenState() {
        state = new OpenState(this);
    }

    public void moveToHalfOpenState() {
        state = new HalfOpenState(this);
    }

    public void increaseFailureCount(Exception ex) {
        LastException = ex;
        failureCount++;
    }

    public void resetFailureCount() {
        failureCount = 0;
    }

    public bool failureThresholdReached() {
        return failureCount &gt;= failureThreshold;
    }

    public void increaseSuccessCount() {
        consecutiveSuccessCount++;
    }

    public void resetConsecutiveSuccessCount() {
        consecutiveSuccessCount = 0;
    }
    
    public bool consecutiveSuccessThresholdReached() {
        return consecutiveSuccessCount &gt;= consecutiveSuccessThreshold;
    }
    
    // 执行代理方法， action 需要执行的代理方法
    public void attemptCall(function protectedCode) {
       synchronized (monitor) {
            state.protectedCodeIsAboutToBeCalled();
        }
    
        try {
            protectedCode();
        } catch (Exception e) {
            synchronized (monitor) {
                state.actUponException(e);
            }
            throw e;
        }
    
        synchronized (monitor) {
            state.protectedCodeHasBeenCalled();
        }
    }
    
    public void Close() {
       synchronized (monitor) {
            moveToClosedState();
        }
    }
    
    public void Open() {
       synchronized (monitor) {
            moveToOpenState();
        }
    }
}
</code></pre>

<p>在该类中</p>

<ul>
<li><p>首先： 定义了一些记录状态的变量，如failureCount，consecutiveSuccessCount 记录失败次数，连续成功次数，以及failureThreshold，consecutiveSuccessThreshold记录最大调用失败次数，连续调用成功次数。这些对象对外部来说是只读的。</p></li>
<li><p>定义了一个 circuitBreakerState类型的state变量，以表示当前系统的状态。</p></li>
<li><p>定义了一些列获取当前状态的方法isOpen, isClose, isHalfOpen,以及表示状态转移的方法moveToOpenState，moveToClosedState等，这些方法比较简单，根据名字即可看出用意。</p></li>
<li><p>然后，可以通过构造函数将在Close状态下最大失败次数，HalfOpen状态下使用的最大连续成功次数，以及Open状态下的超时时间通过构造函数传进来：</p></li>
<li><p>在初始状态下，熔断器切换到闭合状态。</p></li>
<li><p>然后，可以通过attempCall调用，传入期望执行的代理方法，该方法的执行受熔断器保护。这里使用了锁来处理并发问题。</p></li>
<li><p>最后，提供Close和Open两个方法来手动切换当前状态。</p></li>
</ul>

<h2 id="toc_4">测试</h2>

<p>以上的熔断模式，我们可以对其建立单元测试。</p>

<p>首先我们编写几个帮助类以模拟连续执行次数：</p>

<pre><code class="language-java">private static void CallXAmountOfTimes(function codeToCall, int timesToCall) {
    for (int i = 0; i &lt; timesToCall; i++) {
        codeToCall();
    }
}
</code></pre>

<p>以下类用来抛出特定异常：</p>

<pre><code class="language-java">private static void AssertThatExceptionIsThrown&lt;T&gt;(Action code) where T : Exception {
    try {
        code();
    } catch (T) {
        return;
    }

    Assert.Fail(&quot;Expected exception of type {0} was not thrown&quot;, typeof(T).FullName);
}
</code></pre>

<p>然后，使用NUnit，可以建立如下Case：</p>

<pre><code class="language-java">@test
public void ClosesIfProtectedCodeSucceedsInHalfOpenState()
{
    var stub = new Stub(10);
    //定义熔断器，失败10次进入断开状态
    //5秒后进入半断开状态
    //在半断开状态下，连续成功15次，进入闭合状态
    CircuitBreaker circuitBreaker = new CircuitBreaker(10, 15, TimeSpan.FromMilliseconds(5000));
    Assert.That(circuitBreaker.IsClosed);
    //失败10次调用
    CallXAmountOfTimes(() =&gt; AssertThatExceptionIsThrown&lt;ApplicationException&gt;(() =&gt; circuitBreaker.AttemptCall(stub.DoStuff)), 10);

    Assert.AreEqual(10, circuitBreaker.FailureCount);

    Assert.That(circuitBreaker.IsOpen);

    //等待从Open转到HalfOpen
    Thread.Sleep(6000);
    Assert.That(circuitBreaker.IsHalfOpen);
    //成功调用15次
    CallXAmountOfTimes(()=&gt;circuitBreaker.AttemptCall(stub.DoStuff), 15);

    Assert.AreEqual(15, circuitBreaker.ConsecutiveSuccessCount);
    Assert.AreEqual(0, circuitBreaker.FailureCount);
    Assert.That(circuitBreaker.IsClosed);
}
</code></pre>

<p>这个Case模拟了熔断器中状态的转换。首先初始化时，熔断器处于闭合状态，然后连续10次调用抛出异常，这时熔断器进去了断开状态，然后让线程等待6秒，此时在第5秒的时候，状态切换到了半断开状态。然后连续15次成功调用，此时状态又切换到了闭合状态。</p>

<p>七 结论<br/>
在应用系统中，我们通常会去调用远程的服务或者资源(这些服务或资源通常是来自第三方)，对这些远程服务或者资源的调用通常会导致失败，或者挂起没有响应，直到超时的产生。在一些极端情况下，大量的请求会阻塞在对这些异常的远程服务的调用上，会导致一些关键性的系统资源耗尽，从而导致级联的失败，从而拖垮整个系统。熔断器模式在内部采用状态机的形式，使得对这些可能会导致请求失败的远程服务进行了包装，当远程服务发生异常时，可以立即对进来的请求返回错误响应，并告知系统管理员，将错误控制在局部范围内，从而提高系统的稳定性和可靠性。</p>

<p>本文首先介绍了熔断器模式使用的场景，能够解决的问题，以及需要考虑的因素，最后使用代码展示了如何实现一个简单的熔断器，并且给出了测试用例，希望这些对您有帮助，尤其是在当您的系统调用了外部的远程服务或者资源，同时访问量又很大的情况下对提高系统的稳定性和可靠性有所帮助。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说java 显式锁 Lock]]></title>
    <link href="http://www.throne4j.com/15867933931035.html"/>
    <updated>2020-04-13T23:56:33+08:00</updated>
    <id>http://www.throne4j.com/15867933931035.html</id>
    <content type="html"><![CDATA[
<p>锁是用于通过多个线程控制对共享资源的访问工具。通常锁提供对共享资源的独占访问，但是一些锁可能允许并发的访问共享资源，例如ReadWriteLock的读锁。</p>

<p>问:java中有了synchronized，为什么又会出现java显式锁呢？<br/>
答：Lock实现提供比使用synchronized方法可以获得更灵活、更广泛的锁定操作。</p>

<p>使用synchronized方法或语句提供对每个对象相关联的隐式监视器锁访问，但是强制所有锁获取和释放以块的结构方式发生，当获取多个锁的时候，他们必须以相反的顺序被释放，并且所有的锁都必须被释放在与他们相同的词汇范围内。</p>

<p>lock的使用应使用如下的惯用写法:</p>

<pre><code class="language-java">Lock l = ...;
l.lock();
try{
    // 访问被此锁保护起来的相关资源
} finally{
    l.unlock();
}
</code></pre>

<pre><code class="language-text">public interface Lock {
    // 获得锁资源
    void lock();
    // 尝试获得锁，如果当前线程被调用了interrupted则中断，并抛出异常，否则就获得锁
    void lockInterruptibly() throws InterruptedException;
    // 判断能否获得锁，如果能获得，则获得锁，并返回true(此时已经获得了锁)
    boolean tryLock();
    // 保持给定的等待时间，如果期间能拿到锁，则获得锁，同样如果期间被中断，则抛异常
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    // 释放锁
    void unlock();
    // 返回与此Lock对象绑定Condition实例
    Condition newCondition();
}
</code></pre>

<hr/>

<h2 id="toc_0">ReentrantLock重入锁，内部实现有公平锁和非公平锁。</h2>

<h3 id="toc_1">可重入</h3>

<p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞， 该特性的实现需要解决以下两个问题。<br/>
1)线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程， 如果是，则再次成功获取。<br/>
2)锁的最终释放。线程重复 n 次获取了锁，随后在第 n 次释放该锁后，其 他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示 当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于 0 时表示锁已 经成功释放。</p>

<p>nonfairTryAcquire 方法增加了再次获取同步状态的处理逻辑:通过判断当前 线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请 求，则将同步状态值进行增加并返回 true，表示获取同步状态成功。同步状态表 示锁被一个线程重复获取的次数。<br/>
如果该锁被获取了 n 次，那么前(n-1)次 tryRelease(int releases)方法必须返回 false，而只有同步状态完全释放了，才能返回 true。可以看到，该方法将同步状 态是否为 0 作为最终释放的条件，当同步状态为 0 时，将占有线程设置为 null， 并返回 true，表示释放成功。</p>

<h3 id="toc_2">公平和非公平锁</h3>

<pre><code class="language-java">public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>

<p>ReentrantLock 的构造函数中，默认的无参构造函数将会把 Sync 对象创建为NonfairSync 对象，这是一个“非公平锁”;</p>

<p>而另一个构造函数 ReentrantLock(boolean fair)传入参数为 true 时将会把 Sync 对象创建为“公平锁” FairSync。</p>

<p>nonfairTryAcquire(int acquires)方法，对于非公平锁，只要 CAS 设置同步状态 成功，则表示当前线程获取了锁，而公平锁则不同。</p>

<p>tryAcquire 方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 <strong>hasQueuedPredecessors()</strong>方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此 需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>

<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>

<hr/>

<h3 id="toc_3">condition接口</h3>

<p>Condition与Lock要结合使用，使用Condition可以用来实现wait()和notify()/notifyAll()类似的等待/通知模式。与Object对象里不同的是，Condition更加灵活，可以在一个Lock对象里创建多个Condition实例，有选择的进行线程通知，在线程调度上更加灵活。<br/>
Condition接口的通过<br/>
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject <br/>
<a href="15867863097702.html">细说AbstractQueuedSynchronizer(AQS)</a><br/>
来实现。</p>

<p>使用Condition注释上的l栗子：</p>

<pre><code class="language-java">/**
 * 阻塞的有界队列
 */
public class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition(); 
    final Condition notEmpty = lock.newCondition(); 

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            // 当count等于数组的大小时，当前线程等待，直到notFull通知，再进行生产
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            // 当count为0，进入等待，直到notEmpty通知，进行消费。
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>

<p>可以通过多个线程来调用put和take方法，来模拟生产者和消费者。<br/>
我们来换成常规的wait/notify的实现方式：</p>

<pre><code class="language-java">public class BoundedBuffer {
    private final Object lock;
    
    public BoundedBuffer(Object lock) {
        this.lock = lock;
    }
    public void put(Object x) {
        try {
            synchronized (items) {
                while (count == items.length) {
                    items.wait();
                }
                items[putptr] = x;
                if (++putptr == items.length) putptr = 0;
                ++count;
                // items.notify();
                items.notifyAll();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public Object take() {
        try {
            synchronized (items) {
                while (count == 0) {
                    items.wait();
                }
                Object x = items[takeptr];
                if (++takeptr == items.length) takeptr = 0;
                --count;
                // items.notify();
                items.notifyAll();
                return x;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>如果将items.notifyAll()换成items.notify()，在多生产者和多消费者模式情况下，可能出现take唤醒了take的情况，导致生产者在等待消费者消费，而消费者等待生产者生产，最终导致程序无限等待，而用notifyAll()，则唤醒所有的生产者和消费者，不像Condition可以选择性的通知。下面我们来看一下它的源码：</p>

<pre><code class="language-java">public interface Condition {
    // 让当前线程等待，直到被通知或者被中断
    void await() throws InterruptedException;
    // 与前者的区别是，当等待过程中被中断时，仍会继续等待，直到被唤醒，才会设置中断状态
    void awaitUninterruptibly();
    // 让当前线程等待，直到它被告知或中断，或指定的等待时间已经过。
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    // 与上面的类似，让当前线程等待，不过时间单位是纳秒
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    // 让当前线程等待到确切的指定时间，而不是时长
    boolean awaitUntil(Date deadline) throws InterruptedException;
    // 唤醒一个等待当前condition的线程，有多个则随机选一个
    void signal();
    // 唤醒所有等待当前condition的线程
    void signalAll();
}
</code></pre>

<hr/>

<h2 id="toc_4">ReadWriteLock</h2>

<p>读写锁接口只定义了两个获取读锁和写锁的接口方法，需要具体实现类ReentrantReadWriteLock实现</p>

<pre><code class="language-java">public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
</code></pre>

<h3 id="toc_5">ReentrantReadWriteLock</h3>

<h4 id="toc_6">读写状态的设计</h4>

<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的 同步状态。<br/>
回想 ReentrantLock 中自定义同步器的实现，同步状态表示锁被一个线程重 复获取的次数，而读写锁的自定义同步器需要在同步状态(一个整型变量)上维 护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br/>
如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变 量，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写，读写锁 是如何迅速确定读和写各自的状态呢?<br/>
答案是通过位运算。假设当前同步状态值为 S，写状态等于 S&amp;0x0000FFFF (将高 16 位全部抹去)，读状态等于 S&gt;&gt;&gt;16(无符号补 0 右移 16 位)。当写 状态增加 1 时，等于 S+1，当读状态增加 1 时，等于 S+(1&lt;<16)，也就是 S+0x00010000。 根据状态的划分能得出一个推论:S 不等于 0 时，当写状态(S&0x0000FFFF)等 于 0 时，则读状态(S>&gt;&gt;16)大于 0，即读锁已被获取。</p>

<h4 id="toc_7">写锁的获取与释放</h4>

<p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写 状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为 0)或者该线 程不是已经获取写锁的线程，则当前线程进入等待状态。</p>

<p>该方法除了重入条件(当前线程为获取了写锁的线程)之外，增加了一个读 锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于:读写锁要确 保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他 读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读 写线程的后续访问均被阻塞。</p>

<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态， 当写状态为 0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁， 同时前次写线程的修改对后续读写线程可见</p>

<h4 id="toc_8">读锁的获取与释放</h4>

<p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他 写线程访问(或者写状态为 0)时，读锁总会被成功地获取，而所做的也只是(线 程安全的)增加读状态。如果当前线程已经获取了读锁，则增加读状态。</p>

<p>如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。读 状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择 保存在 ThreadLocal 中，由线程自身维护。在 tryAcquireShared(int unused)方法中， 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果 当前线程获取了写锁或者写锁未被获取，则当前线程(线程安全，依靠 CAS 保证) 增加读状态，成功获取读锁。读锁的每次释放(线程安全的，可能有多个读线程 同时释放读锁)均减少读状态。</p>

<h4 id="toc_9">锁的升降级</h4>

<p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放， 最后再获取读锁，这种分段完成的过程不能称之为锁降级。</p>

<p>锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。</p>

<p>RentrantReadWriteLock 不支持锁升级(把持读锁、获取写锁，最后释放读锁 的过程)。目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程 成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。<br/>
ReadLock<br/>
WriteLock </p>

<h3 id="toc_10">StampedLock</h3>

<p>JDK1.8增加的一种新的锁实现</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存分配策略]]></title>
    <link href="http://www.throne4j.com/15869610065512.html"/>
    <updated>2020-04-15T22:30:06+08:00</updated>
    <id>http://www.throne4j.com/15869610065512.html</id>
    <content type="html"><![CDATA[
<p>对象的内存分配，概念上说都是在堆内存上分配(有可能被编译器拆散为标量类型并间接地在栈上分配)。在经典分代设计下，新对象通常会分配在新生代中，少数情况下可能直接分配在老年代。<strong>对象的分配规则并不是固定的，主要取决于JVM使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数设定</strong>。</p>

<p>下面看下serial+serialOld垃圾收集器下的内存分配规则</p>

<h2 id="toc_0">对象优先在Eden区分配</h2>

<p>大多数情况下，对象在Eden区分配，当Eden区空间不足时，将触发一次minor gc。<br/>
jvm提供了-XX:+PrintGCDetails这个收集日志参数，或使用-XX:+PrintHeapAtGC对GC前后的GC日志进行对比</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[垃圾收集器]]></title>
    <link href="http://www.throne4j.com/15869610752834.html"/>
    <updated>2020-04-15T22:31:15+08:00</updated>
    <id>http://www.throne4j.com/15869610752834.html</id>
    <content type="html"><![CDATA[
<p>关于JVM中线程私有的内存区域（程序计数器、虚拟机栈、本地方法栈）是在类结构确定下来的时候就是已知的，他们随着线程的生灭而生灭，因此不需要过多考虑这几块区域。但是java堆就带有很大的不确定性，它在程序运行期间会不断的创建对象，这块的内存的分配和回收的动态性将会是JVM垃圾收集器主要关注的部分。</p>

<p>当需要排查排查各种内存溢出、内存泄漏问题，垃圾收集成为系统高并发瓶颈时，我们需要对jvm的自动化内存管理进行监控和优化。</p>

<h2 id="toc_0">那些对象需要回收</h2>

<p>在垃圾收集器对堆进行回收之前，第一件事就是需要确定下来哪些对象是&quot;死亡&quot;的，然后对这些死亡的对象内存进行回收。</p>

<h3 id="toc_1">引用计数算法</h3>

<p>在对象A中添加一个引用计数器，每当有一个地方引用对象A时，计数器的值+1，引用失效的时候计数器 -1，计数器为0时，这个对象就未被使用的对象。<strong><em>这种算法虽然原理简单、高效，但是却不能解决对象之间的循环引用的问题。</em></strong></p>

<h3 id="toc_2">可达性分析算法</h3>

<p>这个算法的基本思路就是通过一系列的被称为“GC Roots”的根对象为其实节点集，从这写节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者说从GC Roots到这个对象不可达，则证明此对象不可能再被使用。</p>

<p>被称为GC Roots的对象包括以下几种：</p>

<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，比如java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，比如字符串常量池的引用</li>
<li>在本地方法占中JNI引用的对象</li>
<li>JVM内部的引用，比如基本数据类型对应的Class对象，一些常驻的异常对象(NullPointException、OutOfMemoryError)等，还有系统类加载器</li>
<li>所有被同步锁(synchronized关键字)持有的对象</li>
<li>反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>

<h2 id="toc_3">什么时候回收</h2>

<h2 id="toc_4">怎么回收</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 中 java 对象]]></title>
    <link href="http://www.throne4j.com/15866239860150.html"/>
    <updated>2020-04-12T00:53:06+08:00</updated>
    <id>http://www.throne4j.com/15866239860150.html</id>
    <content type="html"><![CDATA[
<p>在java程序运行的过程中，无时无刻都有对象被不断的创建出来。我们创建一个对象通常都是通过new关键字，但是jvm是怎么把一个对象给整出来的呢？</p>

<h2 id="toc_0">对象的创建</h2>

<p>Java中有5种创建对象的方式：</p>

<table>
<thead>
<tr>
<th>创建方式</th>
<th>是否调用构造函数</th>
</tr>
</thead>

<tbody>
<tr>
<td>new关键字</td>
<td>调用构造函数进行初始化</td>
</tr>
<tr>
<td>Class.forName().instance()、Object.class.newInstance()</td>
<td>Class.forName加载并连接类，newInstance()调用构造函数进行初始化</td>
</tr>
<tr>
<td>Constructor类的NewInstance()</td>
<td>调用构造函数进行初始化</td>
</tr>
<tr>
<td>Clone()</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody>
</table>

<p>这里我们只对new关键字进行分析<br/>
当JVM遇到new关键字创建普通的java对象(不包括数组和Class对象等)时，<strong><em>首先</em></strong>检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有那么必须执行相应的加载过程()。</p>

<p>在类加载检查通过后，接下来虚拟机为新生对象分配内存(类加载完成后即可知其大小)，jvm将一块确定大小的内存块从java堆中划拨出来。在划拨堆内存出来的时候，会涉及到如何分配的问题，下面有两种分配方式</p>

<ul>
<li><p>指针碰撞 <br/>
定义： 假设堆内存是规整的，所有使用过的堆内存放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就是是把这个指针向空闲空间方向移动一段与对象大小相等的的距离。<br/>
<img src="media/15866239860150/15869624345720.jpg" alt="" style="width:869px;"/></p></li>
<li><p>空闲列表<br/>
如果堆内存是不规整的，已使用和未被使用的内存是交错在一起的，那就没办法简简单单地进行“指针碰撞”了，虚拟机就必须维护一个用来记录那些内存块是可用的列表，在分配对象的时候找一个内存大小适中的内存空间划分给对象，并更新列表上的记录，这种分配方式被称为空闲列表<br/>
<img src="media/15866239860150/15869639142729.jpg" alt="" style="width:877px;"/></p></li>
</ul>

<p>选择哪种分配方式有java堆是否规整决定，堆是否规整取决于jvm采用哪种垃圾回收器(<a href="15869610752834.html">垃圾收集器</a>)来决定。</p>

<p>因此采用复制算法、标记整理算法的收集器时，系统采用“指针碰撞“，而采用CMS这种基于清除算法的收集器时，采用”空闲列表“来分配。</p>

<p>但是在并发情况下，即使是”指针碰撞“这种仅仅是移动指针所指向位置的操作，也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>

<p>解决上面所说的问题有两种可选方案</p>

<ul>
<li>分配内存空间的动作进行同步处理（JVM是采用CAS配上失败重试的方式保证更新操作的原子性）</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer， TLAB)，哪个线程要分分配内存就在哪个线程的TLAB中分配，TLAB使用完了，分配新的缓存区时才需要同步锁定</li>
</ul>

<p>内存分配完成之后， JVM必须将分配到的内存空间(不包括对象头)都进行初始化，这样保证了在代码中可以不赋初值就可以直接使用。</p>

<p>接下来JVM还要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄、是否使用偏向锁等信息，这些信息存放在java的对象头中。</p>

<p>接下来对象的创建猜刚刚开始----构造函数，即Class文件中的<init>()方法还没执行，所有的对象字段还是初始的默认值，执行完<init>()之后对象才会想我们程序中所希望的那样赋予相应的变量值。</p>

<h2 id="toc_1">对象的内存布局</h2>

<p>对象在堆内存中存储布局可以划分为三部分：对象头(Object Header)、实例数据(Instance Data)、对齐填充(Padding)。</p>

<h3 id="toc_2">对象头</h3>

<p>对象头分两部分：Mark Word、class pointer(类型指针)</p>

<ul>
<li>Mark Word的组成以及布局情况</li>
</ul>

<p>下图是在64位虚拟机上的对象头的堆内存布局：<br/>
<img src="media/15866239860150/15870492871153.jpg" alt=""/></p>

<p>通过Jol工具可以查看对象信息,例如查看Object对象的信息如下：</p>

<pre><code class="language-text">Object a = new Object();
System.out.println(ClassLayout.parseInstance(a).toPrintable());

-----------------------------------------------------------------------
java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
</code></pre>

<p>从输出结果可以看到Object对象的大小总共占用 4 bytes的内存</p>

<ul>
<li>类型指针<br/>
对象指向它的类型元数据指针，java虚拟机通过这个指针来确定对象是哪个类的实例。</li>
</ul>

<h3 id="toc_3">实例数据</h3>

<p>用来存储真正的有效信息，即我们在程序代码里面所定义的各种类型的字段内容。</p>

<h3 id="toc_4">对齐填充</h3>

<p>这部分仅仅是起到占位符的作用。由于jvm的自动内存管理系统要求任何对象的大小必须是8字节的整数倍，如果对象实例数据没有对齐的话，则通过对齐填充来进行补全，使其大小是8字节的整数倍(对象头已经被设计成正好是8字节的整数倍的结构了)</p>

<h2 id="toc_5">对象访问定位</h2>

<p>创建完对象之后，就到了使用对象的时候了。JVM会通过虚拟机栈上的reference（指向对象的引用）数据来操作堆上的具体对象。</p>

<p>jvm主要有两种访问对象的方式：</p>

<ul>
<li><p>使用句柄访问<br/>
java堆内存中将可能划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象的实例数据与类型数据各自具体的地址信息。<br/>
当对象改变之后，只需要改变句柄中的实例数据的指针地址，而句柄本身的地址这不会改变，那么reference的引用也不会改变。</p></li>
<li><p>使用直接指针访问<br/>
reference中存储的直接就是对象的地址，直接访问对象的话，一步到位，访问速度会更加迅速。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JUC辅助同步类之CountDownLatch、CyclicBarrier、Semaphore]]></title>
    <link href="http://www.throne4j.com/15867876320249.html"/>
    <updated>2020-04-13T22:20:32+08:00</updated>
    <id>http://www.throne4j.com/15867876320249.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">CountDownLatch 号令枪</h2>

<p>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行操作。<br/>
CountDownLatch 是通过一个计数器来实现的，计数器的初始值为初始任务 的数量。每当完成了一个任务后，计数器的值就会减 1 (CountDownLatch.countDown()方法)。当计数器值到达 0 时，它表示所有的已 经完成了任务，然后在闭锁上等待 CountDownLatch.await()方法的线程就可以恢 复执行任务。</p>

<pre><code class="language-java">public class MichaelShow {
    private static final AtomicInteger COUNT = new AtomicInteger(0);
    static class Customer extends Thread {
        private final CountDownLatch beQuiet;
        private final CountDownLatch beBoom;

        public Customer(CountDownLatch beQuiet, CountDownLatch beBoom) {
            this.beQuiet = beQuiet;
            this.beBoom = beBoom;
        }

        @Override
        public void run() {
            try {
                beQuiet.await();
                System.out.println(&quot;观众大喊：Michael Jackson， 我爱你！！！晕厥~~~&quot;);
                COUNT.getAndAdd(1);
                beBoom.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch startShow = new CountDownLatch(1);
        CountDownLatch beBoom = new CountDownLatch(100);
        for (int i = 0; i &lt; 100; i++) {
            new Customer(startShow,beBoom).start();
        }

        System.out.println(&quot;Michael号令，演唱会马上开始&quot;);
        startShow.countDown(); // 开始演唱会
        beBoom.await();// 等待晕厥到一定人数，将人送往医院
        System.out.println(&quot;观众晕厥&quot;+COUNT.get()+&quot;个，都被送往医院&quot;);
    }
}
</code></pre>

<h2 id="toc_1">CyclicBarrier</h2>

<p>CyclicBarrier 的字面意思是可循环使用(Cyclic)的屏障(Barrier)。它要做 的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到最后一 个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 </p>

<p>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截 的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然 后当前线程被阻塞。<br/>
CyclicBarrier还提供一个更高级的构造函数CyclicBarrie(r intparties，Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复 杂的业务场景。</p>

<pre><code class="language-java">public class HomeWorkCyclicBarrier {

    private static CyclicBarrier barrier
            = new CyclicBarrier(4, new Treacher());

    //存放子线程工作结果的容器
    private static ConcurrentHashMap&lt;String, Long&gt; resultMap
            = new ConcurrentHashMap&lt;&gt;();

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            Thread thread = new Thread(new Student());
            thread.start();
        }

    }

    /*汇总作业*/
    private static class Treacher implements Runnable {

        @Override
        public void run() {
            StringBuilder result = new StringBuilder();
            for (Map.Entry&lt;String, Long&gt; workResult : resultMap.entrySet()) {
                result.append( workResult.getValue()+&quot;、&quot;);
            }
            System.out.println(&quot;王老师批阅学生&quot; + result+&quot;的作业&quot;);
            System.out.println(&quot;王老师看学生搞对象&quot;);
        }
    }

    /*相互等待的子线程*/
    private static class Student implements Runnable {

        @Override
        public void run() {
            long id = Thread.currentThread().getId();
            resultMap.put(&quot;作业&quot;+Thread.currentThread().getId() + &quot;&quot;, id);
            try {
                Thread.sleep(1000 + id);
                System.out.println(&quot;学生&quot; + id + &quot;写作业&quot;);
                barrier.await();
                Thread.sleep(1000 + id);
                System.out.println(&quot;学生&quot; + id + &quot;搞对象&quot;);
                //barrier.await();
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
</code></pre>

<h3 id="toc_2">Semaphore</h3>

<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p>

<h4 id="toc_3">应用场景</h4>

<p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下：</p>

<pre><code class="language-java">public class DBPoolSemaphore {
    
    private final static int POOL_SIZE = 10;
    //两个指示器，分别表示池子还有可用连接和已用连接
    private final Semaphore useful,useless;
    //存放数据库连接的容器
    private static final LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();
    //初始化池
    static {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            pool.addLast(getConnection());
        }
    }
    public DBPoolSemaphore() {
        this.useful = new Semaphore(10);
        this.useless = new Semaphore(0);
    }
    
    /*归还连接*/
    public void returnConnect(Connection connection) throws InterruptedException {
        if(connection!=null) {
            System.out.println(&quot;当前有&quot;+useful.getQueueLength()+&quot;个线程等待数据库连接!!&quot;
                    +&quot;可用连接数：&quot;+useful.availablePermits());
            useless.acquire();
            synchronized (pool) {
                pool.addLast(connection);
            }
            useful.release();
        }
    }
    
    /*从池子拿连接*/
    public Connection takeConnect() throws InterruptedException {
        useful.acquire();
        Connection connection;
        synchronized (pool) {
            connection = pool.removeFirst();
        }
        useless.release();
        return connection;
    }
    
}
</code></pre>

]]></content>
  </entry>
  
</feed>
