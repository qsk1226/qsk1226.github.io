<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2020-06-28T00:56:40+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Redis 数据结构与命令]]></title>
    <link href="http://www.throne4j.com/15930711977940.html"/>
    <updated>2020-06-25T15:46:37+08:00</updated>
    <id>http://www.throne4j.com/15930711977940.html</id>
    <content type="html"><![CDATA[
<p>Redis 支持多种类型的数据结构，如 字符串（string）， 散列（hashe）， 列表（list）， 集合（sets）， 有序集合（zset） 与范围查询， bitmap， hyperloglogs 和 地理空间（geospatial） 索引半径查询，stream消息队列。</p>

<p>Redis命令十分丰富，包括的命令组有Cluster、Connection、Geo、Hashes、HyperLogLog、Keys、Lists、Pub/Sub、Scripting、Server、Sets、Sorted Sets、Strings、Transactions一共14个redis命令组两百多个redis命令。</p>

<h2 id="toc_0">一、对象结构体 robj</h2>

<p>Redis 是一个 key-value 型数据库， key只能是字符串， vlaue可以是 字符串、列表、集合、有序集合、散列表， 这5中数据类型用结构体 robj表示，robj被称为 Redis 对象。<br/>
robj结构体如下所示：</p>

<pre class="line-numbers"><code class="language-c">typedef struct redisObject {     
    unsigned type:4;    // 对象类型
    unsigned encoding:4;    // 对象编码
    unsigned lru:LRU_BITS;  //缓存淘汰使用, 占24比特
    int refcount;   //存储当前对象的引用次数，用于实现对象的共享    
    void *ptr;  //指向实际存储的某一种数据结构
} robj;
</code></pre>

<h4 id="toc_1">结构体robj的type字段表示对象类型，由 encoding 字段决定。</h4>

<pre class="line-numbers"><code class="language-c">#define OBJ_STRING 0
#define OBJ_LIST 1
#define OBJ_SET 2
#define OBJ_ZSET 3
#define OBJ_HASH 4
</code></pre>

<h4 id="toc_2">结构体 robj 的 encoding</h4>

<p>结构体 robj 的 encoding 表示当前对象的底层存储采用的数据结构，即对象的编码。</p>

<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th>可存储对象类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>OBJ_ENCODING_Quicklist</td>
<td>快速列表</td>
<td>列表</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典</td>
<td>集合、散列表、有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td>散列表、有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合</td>
<td>集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
<td>有序集合</td>
</tr>
<tr>
<td>OBJ_ENCODING_STREAM</td>
<td>stream</td>
<td>stream</td>
</tr>
<tr>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表(不再使用)</td>
<td>不再使用</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>未使用</td>
<td>未使用</td>
</tr>
</tbody>
</table>

<h4 id="toc_3">结构体 robj 的ptr</h4>

<p>ptr是void* 类型的指针，指向实际存储的某一种数据结构。</p>

<h4 id="toc_4">结构体 robj 的 refcount</h4>

<p>refcount 存储当前对象的引用次数，用于实现对象的共享。共享时 refcount加1；删除对象时，refcount减1；当refcount值为0时，释放对象空间。</p>

<h4 id="toc_5">结构体 robj 的 lru</h4>

<p>用于实现缓存淘汰策略，可以在配置文件中使用maxmemory-policy配置已用内存达到最大内存限制时的缓存淘汰策略。lru根据用户配置的缓存淘汰策略存储不同数据，常用的策略就是LRU与LFU。lru的低8比特存储的是对象的访问次数，高16比特存储的是对象的上次访问时间。</p>

<hr/>

<h2 id="toc_6">二、Redis 底层基本数据结构</h2>

<p>Redis  自己实现了底层的数据结构，简单动态字符串、跳跃表、压缩列表、字典、整数集合、quicklist、stream</p>

<table>
<thead>
<tr>
<th>底层数据结构</th>
<th>可存储对象类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>简单动态字符串</td>
<td>字符串</td>
</tr>
<tr>
<td>quickList</td>
<td>列表</td>
</tr>
<tr>
<td>字典</td>
<td>集合、散列表、有序集合</td>
</tr>
<tr>
<td>压缩列表</td>
<td>列表、散列表、有序集合</td>
</tr>
<tr>
<td>整数集合</td>
<td>集合</td>
</tr>
<tr>
<td>跳跃表</td>
<td>有序集合</td>
</tr>
<tr>
<td>stream</td>
<td>stream</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">简单动态字符串 SDS</h3>

<p>简单动态字符串（Simple Dynamic Strings，SDS）是Redis的基本数据结构之一，用于存储字符串和整型数据。SDS兼容C语言标准字符串处理函数，且在此基础上保证了二进制安全。</p>

<pre class="line-numbers"><code class="language-c">struct __attribute__ ((__packed__))sdshdr5 {     
    unsigned char flags; /* 低3位存储类型, 高5位存储长度 */
    char buf[];/*柔性数组，存放实际内容*/ 
};
struct __attribute__((__packed__))sdshdr8 {     
    uint8_t len; /* 已使用长度，用1字节存储 */    
     uint8_t alloc; /* 总长度，用1字节存储*/     
     unsigned char flags; /* 低3位存储类型, 高5位预留 */    
      char buf[];/*柔性数组，存放实际内容*/ 
};
 struct __attribute__((__packed__))sdshdr16 {    
    uint16_t len; /*已使用长度，用2字节存储*/     
    uint16_t alloc; /* 总长度，用2字节存储*/     
    unsigned char flags; /* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
}; 
struct __attribute__((__packed__))sdshdr32 {     
    uint32_t len; /*已使用长度，用4字节存储*/     
    uint32_t alloc; /* 总长度，用4字节存储*/    
    unsigned char flags;/* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
};
struct __attribute__((__packed__))sdshdr64 {     
    uint64_t len; /*已使用长度，用8字节存储*/     
    uint64_t alloc; /* 总长度，用8字节存储*/     
    unsigned char flags; /* 低3位存储类型, 高5位预留 */     
    char buf[];/*柔性数组，存放实际内容*/ 
};
</code></pre>

<p>(1) SDS如何兼容C语言字符串？如何保证二进制安全？SDS对象中的buf是一个柔性数组，上层调用时，SDS直接返回了buf。由于buf是直接指向内容的指针，故兼容C语言函数。而当真正读取内容时，SDS会通过len来限制读取长度，而非“\0”，保证了二进制安全。<br/>
(2) sdshdr5的特殊之处是什么？sdshdr5只负责存储小于32字节的字符串。一般情况下，小字符串的存储更普遍，故Redis进一步压缩了sdshdr5的数据结构，将sdshdr5的类型和长度放入了同一个属性中，用flags的低3位存储类型，高5位存储长度。创建空字符串时，sdshdr5会被sdshdr8替代。<br/>
(3) SDS是如何扩容的？SDS在涉及字符串修改处会调用sdsMakeroomFor函数进行检查，根据不同情况动态扩容，该操作对上层透明。</p>

<h3 id="toc_8">-  跳跃表 zskiplist</h3>

<p>通过将有序集合的部分节点分层，由最上层开始依次向后查找，如果本层的next节点大于要查找的值或next节点为NULL，则从本节点开始，降低一层继续向后查找，依次类推，如果找到则返回节点；否则返回NULL。采用该原理查找节点，在节点数量比较多时，可以跳过一些节点，查询效率大大提升，这就是跳跃表的基本思想。</p>

<p>跳跃表存储结构如下图所示：<br/>
<img src="media/15930711977940/15932648695005.jpg" alt="跳跃表存储结构"/></p>

<p>接下来看下跳跃表的数据结构 </p>

<pre class="line-numbers"><code class="language-c">// 定义了skiplist的节点结构
typedef struct zskiplistNode {    
    sds ele;    //用于存储字符串类型的数据
    double score;   //用于存储排序的分支
    struct zskiplistNode *backward;     //后退指针，只能执行当前节点最底层的前一个节点，头节点和第一个节点的backward指向NULL，从后向前遍历跳跃表时使用
    struct zskiplistLevel {
        struct zskiplistNode *forward;      //指向本层下一个节点，尾结点的forward指向null
        unsigned int span;      //forward 指向的节点与本节点之间的元素个数，span越大，跳过的节点个数越多。
    } level[];      // 柔性数组，每个节点的数组长度不一样，在生成跳跃表节点时，随机生成一个 1~64 的值，值越大出现的概率越低
} zskiplistNode;

// 定义了真正的skiplist结构
typedef struct zskiplist {     
    struct zskiplistNode *header, *tail;    // 头指针header和尾指针tail
    unsigned long length;   // 链表长度length，即链表包含的节点总数。创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中
    int level;  //skiplist的总层数，即所有节点层数的最大值
} zskiplist;
</code></pre>

<p>所有节点是按照分值 score 从小到大的方式排序的，当有序集合的 score 相同时，节点会按照 ele 的字典序进行排序。</p>

<h3 id="toc_9">压缩列表 ziplist</h3>

<p>压缩列表ziplist本质上就是一个字节数组(一块连续的内存空间)，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素，每个元素可以是一个字节数组或一个整数。</p>

<h4 id="toc_10">压缩列表 ziplist 存储结构</h4>

<p>压缩列表 结构示意图如下：<br/>
<img src="media/15930711977940/15932748544287.jpg" alt="" style="width:856px;"/></p>

<ul>
<li>zlbytes： 占4个字节，压缩列表的字节长度，因此压缩列表最多有232 -1个字节。</li>
<li>zltail： 占4个字节,压缩列表尾元素相对于压缩列表起始地址的偏移量。</li>
<li>zllen： 占2个字节,压缩列表的元素个数。zllen无法存储元素个数超过65535（216 -1）的压缩列表，必须遍历整个压缩列表才能获取到元素个数。</li>
<li>entryX： 压缩列表存储的元素，可以是字节数组或者整数，长度不限。</li>
<li>zlend： 占1个字节，压缩列表的结尾，恒为0xFF。</li>
</ul>

<p>查看一个压缩列表示例：</p>

<p><img src="media/15930711977940/15932741442146.jpg" alt="" style="width:888px;"/></p>

<p>了解了压缩列表的基本结构，我们可以很容易地获得压缩列表的字节长度、元素个数等，那么如何遍历压缩列表呢？对于任意一个元素，我们如何判断其存储的是什么类型呢？我们又如何获取字节数组的长度呢？</p>

<p><strong>压缩列表元素</strong>的结构示意图如下所示：<br/>
<img src="media/15930711977940/15932749731815.jpg" alt="" style="width:900px;"/></p>

<p>previous_entry_length 字段表示前一个元素的字节长度，占1个或者5个字节，</p>

<ul>
<li>当前一个元素的长度小于254字节时，用1个字节表示；</li>
<li>当前一个元素的长度大于或等于254字节时，用5个字节来表示。而此时previous_entry_length字段的第1个字节是固定的0xFE，后面4个字节才真正表示前一个元素的长度。<br/>
假设已知当前元素的首地址为p，那么p - previous_entry_length就是前一个元素的首地址，从而实现压缩列表从尾到头的遍历。</li>
</ul>

<p>encoding字段表示当前元素的编码，即content字段存储的数据类型（整数或者字节数组），数据内容存储在content字段。为了节约内存，encoding字段同样长度可变。</p>

<p>压缩列表元素的编码如下表所示：</p>

<table>
<thead>
<tr>
<th>encoding编码</th>
<th>encoding 长度</th>
<th>content类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>00 bbbbbb (6 比特表示content长度)</td>
<td>1字节</td>
<td>最大长度为63的字节数组</td>
</tr>
<tr>
<td>01 bbbbbb xxxxxxxx (14比特表示content 长度)</td>
<td>2字节</td>
<td>最大长度为2<sup>14</sup> -1 的字节数组</td>
</tr>
<tr>
<td>10 aaaaaaaa bbbbbbbb cccccccc dddddddd (32比特表示 content长度)</td>
<td>5字节</td>
<td>最大长度为2<sup>32</sup> -1 的字节数组</td>
</tr>
<tr>
<td>11 00 0000</td>
<td>1字节</td>
<td>int 16整数</td>
</tr>
<tr>
<td>11 01 0000</td>
<td>1字节</td>
<td>int 32整数</td>
</tr>
<tr>
<td>11 10 0000</td>
<td>1字节</td>
<td>int 64整数</td>
</tr>
<tr>
<td>11 11 0000</td>
<td>1字节</td>
<td>24位整数</td>
</tr>
<tr>
<td>11 11 1110</td>
<td>1字节</td>
<td>8位 整数</td>
</tr>
<tr>
<td>11 11 xxxx</td>
<td>1字节</td>
<td>没有 content 字段 xxxx 表示 0~12的整数，数据直接存储在encoding字段的最后4位</td>
</tr>
</tbody>
</table>

<p>Redis 定义的 encoding 字段的各个编码类型：</p>

<pre class="line-numbers"><code class="language-c">#define ZIP_STR_06B (0 &lt;&lt; 6) 
#define ZIP_STR_14B (1 &lt;&lt; 6) 
#define ZIP_STR_32B (2 &lt;&lt; 6) 
#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4) 
#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4) 
#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4) 
#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4) 
#define ZIP_INT_8B 0xfe
</code></pre>

<p>由于previous_entry_length存储前一个元素的字节长度，长度占1个或5个字节，为了能存储前一个元素的字节长度，在更新压缩列表过程中可能会出现一种被称为“连锁更新”的现象，Redis 在删除和插入元素操作的末尾检查是需要更新后续元素的 previous_entry_length字段，不过其造成性能问题的几率很低</p>

<h4 id="toc_11">压缩列表 ziplist 的结构体</h4>

<p>我们发现对于压缩列表的任意元素，获取前一个元素的长度、判断存储的数据类型、获取数据内容都需要经过复杂的解码运算。解码后的结果应该被缓存起来，为此定义了结构体zlentry，用于表示解码后的压缩列表元素。</p>

<pre class="line-numbers"><code class="language-c">typedef struct zlentry {
    unsigned int prevrawlensize;    //previous_entry_length 字段的长度
    unsigned int prevrawlen;    //previous_entry_length 字段存储的内容
    unsigned int lensize;   //encoding 字段的长度
    unsigned int len;   //encoding 元素数据内容的长度
    unsigned char encoding;     //encoding中 数据类型
    unsigned int headersize;    // 表示当前元素的首部长度，即previous_entry_lengh字段长度与encoding字段长度之和
    unsigned char *p;   //当前元素首地址
} zlentry;
</code></pre>

<h3 id="toc_12">字典 Dict</h3>

<p>字典又称为散列表，是用来存储键值 (key-value) 对的一种数据结构，Redis 是K-V 型数据库，任何的增删改查操作实际上都是对字典中的数据进行增删改查操作。</p>

<p>Redis 字典实现依赖的数据结构主要包含了三部分：字典、Hash表、Hash表节点。字典中嵌入了两个 Hash 表，Hash 表中的table字段存放 Hash 表节点，Hash 表节点对应存储的是键值对。</p>

<ul>
<li>Hash表的数据结构如下：</li>
</ul>

<pre class="line-numbers"><code class="language-c">typedef struct dictht {     
    dictEntry **table;                /* 指针数组，用于存储键值对*/     
    unsigned long size;                /* table数组的总大小*/     
    unsigned long sizemask;        /* 掩码 = size - 1 ，用来计算键的索引值*/     
    unsigned long used;                /* table数组已存元素个数，包含next单链表的数据*/ 
} dictht;
</code></pre>

<ul>
<li>Hash 表节点的数据结构如下：</li>
</ul>

<pre class="line-numbers"><code class="language-c">typedef struct dictEntry {     
    void *key;                        /*存储键*/     
    union {         
        void *val;                        /*db.dict中的val*/         
        uint64_t u64;         
        int64_t s64;                /*db.expires中存储过期时间*/         
        double d;     
    } v;                                /*值，是个联合体*/     
    struct dictEntry *next;        /*当Hash冲突时，指向冲突的元素，形成单链表*/ 
} dictEntry;
</code></pre>

<ul>
<li>最外层的 字典 Dict 数据结构 如下：</li>
</ul>

<pre class="line-numbers"><code class="language-c">typedef struct dict {     
    dictType *type;           /*该字典对应的一组特定操作抽象函数*/     
    void *privdata;           /*该字典依赖的数据，配合type字段指向的函数一起使用*/     
    dictht ht[2];               /*  Hash 表的数组，键值对存储在这里，一般情况下只会使用ht[0]，只有当盖子点扩容、缩容需要进行rehash ，才会使用到ht[1]*/     
    long rehashidx;            /*rehash标识。默认值为-1，代表没进行rehash操作；不为-1时，代表正进行rehash操作，存储的值表示Hash表ht[0]的rehash操作进行到了哪个索引值*/     
    unsigned long iterators; /* 当前运行的迭代器数*/ 
} dict;
</code></pre>

<p>Redis字典这个数据结构，除了主数据库的K-V数据存储外，还有很多其他地方会用到。例如，Redis的哨兵模式，就用字典存储管理所有的Master节点及Slave节点；再如，数据库中键值对的值为Hash类型时，存储这个Hash类型的值也是用的字典。在不同的应用中，字典中的键值对形态都可能不同，而dictType结构体，则是为了实现各种形态的字典而抽象出来的一组操作函数。</p>

<p>Redis 字典结构的完整版<br/>
<img src="media/15930711977940/15933377033789.jpg" alt=""/></p>

<p><strong><em>在Hash 表扩容或者收缩的时候，程序需要将现有的哈希表中的所有键值对rehash 到新的 Hash表里面，此rehash 过程不是一次性完成的，而是渐进式的完成。</em></strong></p>

<h3 id="toc_13">整数集合</h3>

<h3 id="toc_14">quicklist</h3>

<h3 id="toc_15">stream</h3>

<hr/>

<h2 id="toc_16">三、Redis数据类型</h2>

<p>Redis可以存储键与 5 种不同数据结构类型之间映射的数据，这 5 种数据结构类型分别为 string(字符串)、list(列表)、set(集合)、zset(有序集合)、hash(散列)。</p>

<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>

<tbody>
<tr>
<td>string</td>
<td>可以使字符串、整数或者浮点数</td>
<td>对整个字符串或字符串的一部分执行操作；对证书和浮点数执行自增、自减操作</td>
</tr>
<tr>
<td>list</td>
<td>底层由链表实现，每个节点都包含一个字符串</td>
<td>从列表的两端推入或者弹出元素；根据偏移量对列表进行修改；读取单个或多个元素；根据值查询或者移除元素</td>
</tr>
<tr>
<td>set</td>
<td>不重复的无序集合</td>
<td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素</td>
</tr>
<tr>
<td>zset</td>
<td>不可重复的有序集合，字符串成员(member)于浮点数分支(score)之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td>添加、获取、移除单个元素；根据分值范围(range)或者成员来获取元素</td>
</tr>
<tr>
<td>hash</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对；获取所有键值对</td>
</tr>
</tbody>
</table>

<p><strong>关于key的几条建议</strong></p>

<ul>
<li>不建议太长的键值，原因：1、消耗内存；2、这类键值计算成本很高</li>
<li>不建议太短的键值，设计键值要有良好的可读性，太短的话，看不懂就有点尴尬了</li>
<li>最好有一个相对固定的键值模式，比如这样的模式： 业务名:对象名:id:[属性] ，业务有销售订单、采购订单，销售订单的键值可以是： sale:order:100:orderId这样的</li>
</ul>

<h3 id="toc_17">Redis 中的 string 字符串</h3>

<p>字符串在Redis中是以key-value形式存储在redisDb的dict中的。</p>

<p>字符串的key经过Hash 之后作为dict的键，只能是string类型，字符串的value是dict的值，用结构体robj来表示。字符串值robj的type值为OBJ_STRING。当字符串值是string类型时，encoding的值根据字符串的长短分别为OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR；当字符串值是long类型时，encoding的值为OBJ_ENCODING_INT。</p>

<h3 id="toc_18">Redis 中的 list 列表</h3>

<p>列表使用快速链表（quicklist）数据结构存储，而快速链表是双向链表与压缩列表 ziplist 的组合。</p>

<p>链表广泛应用于实现 Redis 的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</p>

<h4 id="toc_19">Redis 链表结构如下：</h4>

<pre class="line-numbers"><code class="language-c">typedef struct listNode{
//前置节点
struct listNode *prev
//后置节点
struct listNode *next
// 节点值
void *value
}
</code></pre>

<h4 id="toc_20">Redis 链表实现的特性</h4>

<ul>
<li>双端<br/>
链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</li>
<li>无环<br/>
表 头结点的prev指针和表尾的next指针都指向null，对链表的访问以null为终点</li>
<li>带表头指针和表尾指针<br/>
通过list结构的head指针和tail指针，程序获取链表的头结点和尾结点的复杂度为O(1)</li>
<li>带链表长度计数器<br/>
程序使用list结构的len属性来对list吃鱼哦的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)</li>
<li>多态<br/>
链表节点使用void* 指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于存放各种不同类型的值</li>
</ul>

<h3 id="toc_21">Redis 中的 set 集合</h3>

<h3 id="toc_22">Redis 中的 zset 集合</h3>

<p>当有序集合或散列表的元素个数比较少，且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储结构，<br/>
跳跃表是 Redis 有序集合的底层实现之一，所以每个节点的 ele 存储的有序集合成员 member 值，score 存储成员 score 值。所有节点的分支是按从小到大的方式排序的，当有序集合的成员分值相同时，节点会按照 member 的字典序进行排序。</p>

<hr/>

<h2 id="toc_23">第三节、redis命令</h2>

<p>Redis 服务的相关命令十分丰富，有种头疼的感觉，有意学习所有命令的同学查看网址<a href="http://www.redis.cn/commands.html">redis命令中心</a>，下面只记录一些常用的命令</p>

<h3 id="toc_24">Redis 通用命令</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>keys parttern</td>
<td>查看所有键</td>
<td>keys *</td>
<td>Redis存在大量键时，禁止使用此命令</td>
</tr>
<tr>
<td>hscan</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>dbsize</td>
<td>查看键总数</td>
<td>dbsize</td>
<td>Redis存在大量键时，禁止使用此命令</td>
</tr>
<tr>
<td>expire key seconds</td>
<td>设置键的过期时间</td>
<td>expire mykey 10</td>
<td>mykey键值对 10秒后过期</td>
</tr>
<tr>
<td>persist key</td>
<td>删除key的过期时间，使key长期有效</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ttl [key]</td>
<td>查看键所剩的过期时间</td>
<td>ttl mykey</td>
<td>查看设置过期时间的键所剩过期时间还有几秒</td>
</tr>
<tr>
<td>exists key</td>
<td>查看key是否存在</td>
<td></td>
<td></td>
</tr>
<tr>
<td>flushall</td>
<td>清除所有库的数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>flushdb dbIndex</td>
<td>清除指定index的库</td>
<td></td>
<td></td>
</tr>
<tr>
<td>select dbIndex</td>
<td>选定指定dbIndex的库</td>
<td></td>
<td></td>
</tr>
<tr>
<td>type [key]</td>
<td>查看键的数据结构类型</td>
<td>type mykey</td>
<td>键不存在返回 nil</td>
</tr>
<tr>
<td>OBJECT  help/refcount/encoding/idletime/freq key</td>
<td>查看数据库的值对象编码</td>
<td>object e</td>
<td>help ：帮助命令，object命令使用手册。refcount ：获得指定键关联的值的引用数，即redisObject对象refcount属性。encoding ：获得指定键关联的值的内部存储使用的编码，即redisObject对象encoding属性的字符串表达。idletime ：返回键的空闲时间，即自上次读写键以来经过的近似秒数。freq ：返回键的对数访问频率计数器。当maxmemory-policy设置为LFU策略时，此子命令可用。</td>
</tr>
<tr>
<td>rename key newkey</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>renamenx key newkey</td>
<td>重命名后的key不存在时才能执行成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td>scan cursor [MATCH parttern] [COUNT count]</td>
<td></td>
<td></td>
<td>scan命令和hscan、sscan、zscan命令都用于增量迭代，每次只返回少量数据，不会有像keys命令堵塞服务器的隐患</td>
</tr>
<tr>
<td>randomkey</td>
<td>随机取键</td>
<td></td>
<td></td>
</tr>
<tr>
<td>del key [key ...</td>
<td>同步方式删除键 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unlink key [key ...]</td>
<td>根据删除的工作量决定使用同步方式还是异步方式删除键 key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dump key</td>
<td>序列化key并返回序列化后的数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td>restore key ttl serialized-value [replace]</td>
<td>反序列化serialized-value，并与key关联</td>
<td></td>
<td></td>
</tr>
<tr>
<td>move key dbIndex</td>
<td>将key移动到另一个数据库</td>
<td>move mykey 3</td>
<td>移动mykey到3号数据库</td>
</tr>
<tr>
<td>migrate</td>
<td>将指定 key 迁移到另一个 Redis 实例</td>
<td></td>
<td>用于运维数据迁移数据</td>
</tr>
<tr>
<td>sort key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]</td>
<td>对列表、集合或有序集合中的元素进行排序，返回或保存List、Set、Zset类型的key中排序后的元素</td>
<td></td>
<td>·BY： 使用其他键的值作为权重进行排序，如果其他键不存在则跳过排序。·LIMIT： 限定排序返回的元素。·GET： 跟BY作用相反，将排序结果作为权重来排序匹配的其他键，可多次使用。·ASC/DESC： 正序/倒序排序。·ALPHA： 对字符串进行排序，默认使用数字排序。·STORE： 将排序后的结果保存到指定的键。</td>
</tr>
</tbody>
</table>

<p>设置临时密码：</p>

<pre class="line-numbers"><code class="language-cmd">config set requirepass 123456 
</code></pre>

<h3 id="toc_25">string 相关命令</h3>

<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>设置</td>
<td>SET key value [NX] [XX] [EX seconds] [PX milliseconds]</td>
<td>设置存储在给定键中的值</td>
<td>set mykey  myvalue</td>
<td>·NX： 当数据库中key不存在时，可以将key-value添加到数据库。·XX： 当数据库中key存在时，可以将key-value设置到数据库，与NX参数互斥。·EX： key的超时秒数。·PX： key的超时毫秒数，与EX参数互斥。</td>
</tr>
<tr>
<td>设置</td>
<td>mset key value [key value ...]</td>
<td>设置多个key-value，如果key之前存在，则使用新的value进行覆盖</td>
<td>mset idear1 eat idear2 play</td>
<td>设置键值对 idear1 : ear 、 idear2  : play</td>
</tr>
<tr>
<td>设置</td>
<td>setex key second value</td>
<td>设置key-value并设置过期时间(单位：秒)</td>
<td>setex mykey 10  hungry</td>
<td>设置的mykey : hungry 10秒钟后过期，10秒后get mykey 返回 nil；</td>
</tr>
<tr>
<td>设置</td>
<td>setnx key value</td>
<td>只有key不存在时才会设置key-value</td>
<td>setnx mykey myvalue</td>
<td>如果mykey不存在则设置，如果存在不执行覆盖操作</td>
</tr>
<tr>
<td>设置</td>
<td>msetnx key value [key value ...]</td>
<td>当所有的key都不存在时才会设置这些key-value</td>
<td>msetnx mykey1 myvalue1 mykey2 myvalue2</td>
<td>所有的key都不存在设置这些个key-value</td>
</tr>
<tr>
<td>获取</td>
<td>get key</td>
<td>获取存储在给定键中的值</td>
<td>get mykey</td>
<td>返回myvalue</td>
</tr>
<tr>
<td>获取</td>
<td>mget key [key...]</td>
<td>获取多个key</td>
<td>mget mykey1 mykey2</td>
<td>获取mykey1、mykey2的值</td>
</tr>
<tr>
<td>获取</td>
<td>getrange key start end</td>
<td>获取存储在给定键中的值的某一段</td>
<td>get mykey 0 -2</td>
<td>返回myvalue 值递第一位置至倒数第二位置的value 值</td>
</tr>
<tr>
<td>获取</td>
<td>strlen</td>
<td>获取指定key的长度</td>
<td>strlen mykey</td>
<td>复杂度为O(1)</td>
</tr>
<tr>
<td>修改</td>
<td>append key value</td>
<td>追加一个值到key上</td>
<td>append mykey tony</td>
<td>添加完tony之后运行get mykey 得到结果 myvalue tony</td>
</tr>
<tr>
<td>修改</td>
<td>decr key</td>
<td>整数原子减 1</td>
<td>decr mykey</td>
<td>如果mykey原先不存在，在减1之前，age会被置为0</td>
</tr>
<tr>
<td>修改</td>
<td>decrby key decrement</td>
<td>整数原子减指定整数</td>
<td>decrby mykey</td>
<td>如果mykey原先不存在，在减decrement之前，mykey会被置为0</td>
</tr>
<tr>
<td>修改</td>
<td>incr key</td>
<td>整数原子加1</td>
<td>incr mykey</td>
<td>如果mykey原先不存在，在加1之前mykey会被置为0</td>
</tr>
<tr>
<td>修改</td>
<td>incrby key increment</td>
<td>整数原子加指定整数</td>
<td>incrby mykey 10</td>
<td>如果mykey原先不存在，在加increment之前mykey会被置为0</td>
</tr>
<tr>
<td>修改</td>
<td>setrange key offset value</td>
<td>覆盖key的value的offset之后的字符串</td>
<td>setrange mykey 2 qu</td>
<td>mykey之前的值是woca，执行此命令之后的结果就是woqu</td>
</tr>
<tr>
<td>通用</td>
<td>del key</td>
<td>删除存储在给定键中的值</td>
<td>del mykey</td>
<td>删除 mykey 键</td>
</tr>
</tbody>
</table>

<p>此外还有一种字符串的位操作：<br/>
位操作是高级语言的基础，Redis提供了位设置、操作、统计等命令，这些命令主要包括setbit、getbit、bitpos、bitcount、bittop 和 bitfield。抽空在补这部分内容  TODO。</p>

<h3 id="toc_26">list 相关命令</h3>

<p>Redis列表对象的底层数据结构是quicklist，下面看下list 列表的相关命令<br/>
每条命令操作之前 myList被设置为[list3,list2,list1]</p>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>blpop key [key ...] timeout</td>
<td>lpop的阻塞版本</td>
<td>blpop myList 0</td>
<td>调用返回key和左边第一个元素的组合 myList、list3</td>
</tr>
<tr>
<td>brpop key [key ...] timeout</td>
<td>rpop的阻塞版本</td>
<td>brpop myList</td>
<td>没元素的话阻塞在key的列表上</td>
</tr>
<tr>
<td>lindex key index</td>
<td>通过列表索引获取key列表的value值, index  0：表示第一个元素； -1：表示最后一个元素；-2 ：表示倒数第二个原始</td>
<td>lindex myList 0</td>
<td>返回list3</td>
</tr>
<tr>
<td>linsert key before/after pivot value</td>
<td>把value插入myList 列表中在元素的的前面或后面</td>
<td>linsert myList before  list2 beauty</td>
<td>返回[list3,beauty,list2,list1]</td>
</tr>
<tr>
<td>llen key</td>
<td>获得列表的长度</td>
<td>llen myList</td>
<td>返回3</td>
</tr>
<tr>
<td>lpop key</td>
<td>从队列的左边出队并返回一个元素，列表为空时返回nil</td>
<td>lpop myList</td>
<td>返回并删除了第一个元素list3</td>
</tr>
<tr>
<td>lpush key value [value ...]</td>
<td>从队列的左边入队一个或多个元素</td>
<td>lpush myList list4 list 5</td>
<td>value按照先后顺序插入到列表头，最后列表元素[list5,list4,list3,beauty,list2,list1]</td>
</tr>
<tr>
<td>lpushx key vlaue</td>
<td>当列表存在时，从列表左边入队一个元素</td>
<td>lpushx myList1  hello</td>
<td>myList1 不存在 元素插入不成功</td>
</tr>
<tr>
<td>lrange key startIndex stopIndex</td>
<td>从列表中获取指定位置范围内的元素</td>
<td>lrange myList 0 1</td>
<td>结果[list3,list2]</td>
</tr>
<tr>
<td>lrem key count value</td>
<td>从存于key的列表中移除前count个的值为value的元素，count&gt;0 :从头向尾移除置为value的元素；count&lt;0: 从尾向头移除置为value的元素；count=0： 移除所有值为value的元素</td>
<td>lrem myList 1 list2</td>
<td>[list3,list1]</td>
</tr>
<tr>
<td>lset key index value</td>
<td>设置列表里面的index位置的元素值</td>
<td>lset myList 2 ghost</td>
<td>列表更新为[list3,list2,ghost]</td>
</tr>
<tr>
<td>ltrim key start stop</td>
<td>修剪并保留指定范围内的元素</td>
<td>ltrim myList 1 2</td>
<td>列表被编辑为 [list2,list1]</td>
</tr>
<tr>
<td>rpop key</td>
<td>从列表右边出队并返回一个元素，列表为空时返回nil</td>
<td>rpop myList</td>
<td>列表被编辑为 [list3,list2]</td>
</tr>
<tr>
<td>rpush key value [value ...]</td>
<td>从列表右边入队一个或多个元素</td>
<td>rpush myList niu</td>
<td>列表被编辑为 [list3,list2,list1,niu]</td>
</tr>
<tr>
<td>rpushx key value</td>
<td>列表如果存在，则从列表右边入队一个元素</td>
<td>rpushx myList leng</td>
<td>列表被编辑为 [list3,list2,list1,leng]，如果myList不存在，啥都不干</td>
</tr>
</tbody>
</table>

<h3 id="toc_27">set 相关命令</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
</tbody>
</table>

<h3 id="toc_28">zset 相关命令</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
</tbody>
</table>

<h3 id="toc_29">hash 相关命令</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>

<tbody>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis快速入门]]></title>
    <link href="http://www.throne4j.com/15929223279523.html"/>
    <updated>2020-06-23T22:25:27+08:00</updated>
    <id>http://www.throne4j.com/15929223279523.html</id>
    <content type="html"><![CDATA[
<p>此 Redis服务 采用 5.0+版本</p>

<h2 id="toc_0">redis简介</h2>

<p>redis是一个使用ANSI C语言编写的开源的基于内存的key-value高性能非关系型缓存数据库，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询，stream。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>

<h3 id="toc_1">Redis5.0版本新特性</h3>

<ul>
<li>新增Streams数据类型，可以把 Streams 当做消息队列</li>
<li>新的模块 API 、定时器、集群集资点</li>
<li>RDB 中持久化存储 LFU 和 LRU 的信息</li>
<li>将集群管理功能完全用C语言集成到 redis-cli 中</li>
<li> 有序集合新增命令 zpopmin/zpopmax</li>
<li> 改进HyperLogLogs实现</li>
<li> 新增 client unblock 和 client id</li>
<li> 新增 lolwut 命令</li>
<li> Redis主从复制中的从 不在成为Slaves，改称 Replicas</li>
<li>引入动态哈希，一平衡 CPU 的利用率和相应性能，可以通过配置文件进行配置</li>
<li>Redis 核心代码新型了部分重构和优化</li>
</ul>

<h2 id="toc_2">Redis 可执行文件介绍</h2>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>redis-server</td>
<td>启动redis</td>
</tr>
<tr>
<td>redis-cli</td>
<td>redis命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>基准测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>AOF持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-rdb</td>
<td>RDB持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>启动哨兵</td>
</tr>
<tr>
<td>redis-trib</td>
<td>cluster集群构建工具</td>
</tr>
</tbody>
</table>

<h2 id="toc_3">为什么使用 Redis</h2>

<ul>
<li>读写速度快<br/>
数据存放在内存中，官方给出的读写性能可达到 10w/s
<ul>
<li>数据存放在内存中是速度快的主要原因</li>
<li>C语言实现，与操作系统的距离近</li>
<li>Redis 数据结构是专门设计的，增删改查等操作相对简单</li>
<li>使用了单线程架构
<ul>
<li>避免多线程可能产生的线程切换和竞争产生的资源消耗；</li>
<li>采用多路复用IO模型（select、poll、epoll）可以高效的处理大量并发连接；<br/>
Redis 命令的执行过程： 发送指令 --&gt; 执行指令 --&gt; 返回结果；<br/>
执行指令： 单线程执行，所有的指令进入队列，按顺序执行，使用I/O多路复用技术解决一个线程处理多个连接的问题。</li>
</ul></li>
</ul></li>
<li>键值对的value不仅可以是字符串，还可以是复杂的数据类型，如链表、集合、散列表等<br/></li>
<li>丰富的功能  发布订阅、主从复制、持久化、脚本、事务等功能</li>
<li>支持数据持久化，可以采用RDB、AOF、RDB&amp;AOF三种方案。计算机重启后可以在磁盘中进行数据恢复。 <br/>
发生断电或机器故障，数据可能会丢失，持久化到磁盘</li>
<li> 支持主从结构，可以利用从库进行数据备份<br/>
实现了多个相同数据的Redis副本，提高了系统的健壮性</li>
<li>高可用和分布式<br/>
哨兵机制实现高可用，保证redis节点故障发现和自动转移</li>
<li>有多种语言的客户端</li>
</ul>

<h2 id="toc_4">Redis与其他数据库之间的比较</h2>

<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>存储数据类型</th>
<th>查询类型</th>
<th>附加功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>redis</td>
<td>使用内存存储的非关系型数据库</td>
<td>字符串、列表、散列表、集合、有序集合</td>
<td>每种数据类型都有自己专属命令，另外还有批量操作和不完全的事务支持</td>
<td>发布订阅、主从复制、持久化、脚本(存储过程)</td>
</tr>
<tr>
<td>memcached</td>
<td>使用内存存储的键值缓存</td>
<td>键值之间的映射</td>
<td>创建、读取、更新、删除以及其他几个命令</td>
<td>为提升性能而设计的多线程服务器</td>
</tr>
<tr>
<td>MySql</td>
<td>关系型数据库</td>
<td>每个数据库可以包含多个表，每个表可以包含多行，可以处理多表视图，支持空间和第三方支持</td>
<td>insert、select、update、delete、函数、存储过程</td>
<td>支持ACID性质、主从复制、多主复制</td>
</tr>
<tr>
<td>MongoDB</td>
<td>使用硬盘存储的非关系的文档存储</td>
<td>每个数据库可以包含多个表，每个表可以包含无schema的BSON文档</td>
<td>创建、读取、更新、删除、条件查询命令</td>
<td>支持map-reduce操作、主从复制、分片、空间索引</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">Redis的使用场景</h2>

<p>redis的应用场景可以肆意的发挥想象力，以下是Redis 较为适用的一些场景</p>

<ul>
<li>缓存<br/>
例如session缓存、全页缓存、合理使用缓存加快数据访问速度，降低后端数据源压力</li>
<li>排行榜<br/>
按照热度、发布时间排行，主要用到列表和有序集合</li>
<li>计数器  网站的浏览数等</li>
<li>社交网络</li>
<li>消息队列  发布订阅</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://www.throne4j.com/15929200774650.html"/>
    <updated>2020-06-23T21:47:57+08:00</updated>
    <id>http://www.throne4j.com/15929200774650.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[布隆过滤器原理]]></title>
    <link href="http://www.throne4j.com/15928436000448.html"/>
    <updated>2020-06-23T00:33:20+08:00</updated>
    <id>http://www.throne4j.com/15928436000448.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java 语法树]]></title>
    <link href="http://www.throne4j.com/15925048146279.html"/>
    <updated>2020-06-19T02:26:54+08:00</updated>
    <id>http://www.throne4j.com/15925048146279.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005]]></title>
    <link href="http://www.throne4j.com/15925030861213.html"/>
    <updated>2020-06-19T01:58:06+08:00</updated>
    <id>http://www.throne4j.com/15925030861213.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM 类加载机制]]></title>
    <link href="http://www.throne4j.com/15922073766854.html"/>
    <updated>2020-06-15T15:49:36+08:00</updated>
    <id>http://www.throne4j.com/15922073766854.html</id>
    <content type="html"><![CDATA[
<p>JVM 类加载机制分为五个部分<br/>
<img src="media/15922073766854/15922110200798.jpg" alt=""/></p>

<h2 id="toc_0">加载</h2>

<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的入口。<br/>
此阶段完成三件事。</p>

<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流(可以来自zip、war等压缩包，网络，动态生成，数据库等)。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>

<p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成。</p>

<p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在 内存中动态构造出来的。但是数组的元素类型还是需要通过类加载器来完成加载。</p>

<ul>
<li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标 识在加载该组件类型的类加载器的类名称空间上(一个类型必须与类加 载器一起确定唯一性)</li>
<li>如果数组的组件类型不是引用类型(例如int[]数组的组件类型为int)，Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ul>

<h2 id="toc_1">验证</h2>

<p>确保Class文件的字节流中包含的信息是否符合当前虚拟机要求.</p>

<ul>
<li>class文件格式验证</li>
<li><p>元数据验证</p>
<ul>
<li>这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)。</li>
<li>这个类的父类是否继承了不允许被继承的类(被final修饰的类)。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等)。</li>
</ul></li>
<li><p>字节码验证<br/>
主要目的是通过数据流分析和控制流分析，确定 程序语义是合法的、符合逻辑的</p></li>
<li><p>符号引用验证</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性(private、protected、public、<package>)是否可被当 前类访问。<br/>
阶段的校验行为发生在虚拟机将符号引用转化为直接引用[3]的时候，这个转化动作将在 连接的第三阶段——解析阶段中发生,此阶段的目的是保证解析能够正常执行。</li>
</ul></li>
</ul>

<h2 id="toc_2">准备</h2>

<p>准备阶段是正式为类中定义的<strong>变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值</strong>的阶段。</p>

<p><strong><em>注意</em></strong> ： 关于准备阶段，还有两个容易产生混淆的概念笔者需要着重强调，首先是这时候进行内存分配的 仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，</p>

<h2 id="toc_3">解析</h2>

<p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>

<ul>
<li><p>符号引用<br/>
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（class文件中的CONSTANT_CLASS_INFO、CONSTANT_FIELD_INFO、CONSTANT_METHOD_INFO等类型的常量），符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。<br/>
各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的Class文件格式中</p></li>
<li><p>直接引用：可以是执行目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标必定已经存在于内存中。</p></li>
</ul>

<h2 id="toc_4">初始化</h2>

<p>类加载阶段 的最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都有jvm主导，到了初始化阶段，才开始真正执行类中定义的java程序代码。</p>

<p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变 量的赋值操作和静态语句块中的语句合并而成的。<strong>虚拟机会保证子<client>方法执行之前，父类 的<client>方法已经执行完毕</strong></p>

<h3 id="toc_5">有且只有以下<strong>六种对类型进行主动引用的情况需要立即对类进行初始化</strong>：</h3>

<ul>
<li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先出法器初始化阶段。</p>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候</li>
<li><strong>调用一个类型的静态方法的时候</strong></li>
</ul></li>
<li><p>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发器初始化</p></li>
<li><p>当初始化类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化</p></li>
<li><p>当虚拟机启动时，用户需要制定一个要执行的主类(包含main()方法的哪个类)，虚拟机会先初始化这个主类</p></li>
<li><p>当使用 jdk7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_p utStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，需要先触发其初始化</p></li>
<li><p>当一个接口中定义了jdk8新加入的默认方法(被default关键字修饰的接口方法)时，如果有这个接口的实现类发生了初始化，那该接口在其之前被初始化。</p></li>
</ul>

<hr/>

<h3 id="toc_6">以下几种 对类型的被动引用情况不会执行类初始化：</h3>

<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化</li>
<li>通过对象数组，不会触发该类的初始化</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类</li>
<li>通过类名获取Class对象，不会触发类的初始化</li>
<li>通过Class.forName加载指定类是，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化</li>
<li>通过ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://www.throne4j.com/15917994951575.html"/>
    <updated>2020-06-10T22:31:35+08:00</updated>
    <id>http://www.throne4j.com/15917994951575.html</id>
    <content type="html"><![CDATA[
<p>WebMvcConfigurer<br/>
跨域--&gt; WebMvcConfigurer#addCorsMappings(CorsRegistry registry)</p>

<p>HandlerInterceptor<br/>
WebRequestInterceptor</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#addDefaultHttpMessageConverters</p>

<hr/>

<p>WebMvcConfigurationSupport#requestMappingHandlerMapping</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcPathMatcher</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcUrlPathHelper</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcContentNegotiationManager</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#viewControllerHandlerMapping</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#beanNameHandlerMapping</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#resourceHandlerMapping</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcResourceUrlProvider</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#defaultServletHandlerMapping</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerAdapter</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcConversionService</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcValidator</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcUriComponentsContributor</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#httpRequestHandlerAdapter</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#simpleControllerHandlerAdapter</p>

<p><strong>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#handlerExceptionResolver</strong></p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcViewResolver</p>

<p>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#mvcHandlerMappingIntrospector</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观察者模式]]></title>
    <link href="http://www.throne4j.com/15917825632729.html"/>
    <updated>2020-06-10T17:49:23+08:00</updated>
    <id>http://www.throne4j.com/15917825632729.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">观察者模式定义</a>
</li>
<li>
<a href="#toc_1">观察者模式结构</a>
<ul>
<li>
<a href="#toc_2">优点</a>
</li>
<li>
<a href="#toc_3">缺点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">代码示例</a>
</li>
<li>
<a href="#toc_5">使用场景</a>
</li>
</ul>


<h2 id="toc_0">观察者模式定义</h2>

<p>观察者模式是使用频率较高的设计模式之一。它定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。</p>

<p>观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p>

<p>观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。</p>

<h2 id="toc_1">观察者模式结构</h2>

<p>Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p>

<p>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p>

<p>Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p>

<p>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p>

<p><img src="media/15917825632729/15919534018048.jpg" alt=""/></p>

<h3 id="toc_2">优点</h3>

<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li>
<li>目标与观察者之间建立了一套触发机制</li>
<li>支持广播通信</li>
<li>符合“开闭原则”的要求</li>
</ul>

<h3 id="toc_3">缺点</h3>

<ul>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li>
</ul>

<h2 id="toc_4">代码示例</h2>

<pre class="line-numbers"><code class="language-java">
/**
 * 抽象观察者
 **/
public interface Observer {
    public void update(String message);
}

/**
 * 具体观察者
 **/
public class GuardianObserver implements Observer {

    private String name;

    public GuardianObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + &quot;-&quot; + message);
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">
/**
 * 抽象被观察者
 **/
public interface Subject {
    /**
     * 增加订阅者
     */
    public void addObserver(Observer observer);

    /**
     * 删除订阅者
     */
    public void removeObserver(Observer observer);

    /**
     * 通知订阅者更新消息
     */
    public void notifyObserver(String message);
}

/**
 * 具体的被观察者
 **/
public class SubscriptionSubject implements Subject {
    
    private List&lt;Observer&gt; guardianObserver = new ArrayList&lt;&gt;();

    @Override
    public void addObserver(Observer observer) {
        guardianObserver.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        guardianObserver.remove(observer);
    }

    @Override
    public void notifyObserver(String message) {
        for (Observer observer : guardianObserver) {
            observer.update(message);
        }
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 观察者模式客户端
 **/
public class Client {
    public static void main(String[] args) {
        SubscriptionSubject mSubscriptionSubject = new SubscriptionSubject();
        //创建监护人
        GuardianObserver user1 = new GuardianObserver(&quot;孩儿他爹&quot;);
        GuardianObserver user2 = new GuardianObserver(&quot;孩儿他娘&quot;);
        // 添加监护
        mSubscriptionSubject.addObserver(user1);
        mSubscriptionSubject.addObserver(user2);
        // 通知打架的通知
        mSubscriptionSubject.notifyObserver(&quot;孩儿又在学校打架了&quot;);
    }
}
</code></pre>

<h2 id="toc_5">使用场景</h2>

<ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://www.throne4j.com/15917825462034.html"/>
    <updated>2020-06-10T17:49:06+08:00</updated>
    <id>http://www.throne4j.com/15917825462034.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">装饰者模式定义</h2>

<p>动态地给一个对象增加一些额外的职责，增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>

<p>在装饰者模式中，为了让系统具有更好的灵活性和可扩展性，我们通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类</p>

<h2 id="toc_1">装饰者模式结构</h2>

<ul>
<li><p>Component（抽象构件）<br/>
它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p></li>
<li><p>ConcreteComponent（具体构件）<br/>
它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p></li>
<li><p>Decorator（抽象装饰类）<br/>
它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p></li>
<li><p>ConcreteDecorator（具体装饰类）<br/>
它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p></li>
</ul>

<p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>

<p>装饰模式的核心在于抽象装饰类的设计。</p>

<p><img src="media/15917825462034/15919264601093.jpg" alt="" style="width:2398px;"/></p>

<h2 id="toc_2">代码示例</h2>

<pre class="line-numbers"><code class="language-java">/**
 * 抽象车辆,组件间、装饰者、被装饰者的超类
 * 抽象构件
 **/
@Data
public abstract class AbsCar {
    /**
     * 车辆描述
     */
    public abstract String getDescription();

    /**
     * 价格
     */
    public abstract double cost();
}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 被装饰的对象
 * 具体构件
 **/
public class NormalCar extends AbsCar{

    @Override
    public String getDescription() {
        return &quot;破车一两&quot;;
    }

    @Override
    public double cost() {
        return 100;
    }
}

</code></pre>

<pre class="line-numbers"><code class="language-java">
/**
 * 抽象装饰类
 **/
public abstract class AbsDecorator extends AbsCar {

    private AbsCar absCar;

    public AbsDecorator(AbsCar absCar) {
        this.absCar = absCar;
    }

    @Override
    public String getDescription() {
        return this.absCar.getDescription();
    }

    @Override
    public double cost() {
        return this.absCar.cost();
    }

    protected abstract void doSomething();

}


/**
 * 发动机装饰
 * 具体装饰类
 **/
public class EngineDecorator extends AbsDecorator {

    public EngineDecorator(AbsCar absCar) {
        super(absCar);
    }

    @Override
    protected void doSomething() {
        System.out.println(getDescription());
    }

    @Override
    public String getDescription() {
        return super.getDescription() +&quot; 更换V8发动机&quot;;
    }

    @Override
    public double cost() {
        return super.cost()+ 100000;
    }
}


/**
 * 外观装饰
 **/
public class OutWardDecorator extends AbsDecorator {
    public OutWardDecorator(AbsCar absCar) {
        super(absCar);
    }

    @Override
    public String getDescription() {
        return super.getDescription() +&quot; 重新喷漆&quot;;
    }

    @Override
    public double cost() {
        return super.cost()+10000;
    }

    @Override
    protected void doSomething() {
        System.out.println(getDescription());
    }
}

</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 装饰者客户端
 **/
public class DecoratorClient {
    public static void main(String[] args) {
        NormalCar normalCar = new NormalCar();
        EngineDecorator engineDecorator = new EngineDecorator(normalCar);
        OutWardDecorator outWardDecorator = new OutWardDecorator(engineDecorator);
        outWardDecorator.doSomething();

    }
}
</code></pre>

<h2 id="toc_3">装饰者模式的类型</h2>

<p>装饰者模式有可分为 透明装饰模式 与 半透明装饰模式</p>

<p>(1) 透明装饰模式<br/>
在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。</p>

<p>(2) 半透明装饰模式<br/>
透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不 <strong>用具体装饰类型来定义装饰之后的对象</strong>，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。<br/>
上面的代码示例是一种半透明装饰模式。</p>

<h2 id="toc_4">装饰模式注意事项</h2>

<p>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</p>

<p>(2) 尽量保持具体构件类是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</p>

<p>(3) 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。</p>

<h2 id="toc_5">jdk IO中的装饰模式</h2>

<p><img src="media/15917825462034/15919491694110.jpg" alt=""/></p>

<p><img src="media/15917825462034/15919493101153.jpg" alt=""/><br/>
<img src="media/15917825462034/15919493357557.jpg" alt=""/><br/>
<img src="media/15917825462034/15919493571997.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[责任链模式]]></title>
    <link href="http://www.throne4j.com/15917825334671.html"/>
    <updated>2020-06-10T17:48:53+08:00</updated>
    <id>http://www.throne4j.com/15917825334671.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">责任链模式定义</h2>

<p>责任链模式是一种<strong>行为设计模式</strong>，使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系</p>

<p>允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>

<p>用图例来表示的话如下图所示：<br/>
<img src="media/15917825334671/15918442545791.jpg" alt=""/></p>

<h2 id="toc_1">责任链模式结构</h2>

<ul>
<li><p>Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</p></li>
<li><p>ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p></li>
</ul>

<p><img src="media/15917825334671/15918572263532.jpg" alt=""/></p>

<p>纯的责任链模式：</p>

<ul>
<li>一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况</li>
<li>一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li>
</ul>

<p>不纯的责任链模式：</p>

<ul>
<li>允许某个请求被一个具体处理者部分处理后再向下传递</li>
<li>或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li>
<li>而且一个请求可以最终不被任何处理者对象所接收</li>
</ul>

<h3 id="toc_2">优缺点</h3>

<ul>
<li><p>职责链模式的主要优点</p>
<ul>
<li>对象仅需知道该请求会被处理即可，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接</li>
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以在运行时对该链进行动态的增删改，改变处理一个请求的职责</li>
<li>新增一个新的具体请求处理者时无须修改原有代码，只需要在客户端重新建链即可，符合 &quot;开闭原则&quot;</li>
</ul></li>
<li><p>职责链模式的主要缺点</p>
<ul>
<li>一个请求可能因职责链没有被正确配置而得不到处理</li>
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，且不方便调试</li>
<li>可能因为职责链创建不当，造成循环调用，导致系统陷入死循环</li>
</ul></li>
</ul>

<h2 id="toc_3">实例代码</h2>

<pre class="line-numbers"><code class="language-java">
/**
 * 抽象处理类
 **/
@Data
public abstract class Handler {
    protected String name; // 处理者姓名
    protected Handler nextHandler;  // 下一个处理者

    public Handler(String name) {
        this.name = name;
    }

    public Handler(String name, Handler nextHandler) {
        this.name = name;
        this.nextHandler = nextHandler;
    }

    public abstract boolean process(LeaveRequest leaveRequest); // 处理请假
}
</code></pre>

<pre class="line-numbers"><code class="language-java">
/**
 * 主管处理这
 **/
public class DirectorHandler extends Handler {
    public DirectorHandler(String name) {
        super(name);
    }

    public DirectorHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;主管&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        if (!result) {  // 不批准
            return false;
        } else if (leaveRequest.getNumOfDays() &lt; 3) { // 批准且天数小于3，返回true
            return true;
        }
        return nextHandler.process(leaveRequest);   // 批准且天数大于等于3，提交给下一个处理者处理
    }
}

</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 经理
 **/
public class ManagerHandler extends Handler {
    public ManagerHandler(String name) {
        super(name);
    }

    public ManagerHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        if (!result) {  // 不批准
            return false;
        } else if (leaveRequest.getNumOfDays() &lt; 7) { // 批准且天数小于7
            return true;
        }
        return nextHandler.process(leaveRequest);   // 批准且天数大于等于7，提交给下一个处理者处理
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">
/**
 * 总经理
 **/
public class TopManagerHandler extends Handler {
    public TopManagerHandler(String name) {
        super(name);
    }

    public TopManagerHandler(String name, Handler nextHandler) {
        super(name, nextHandler);
    }

    @Override
    public boolean process(LeaveRequest leaveRequest) {
        boolean result = (new Random().nextInt(10)) &gt; 3; // 随机数大于3则为批准，否则不批准
        String log = &quot;总经理&lt;%s&gt; 审批 &lt;%s&gt; 的请假申请，请假天数： &lt;%d&gt; ，审批结果：&lt;%s&gt; &quot;;
        System.out.println(String.format(log, this.name, leaveRequest.getName(), leaveRequest.getNumOfDays(), result ? &quot;批准&quot; : &quot;不批准&quot;));

        // 总经理不批准
        return result;// 总经理最后批准
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 请求
 **/
@Data
@AllArgsConstructor
public class LeaveRequest {
    private String name;    // 请假人姓名
    private int numOfDays;  // 请假天数
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public class ChainClient {
    public static void main(String[] args) {
        Handler topManagerHandler = new TopManagerHandler(&quot;狗蛋&quot;);
        Handler managerHandler = new ManagerHandler(&quot;饭桶&quot;, topManagerHandler);
        Handler directorHandler = new DirectorHandler(&quot;事妈&quot;, managerHandler);
        directorHandler.process(new LeaveRequest(&quot;窦娥&quot;, 3));
    }
}
</code></pre>

<h2 id="toc_4">适用场景</h2>

<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何优雅的做数据校验-Hibernate Validator详细使用说明]]></title>
    <link href="http://www.throne4j.com/15910938991760.html"/>
    <updated>2020-06-02T18:31:39+08:00</updated>
    <id>http://www.throne4j.com/15910938991760.html</id>
    <content type="html"><![CDATA[
<p>数据校验是在平时的编码过程中常做的工作，在系统的各个层可能都要去实现一些校验逻辑，再去做业务处理。这些繁琐的校验与我们的业务代码在一块就会显得臃肿。而且这些校验通常是业务无关的。也是在工作中使用到Hibernate Validator，但却发现有人没有使用好它（竟然还能看到一些if else的校验代码...），所以在这里决定整理下关于Hibernate Validator的使用<br/>
Bean Validation 2.0（JSR 380）定义了用于实体和方法验证的元数据模型和API，Hibernate Validator是目前最好的实现，这篇主要是说Hibernate Validator的使用</p>

<h2 id="toc_0">Hibernate Validator的使用</h2>

<p>依赖<br/>
如果是Spring Boot项目，那么spring-boot-starter-web中就已经依赖hibernate-validator了</p>

<pre class="line-numbers"><code class="language-markup">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>如果是Spring Mvc，那可以直接添加hibernate-validator依赖</p>

<pre class="line-numbers"><code class="language-xml&lt;dependency&gt;">    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;6.0.17.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h2 id="toc_1">bean约束声明和验证，Validator</h2>

<p>先给我们的Java对象添加约束注解</p>

<pre class="line-numbers"><code class="language-java">@Data
@AllArgsConstructor
public class User {

    private String id;

    @NotBlank
    @Size(max = 20)
    private String name;

    @NotNull
    @Pattern(regexp = &quot;[A-Z][a-z][0-9]&quot;)
    private String password;
    
    @NotNull
    private Integer age;

    @Max(10)
    @Min(1)
    private Integer level;
}
</code></pre>

<p>验证实体实例需要先获取Validator实例</p>

<pre class="line-numbers"><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
validator = factory.getValidator();
</code></pre>

<p>Validator接口有三个方法，可用于验证整个实体或仅验证实体的单个属性</p>

<ul>
<li>Validator#validate()                   验证所有bean的所有约束</li>
<li>Validator#validateProperty()   验证单个属性</li>
<li>Validator#validateValue()         检查给定类的单个属性是否可以成功验证</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class UserTest {
    private static Validator validator;
    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void validatorTest() {
        User user = new User(null, &quot;&quot;, &quot;!@#$&quot;, null, 11);

        // 验证所有bean的所有约束
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validate(user);
        // 验证单个属性
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateProperty(user, &quot;name&quot;);
        // 检查给定类的单个属性是否可以成功验证
        Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, &quot;password&quot;, &quot;sa!&quot;);

        constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
        constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
        constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    }
}
</code></pre>

<p>测试结果</p>

<pre class="line-numbers"><code class="language-text">不能为空
最大不能超过10
需要匹配正则表达式&quot;[A-Z][a-z][0-9]&quot;
不能为null
不能为空
需要匹配正则表达式&quot;[A-Z][a-z][0-9]&quot;
</code></pre>

<h2 id="toc_2">方法约束声明和验证，ExecutableValidator</h2>

<p>从Bean Validation 1.1开始，约束不仅可以应用于JavaBean及其属性，而且可以应用于任何Java类型的方法和构造函数的参数和返回值，这里简单看一个例子</p>

<pre class="line-numbers"><code class="language-java">public class RentalStation {

    public RentalStation(@NotNull String name) {
        //...
    }

    public void rentCar(@NotNull @Future LocalDate startDate, @Min(1) int durationInDays) {
        //...
    }

    @NotNull
    @Size(min = 1)
    public List&lt;@NotNull String&gt; getCustomers() {
        //...
        return null;
    }
}
</code></pre>

<p>ExecutableValidator接口可以完成方法约束的验证</p>

<pre class="line-numbers"><code class="language-text">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();
</code></pre>

<p>该ExecutableValidator界面共有四种方法：</p>

<ul>
<li>validateParameters()和validateReturnValue()用于方法验证</li>
<li>validateConstructorParameters()和validateConstructorReturnValue()用于构造函数验证</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class RentalStationTest {

    private static ExecutableValidator executableValidator;

    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        executableValidator = factory.getValidator().forExecutables();
    }

    @Test
    public void validatorTest() throws NoSuchMethodException {
        RentalStation rentalStation = new RentalStation(&quot;z&quot;);

        Method method = RentalStation.class.getMethod(&quot;rentCar&quot;, LocalDate.class, int.class);
        Object[] parameterValues = {LocalDate.now().minusDays(1), 0};
        Set&lt;ConstraintViolation&lt;RentalStation&gt;&gt; violations = executableValidator.validateParameters(
                rentalStation, method, parameterValues);

        violations.forEach(violation -&gt; System.out.println(violation.getMessage()));
    }
}
</code></pre>

<p>测试结果</p>

<pre class="line-numbers"><code class="language-text">需要是一个将来的时间
最小不能小于1
</code></pre>

<p>约束注解<br/>
validator-api-2.0的约束注解有22个，具体我们看下面表格</p>

<p><strong>空与非空检查</strong></p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Null</td>
<td>Object</td>
<td>为null</td>
</tr>
<tr>
<td>@NotNull</td>
<td>Object</td>
<td>不为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>CharSequence</td>
<td>不为null，且必须有一个非空格字符</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>CharSequence、Collection、Map、Array</td>
<td>不为null，且不为空（length/size&gt;0）</td>
</tr>
</tbody>
</table>

<p>Boolean值检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@AssertTrue</td>
<td>boolean、Boolean</td>
<td>为true</td>
<td>为null有效</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>boolean、Boolean</td>
<td>为false</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>日期检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Future</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@FutureOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之后</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Past</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间之前</td>
<td>为null有效</td>
</tr>
<tr>
<td>@PastOrPresent</td>
<td>Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate</td>
<td>验证日期为当前时间或之前</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>数值检查</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Max</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Min</td>
<td>BigDecimal、BigInteger，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>小于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>大于或等于</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Negative</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@NegativeOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>负数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Positive</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数</td>
<td>为null有效，0无效</td>
</tr>
<tr>
<td>@PositiveOrZero</td>
<td>BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类</td>
<td>正数或零</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Digits(integer = 3, fraction = 2)</td>
<td>BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类</td>
<td>整数位数和小数位数上限</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>其他</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>@Pattern</td>
<td>CharSequence</td>
<td>匹配指定的正则表达式</td>
<td>为null有效</td>
</tr>
<tr>
<td>@Email</td>
<td>CharSequence</td>
<td>邮箱地址</td>
<td>为null有效，默认正则 &#39;.*&#39;</td>
</tr>
<tr>
<td>@Size</td>
<td>CharSequence、Collection、Map、Array</td>
<td>大小范围（length/size&gt;0）</td>
<td>为null有效</td>
</tr>
</tbody>
</table>

<p>hibernate-validator扩展约束（部分）</p>

<table>
<thead>
<tr>
<th>注解</th>
<th>支持Java类型</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>@LengthString</td>
<td>字符串长度范围</td>
<td></td>
</tr>
<tr>
<td>@Range</td>
<td>数值类型和String</td>
<td>指定范围</td>
</tr>
<tr>
<td>@URL</td>
<td>URL</td>
<td>地址验证</td>
</tr>
</tbody>
</table>

<p>自定义约束注解<br/>
除了以上提供的约束注解（大部分情况都是能够满足的），我们还可以根据自己的需求自定义自己的约束注解<br/>
定义自定义约束，有三个步骤</p>

<ul>
<li>创建约束注解</li>
<li>实现一个验证器</li>
<li>定义默认的错误信息<br/>
那么下面就直接来定义一个简单的验证手机号码的注解</li>
</ul>

<pre class="line-numbers"><code class="language-java">@Documented
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Constraint(validatedBy = {MobileValidator.class})
@Retention(RUNTIME)
@Repeatable(Mobile.List.class)
public @interface Mobile {

    /**
     * 错误提示信息，可以写死,也可以填写国际化的key
     */
    String message() default &quot;手机号码不正确&quot;;

    Class&lt;?&gt;[] groups() default {};
    
    Class&lt;? extends Payload&gt;[] payload() default {};

    String regexp() default &quot;^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$&quot;;

    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Mobile[] value();
    }
}
</code></pre>

<p>关于注解的配置这里不说了，自定义约束需要下面3个属性</p>

<ul>
<li>message 错误提示信息，可以写死,也可以填写国际化的key</li>
<li>groups 分组信息，允许指定此约束所属的验证组（下面会说到分组约束）</li>
<li>payload 有效负载，可以通过payload来标记一些需要特殊处理的操作<br/>
@Repeatable注解和List定义可以让该注解在同一个位置重复多次，通常是不同的配置（比如不同的分组和消息）<br/>
@Constraint(validatedBy = {MobileValidator.class})该注解是指明我们的自定义约束的验证器，那下面就看一下验证器的写法，需要实现javax.validation.ConstraintValidator接口</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class MobileValidator implements ConstraintValidator&lt;Mobile, String&gt; {

    /**
     * 手机验证规则
     */
    private Pattern pattern;

    @Override
    public void initialize(Mobile mobile) {
        pattern = Pattern.compile(mobile.regexp());
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }

        return pattern.matcher(value).matches();
    }
}
</code></pre>

<p>ConstraintValidator接口定义了在实现中设置的两个类型参数。第一个指定要验证的注解类（如Mobile），第二个指定验证器可以处理的元素类型（如String）；initialize()方法可以访问约束注解的属性值；isValid()方法用于验证，返回true表示验证通过<br/>
Bean验证规范建议将空值视为有效。如果null不是元素的有效值，则应使用@NotNull 显式注释<br/>
到这里我们自定义的约束就写好了，可以用个例子来测试一下</p>

<pre class="line-numbers"><code class="language-java">public class MobileTest {

    public void setMobile(@Mobile String mobile){
        // to do
    }

    private static ExecutableValidator executableValidator;

    @BeforeAll
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        executableValidator = factory.getValidator().forExecutables();
    }

    @Test
    public void manufacturerIsNull() throws NoSuchMethodException {
        MobileTest mobileTest = new MobileTest();

        Method method = MobileTest.class.getMethod(&quot;setMobile&quot;, String.class);
        Object[] parameterValues = {&quot;1111111&quot;};
        Set&lt;ConstraintViolation&lt;MobileTest&gt;&gt; violations = executableValidator.validateParameters(
                mobileTest, method, parameterValues);

        violations.forEach(violation -&gt; System.out.println(violation.getMessage()));
    }
}
</code></pre>

<p>分组约束<br/>
在上面的自定义约束中，有个groups属性是用来指定验证约束的分组，我们在为属性加上注解的时候，如果没有配置分组信息，那么默认会采用默认分组 javax.validation.groups.Default<br/>
分组是用接口定义的，用做标识，这里创建两个标识AddGroup和UpdateGroup，分别标识新增和修改<br/>
public interface AddGroup {<br/>
}</p>

<p>public interface UpdateGroup {<br/>
}<br/>
复制代码<br/>
然后对我们的User对象的id属性做分组标识</p>

<pre class="line-numbers"><code class="language-java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Null(groups = AddGroup.class)
    @NotBlank(groups = UpdateGroup.class)
    private String id;
    
    // ... 省略了其他属性
}    

我们看下如何使用
@Test
public void validatorGroupTest() {
    User user = new User();

    // 检查给定类的单个属性是否可以成功验证
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;, UpdateGroup.class);
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations2 = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;);
    Set&lt;ConstraintViolation&lt;User&gt;&gt; constraintViolations3 = validator.validateValue(User.class, &quot;id&quot;, &quot;&quot;, AddGroup.class);

    constraintViolations.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    constraintViolations2.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
    constraintViolations3.forEach(constraintViolation -&gt; System.out.println(constraintViolation.getMessage()));
}
</code></pre>

<p>上面的测试只有加了UpdateGroug分组才会验证，返回错误信息，而下面的constraintViolations2并不会去验证，因为默认会采用Default分组。如果想要不标记分组的时候，也会去验证Default分组，可以去继承默认分组</p>

<pre class="line-numbers"><code class="language-java">public interface AddGroup extends Default {
}
</code></pre>

<p>在Spring中使用Hibernate Validator<br/>
上面介绍了Validator的一些使用，还有注解的介绍，那么在Spring中我们怎么去使用Hibernate Validator做验证呢？或者说再Web项目中怎么使用Hibernate Validator？<br/>
spring-boot-starter-web中是添加了hibernate-validator依赖的，说明Spring Boot本身也是使用到了Hibernate Validator验证框架的<br/>
配置Validator</p>

<pre class="line-numbers"><code class="language-java">@Configuration
public class ValidatorConfig {

    /**
     * 配置验证器
     *
     * @return validator
     */
    @Bean
    public Validator validator() {
        ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)
                .configure()
                // 快速失败模式
                .failFast(true)
                // .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )
                .buildValidatorFactory();
        return validatorFactory.getValidator();
    }
}
</code></pre>

<p>可以通过方法 failFast(true)或 addProperty(&quot;hibernate.validator.fail_fast&quot;, &quot;true&quot;)设置为快速失败模式，快速失败模式在校验过程中，当遇到第一个不满足条件的参数时就立即返回，不再继续后面参数的校验。否则会一次性校验所有参数，并返回所有不符合要求的错误信息<br/>
如果是Spring MVC的话，需要xml配置可参考下面的配置</p>

<pre class="line-numbers"><code class="language-markup">&lt;mvc:annotation-driven validator=&quot;validator&quot;/&gt;

&lt;!-- validator基本配置 --&gt;
&lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;
    &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt;
    &lt;!-- 映射资源文件 --&gt;
    &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot; name=&quot;messageSource&quot;&gt;
    &lt;!--&lt;property name=&quot;basenames&quot;&gt;
                &lt;list&gt;
                    &lt;value&gt;classpath:messages/messages&lt;/value&gt;
                    &lt;value&gt;classpath:messages/ValidationMessages&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;--&gt;
    &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;false&quot; /&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
    &lt;property name=&quot;cacheSeconds&quot; value=&quot;60&quot; /&gt;
&lt;/bean&gt;
</code></pre>

<p>请求参数bean验证<br/>
接口上的Bean验证，需要在参数前加上@Valid或Spring的 @Validated注解，这两种注释都会导致应用标准Bean验证。如果验证不通过会抛出BindException异常，并变成400（BAD_REQUEST）响应；或者可以通过Errors或BindingResult参数在控制器内本地处理验证错误。另外，如果参数前有@RequestBody注解，验证错误会抛出MethodArgumentNotValidException异常。</p>

<pre class="line-numbers"><code class="language-java">
@RestController
public class UserController {

    @PostMapping(&quot;/user&quot;)
    public R handle(@Valid @RequestBody User user, BindingResult result) {
        // 在控制器内本地处理验证错误
        if (result.hasErrors()) {
            result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage()));
             return R.fail(result.getAllErrors().get(0).getDefaultMessage());
        }
        // ...
        return R.success();
    }

    @PostMapping(&quot;/user2&quot;)
    public R handle2(@Valid User user, BindingResult result) {
        // 在控制器内本地处理验证错误
        if (result.hasErrors()) {
            result.getAllErrors().forEach(s -&gt; System.out.println(s.getDefaultMessage()));
             return R.fail(result.getAllErrors().get(0).getDefaultMessage());
        }
        // ...
        return R.success();
    }

    /**
     * 验证不通过抛出 `MethodArgumentNotValidException`
     */
    @PostMapping(&quot;/user3&quot;)
    public R handle3(@Valid @RequestBody User user) {
        // ...
        return R.success();
    }

    /**
     * 验证不通过抛出 `BindException`
     */
    @PostMapping(&quot;/user4&quot;)
    public R handle4(@Valid User user) {
        // ...
        return R.success();
    }
}
</code></pre>

<p>配合Spring的BindingResult参数，我们是可以在控制器中去处理验证错误，不过通常也是把验证错误的消息转成我们自己的返回格式，那么在每个方法中都去做这样的验证错误处理，显然是没有必要的。我们可以利用验证不通过的异常来做统一的错误处理</p>

<pre class="line-numbers"><code class="language-java">@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * hibernate validator 数据绑定验证异常拦截
     *
     * @param e 绑定验证异常
     * @return 错误返回消息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(BindException.class)
    public R validateErrorHandler(BindException e) {
        ObjectError error = e.getAllErrors().get(0);
        log.info(&quot;数据验证异常：{}&quot;, error.getDefaultMessage());
        return R.fail(error.getDefaultMessage());
    }

    /**
     * hibernate validator 数据绑定验证异常拦截
     *
     * @param e 绑定验证异常
     * @return 错误返回消息
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public R validateErrorHandler(MethodArgumentNotValidException e) {
        ObjectError error = e.getBindingResult().getAllErrors().get(0);
        log.info(&quot;数据验证异常：{}&quot;, error.getDefaultMessage());
        return R.fail(error.getDefaultMessage());
    }
}    
</code></pre>

<p>方法参数验证<br/>
配置</p>

<p>Hibernate Validator是可以在方法级验证参数的，Spring中当然也是有实现的。<br/>
我们在Validator的配置中，添加MethodValidationPostProcessorBean，在上面的ValidatorConfig.java中添加一下配置</p>

<pre class="line-numbers"><code class="language-java">/**
 * 设置方法参数验证器
 */
@Bean
public MethodValidationPostProcessor methodValidationPostProcessor() {
    MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor();
    // 设置validator模式为快速失败返回
    postProcessor.setValidator(validator());
    return postProcessor;
}
</code></pre>

<p>如果是Spring Mvc，那么要在spring-mvc.xml中声明bean信息，不然在Controller里面是无效的</p>

<pre class="line-numbers"><code class="language-markup">&lt;!-- 设置方法参数验证器 --&gt;
&lt;bean id=&quot;methodValidationPostProcessor&quot; class=&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;&gt;
    &lt;property name=&quot;validator&quot; ref=&quot;validator&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>使用</p>

<p>配置了上面的MethodValidationPostProcessor，我们就可以在方法参数或返回值使用约束注解了，要注意的是，在要使用参数验证的类上一定要加上@Validated注解，否则无效</p>

<pre class="line-numbers"><code class="language-java">/**
 * 一定要加上 `@Validated` 注解
 */
@Validated
@RestController
public class UserController {

    @GetMapping(&quot;/user&quot;)
    public R handle(@Mobile String mobile) {
        // ...
        return R.success();
    }
}
</code></pre>

<p>如果验证不通过，会抛出ConstraintViolationException异常，同样的，我们可以在全局的异常处理器里面处理验证错误，在GlobalExceptionHandler中添加一下代码</p>

<pre class="line-numbers"><code class="language-java">/**
 * spring validator 方法参数验证异常拦截
 *
 * @param e 绑定验证异常
 * @return 错误返回消息
 */
@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(ConstraintViolationException.class)
public R defaultErrorHandler(ConstraintViolationException e) {
    Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations();
    ConstraintViolation&lt;?&gt; violation = violations.iterator().next();
    log.info(&quot;数据验证异常：{}&quot;, violation.getMessage());
    return R.fail(violation.getMessage());
}
</code></pre>

<p>分组<br/>
Spring的@Validate注解是可以支持分组验证的</p>

<pre class="line-numbers"><code class="language-java">@PostMapping(&quot;/user&quot;)
public R handle(@Validated(AddGroup.class) @RequestBody User user) {
    // ...
    return R.success();
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存一致性问题如何解决]]></title>
    <link href="http://www.throne4j.com/15902913212619.html"/>
    <updated>2020-05-24T11:35:21+08:00</updated>
    <id>http://www.throne4j.com/15902913212619.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>数据实时同步更新<br/>
使用缓存工具或AOP，在更新数据库的同时更新缓存，这种方式数据一致性强，</p>
<ul>
<li>不会出现缓存雪崩的问题，</li>
<li>但是代码耦合、运行期耦合、影响正常业务、增加一次网络开销，</li>
<li>适用于写操作频繁的细粒度缓存数据，数据一致实时性要求比较高的场景，如银行业务、证券业务，对于写操作较少的粗粒度操作则不适合。</li>
</ul></li>
<li><p>数据准时更新</p>
<ul>
<li>准一致性，更新数据库后，异步更新缓存，使用AOP进行封装给予多线程或者mq实现</li>
<li>数据同步有短暂延迟，与业务解耦，不影响正常业务运行，不会出现缓存雪崩问题</li>
<li>有较短延迟，需要补偿机制</li>
<li>不适合写操作频繁并且数据一致实时性要求严格的场景</li>
</ul></li>
<li><p>缓存失效机制</p>
<ul>
<li>弱一致性，给予缓存本身的失效机制</li>
<li>实现简单，与业务完美解耦，不影响正常业务</li>
<li>有一定延迟，不保证强一致性，但保证最终一致性，存在缓存雪崩的问题</li>
<li>适合于读多写少的互联网场景，能接受一定的数据延时，比如电商业务、社交业务等</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis面试]]></title>
    <link href="http://www.throne4j.com/15902453905639.html"/>
    <updated>2020-05-23T22:49:50+08:00</updated>
    <id>http://www.throne4j.com/15902453905639.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>MyBatis 的好处是什么？</p>
<ul>
<li>MyBatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写， 给程序的维护带来了很大便利。 </li>
<li>MyBatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 Java Bean 对象，大大简化了 Java 数据库编程的重复工作。 </li>
<li>因为 MyBatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的 特点灵活控制 sql 语句，因此能够实现比 Hibernate 等全自动 orm 框架更高的查 询效率，能够完成复杂查询</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？<br/>
答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集 合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询 关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映<br/>
射工具。</li>
</ul>

<hr/>

<ul>
<li>接口绑定有几种实现方式,分别是怎么实现的?<br/>
答：接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定,另外一种就是通过 xml 里面写 SQL 来绑定,在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全 路径名。</li>
</ul>

<hr/>

<ul>
<li>resultType 和 resultMap 的区别？<br/>
答：resultType 和 resultMap 都是表示数据库表与 pojo 之间的映射规则的。类的名字和数据 库相同时，可以直接设置 resultType 参数为 Pojo 类。若不同或者有关联查询，需要设置 resultMap 将结果名字和 Pojo 名字进行转换；从编程的最佳实践来讲，强制使用resultMap, 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义； </li>
</ul>

<hr/>

<ul>
<li>在 MyBatis 中如何在 mapper 接口中传入多个参数？<br/>
答：MyBatis 的接口默认只支持一个入参，如果要传递多个参数有三种方式：
<ul>
<li>使用 map 传递参数  可读性差，导致可维护性和可扩展性差，杜绝使用</li>
<li>使用注解传递参数 直观明了，当参数较少一般小于 5 个的时候，建议使用</li>
<li>使用 Java Bean 的方 式传递参数</li>
</ul></li>
</ul>

<hr/>

<ul>
<li><p><code>问${}和#{}的区别是什么？</code><br/>
答：向 sql 语句中传递的可变参数,分为预编译#{}和传值${}两种 </p>
<ul>
<li>预编译 #{}：将传入的数据都当成一个字符串，会对自动传入的数据加一个单引号，能 够很大程度防止 sql 注入； </li>
<li> 传值\({}：传入的数据直接显示生成在 sql 中，无法防止 sql 注入；适用场景：动态报表， 表名、选取的列是动态的，orderby 和 in 操作， 可以考虑使用\)</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>通过 Mybatis 怎么样进行批量插入操作<br/>
答：有两种方式：
<ul>
<li>通过 foreach 动态拼装 SQL 语句 </li>
<li> 使用 BATCH 类型的 excutor； 而且这两种方式都能返回数据库主键字段；</li>
</ul></li>
</ul>

<hr/>

<ul>
<li><p>Mybatis 怎么样实现关联查询<br/>
答：有两种方式：</p>
<ul>
<li><p>嵌套结果:使用嵌套结果映射来处理重复的联合结果的子集。使用 join 查询，一部分<br/>
列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。 </p></li>
<li><p>嵌套查询:通过执行另外一个 SQL 映射语句来返回预期的复杂类型，在关联标签中配 置 select、fetchType 这样的属性实现，是通过发送多段 SQL 实现的；</p></li>
</ul></li>
</ul>

<hr/>

<ul>
<li>什么是 N+1 问题，怎么解决？<br/>
答：嵌套查询会导致“N+1 查询问题” ，导致该问题产生的原因: 
<ul>
<li>你执行了一个单独的 SQL 语句来获取结果列表(就是“+1”)。 </li>
<li>对返回的每条记录,你执行了一个查询语句来为每个加载细节(就是“N”)。 这个问题会导致成百上千的 SQL 语句被执行。这通常不是期望的。 <br/>
解决“N+1 查询问题”的办法就是开启懒加载、按需加载数据，开启懒加载配置： 在select 节点上配置“fetchType=lazy”，在 MyBatis 核心配置文件中加入如下配置：</li>
</ul></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;!-- 开启懒加载 ，当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每 种属性将会按需要加载。默认：true --&gt; 
&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;
</code></pre>

<hr/>

<ul>
<li>什么是一级缓存？怎么理解二级缓存？<br/>
答：一级缓存存在于 SqlSession 的生命周期中，在同一个 SqlSession 中查询时使用。二级缓存 也叫应用缓存，存在于 SqlSessionFactory 的生命周期中，可以理解为跨 sqlSession；二级缓存是 以 namespace 为单位的，不同 namespace 下的操作互不影响。在项目中为了避免脏读的问题， 建议不适用二级缓存。</li>
</ul>

<hr/>

<ul>
<li>Mybatis 是如何进行分页的？分页插件的原理是什么？<br/>
答： 
<ul>
<li>Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。 </li>
<li>分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql。 举例： select <em>from student，拦截 sql 后重写为： select t.</em> from（select * from student） t limit 0，10</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>简述 Mybatis 的插件运行原理，以及如何编写一个插件？<br/>
答： 
<ul>
<li>Mybatis 仅可以编写针对 ParameterHandler、 ResultSetHandler、 StatementHandler、 Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理 对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦 截方法，具体就是 InvocationHandler 的 invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>
<li>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写 注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你 编写的插件。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？<br/>
答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace， 那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。原因就是 namespace+id 是作为 Map<String, MappedStatement>的 key 使用的，如果没有 namespace，就剩下 id， 那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同， namespace+id 自然也就不同。</li>
</ul>

<hr/>

<ul>
<li>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？<br/>
答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。
<ul>
<li>SimpleExecutor：Mybatis 的默认执行器，每执行一次 update 或 select，就开启一个 Statement 对 象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放 置于 Map3）BatchExecutor：完成批处理。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>使用 MyBatis 的 mapper 接口调用时有哪些要求？<br/>
答： 
<ul>
<li>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同； </li>
<li> Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的 类型相同； </li>
<li>  Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型 相同； </li>
<li>  Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。</li>
</ul></li>
</ul>

<hr/>

<ul>
<li>为什么使用 mapper 接口就能对数据库进行访问？<br/>
答：表面上我们在使用 mapper 接口访问数据库，实际 MyBatis 通过动态代理生成了 mapper 接 口的实现类，通过这个动态生成的实现类，将数据库的访问请求转发给 SqlSession。转发过程中 需要实现三个翻译： 
<ul>
<li>通过 sql 语句的类型和接口方法的返回参数确定调用 SqlSession 的哪个方法； </li>
<li>将 sql 语句在 MyBatis 中的两维坐标作为第一个参数，传入 SqlSession 的方法；</li>
<li> 将接口传入的参数封装成 map 后作为第二个参数，传入 SqlSession 的方法； 请求转发给 SqlSession 后实现对数据库的访问操作；</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 插件开发]]></title>
    <link href="http://www.throne4j.com/15902453903846.html"/>
    <updated>2020-05-23T22:49:50+08:00</updated>
    <id>http://www.throne4j.com/15902453903846.html</id>
    <content type="html"><![CDATA[
<p>插件是用来改变或者扩展 mybatis 的原有的功能，mybaits 的插件就是通过继承 Interceptor 拦截器实现的；注意：在没有完全理解插件之前禁止使用插件对 mybaits 进行扩 展，又可能会导致严重的问题；MyBatis 中能使用插件进行拦截的接口和方法如下： </p>

<ul>
<li>Executor（update、 query、 flushStatment、 commit、 rollback、 getTransaction、 close、 isClose）</li>
<li>StatementHandler（prepare、paramterize、batch、update 、query） </li>
<li>ParameterHandler（getParameterObject 、setParameters） </li>
<li>ResultSetHandler（handleResultSets、handleCursorResultSets 、handleOutputParameters）</li>
</ul>

<h2 id="toc_0">插件开发如何实现</h2>

<h3 id="toc_1">实现Interceptor接口</h3>

<p>MyBatis插件的实现必须实现Interceptor接口，该接口有3个方法</p>

<pre class="line-numbers"><code class="language-java">public interface Interceptor {
  // 插件对业务进行增强的核心方法
  Object intercept(Invocation invocation) throws Throwable;
  // target是配拦截的对象，它的作用就是给被拦截的对象生成一个代理对象
  default Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  // 读取在plugin中设置的参数
  default void setProperties(Properties properties) {
    // NOP
  }

}

</code></pre>

<h3 id="toc_2">确定拦截的签名</h3>

<p>注解 @Intercepts 和 @Signature就是用于表示插件拦截的位置，@Intercepts 其值是一个 @Signature 数组。 @Intercepts 用于表明当前的对象是一个Interceptor， 而@Signature 则表明要拦截的接口、方法以及对应的参数类型。<br/>
如下所示：</p>

<pre class="line-numbers"><code class="language-java">@Intercepts(
        {
                @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}),
                @Signature(type = Executor.class, method = &quot;query&quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class}),
        }
)
public class PageInterceptor implements Interceptor {

}
</code></pre>

<h3 id="toc_3">插件模块源码分析</h3>

<p>插件模块的源码分析主要搞清楚初始化、插件加载以及插件如何调用三个问题；</p>

<h4 id="toc_4">插件初始化</h4>

<p>在MyBatis配置初始化的时候，对标签plugins进行解析的时候，对插件进行了初始化</p>

<pre class="line-numbers"><code class="language-java">private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
}
</code></pre>

<p>在 configuration 对象中，使用 interceptorChain 类属性保存所有的插件， interceptorChain 类中有个 List 用于顺序保存所有的插件；</p>

<h4 id="toc_5">插件加载</h4>

<p>为什么插件可以拦截 Executor、StatementHandler、ParameterHandler、ResultSetHandler 四个接口指定的方法呢？那是因为通过 configuration 对象创建这四大对象时，通过责任 链模式按插件的顺序对四大对象进行了增强</p>

<ul>
<li>Executor的添加拦截功能</li>
</ul>

<pre class="line-numbers"><code class="language-java">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
      executor = new CachingExecutor(executor);
    }
    // 通过interceptorChain遍历所有的插件为executor增强插件功能
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}
</code></pre>

<ul>
<li>为StatementHandler添加拦截功能</li>
</ul>

<pre class="line-numbers"><code class="language-java">public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
}
</code></pre>

<ul>
<li>为ParameterHandler添加拦截功能</li>
</ul>

<pre class="line-numbers"><code class="language-java">public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
    return parameterHandler;
}
</code></pre>

<ul>
<li>为ResultSetHandler添加拦截功能</li>
</ul>

<pre class="line-numbers"><code class="language-java">public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
      ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
}
</code></pre>

<h4 id="toc_6">插件调用</h4>

<p>插件加载是通过 ExamplePlugin.plugin(Object)来增强的，plugin 方法内部一般使用 Plugin.wrap(target,this)来对四大对象进行增强</p>

<pre class="line-numbers"><code class="language-java">public static Object wrap(Object target, Interceptor interceptor) {
    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);
    Class&lt;?&gt; type = target.getClass();
    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);
    if (interfaces.length &gt; 0) {
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());
      if (methods != null &amp;&amp; methods.contains(method)) {
        return interceptor.intercept(new Invocation(target, method, args));
      }
      return method.invoke(target, args);
    } catch (Exception e) {
      throw ExceptionUtil.unwrapThrowable(e);
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 与 Spring整合]]></title>
    <link href="http://www.throne4j.com/15902065220428.html"/>
    <updated>2020-05-23T12:02:02+08:00</updated>
    <id>http://www.throne4j.com/15902065220428.html</id>
    <content type="html"><![CDATA[
<p>Mybatis-Spring 用于帮助你将 MyBatis 代码无缝地整合到 Spring 中，集成过程中的增强主 要体现在如下四个方面：</p>

<ul>
<li>Spring 将会加载必要的 MyBatis 工厂类和 session 类 </li>
<li>提供一个简单的方式来注入 MyBatis 数据映射器和 SqlSession 到业务层的 bean<br/>
中</li>
<li>方便集成 spring 事务</li>
<li>翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常(数据访问异常)中</li>
</ul>

<h2 id="toc_0">MyBatis-Spring 集成配置最佳实践</h2>

<ul>
<li>准备Mybatis-spring的maven项目</li>
<li>pom文件中添加mybatis-spring依赖</li>
<li>配置 SqlSessionFactoryBean，在 MyBatis-Spring 中， SqlSessionFactoryBean 用于创建 SqlSessionFactory，几个关键配置选项如下所示：
<ul>
<li>dataSource ：用于配置数据源，该属性为必选项，必须通过这个属性配置数 据源 ，这里使用了上一节中配置好的 dataSource 数据库连接池 。</li>
<li> mapper Locations ： 配置 SqlSessionFactoryBean 扫描 XML 映射文件的路径， 可以使用 Ant 风格的路径进行配置。</li>
<li> configLocation ： 用于配置mybatis config XML的路径，除了数据源外，对MyBatis 的各种配直仍然可以通过这种方式进行，并且配置 MyBatis settings 时只能使 用这种方式。但配置文件中任意环境,数据源 和 MyBatis 的事务管理器都会被 忽略；</li>
<li> typeAliasesPackage ： 配置包中类的别名，配置后，包中的类在 XML 映射文 件中使用时可以省略包名部分 ，直接使用类名。这个配置不支持 Ant 风格的 路径，当需要配置多个包路径时可以使用分号或逗号进行分隔 ；</li>
</ul></li>
<li>配置 MapperScannerConfigurer，通过 MapperScannerConfigurer 类自动扫描所有的 Mapper 接口，使用时可以直接注入接口。MapperScannerConfigurer 中常配置以下两个 属性 ：
<ul>
<li>basePackage ： 用于配置基本的包路径。可以使用分号或逗号作为分隔符设 置多于一个的包路径，每个映射器将会在指定的包路径中递归地被搜索到 。</li>
<li>annotationClass ： 用于过滤被扫描的接口，如果设置了该属性，那么 MyBatis 的接口只有包含该注解才会被扫描进去</li>
</ul></li>
<li>配置事务，让 Mybatis 集成 spring 的事务；</li>
</ul>

<p>项目GitHub地址： <a href="https://github.com/qsk1226/mybatis-spring-study">mybatis-spring-study</a></p>

<h2 id="toc_1">mybatis-spring 集成原理分析</h2>

<h3 id="toc_2">SqlSessionFactoryBean 源码分析</h3>

<p>它创建一个MyBatis SqlSessionFactory。这是在Spring应用程序上下文中设置共享MyBatis SqlSessionFactory的常用方法;然后，SqlSessionFactory可以通过依赖注入传递到基于mybatiso的dao。DataSourceTransactionManager或JtaTransactionManager都可以与SqlSessionFactory一起用于事务界定。JTA应该用于跨多个数据库的事务或正在使用容器管理事务(container managed transactions, CMT)的事务。</p>

<p>SqlSessionFactoryBean 来充当 SqlSessionFactory，这里我们要搞清楚的就是为什么 SqlSessionFactoryBean 为什么能在 Spring IOC 容器中以 SqlSessionFactory 的类型保存并被获 取？先来看看 SqlSessionFactoryBean 的定义是怎样的：</p>

<pre class="line-numbers"><code class="language-java">public class SqlSessionFactoryBean
    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; {

  private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class);

  private static final ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = new PathMatchingResourcePatternResolver();
  private static final MetadataReaderFactory METADATA_READER_FACTORY = new CachingMetadataReaderFactory();

  private Resource configLocation;

  private Configuration configuration;

  private Resource[] mapperLocations;

  private DataSource dataSource;

  private TransactionFactory transactionFactory;

  private Properties configurationProperties;

  private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();

  private SqlSessionFactory sqlSessionFactory;

  // EnvironmentAware requires spring 3.1
  private String environment = SqlSessionFactoryBean.class.getSimpleName();

  private boolean failFast;

  private Interceptor[] plugins;

  private TypeHandler&lt;?&gt;[] typeHandlers;

  private String typeHandlersPackage;

  private Class&lt;?&gt;[] typeAliases;

  private String typeAliasesPackage;

  private Class&lt;?&gt; typeAliasesSuperType;

  private LanguageDriver[] scriptingLanguageDrivers;

  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;

  // issue #19. No default provider.
  private DatabaseIdProvider databaseIdProvider;

  private Class&lt;? extends VFS&gt; vfs;

  private Cache cache;

  private ObjectFactory objectFactory;

  private ObjectWrapperFactory objectWrapperFactory;

}
</code></pre>

<h4 id="toc_3">SqlSessionFactoryBean 实现了 <strong><em>InitializingBean</em></strong> 接口，那么容器在初始化完成 SqlSessionFactoryBean 之后必然会调用 afterPropertiesSet()方法</h4>

<pre class="line-numbers"><code class="language-java"> @Override
  public void afterPropertiesSet() throws Exception {
notNull(dataSource, &quot;Property &#39;dataSource&#39; is required&quot;);
notNull(sqlSessionFactoryBuilder, &quot;Property &#39;sqlSessionFactoryBuilder&#39; is required&quot;);
state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),
    &quot;Property &#39;configuration&#39; and &#39;configLocation&#39; can not specified with together&quot;);
// 封装者MyBatis的配置初始化阶段
this.sqlSessionFactory = buildSqlSessionFactory();
}
</code></pre>

<h4 id="toc_4">SqlSessionFactoryBean 实现了 <strong><em>FactoryBean</em></strong> 接口，当在容器中配置 FactoryBean 的实现类时，并不是将该 FactoryBean 注入到容器，而是调用 FactoryBean 的 getObject 方法产生的实例对象注入容器</h4>

<pre class="line-numbers"><code class="language-java">/**
 * 将sqlSessionFactory对象注入spring容器
 */
public SqlSessionFactory getObject() throws Exception {
if (this.sqlSessionFactory == null) {
  afterPropertiesSet();
}

return this.sqlSessionFactory;
}
</code></pre>

<p>SqlSessionFactoryBean 就是将 sqlSessionFactory 注入容器， IOC 容器中的其他类型能拿到 SqlSession 实例了，就可以进行相关的 SQL 执行任务了；</p>

<h3 id="toc_5">MapperFactoryBean 源码分析</h3>

<p>在之前的所有配置中都没有出现过MapperFactoryBean，但实际上真正帮助Spring生成Mapper接口实现类的就是MapperFactoryBean</p>

<pre class="line-numbers"><code class="language-java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {

  private Class&lt;T&gt; mapperInterface;

  private boolean addToConfig = true;

  /**
   * 方法实际是封装了 MyBatis 的第二阶段,获取 Mapper 接口
   * getSqlSession():用户应该使用这个方法来获取一个SqlSession来调用它的语句方法，这个SqlSession是由spring管理的。用户不应该提交/回滚/关闭它，因为它将自动完成。
   * 
   * getMapper(this.mapperInterface)获取mapper接口
   */
  @Override
  public T getObject() throws Exception {
    return getSqlSession().getMapper(this.mapperInterface);
  }
}
</code></pre>

<p>MapperFactoryBean 实现了 FactoryBean 接口，getObject 方法实际是封装了 MyBatis 的第二阶段，注入容器的是 SqlSession 实例化的 Mapper 接口的实现类。</p>

<p>它是支持注入MyBatis映射器接口的BeanFactory，可以使用SqlSessionFactory或预先配置的SqlSessionTemplate进行设置，这个工厂只能注入接口，而不能注入具体的类。</p>

<h3 id="toc_6">MapperScannerConfigurer 源码分析</h3>

<p>MapperFactoryBean 用于帮助 Spring 生成 Mapper 接口，但我们很少直接配置 MapperFactoryBean 而是配置 MapperScannerConfigurer。</p>

<p>原因在于又可能工程中的 mapper 接口数量比较多，为每个 mapper 接口都配置 MapperFactoryBean，配置文件会变得非常庞大，所以才会使用 MapperScannerConfigurer 为 每个 mapper 接口一对一的生成 MapperFactoryBean，那 MapperScannerConfigurer 是怎么做 到的呢？先看看其源码：</p>

<pre class="line-numbers"><code class="language-java">/**
 * BeanDefinitionRegistryPostProcessor： spring容器的后置处理器的一种实现，可以将Bean的结构调整之后注入容器中
 * 
 */
public class MapperScannerConfigurer
    implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {

  private String basePackage;

  private boolean addToConfig = true;

  private String lazyInitialization;

  private SqlSessionFactory sqlSessionFactory;

  private SqlSessionTemplate sqlSessionTemplate;

  private String sqlSessionFactoryBeanName;

  private String sqlSessionTemplateBeanName;

  private Class&lt;? extends Annotation&gt; annotationClass;

  private Class&lt;?&gt; markerInterface;

  private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass;

  private ApplicationContext applicationContext;

  private String beanName;

  private boolean processPropertyPlaceHolders;

  private BeanNameGenerator nameGenerator;
 
 
  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    if (this.processPropertyPlaceHolders) {
      processPropertyPlaceHolders();
    }

    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.setAddToConfig(this.addToConfig);
    scanner.setAnnotationClass(this.annotationClass);
    scanner.setMarkerInterface(this.markerInterface);
    scanner.setSqlSessionFactory(this.sqlSessionFactory);
    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
    scanner.setResourceLoader(this.applicationContext);
    scanner.setBeanNameGenerator(this.nameGenerator);
    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
    if (StringUtils.hasText(lazyInitialization)) {
      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
    }
    scanner.registerFilters();
    scanner.scan(
        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }
  
  // 省略一大堆代码
}
</code></pre>

<p>MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口， 因此可以对 Bean 的结构调整之后再注入容器。那 MapperScannerConfigurer 在扫描完这些 mapper 接口之后，主要是通过ClassPathMapperScanner将 Mapper 接口一个个的转换成 MapperFactoryBean 之后注入容器。</p>

<p>至此就完成了 MyBatis 与 Spring框架的整合。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程等待/通知机制]]></title>
    <link href="http://www.throne4j.com/15896322618729.html"/>
    <updated>2020-05-16T20:31:01+08:00</updated>
    <id>http://www.throne4j.com/15896322618729.html</id>
    <content type="html"><![CDATA[
<p>是指一个线程 A 调用了对象 X 的 wait()方法进入等待状态，<br/>
而另一个线程 B 调用了对象 X的 notify()或者 notifyAll()方法，<br/>
线程 A 收到通知后从对象 X 的 wait() 方法返回，进而执行后续操作。</p>

<p>上述两个线程通过对象 X 来完成交互，而对象 上的 wait()和 notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>

<p>notify()： 通知一个在对象上等待的线程,使其从 wait 方法返回,而返回的前提是该线程 获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。 </p>

<p>notifyAll()： 通知所有等待在该对象上的线程 </p>

<p>wait() 调用该方法的线程进入 WAITING 状态,只有等待另外线程的通知或被中断 才会返回.需要注意,调用 wait()方法后,会释放对象的锁 </p>

<p>wait(long) 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n 毫秒,如果没有 通知就超时返回 wait (long,int) 对于超时时间更细粒度的控制,可以达到纳秒</p>

<p>等待和通知的标准范式 等待方遵循如下原则:</p>

<p>1）获取对象的锁。 <br/>
2）如果条件不满足，那么调用对象的 wait()方法，被通知后仍要检查条件。 <br/>
3）条件满足则执行对应的逻辑。</p>

<pre class="line-numbers"><code class="language-text">synchronized(obj) {
    while(obj.isOk()) {
        obj.wait();
    }
}
</code></pre>

<p>通知方遵循如下原则: </p>

<p>1）获得对象的锁。 <br/>
2）改变条件。 <br/>
3）通知所有等待在对象上的线程。</p>

<pre class="line-numbers"><code class="language-text">synchronized(obj) {
    obj.notifyAll();
}
</code></pre>

<p>在调用 wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，<br/>
即只能在同步方法或同步块中调用 wait(）方法、notify()系列方法，进入 wait(）方法后，当前线程释放锁，在从 wait(）返回前，线程与其他线程竞争重新获得锁，执行 notify()系列方法的线程退出调用了 notifyAll 的 synchronized 代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会 继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的 线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>

<p>Question: 调用 yield() 、sleep()、wait()、notify()等方法对锁有何影响？ </p>

<p>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。 </p>

<p>调用 wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行 wait 方法后面的代码。 </p>

<p>调用 notify()系列方法后，对锁无影响，线程只有在 syn 同步代码执行完后才 会自然而然的释放锁，所以 notify()系列方法一般都是 syn 同步代码的最后一行</p>

<p>使用wait、和notify实现一个连接池的实例如下：</p>

<pre class="line-numbers"><code class="language-java">public class DBPool {

    /*容器，存放连接*/
    private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();

    /*限制了池的大小=20*/
    public DBPool(int initialSize) {
        if (initialSize &gt; 0) {
            for (int i = 0; i &lt; initialSize; i++) {
                pool.addLast(createConnection());
            }
        }
    }

    /*释放连接,通知其他的等待连接的线程*/
    public void releaseConnection(Connection connection) {
        if (connection != null) {
            synchronized (pool){
                pool.addLast(connection);
                //通知其他等待连接的线程
                pool.notifyAll();
            }
        }
    }

    /*获取*/
    // 在mills内无法获取到连接，将会返回null 1S
    public Connection fetchConnection(long mills)
            throws InterruptedException {
        synchronized (pool){
            //永不超时
            if(mills&lt;=0){
                while(pool.isEmpty()){
                    pool.wait();
                }
                return pool.removeFirst();
            }else{
                /*超时时刻*/
                long future = System.currentTimeMillis()+mills;
                /*等待时长*/
                long remaining = mills;
                while(pool.isEmpty()&amp;&amp;remaining&gt;0){
                    pool.wait(remaining);
                    /*唤醒一次，重新计算等待时长*/
                    remaining = future-System.currentTimeMillis();
                }
                Connection connection = null;
                if(!pool.isEmpty()){
                    connection = pool.removeFirst();
                }
                return connection;
            }
        }

    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis逆向工程]]></title>
    <link href="http://www.throne4j.com/15896298256850.html"/>
    <updated>2020-05-16T19:50:25+08:00</updated>
    <id>http://www.throne4j.com/15896298256850.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">配置文件</h2>

<p>generator.properties</p>

<pre class="line-numbers"><code class="language-properties">jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.connectionURL=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false
jdbc.user=root
jdbc.password=12345678
java.target.package=com.shengke.sbd.entity
example.target.package=com.shengke.sbd.entity.example
mapper.target.package=com.shengke.sbd.mapper
sql.mapper.target.package=mapper

</code></pre>

<p>generatorConfig.xml</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;
&lt;!-- 配置生成器 --&gt;
&lt;generatorConfiguration&gt;
    &lt;properties resource=&quot;generator/generator.properties&quot;/&gt;

    &lt;!--MyBatis3、 Mybatis3Simple（没有example这些个东西），defaultModelType推荐 flat， 可选值flat、conditional、hierarchical--&gt;
    &lt;context id=&quot;mysql&quot; targetRuntime=&quot;Mybatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；
                   一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖
                --&gt;
        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 生成的Java文件的编码 --&gt;
        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;
        &lt;!-- 格式化java代码 --&gt;
        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;
        &lt;!-- 格式化XML代码 --&gt;
        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;


        &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;


        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;
        &lt;!--重新生成覆盖原mapper.XML文件--&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.OverIsMergeablePlugin&quot;/&gt;
        &lt;!-- Example和mapper类中文注释 --&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.CommentPlugin&quot;/&gt;
        &lt;!-- .Lombok插件 默认在实体类里增加@Data 不生成Get、Set方法 --&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.LombokPlugin&quot;&gt;
            &lt;property name=&quot;lombokAnnotations&quot; value=&quot;@Data&quot;/&gt;
        &lt;/plugin&gt;

        &lt;!-- 修改生成的Example类的类名和Mapper类中的方法名或参数名--&gt;
        &lt;plugin type=&quot;com.mybatis.generator.plugin.ExampleConfigPlugin&quot;&gt;
            &lt;!-- example包名 --&gt;
            &lt;property name=&quot;targetPackage&quot; value=&quot;${example.target.package}&quot;/&gt;
            &lt;property name=&quot;classMethodSearchString&quot; value=&quot;Example&quot;/&gt;
            &lt;property name=&quot;classMethodReplaceString&quot; value=&quot;Condition&quot;/&gt;
            &lt;property name=&quot;parameterSearchString&quot; value=&quot;example&quot;/&gt;
            &lt;property name=&quot;parameterReplaceString&quot; value=&quot;condition&quot;/&gt;
        &lt;/plugin&gt;
        &lt;!--生成中文注释--&gt;
        &lt;commentGenerator type=&quot;com.mybatis.generator.comment.MyCommentGenerator&quot;&gt;
            &lt;!-- 是否禁止显示日期 true：是 ： false:否 --&gt;
            &lt;property name=&quot;suppressDate&quot; value=&quot;false&quot;/&gt;
            &lt;!-- 是否去除自动生成的所有注释 true：是 ： false:否 --&gt;
            &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt;
            &lt;!--注释是否包含数据库表的注释--&gt;
            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;
        &lt;/commentGenerator&gt;

        &lt;!--数据库链接URL，用户名、密码 --&gt;
        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.connectionURL}&quot; userId=&quot;${jdbc.user}&quot;
                        password=&quot;${jdbc.password}&quot;&gt;
            &lt;property name=&quot;useInformationSchema&quot; value=&quot;true&quot;/&gt;
        &lt;/jdbcConnection&gt;

        &lt;!-- java类型处理器
            用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；
            注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；
        --&gt;
        &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;
            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;useJava8Time&quot; value=&quot;${jdk.use_jdk8_time}&quot;/&gt;
        &lt;/javaTypeResolver&gt;

        &lt;!-- 配置生成实体类的包名和位置 --&gt;
        &lt;javaModelGenerator targetPackage=&quot;${java.target.package}&quot; targetProject=&quot;src/main/java&quot;&gt;
            &lt;!--  for MyBatis3/MyBatis3Simple
                自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
             --&gt;
            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;

            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

            &lt;!-- for MyBatis3 / MyBatis3Simple
                是否创建一个不可变的类，如果为true，
                那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类
             --&gt;
            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;

            &lt;!-- 设置一个根对象，
                如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项
                注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：
                    1，属性名相同，类型相同，有相同的getter/setter方法；
                比如BaseEntity中定义的createdTime、createUserId、createUserName等
             --&gt;
            &lt;!--&lt;property name=&quot;rootClass&quot; value=&quot;com.indexes.server.domain.BaseDomain&quot;/&gt;--&gt;

            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;
            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;
        &lt;/javaModelGenerator&gt;


        &lt;!-- 生成SQL map的XML文件生成器，
            注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），
                或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置
            targetPackage/targetProject:同javaModelGenerator
         --&gt;
        &lt;sqlMapGenerator targetPackage=&quot;${sql.mapper.target.package}&quot; targetProject=&quot;src/main/resources&quot;&gt;
            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;
        &lt;/sqlMapGenerator&gt;


        &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口
            targetPackage/targetProject:同javaModelGenerator
            type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：
                1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；
                2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；
                3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；
            注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER
        --&gt;
        &lt;javaClientGenerator targetPackage=&quot;${mapper.target.package}&quot; type=&quot;XMLMAPPER&quot;
                             targetProject=&quot;src/main/java&quot;&gt;
            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;
            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;

            &lt;!--可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查--&gt;
            &lt;property name=&quot;rootInterface&quot; value=&quot;com.shengke.sbd.mapper.BaseMapper&quot;/&gt;

        &lt;/javaClientGenerator&gt;


        &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素
            选择的table会生成一下文件：
            1，SQL map文件
            2，生成一个主键类；
            3，除了BLOB和主键的其他字段的类；
            4，包含BLOB的类；
            5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；
            6，Mapper接口（可选）

            tableName（必要）：要生成对象的表名；
            注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会
                根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：
                1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；
                2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；
                3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；
                4，否则，使用指定的大小写格式查询；
            另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；
            这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；

            可选：
            1，schema：数据库的schema；
            2，catalog：数据库的catalog；
            3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName
            4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；
            5，enableInsert（默认true）：指定是否生成insert语句；
            6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；
            7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；
            8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；
            9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；
            10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；
            11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；
            12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；
            13，modelType：参考context元素的defaultModelType，相当于覆盖；
            14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）
            15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性

            注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；
         --&gt;
        &lt;!--
            &lt;table tableName=&quot;t_collection_order_approval&quot; domainObjectName=&quot;CollectionOrderApproval&quot;
                   enableSelectByExample=&quot;true&quot;
                   enableCountByExample=&quot;true&quot;
                   enableDeleteByExample=&quot;true&quot;
                   enableUpdateByExample=&quot;true&quot;&gt;
              &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
              &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
              &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
              &lt;columnOverride column=&quot;create_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;update_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;cancel_at&quot; javaType=&quot;java.time.Instant&quot;/&gt;
              &lt;columnOverride column=&quot;customer_type&quot; javaType=&quot;java.lang.Integer&quot;/&gt;
              &lt;columnOverride column=&quot;special_customer_reason&quot; javaType=&quot;java.lang.Integer&quot;/&gt;
            &lt;/table&gt;
        --&gt;
        &lt;!--&lt;table  tableName=&quot;%&quot;&gt;&lt;/table&gt;--&gt;

        &lt;table tableName=&quot;t_user&quot; domainObjectName=&quot;User&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_role_permission&quot; domainObjectName=&quot;RolePermission&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_health_report_female&quot; domainObjectName=&quot;HealthReportFemale&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_health_report_male&quot; domainObjectName=&quot;HealthReportMale&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_job_history&quot; domainObjectName=&quot;JobHistory&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_position&quot; domainObjectName=&quot;Position&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_role&quot; domainObjectName=&quot;Role&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_user_role&quot; domainObjectName=&quot;UserRole&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
        &lt;table tableName=&quot;t_user_test&quot; domainObjectName=&quot;UserTest&quot;&gt;
            &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;
            &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;id DESC&quot;/&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;

&lt;/generatorConfiguration&gt;


</code></pre>

<h2 id="toc_1">maven关于mybatis反向工程的插件</h2>

<pre class="line-numbers"><code class="language-markup">&lt;plugin&gt;
    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.3.6&lt;/version&gt;
    &lt;configuration&gt;
        &lt;configurationFile&gt;src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;
        &lt;outputDirectory&gt;${project.build.directory}/generated/mybatis-generator&lt;/outputDirectory&gt;
        &lt;verbose&gt;true&lt;/verbose&gt;
        &lt;overwrite&gt;true&lt;/overwrite&gt;
    &lt;/configuration&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.19&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mybatis.generator.plugin&lt;/groupId&gt;
            &lt;artifactId&gt;generator-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[享元模式]]></title>
    <link href="http://www.throne4j.com/15896298176989.html"/>
    <updated>2020-05-16T19:50:17+08:00</updated>
    <id>http://www.throne4j.com/15896298176989.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">享元模式的定义</h2>

<p>享元模式是一种<strong>结构性设计模式</strong>，它是考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>

<p>采用一个共享类来避免大量拥有相同内容的“小类”的开销。这种开销中最常见、直观的影响就是增加了内存的损耗。</p>

<p>享元模式以共享的方式高效地支持大量的细粒度对象，减少其带来的开销，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。其中：</p>

<ul>
<li>内部状态 是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li>
<li>外部状态 是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。 </li>
</ul>

<h2 id="toc_1">享元模式结构</h2>

<p>单纯享元模式的结构。</p>

<ul>
<li>抽象享元角色: 为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式 通过此方法传入。在 Java 中可以由抽象类、接口来担当。</li>
<li>具体享元角色: 实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供 存储空间。</li>
<li>享元工厂角色: 负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关 键!</li>
<li>客户端角色: 维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。 来用类图来形象地表示出它们的关系吧。</li>
</ul>

<p><img src="media/15896298176989/15917826923765.jpg" alt=""/></p>

<h3 id="toc_2">优点</h3>

<p>1）它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；<br/>
2）享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</p>

<h3 id="toc_3">缺点</h3>

<p>1）享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化；<br/>
2）为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</p>

<h2 id="toc_4">代码示例</h2>

<pre class="line-numbers"><code class="language-java">/**
 * 抽象享元角色类
 *
 **/
public interface Flyweight {
    /**
     * 一个示意性方法，参数state是外蕴状态
     */
    public void operation(String state);
}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 具体享元角色类
 * &lt;p&gt;
 * 具体享元角色类ConcreteFlyweight有一个内蕴状态，在本例中一个Character类型的intrinsicState属性代表，它的值应当在享元对象
 * 被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。如果一个享元对象有外蕴状态的话，所有的外部状态都必须存储在客户端，
 * 在使用享元对象时，再由客户端传入享元对象。这里只有一个外蕴状态，operation()方法的参数state就是由外部传入的外蕴状态。
 *
 **/
public class ConcreteFlyweight implements Flyweight {
    private Character intrinsicState = null;

    /**
     * 构造函数，内蕴状态作为参数传入
     *
     * @param state
     */
    public ConcreteFlyweight(Character state) {
        this.intrinsicState = state;
    }


    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，但是并不改变对象的内蕴状态。
     *
     * @param state 外蕴状态
     */
    @Override
    public void operation(String state) {
        // TODO Auto-generated method stub
        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);
        System.out.println(&quot;Extrinsic State = &quot; + state);
    }

}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 享元工厂角色类
 * &lt;p&gt;
 * 必须指出的是，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。
 * 一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。
 * 当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。
 **/
public class FlyweightFactory {
    private Map&lt;Character, Flyweight&gt; files = new HashMap&lt;&gt;();

    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;First Call&quot;);

        fly = factory.factory(&#39;b&#39;);
        fly.operation(&quot;Second Call&quot;);

        fly = factory.factory(&#39;a&#39;);
        fly.operation(&quot;Third Call&quot;);
    }

}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 复合享元角色类
 * &lt;p&gt;
 * 复合享元对象是由单纯享元对象通过复合而成的，因此它提供了add()这样的聚集管理方法。由于一个复合享元对象具有不同的聚集元素，
 * 这些聚集元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。
 * 复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。
 * 一个复合享元对象的所有单纯享元对象元素的外蕴状态都是与复合享元对象的外蕴状态相等的；
 * 而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。
 **/
public class ConcreteCompositeFlyweight implements Flyweight {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 增加一个新的单纯享元对象到聚集中
     */
    public void add(Character key, Flyweight fly) {
        flyweightMap.put(key, fly);
    }

    /**
     * 外蕴状态作为参数传入到方法中
     */
    @Override
    public void operation(String state) {
        Flyweight fly = null;
        for (Object o : flyweightMap.keySet()) {
            fly = flyweightMap.get(o);
            fly.operation(state);
        }

    }

}
</code></pre>

<pre class="line-numbers"><code class="language-java">/**
 * 复合享元工厂角色类
 * &lt;p&gt;
 * 享元工厂角色提供两种不同的方法，一种用于提供单纯享元对象，另一种用于提供复合享元对象。
 **/
public class CompositeFlyweightFactory {

    private Map&lt;Character, Flyweight&gt; flyweightMap = new HashMap&lt;&gt;();

    /**
     * 复合享元工厂方法
     */
    public Flyweight factory(List&lt;Character&gt; compositeState) {
        ConcreteCompositeFlyweight compositeFly = new ConcreteCompositeFlyweight();

        for (Character state : compositeState) {
            compositeFly.add(state, this.factory(state));
        }

        return compositeFly;
    }

    /**
     * 单纯享元工厂方法
     */
    public Flyweight factory(Character state) {
        //先从缓存中查找对象
        Flyweight fly = flyweightMap.get(state);
        if (fly == null) {
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            flyweightMap.put(state, fly);
        }
        return fly;
    }

    public static void main(String[] args) {
        List&lt;Character&gt; compositeState = new ArrayList&lt;&gt;();
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);
        compositeState.add(&#39;c&#39;);
        compositeState.add(&#39;a&#39;);
        compositeState.add(&#39;b&#39;);

        CompositeFlyweightFactory flyFactory = new CompositeFlyweightFactory();
        Flyweight compositeFly1 = flyFactory.factory(compositeState);
        Flyweight compositeFly2 = flyFactory.factory(compositeState);
        compositeFly1.operation(&quot;Composite Call&quot;);

        System.out.println(&quot;---------------------------------&quot;);
        System.out.println(&quot;复合享元模式是否可以共享对象：&quot; + (compositeFly1 == compositeFly2));

        Character state = &#39;a&#39;;
        Flyweight fly1 = flyFactory.factory(state);
        Flyweight fly2 = flyFactory.factory(state);
        System.out.println(&quot;单纯享元模式是否可以共享对象：&quot; + (fly1 == fly2));
    }

}
</code></pre>

<h2 id="toc_5">适用场景</h2>

<p>在以下情况下可以使用享元模式：</p>

<ul>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中(细粒度对象)；</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li>
</ul>

<p><strong>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模板方法模式]]></title>
    <link href="http://www.throne4j.com/15896087713606.html"/>
    <updated>2020-05-16T13:59:31+08:00</updated>
    <id>http://www.throne4j.com/15896087713606.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">模板方法模式的定义</a>
</li>
<li>
<a href="#toc_1">模板方法模式结构</a>
<ul>
<li>
<a href="#toc_2">模板方法模式 UML</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">使用场景</a>
</li>
</ul>


<h2 id="toc_0">模板方法模式的定义</h2>

<p>模板方法(Template Method)模式: 定义一个操作中的算法的骨架，而将一些步骤延<br/>
迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<p>模板方法模式也是为了解决某些变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。</p>

<h2 id="toc_1">模板方法模式结构</h2>

<ul>
<li><p>抽象类</p>
<ul>
<li>定义了一到多个的抽象方法，以供具体的子类来实现它们</li>
<li>需要实现一个模板方法，来定义一个算法的骨架。该模板方法不仅调用前面的抽象方法，也可以调用其他的操作，只要能完成自身的使命。</li>
</ul></li>
<li><p>具体类<br/>
实现父类中的抽象方法以完成算法中与特定子类相关的步骤。</p></li>
</ul>

<h3 id="toc_2">模板方法模式 UML</h3>

<p><img src="media/15896087713606/15917532214702.jpg" alt=""/></p>

<h2 id="toc_3">使用场景</h2>

<p>模板方法适用于以下情况:</p>

<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>控制子类扩展。<br/>
模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。如果你不愿子类来修改你的模板方法定义的框架，你可以采用两种方式来做:一是在 API 中不体现出你的模板方法;或者将你的模板方法置为 final 就可以了。 可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。这样你在实现子类的时候，根本不需要对业务流程有太多的了解。</li>
</ul>

]]></content>
  </entry>
  
</feed>
