<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[大爷来玩儿啊~]]></title>
  <link href="http://www.throne4j.com/atom.xml" rel="self"/>
  <link href="http://www.throne4j.com/"/>
  <updated>2021-01-03T22:47:45+08:00</updated>
  <id>http://www.throne4j.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[]]></title>
    <link href="http://www.throne4j.com/16096493263582.html"/>
    <updated>2021-01-03T12:48:46+08:00</updated>
    <id>http://www.throne4j.com/16096493263582.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScheduledThreadPoolExecutor]]></title>
    <link href="http://www.throne4j.com/16095830618165.html"/>
    <updated>2021-01-02T18:24:21+08:00</updated>
    <id>http://www.throne4j.com/16095830618165.html</id>
    <content type="html"><![CDATA[
<ul>
<li>ScheduledThreadPoolExecutor要解决什么样的问题? </li>
<li>ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性? </li>
<li>ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类? </li>
<li>ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么? </li>
<li>ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么? </li>
<li>为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor? </li>
<li>Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?</li>
</ul>

<h2 id="toc_0">ScheduledThreadPoolExecutor 简介</h2>

<p>ScheduledThreadPoolExecutor继承自 ThreadPoolExecutor，为任务提供延迟或周期执行，属于线程池的一种。和 ThreadPoolExecutor 相比，它还具有以下几种特性: </p>

<ul>
<li>使用专门的任务类型—ScheduledFutureTask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 ExecutorService 来执行)。 </li>
<li>使用专门的存储队列—DelayedWorkQueue 来存储任务，DelayedWorkQueue 是无界延迟队列DelayQueue 的一种。相比ThreadPoolExecutor也简化了执行机制(delayedExecute方法，后面单独分析)。 </li>
<li>支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。 </li>
</ul>

<h2 id="toc_1">ScheduledThreadPoolExecutor 数据结构</h2>

<p><figure><img src="media/16095830618165/16095838360233.jpg" alt=""/></figure></p>

<p>ScheduledThreadPoolExecutor继承自 ThreadPoolExecutor<a href="15878284668401.html">线程池</a></p>

<p>ScheduledThreadPoolExecutor 内部构造了两个内部类 ScheduledFutureTask 和 DelayedWorkQueue</p>

<ul>
<li><p>ScheduledFutureTask: 继承了FutureTask，说明是一个异步运算任务；最上层分别实现了Runnable、Future、Delayed接口，说明它是一个可以延迟执行的异步运算任务。</p></li>
<li><p>DelayedWorkQueue: 这是 ScheduledThreadPoolExecutor 为存储周期或延迟任务专门定义的一个延迟队列，继承了 AbstractQueue，为了契合 ThreadPoolExecutor 也实现了 BlockingQueue 接口。它内部只允许存储 RunnableScheduledFuture 类型的任务。与 DelayQueue 的不同之处就是它只允许存放 RunnableScheduledFuture 对象，并且自己实现了二叉堆(DelayQueue 是利用了 PriorityQueue 的二叉堆结构)</p></li>
</ul>

<h2 id="toc_2">ScheduledThreadPoolExecutor源码解析</h2>

<h3 id="toc_3">内部类ScheduledFutureTask</h3>

<pre><code class="language-java">//为相同延时任务提供的顺序编号
private final long sequenceNumber;

//任务可以执行的时间，纳秒级
private long time;

//重复任务的执行周期时间，纳秒级。
private final long period;

//重新入队的任务
RunnableScheduledFuture&lt;V&gt; outerTask = this;

//延迟队列的索引，以支持更快的取消操作
int heapIndex;

</code></pre>

<ul>
<li>sequenceNumber: 当两个任务有相同的延迟时间时，按照 FIFO 的顺序入队。sequenceNumber 就是为相同延时任务提供的顺序编号。 </li>
<li>time: 任务可以执行时的时间，纳秒级，通过triggerTime方法计算得出。 </li>
<li>period: 任务的执行周期时间，纳秒级。正数表示固定速率执行(为scheduleAtFixedRate提供服务)，负数表示固定延迟执行(为scheduleWithFixedDelay提供服务)，0表示不重复任务。 </li>
<li>outerTask: 重新入队的任务，通过reExecutePeriodic方法入队重新排序。</li>
</ul>

<h4 id="toc_4">核心方法run()</h4>

<pre><code class="language-java">public void run() {
    boolean periodic = isPeriodic();//是否为周期任务
    if (!canRunInCurrentRunState(periodic))//当前状态是否可以执行
        cancel(false);
    else if (!periodic)
        //不是周期任务，直接执行
        ScheduledFutureTask.super.run();
    else if (ScheduledFutureTask.super.runAndReset()) {
        setNextRunTime();//设置下一次运行时间
        reExecutePeriodic(outerTask);//重排序一个周期任务
    }
}

</code></pre>

<p>ScheduledFutureTask 的run方法重写了 FutureTask 的版本，以便执行周期任务时重置/重排序任务。任务的执行通过父类 FutureTask 的run实现。内部有两个针对周期任务的方法:</p>

<h5 id="toc_5">setNextRunTime(): 用来设置下一次运行的时间</h5>

<pre><code class="language-java">//设置下一次执行任务的时间
private void setNextRunTime() {
    long p = period;
    if (p &gt; 0)  //固定速率执行，scheduleAtFixedRate
        time += p;
    else
        time = triggerTime(-p);  //固定延迟执行，scheduleWithFixedDelay
}
//计算固定延迟任务的执行时间
long triggerTime(long delay) {
    return now() +
        ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay));
}

</code></pre>

<h5 id="toc_6">reExecutePeriodic(): 周期任务重新入队等待下一次执行</h5>

<pre><code class="language-java">//重排序一个周期任务
void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {
    if (canRunInCurrentRunState(true)) {//池关闭后可继续执行
        super.getQueue().add(task);//任务入列
        //重新检查run-after-shutdown参数，如果不能继续运行就移除队列任务，并取消任务的执行
        if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))
            task.cancel(false);
        else
            ensurePrestart();//启动一个新的线程等待任务
    }
}
</code></pre>

<p>reExecutePeriodic与delayedExecute的执行策略一致，只不过reExecutePeriodic不会执行拒绝策略而是直接丢掉任务</p>

<h4 id="toc_7">cancel 方法</h4>

<pre><code class="language-java">public boolean cancel(boolean mayInterruptIfRunning) {
    boolean cancelled = super.cancel(mayInterruptIfRunning);
    if (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= 0)
        remove(this);
    return cancelled;
}
</code></pre>

<p>ScheduledFutureTask.cancel本质上由其父类 FutureTask.cancel 实现。取消任务成功后会根据removeOnCancel参数决定是否从队列中移除此任务</p>

<h3 id="toc_8">核心属性</h3>

<pre><code class="language-java">//关闭后继续执行已经存在的周期任务 
private volatile boolean continueExistingPeriodicTasksAfterShutdown;

//关闭后继续执行已经存在的延时任务 
private volatile boolean executeExistingDelayedTasksAfterShutdown = true;

//取消任务后移除 
private volatile boolean removeOnCancel = false;

//为相同延时的任务提供的顺序编号，保证任务之间的FIFO顺序
private static final AtomicLong sequencer = new AtomicLong();

</code></pre>

<ul>
<li>continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown是 ScheduledThreadPoolExecutor 定义的 run-after-shutdown 参数，用来控制池关闭之后的任务执行逻辑。 </li>
<li>removeOnCancel用来控制任务取消后是否从队列中移除。当一个已经提交的周期或延迟任务在运行之前被取消，那么它之后将不会运行。默认配置下，这种已经取消的任务在届期之前不会被移除。 通过这种机制，可以方便检查和监控线程池状态，但也可能导致已经取消的任务无限滞留。为了避免这种情况的发生，我们可以通过setRemoveOnCancelPolicy方法设置移除策略，把参数removeOnCancel设为true可以在任务取消后立即从队列中移除。 </li>
<li>sequencer是为相同延时的任务提供的顺序编号，保证任务之间的 FIFO 顺序。与 ScheduledFutureTask 内部的sequenceNumber参数作用一致。</li>
</ul>

<h3 id="toc_9">构造函数</h3>

<p>ScheduledThreadPoolExecutor 内部有四个构造函数，这里我们只看这个最大构造灵活度的, 通过super调用了ThreadPoolExecutor的构造，并且使用特定等待队列DelayedWorkQueue:</p>

<pre><code class="language-java">public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory,
                                   RejectedExecutionHandler handler) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue(), threadFactory, handler);
}
</code></pre>

<h3 id="toc_10">核心方法:Schedule</h3>

<pre><code class="language-java">public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,
                                       long delay,
                                       TimeUnit unit) {
    if (callable == null || unit == null)
        throw new NullPointerException();
    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,
        new ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)));//构造ScheduledFutureTask任务
    delayedExecute(t);//任务执行主方法
    return t;
}
</code></pre>

<p>schedule主要用于执行一次性(延迟)任务。</p>

<h4 id="toc_11">封装 Callable/Runnable</h4>

<p>首先通过triggerTime计算任务的延迟执行时间，然后通过 ScheduledFutureTask 的构造函数把 Runnable/Callable 任务构造为ScheduledThreadPoolExecutor可以执行的任务类型，最后调用decorateTask方法执行用户自定义的逻辑；decorateTask是一个用户可自定义扩展的方法，默认实现下直接返回封装的RunnableScheduledFuture任务</p>

<pre><code class="language-java">protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
    Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) {
    return task;
}
</code></pre>

<h4 id="toc_12">执行任务: 通过delayedExecute实现</h4>

<pre><code class="language-java">private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {
    if (isShutdown())
        reject(task);//池已关闭，执行拒绝策略
    else {
        super.getQueue().add(task);//任务入队
        if (isShutdown() &amp;&amp;
            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;//判断run-after-shutdown参数
            remove(task))//移除任务
            task.cancel(false);
        else
            ensurePrestart();//启动一个新的线程等待任务
    }
}
</code></pre>

<p>delayedExecute是执行任务的主方法，方法执行逻辑如下: </p>

<ul>
<li>如果池已关闭(ctl &gt;= SHUTDOWN)，执行任务拒绝策略； </li>
<li><p>池正在运行，首先把任务入队排序；然后重新检查池的关闭状态</p>
<ul>
<li>如果池正在运行，或者 run-after-shutdown 参数值为true，则调用父类 ThreadPoolExecutor 的方法 ensurePrestart 启动一个新的线程等待执行任务，即使corePoolSize为0也会安排一个新线程。</li>
</ul>
<pre><code class="language-java">void ensurePrestart() {
    int wc = workerCountOf(ctl.get());<br/>
    if (wc &lt; corePoolSize)<br/>
        addWorker(null, true);<br/>
    else if (wc == 0)<br/>
        addWorker(null, false);<br/>
}
</code></pre>
<ul>
<li>如果池已经关闭，并且 run-after-shutdown 参数值为false，则执行父类(ThreadPoolExecutor)方法remove移除队列中的指定任务，成功移除后调用ScheduledFutureTask.cancel取消任务。</li>
</ul></li>
</ul>

<h3 id="toc_13">核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay</h3>

<pre><code class="language-java">/**
 * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，
 * 之后每隔period执行一次，不等待第一次执行完成就开始计时
 */
public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                              long initialDelay,
                                              long period,
                                              TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (period &lt;= 0)
        throw new IllegalArgumentException();
    //构建RunnableScheduledFuture任务类型
    ScheduledFutureTask&lt;Void&gt; sft =
        new ScheduledFutureTask&lt;Void&gt;(command,
                                      null,
                                      triggerTime(initialDelay, unit),//计算任务的延迟时间
                                      unit.toNanos(period));//计算任务的执行周期
    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);//执行用户自定义逻辑
    sft.outerTask = t;//赋值给outerTask，准备重新入队等待下一次执行
    delayedExecute(t);//执行任务
    return t;
}

/**
 * 创建一个周期执行的任务，第一次执行延期时间为initialDelay，
 * 在第一次执行完之后延迟delay后开始下一次执行
 */
public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                 long initialDelay,
                                                 long delay,
                                                 TimeUnit unit) {
    if (command == null || unit == null)
        throw new NullPointerException();
    if (delay &lt;= 0)
        throw new IllegalArgumentException();
    //构建RunnableScheduledFuture任务类型
    ScheduledFutureTask&lt;Void&gt; sft =
        new ScheduledFutureTask&lt;Void&gt;(command,
                                      null,
                                      triggerTime(initialDelay, unit),//计算任务的延迟时间
                                      unit.toNanos(-delay));//计算任务的执行周期
    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);//执行用户自定义逻辑
    sft.outerTask = t;//赋值给outerTask，准备重新入队等待下一次执行
    delayedExecute(t);//执行任务
    return t;
}

</code></pre>

<p>scheduleAtFixedRate和scheduleWithFixedDelay方法的逻辑与schedule类似。 </p>

<p>注意scheduleAtFixedRate和scheduleWithFixedDelay的区别: <br/>
乍一看两个方法一模一样，其实，在unit.toNanos这一行代码中还是有区别的。没错，scheduleAtFixedRate传的是正值，而scheduleWithFixedDelay传的则是负值，这个值就是 ScheduledFutureTask 的period属性。</p>

<h3 id="toc_14">核心方法:shutdown()</h3>

<p>池关闭方法调用了父类 ThreadPoolExecutor 的 shutdown,</p>

<p>这里主要介绍以下在 shutdown 方法中调用的关闭钩子 onShutdown 方法，它的主要作用是在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown)来决定线程池关闭后是否关闭已经存在的任务。</p>

<pre><code class="language-java">public void shutdown() {
    super.shutdown();
}
//取消并清除由于关闭策略不应该运行的所有任务
@Override void onShutdown() {
    BlockingQueue&lt;Runnable&gt; q = super.getQueue();
    //获取run-after-shutdown参数
    boolean keepDelayed =
        getExecuteExistingDelayedTasksAfterShutdownPolicy();
    boolean keepPeriodic =
        getContinueExistingPeriodicTasksAfterShutdownPolicy();
    if (!keepDelayed &amp;&amp; !keepPeriodic) {//池关闭后不保留任务
        //依次取消任务
        for (Object e : q.toArray())
            if (e instanceof RunnableScheduledFuture&lt;?&gt;)
                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(false);
        q.clear();//清除等待队列
    }
    else {//池关闭后保留任务
        // Traverse snapshot to avoid iterator exceptions
        //遍历快照以避免迭代器异常
        for (Object e : q.toArray()) {
            if (e instanceof RunnableScheduledFuture) {
                RunnableScheduledFuture&lt;?&gt; t =
                    (RunnableScheduledFuture&lt;?&gt;)e;
                if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||
                    t.isCancelled()) { // also remove if already cancelled
                    //如果任务已经取消，移除队列中的任务
                    if (q.remove(t))
                        t.cancel(false);
                }
            }
        }
    }
    tryTerminate(); //终止线程池
}
</code></pre>

<h3 id="toc_15">为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor？</h3>

<p>例如: 由于 ScheduledThreadPoolExecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整 maximumPoolSize 对其没有任何影响(所以 ScheduledThreadPoolExecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为Integer.MAX_VALUE)。此外，设置corePoolSize为0或者设置核心线程空闲后清除(allowCoreThreadTimeOut)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 常用命令]]></title>
    <link href="http://www.throne4j.com/16087365812100.html"/>
    <updated>2020-12-23T23:16:21+08:00</updated>
    <id>http://www.throne4j.com/16087365812100.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">软件包管理</h2>

<h3 id="toc_1">rpm -qa # 查看所有安装的软件包</h3>

<h3 id="toc_2">rpm -ivh  mysql-connector-odbc-5.1.5.rpm</h3>

<h3 id="toc_3">yum list  列出来所有可以安装的包</h3>

<h3 id="toc_4">yum search</h3>

<h3 id="toc_5">yum -y install     -y:yes</h3>

<h3 id="toc_6">yum -y install gcc</h3>

<h3 id="toc_7">rpm -p gcc</h3>

<h3 id="toc_8">yum -y update （包名）  远程千万不要要加包名</h3>

<h3 id="toc_9">yum -y remove （包名）卸载要添加包名</h3>

<h3 id="toc_10">yum grouplist</h3>

<h2 id="toc_11">操作系统</h2>

<h3 id="toc_12">uname -a # 查看内核/操作系统/CPU信息</h3>

<h3 id="toc_13">head -n 1 /etc/issue # 查看操作系统版本</h3>

<h3 id="toc_14">cat /proc/cpuinfo # 查看CPU信息</h3>

<h3 id="toc_15">hostname # 查看计算机名</h3>

<h3 id="toc_16">lspci -tv # 列出所有PCI设备</h3>

<h3 id="toc_17">lsusb -tv # 列出所有USB设备</h3>

<h3 id="toc_18">lsmod # 列出加载的内核模块</h3>

<h3 id="toc_19">env # 查看环境变量资源</h3>

<h3 id="toc_20">free -m # 查看内存使用量和交换区使用量</h3>

<h3 id="toc_21">df -h # 查看各分区使用情况</h3>

<h3 id="toc_22">du -sh &lt;目录名&gt; # 查看指定目录的大小</h3>

<h3 id="toc_23">grep MemTotal /proc/meminfo # 查看内存总量</h3>

<h3 id="toc_24">grep MemFree /proc/meminfo # 查看空闲内存量</h3>

<h3 id="toc_25">uptime # 查看系统运行时间、用户数、负载</h3>

<h3 id="toc_26">cat /proc/loadavg # 查看系统负载磁盘和分区</h3>

<h3 id="toc_27">mount | column -t # 查看挂接的分区状态</h3>

<h3 id="toc_28">fdisk -l # 查看所有分区</h3>

<h3 id="toc_29">swapon -s # 查看所有交换分区</h3>

<h3 id="toc_30">hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)</h3>

<h2 id="toc_31">网络</h2>

<h3 id="toc_32">dmesg | grep IDE # 查看启动时IDE设备检测状况网络</h3>

<h3 id="toc_33">ifconfig # 查看所有网络接口的属性</h3>

<h3 id="toc_34">iptables -L # 查看防火墙设置</h3>

<h3 id="toc_35">route -n # 查看路由表</h3>

<h3 id="toc_36">netstat -lntp # 查看所有监听端口</h3>

<h3 id="toc_37">netstat -antp # 查看所有已经建立的连接</h3>

<h3 id="toc_38">netstat -s # 查看网络统计信息进程</h3>

<h1 id="toc_39">ps -ef # 查看所有进程</h1>

<h1 id="toc_40">top # 实时显示进程状态用户</h1>

<h1 id="toc_41">w # 查看活动用户</h1>

<h1 id="toc_42">id &lt;用户名&gt; # 查看指定用户信息</h1>

<h1 id="toc_43">last # 查看用户登录日志</h1>

<h1 id="toc_44">cut -d: -f1 /etc/passwd # 查看系统所有用户</h1>

<h1 id="toc_45">cut -d: -f1 /etc/group # 查看系统所有组</h1>

<h1 id="toc_46">crontab -l # 查看当前用户的计划任务服务</h1>

<h1 id="toc_47">chkconfig –list # 列出所有系统服务</h1>

<h1 id="toc_48">chkconfig –list | grep on # 列出所有启动的系统服务程序</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring 框架去除 web.xml 实现 servlet 容器的初始化]]></title>
    <link href="http://www.throne4j.com/16082729328747.html"/>
    <updated>2020-12-18T14:28:52+08:00</updated>
    <id>http://www.throne4j.com/16082729328747.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">SpringServletContainerInitializer</h2>

<p>SpringServletContainerInitializer 继承自 Servlet3.0 包中的 ServletContainerInitializer 类，它借助 JAVA 中 SPI 思想进行调用，已达到去 web.xml 配置文件的容器初始化。</p>

<pre><code class="language-java">@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {

    public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext){
        
        // 将webAppInitializerClasses 存入 initializer 容器中
        
        ....
        
        for (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
        
    }
}
</code></pre>

<h2 id="toc_1">HandlesTypes 注解</h2>

<p>通过上面的代码 SpringServletContainerInitializer 被 @HandlesTypes 标注，这行的作用是将 WebApplicationInitializer 的实现类作为参数传递给 ServletContainerInitializer 的 onStartup 方法。</p>

<h2 id="toc_2">WebApplicationInitializer 接口</h2>

<p>WebApplicationInitializer 接口方便了以编程的方式配置 ServletContext</p>

<p>例如下面的这段配置</p>

<pre><code class="language-markup">&lt;servlet&gt;
 &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
 &lt;servlet-class&gt;
   org.springframework.web.servlet.DispatcherServlet
 &lt;/servlet-class&gt;
 &lt;init-param&gt;
   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
   &lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;
 &lt;/init-param&gt;
 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
  
&lt;servlet-mapping&gt;
 &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>将其通过代码实现的话如下所示：</p>

<pre><code class="language-java">public class MyWebAppInitializer implements WebApplicationInitializer {
  
  @Override
  public void onStartup(ServletContext container) {
    XmlWebApplicationContext appContext = new XmlWebApplicationContext();
    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);
  
    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  }
  
}
</code></pre>

<p>更进一步看怎么省去 dispatcher-config.xml 文件，将配置移交到 DispatherConfig 配置类中</p>

<pre><code class="language-java">public class MyWebAppInitializer implements WebApplicationInitializer {
  
  @Override
  public void onStartup(ServletContext container) {
    // Create the &#39;root&#39; Spring application context
    AnnotationConfigWebApplicationContext rootContext =
      new AnnotationConfigWebApplicationContext();
    rootContext.register(AppConfig.class);
  
    // Manage the lifecycle of the root application context
    container.addListener(new ContextLoaderListener(rootContext));
  
    // Create the dispatcher servlet&#39;s Spring application context
    AnnotationConfigWebApplicationContext dispatcherContext =
      new AnnotationConfigWebApplicationContext();
    dispatcherContext.register(DispatcherConfig.class);
  
    // Register and map the dispatcher servlet
    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(dispatcherContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  }
  
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ServletRequest、ServletResponse]]></title>
    <link href="http://www.throne4j.com/16082722990451.html"/>
    <updated>2020-12-18T14:18:19+08:00</updated>
    <id>http://www.throne4j.com/16082722990451.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作系统常用的调度算法总结]]></title>
    <link href="http://www.throne4j.com/16080888993841.html"/>
    <updated>2020-12-16T11:21:39+08:00</updated>
    <id>http://www.throne4j.com/16080888993841.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1 常见的批处理作业调度算法</h2>

<h3 id="toc_1">1.1 先来先服务调度算法（FCFS）:</h3>

<p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也用于进程调度</p>

<p>当在作业调度中采用该算法时，每次调度都是<strong>从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存</strong>，为它们分配资源、创建进程，然后放入就绪队列。</p>

<p>在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机</p>

<p>这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p>

<h3 id="toc_2">1.2 短作业优先调度算法(SPF)</h3>

<p>短作业优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。所谓短是指作业或进程的运行时间短。而在作业或进程未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值</p>

<p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p>

<h3 id="toc_3">1.3 最高响应比优先算法(HRN)</h3>

<p>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。</p>

<h3 id="toc_4">1.4 基于优先数调度算法(HPF)</h3>

<p>每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。<br/>
　　</p>

<h3 id="toc_5">1.5 均衡调度算法</h3>

<p>　　多级队列调度算法，基本概念：<br/>
　　作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)；<br/>
　　作业平均周转时间(T)＝周转时间/作业个数；<br/>
　　作业带权周转时间（Wi）＝周转时间/运行时间；<br/>
　　响应比＝（等待时间＋运行时间）/运行时间。</p>

<h2 id="toc_6">2 进程调度算法</h2>

<h3 id="toc_7">2.1 先进先出算法(FIFO):</h3>

<p>按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。<br/>
　　<br/>
<strong>每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行</strong>。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。<br/>
　　</p>

<h3 id="toc_8">2.2 时间片轮转算法(RR):</h3>

<p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。<br/>
　　</p>

<h3 id="toc_9">2.3 最高优先级算法(HPF):</h3>

<p>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。</p>

<h3 id="toc_10">2.4 多级反馈队列调度算法</h3>

<p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：</p>

<ul>
<li><p>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p></li>
<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。</p></li>
<li><p>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即第i队列中某个正在运行的进程的时间片用完后，由调度程序选择优先权较高的队列中的那一个进程，把处理机分配给它。</p></li>
</ul>

<h2 id="toc_11">3 空闲分区分配算法</h2>

<h3 id="toc_12">3.1 首先适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。</p>

<h3 id="toc_13">3.2 最佳适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。</p>

<h3 id="toc_14">3.3 最坏适应算法:</h3>

<p>当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p>

<h2 id="toc_15">4 虚拟页式存储管理中的页面置换算法</h2>

<h3 id="toc_16">4.1 理想页面置换算法(OPT):</h3>

<p>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择以后永不使用或在最长时间内不再被访问的内存页面予以淘汰。</p>

<h3 id="toc_17">4.2 先进先出页面置换算法(FIFO)：</h3>

<p>选择最先进入内存的页面予以淘汰。</p>

<h3 id="toc_18">4.3 最近最久未使用算法（LRU）：</h3>

<p>选择在最近一段时间内最久没有使用过的页，把它淘汰。</p>

<h3 id="toc_19">4.4 少使用算法（LFU）：</h3>

<p>选择到当前时间为止被访问次数最少的页转换。</p>

<h2 id="toc_20">5 磁盘调度</h2>

<h3 id="toc_21">5.1 先来先服务（FCFS）：</h3>

<p>是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置。</p>

<h3 id="toc_22">5.2 最短寻道时间优先（SSTF）：</h3>

<p>让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题。</p>

<h3 id="toc_23">5.3 扫描算法（SCAN）或电梯调度算法：</h3>

<p>　　总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>

<h3 id="toc_24">5.4 循环扫描算法（CSCAN）：</h3>

<p>　　循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ResponseBodyAdvice]]></title>
    <link href="http://www.throne4j.com/16079180311610.html"/>
    <updated>2020-12-14T11:53:51+08:00</updated>
    <id>http://www.throne4j.com/16079180311610.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HandlerInterceptor]]></title>
    <link href="http://www.throne4j.com/16079177661857.html"/>
    <updated>2020-12-14T11:49:26+08:00</updated>
    <id>http://www.throne4j.com/16079177661857.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RequestContextHolder 类详解]]></title>
    <link href="http://www.throne4j.com/16078839880324.html"/>
    <updated>2020-12-14T02:26:28+08:00</updated>
    <id>http://www.throne4j.com/16078839880324.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebApplicationContext]]></title>
    <link href="http://www.throne4j.com/16078839202895.html"/>
    <updated>2020-12-14T02:25:20+08:00</updated>
    <id>http://www.throne4j.com/16078839202895.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ContextLoaderListener]]></title>
    <link href="http://www.throne4j.com/16078838973010.html"/>
    <updated>2020-12-14T02:24:57+08:00</updated>
    <id>http://www.throne4j.com/16078838973010.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpMessage]]></title>
    <link href="http://www.throne4j.com/16078835677518.html"/>
    <updated>2020-12-14T02:19:27+08:00</updated>
    <id>http://www.throne4j.com/16078835677518.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HttpMessageConverter]]></title>
    <link href="http://www.throne4j.com/16078834576798.html"/>
    <updated>2020-12-14T02:17:37+08:00</updated>
    <id>http://www.throne4j.com/16078834576798.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebApplicationContext]]></title>
    <link href="http://www.throne4j.com/16078833088880.html"/>
    <updated>2020-12-14T02:15:08+08:00</updated>
    <id>http://www.throne4j.com/16078833088880.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程经典题]]></title>
    <link href="http://www.throne4j.com/16078608737984.html"/>
    <updated>2020-12-13T20:01:13+08:00</updated>
    <id>http://www.throne4j.com/16078608737984.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">多线程的出现是要解决什么问题的?</a>
</li>
<li>
<a href="#toc_1">并发出现问题的根源</a>
</li>
<li>
<a href="#toc_2">java 线程状态</a>
</li>
<li>
<a href="#toc_3">并行和并发</a>
</li>
<li>
<a href="#toc_4">进程与线程的区别</a>
</li>
<li>
<a href="#toc_5">java中守护进程和本地进程的区别</a>
</li>
<li>
<a href="#toc_6">通常线程有哪几种使用方式?</a>
</li>
<li>
<a href="#toc_7">死锁和活锁的区别，死锁与饥饿的区别</a>
</li>
<li>
<a href="#toc_8">怎么唤醒一个阻塞的线程？</a>
</li>
<li>
<a href="#toc_9">不可变对象对多线程有什么帮助</a>
</li>
<li>
<a href="#toc_10">什么是线程的上下文切换</a>
</li>
<li>
<a href="#toc_11">java 中用到的线程调度算法是什么</a>
</li>
<li>
<a href="#toc_12">Thread.sleep(0)的作用是什么？</a>
</li>
<li>
<a href="#toc_13">Runnable接口和Callable接口的区别？</a>
</li>
<li>
<a href="#toc_14">什么是线程组，为什么在 Java 中不推荐使用?</a>
</li>
<li>
<a href="#toc_15">多线程同步和互斥有几种实现方法？</a>
</li>
<li>
<a href="#toc_16">什么是java内存模型？</a>
</li>
<li>
<a href="#toc_17">volatile 关键字的作用？</a>
</li>
<li>
<a href="#toc_18">什么是 CAS</a>
</li>
<li>
<a href="#toc_19">ThreadLocal 有什么作用</a>
</li>
<li>
<a href="#toc_20">为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面?</a>
<ul>
<li>
<a href="#toc_21">为什么 wait 和 notify 方法要在同步块中调用?</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">怎么检测一个线程是否持有对象监视器</a>
</li>
<li>
<a href="#toc_23">同步方法和同步块，哪个是更好的选择</a>
</li>
<li>
<a href="#toc_24">乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</a>
</li>
<li>
<a href="#toc_25">什么是线程安全</a>
</li>
<li>
<a href="#toc_26">线程类的构造方法、静态块是被哪个线程调用的？</a>
</li>
<li>
<a href="#toc_27">Java中如何获取到线程dump文件？</a>
</li>
<li>
<a href="#toc_28">一个线程如果出现了运行时异常会怎么样？</a>
</li>
<li>
<a href="#toc_29">如何在两个线程之间共享数据？</a>
</li>
<li>
<a href="#toc_30">sleep方法和wait方法有什么区别 ？</a>
</li>
<li>
<a href="#toc_31">Java中interrupted 和 isInterrupted方法的区别？</a>
</li>
<li>
<a href="#toc_32">单例模式的线程安全性？</a>
</li>
<li>
<a href="#toc_33">HashTable 的size()方法中明明只有一条语句&quot;return count&quot;，为什么还要做同步？</a>
</li>
<li>
<a href="#toc_34">介绍一下Executor 框架</a>
<ul>
<li>
<a href="#toc_35">为什么使用 Executor 框架</a>
</li>
</ul>
</li>
<li>
<a href="#toc_36">Java 线程池中 submit() 和 execute()方法有什么区别?</a>
</li>
<li>
<a href="#toc_37">如果你提交任务时，线程池队列已满，这时会发生什么？</a>
</li>
<li>
<a href="#toc_38">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</a>
</li>
<li>
<a href="#toc_39">什么是 FutureTask</a>
</li>
<li>
<a href="#toc_40">什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</a>
</li>
<li>
<a href="#toc_41">什么是 AQS</a>
</li>
<li>
<a href="#toc_42">CyclicBarrier和CountDownLatch的区别？</a>
</li>
<li>
<a href="#toc_43">Semaphore 有什么作用</a>
</li>
<li>
<a href="#toc_44">写时复制容器可以用于什么应用场景</a>
</li>
<li>
<a href="#toc_45">生产者消费者模型的作用是什么？</a>
</li>
<li>
<a href="#toc_46">什么是可重入锁(ReentrantLock)?谈谈它的实现</a>
</li>
<li>
<a href="#toc_47">synchronized 和 ReentrantLock 的对比</a>
</li>
<li>
<a href="#toc_48">说一下 synchronized 的实现原理</a>
</li>
<li>
<a href="#toc_49">什么是自旋？</a>
</li>
<li>
<a href="#toc_50">ReadWriteLock 是什么</a>
</li>
<li>
<a href="#toc_51">ConcurrentHashMap的并发度是什么？</a>
</li>
<li>
<a href="#toc_52">Linux环境下如何查找哪个线程使用CPU最长</a>
</li>
</ul>


<h2 id="toc_0">多线程的出现是要解决什么问题的?</h2>

<p>随着计算机硬件技术的发展，CPU、内存、IO等设备的速度差异有了极大的差异，为了充分的利用 CPU 资源，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献。</p>

<ul>
<li>CPU 增加了缓存，以均衡与内存的速度差异， 导致了 可见性问题 </li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致了原子性问题 </li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致了顺序性问题</li>
</ul>

<h2 id="toc_1">并发出现问题的根源</h2>

<p>结合上一个问题看这个问题<br/>
原子性、可见性、有序性：</p>

<ul>
<li><p>原子性<br/>
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。</p>
<p>最有代表性的示例就是银行转账问题了：比如从账户A 向账户B 转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 </p>
<p>如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。则只有 账户A 上面少了 1000元，而账户B 上却没有收到这笔钱，1000元就这样蒸发了，这种情况是不是很可怕，要是转账1000W的话，不知有多少人要跳楼喽。</p></li>
<li><p>可见性<br/>
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。</p>
<p>现在假设有两个线程，分别是 CPU1 和 CPU2, 现在要修改一个变量 count = 0，先是 CPU1 从主内存中加载到 CPU1 的高速缓冲区，并对 count 进行修改 count = 10，但是这时候，count = 10 还未刷新回主存，CPU2 从主内存中 读取count，这时候的 count 值仍然是 0，CPU2 未立即得到 CPU1 的计算结果 count = 10，这既是可见性问题</p></li>
<li><p>有序性<br/>
有序性，即程序的执行顺序按照代码的先后顺序来执行。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： </p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </li>
<li>内存系统的重排序。由于处理器使用缓存和 读/写 缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul></li>
</ul>

<h2 id="toc_2">java 线程状态</h2>

<p><figure><img src="media/16078608737984/16078815638754.jpg" alt=""/></figure></p>

<p>在Java中线程的状态一共被分成6种：</p>

<ul>
<li>初始态：</li>
</ul>

<p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p>

<ul>
<li><p>运行态：<br/>
在Java中，运行态包括就绪态和运行态。</p>
<ul>
<li>就绪态该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。所有就绪态的线程存放在就绪队列中。</li>
<li>运行态获得CPU执行权，正在执行的线程。由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li>
</ul></li>
<li><p>阻塞态：<br/>
当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在Java中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。PS：锁、IO、Socket等都资源。</p></li>
<li><p>等待态：<br/>
当前线程中调用wait、join、park 函数时，当前线程就会进入等待态。也有一个等待队列存放所有等待态的线程。线程处于等待态表示它需要等待其他线程的指示才能继续运行。进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</p></li>
<li><p>超时等待态：<br/>
当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；进入该状态后释放CPU执行权 和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p></li>
<li><p>终止态：<br/>
线程执行结束后的状态。</p></li>
</ul>

<p><strong>注意</strong>：</p>

<ul>
<li>wait()方法会释放CPU执行权和占有的锁。</li>
<li>sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li>
<li>yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li>
<li>wait和notify必须配套使用，即必须使用同一把锁调用；</li>
<li>wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</li>
</ul>

<h2 id="toc_3">并行和并发</h2>

<p>并发:指应用能够交替执行不同的任务,比如单 CPU 核心下执行多线程并非是 同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不 断去切换这两个任务,已达到&quot;同时执行效果&quot;,其实并不是的,只是计算机的速度太 快,我们无法察觉到而已.</p>

<p>并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话, 这两件事情可以同时执行</p>

<p>两者区别:一个是交替执行,一个是同时执行.</p>

<h2 id="toc_4">进程与线程的区别</h2>

<p>线程具有许多传统进程锁具有的特征，故又称为轻型进程，而把传统的进程成为重型进程，它相当于只有一个线程的任务。在引入线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p>

<ul>
<li>根本区别：进程是操作系统资源分配的基本单位，线程是处理器任务调度和执行的基本单位</li>
<li>资源开销： 每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换开销较小</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多线程共同完成的；线程是进程的一部分，所以线程也被成为轻量进程</li>
<li>内存分配：同一个进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</li>
<li>影响关系： 一个进程崩溃后，在保护模式下不会对其它进程产生影响，但是一个线程崩溃整个进程都会crash，所以多进程要比多线程健壮</li>
<li>执行过程：每个独立的进程有程序运行入口、顺序执行序列和程序出口，但是线程不能独立运行，必须依存在应用程序中，有应用程序提供多个线程执行控制，两者均可并发执行。</li>
</ul>

<h2 id="toc_5">java中守护进程和本地进程的区别</h2>

<p>java中线程分为两种：守护线程和用户线程</p>

<p>任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolean on) true则把该线程设置为守护线程，反之则为用户线程(这个方法必须在线程 start 之前设置才会生效)</p>

<p>两者区别：</p>

<ul>
<li>当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。</li>
<li>在 Daemon 线程中产生的新线程也是 Daemon 的。</li>
<li>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务，比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了。</li>
</ul>

<h2 id="toc_6">通常线程有哪几种使用方式?</h2>

<ul>
<li>Runnable 不带返回值的任务</li>
<li>Callable 带返回值的任务</li>
<li>Thread</li>
</ul>

<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>

<h2 id="toc_7">死锁和活锁的区别，死锁与饥饿的区别</h2>

<p>死锁与活锁请参见 <a href="16017068710077.html">死锁与活锁</a></p>

<p>饥饿：一个或者多个线程因为种种原因无法获得所需的资源，导致一直无法执行的状态</p>

<p>java中导致饥饿的原因：</p>

<ul>
<li>高优先级的线程侵占所有低优先级线程的 CPU 时间</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续的对该同步代码块进行访问</li>
<li>线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的 wait 方法，因为其它线程总是被持续的获得唤醒</li>
</ul>

<h2 id="toc_8">怎么唤醒一个阻塞的线程？</h2>

<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>

<h2 id="toc_9">不可变对象对多线程有什么帮助</h2>

<p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步操作，提升了代码的执行效率</p>

<h2 id="toc_10">什么是线程的上下文切换</h2>

<p>多线程的上下文切换是指cpu控制权由一个正在运行的线程切换到另一个就绪并等待获取 cpu 执行权的线程的过程。cpu在切换线程的时候，要保留上一个线程的车祸现场，一遍下次轮到它的时候，可以恢复车祸线程方便警察叔叔执行公务。</p>

<h2 id="toc_11">java 中用到的线程调度算法是什么</h2>

<p>操作系统中线程调度是系统为线程分配 cpu 资源的过程，主要调度方式有两种</p>

<ul>
<li><p>协同式线程调度<br/>
使用协同式线程调度的多线程系统，线程执行的时间由线程本身来控制，线 程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。</p></li>
<li><p>抢占式线程调度<br/>
使用抢占式线程调度的多线程系统，每个线程执行的时间以及是否切换都由 系统决定。</p></li>
</ul>

<p>Java 中的线程是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，而操作系统级别，OS 是以抢占式调度线程，我们可以认为线程是抢占式的。Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。而且操作系统中线程的优先级有时并不能和 Java 中的一一对应，所以 Java 优先级并不是特别靠谱。</p>

<h2 id="toc_12">Thread.sleep(0)的作用是什么？</h2>

<p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>

<h2 id="toc_13">Runnable接口和Callable接口的区别？</h2>

<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>

<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>

<h2 id="toc_14">什么是线程组，为什么在 Java 中不推荐使用?</h2>

<p>线程组 ThreadGroup 对象中比较有用的方法是 stop、resume、suspend 等 方法，由于这几个方法会导致线程的安全问题(主要是死锁问题)，已经被官方 废弃掉了，所以线程组本身的应用价值就大打折扣了。</p>

<p>线程组 ThreadGroup 不是线程安全的，这在使用过程中获取的信息并不全 是及时有效的，这就降低了它的统计使用价值。</p>

<h2 id="toc_15">多线程同步和互斥有几种实现方法？</h2>

<p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个 线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>

<p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以 看成是一种特殊的线程同步。</p>

<p>线程间的同步方法大体可分为两类: 用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p>

<p>用户模式下的方法有: 原子操作(例如一个单一的全局变量)，临界区。内核模式下的方法有: 事件，信号量，互斥量。</p>

<h2 id="toc_16">什么是java内存模型？</h2>

<p>详情请参见 ：<a href="16019058386155.html">java 内存模型之初识</a><br/>
<a href="16020511412975.html">java内存模型之 volatile 同步原语详解</a><br/>
<a href="16082130374121.html">java内存模型之 final 同步原语详解</a><br/>
<a href="16005248987908.html">java内存模型之 Synchronized 同步原语详解</a></p>

<h2 id="toc_17">volatile 关键字的作用？</h2>

<p>理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见<a href="16019058386155.html">java 内存模型</a><br/><br/>
这里简要说明一下 volatile关键字的作用，主要有两个：</p>

<ul>
<li><p>多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p></li>
<li><p>代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是Java代码--&gt;字节码--&gt;根据字节码执行对应的C/C++代码--&gt;C/C++代码被编译成汇编语言--&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。</p></li>
</ul>

<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>

<h2 id="toc_18">什么是 CAS</h2>

<p>详情请参见 ：<a href="15874857577712.html">原子操作CAS 无锁操作</a></p>

<h2 id="toc_19">ThreadLocal 有什么作用</h2>

<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。详情请参见：<a href="ThreadLocal.html">ThreadLocal源码分析以及使用</a></p>

<h2 id="toc_20">为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面?</h2>

<p>JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获 得。如果线程需要等待某些锁那么调用对象中的 wait()方法就有意义了。如果 wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说， 由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中 因为锁属于对象。</p>

<h3 id="toc_21">为什么 wait 和 notify 方法要在同步块中调用?</h3>

<p>主要是因为 Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</p>

<h2 id="toc_22">怎么检测一个线程是否持有对象监视器</h2>

<p>Thread 类提供了一个 holdsLock(Object obj)方法，当且仅当对象obj的监视器被当前线程持有的时候才会返回true</p>

<h2 id="toc_23">同步方法和同步块，哪个是更好的选择</h2>

<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>

<p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁--&gt;解锁的次数，有效地提升了代码执行的效率。</p>

<h2 id="toc_24">乐观锁和悲观锁的理解及如何实现，有哪些实现方式?</h2>

<ul>
<li><p>悲观锁:总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所 以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。 Java 里面的同步原语 synchronized 关键字的实现是悲观锁。</p></li>
<li><p>乐观锁:顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改， 所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，可以使用版本号等机制。在 Java 中 j 原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 乐观锁的实现方式:</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交 后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程 都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以 再次尝试。</li>
</ul></li>
</ul>

<h2 id="toc_25">什么是线程安全</h2>

<p>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p>

<h2 id="toc_26">线程类的构造方法、静态块是被哪个线程调用的？</h2>

<p>线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>

<p>假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>

<ul>
<li>Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li>
<li>Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li>
</ul>

<h2 id="toc_27">Java中如何获取到线程dump文件？</h2>

<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p>

<ul>
<li>获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</li>
<li>打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</li>
</ul>

<p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p>

<h2 id="toc_28">一个线程如果出现了运行时异常会怎么样？</h2>

<p>如果这个线程的异常没有被捕获的话，这个线程会停止执行，如果这个线程持有某个对象的监视器，那么这个对象监视器也会被立即释放</p>

<h2 id="toc_29">如何在两个线程之间共享数据？</h2>

<p>通过共享对象，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的。</p>

<h2 id="toc_30">sleep方法和wait方法有什么区别 ？</h2>

<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>

<h2 id="toc_31">Java中interrupted 和 isInterrupted方法的区别？</h2>

<p>interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。<br/>
注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>

<p>interrupted查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。</p>

<p>isInterrupted仅仅是查询当前线程的中断状态</p>

<h2 id="toc_32">单例模式的线程安全性？</h2>

<p><a href="15896032913368.html">单例模式</a></p>

<h2 id="toc_33">HashTable 的size()方法中明明只有一条语句&quot;return count&quot;，为什么还要做同步？</h2>

<p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p>

<h2 id="toc_34">介绍一下Executor 框架</h2>

<p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务 的框架。它管理多个异步任务的执行，而无需程序员显式的管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>

<p>Executor主要有三种: </p>

<ul>
<li>CachedThreadPool: 一个任务创建一个线程； </li>
<li>FixedThreadPool: 所有任务只能使用固定大小的线程； </li>
<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>
</ul>

<h3 id="toc_35">为什么使用 Executor 框架</h3>

<ul>
<li>第一:降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二:提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立 即执行。</li>
<li>第三:提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>

<h2 id="toc_36">Java 线程池中 submit() 和 execute()方法有什么区别?</h2>

<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定 义在 Executor 接口中。<br/>
而 submit()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口</p>

<h2 id="toc_37">如果你提交任务时，线程池队列已满，这时会发生什么？</h2>

<p>这里区分一下：</p>

<p>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</p>

<p>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</p>

<h2 id="toc_38">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h2>

<p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p>

<p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>

<p>（2）并发不高、任务执行时间长的业务要区分开看：</p>

<p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p>

<p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>

<p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>

<h2 id="toc_39">什么是 FutureTask</h2>

<p>FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask 也可以放入线程池中。</p>

<h2 id="toc_40">什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2>

<p>阻塞队列是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>

<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>

<p>JDK7提供了7个阻塞队列。分别是：</p>

<ul>
<li><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p></li>
<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p></li>
<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p></li>
<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p></li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p></li>
<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p></li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p></li>
</ul>

<p>BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>

<p>阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析</p>

<h2 id="toc_41">什么是 AQS</h2>

<p>详情请参见 ： <a href="15867876320249.html">AQS--AbstractQueuedSynchronizer 详解</a></p>

<h2 id="toc_42">CyclicBarrier和CountDownLatch的区别？</h2>

<p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>

<ul>
<li><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p></li>
<li><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p></li>
<li><p>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p></li>
</ul>

<h2 id="toc_43">Semaphore 有什么作用</h2>

<p>详情请参见 <a href="16017007365424.html">Semaphore</a></p>

<h2 id="toc_44">写时复制容器可以用于什么应用场景</h2>

<p>CopyOnWrite 并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>

<p>CopyOnWriteArrayList(免锁容器) 的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。</p>

<p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>

<ul>
<li><p>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；</p></li>
<li><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</p></li>
</ul>

<p>CopyOnWriteArrayList透露的思想：读写分离，读和写分开、最终一致性、使用另外开辟空间的思路，来解决并发冲突</p>

<h2 id="toc_45">生产者消费者模型的作用是什么？</h2>

<ul>
<li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</li>
<li>解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</li>
</ul>

<h2 id="toc_46">什么是可重入锁(ReentrantLock)?谈谈它的实现</h2>

<p>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块， synchronized、ReentrantLock 都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每释放一次锁， 进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p>

<h2 id="toc_47">synchronized 和 ReentrantLock 的对比</h2>

<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>

<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>

<h2 id="toc_48">说一下 synchronized 的实现原理</h2>

<p>详情请参见： <a href="16005248987908.html">Synchronized关键字解析</a></p>

<h2 id="toc_49">什么是自旋？</h2>

<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>

<h2 id="toc_50">ReadWriteLock 是什么</h2>

<p>首先我们得直到 ReentrantLock 的局限性。</p>

<p>如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>

<p>因为这个，才诞生了读写锁 ReadWriteLock。ReadWriteLock 是一个读写锁接口，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>

<h2 id="toc_51">ConcurrentHashMap的并发度是什么？</h2>

<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p>

<p>在JDK8后，它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>

<h2 id="toc_52">Linux环境下如何查找哪个线程使用CPU最长</h2>

<ul>
<li>获取项目的pid，jps 或者 ps -ef | grep java</li>
<li>top -H -p pid，顺序不能改变</li>
</ul>

<p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。</p>

<p>注意这里打出的是LWP，也就是操作系统原生线程的线程号。</p>

<p>使用&quot;top -H -p pid&quot; + &quot;jps pid&quot; 可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p>

<p>最后提一点，&quot;top -H -p pid&quot;打出来的LWP是十进制的，&quot;jps pid&quot;打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring 面试题]]></title>
    <link href="http://www.throne4j.com/16078475422536.html"/>
    <updated>2020-12-13T16:19:02+08:00</updated>
    <id>http://www.throne4j.com/16078475422536.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是控制反转(IOC)？什么是依赖注入？</h2>

<h2 id="toc_1">BeanFactory 和 ApplicationContext 有什么区别？</h2>

<h2 id="toc_2">请解释 Spring Bean 的生命周期？</h2>

<h2 id="toc_3">请举例解释@Autowired 注解？</h2>

<h2 id="toc_4">Spring 框架中有哪些不同类型的事件？</h2>

<ul>
<li><p>1.上下文更新事件ContextRefreshedEvent： 该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用 ConfigurableApplicationContext 接口中的 refresh()方法时被触发。</p></li>
<li><p>2.上下文开始事件ContextStartedEvent： 当容器调用ConfigurableApplicationContext的 Start()方法开始/重新开始容器时触发该事件。</p></li>
<li><p>3.上下文停止事件ContextStoppedEvent： 当容器调用 ConfigurableApplicationContext的 Stop()方法停止容器时触发该事件。</p></li>
<li><p>4.上下文关闭事件ContextClosedEvent： 当 ApplicationContext 被 关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</p></li>
<li><p>5.请求处理事件RequestHandledEvent： 在 Web 应用中，当一个 http 请求（request）结束触发该事件。除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发自定义的事件。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是脏读、幻读、不可重复度]]></title>
    <link href="http://www.throne4j.com/16077870652991.html"/>
    <updated>2020-12-12T23:31:05+08:00</updated>
    <id>http://www.throne4j.com/16077870652991.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">隔离级别详解</h1>

<h1 id="toc_1">Mysql 存储引擎、行锁、表锁、隔离性关联</h1>

<h1 id="toc_2">Mysql LBCC （lock Model) 底层实现</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netty 之 Channel]]></title>
    <link href="http://www.throne4j.com/16075310570444.html"/>
    <updated>2020-12-10T00:24:17+08:00</updated>
    <id>http://www.throne4j.com/16075310570444.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/16075310570444/NioSocketChannel.jpg" alt="NioSocketChannel"/><figcaption>NioSocketChannel</figcaption></figure><br/>
<figure><img src="media/16075310570444/NioServerSocketChannel.jpg" alt="NioServerSocketChannel"/><figcaption>NioServerSocketChannel</figcaption></figure></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netty 之 EventLoop 相关源码分析]]></title>
    <link href="http://www.throne4j.com/16074361744050.html"/>
    <updated>2020-12-08T22:02:54+08:00</updated>
    <id>http://www.throne4j.com/16074361744050.html</id>
    <content type="html"><![CDATA[
<p><figure><img src="media/16074361744050/NioEventLoop.jpg" alt="NioEventLoop"/><figcaption>NioEventLoop</figcaption></figure><br/>
<figure><img src="media/16074361744050/NioEventLoopGroup.jpg" alt="NioEventLoopGroup"/><figcaption>NioEventLoopGroup</figcaption></figure></p>

<h2 id="toc_0">EventLoopGroup 和 EventLoop 代码分析</h2>

<pre><code class="language-text">EventLoopGroup group = new NioEventLoopGroup();
</code></pre>

<p>执行这行代码时会发生什么?，由 NioEventLoopGroup 开始，一路调用，到达 MultithreadEventLoopGroup，如果没有指定创建的线程数量，则默认创建的线程个数为 DEFAULT_EVENT_LOOP_THREADS，该数值为:处理器数量 x2。</p>

<pre><code class="language-java">private static final int DEFAULT_EVENT_LOOP_THREADS;

static {
    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
            &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));
}

protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}
</code></pre>

<p>最终由 MultithreadEventExecutorGroup 实例化</p>

<p>由此可见，每个 NioEventLoop 的执行器为 ThreadPerTaskExecutor，ThreadPerTaskExecutor 实现了 Executor 接口，并会在 execute 方法中启动真正的线程，但是要和 NioEventLoop 的线 程挂钩则在 SingleThreadEventExecutor 的 doStartThread 方法里</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring AOP]]></title>
    <link href="http://www.throne4j.com/16073961967770.html"/>
    <updated>2020-12-08T10:56:36+08:00</updated>
    <id>http://www.throne4j.com/16073961967770.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">execution 表达式</h2>

<pre><code class="language-text">execution(* com.loongshawn.method..*.*(..))
</code></pre>

<p>execution 表达式主体</p>

<ul>
<li>第一个 * 表示任何返回对象</li>
<li>com.loongshawn.method 包</li>
<li>后来的 .. 表示当前包以及子包</li>
<li>第二个 * 表示类名</li>
<li>*.(..) 表示任何方法名，括号表示参数，两个点表示任何参数类型</li>
</ul>

]]></content>
  </entry>
  
</feed>
