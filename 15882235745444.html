<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  CompletableFuture - 大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>CompletableFuture</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/04/30</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <ul>
<li>
<a href="#toc_0">概览</a>
</li>
<li>
<a href="#toc_1">创建CompletableFuture对象</a>
</li>
<li>
<a href="#toc_2">CompletableFuture 其它操作</a>
<ul>
<li>
<a href="#toc_3">whenComplete* 和 exceptionally 方法</a>
</li>
<li>
<a href="#toc_4">handle* 方法</a>
</li>
<li>
<a href="#toc_5">thenApply* 方法：连接</a>
</li>
<li>
<a href="#toc_6">thenAccept* 方法：纯消费一个CompletableFuture对象的结果</a>
</li>
<li>
<a href="#toc_7">thenAcceptBoth* 方法：在两个CompletableFuture对象的执行完后执行。</a>
</li>
<li>
<a href="#toc_8">thenRun* 方法：不消费CompletableFuture对象的结果，执行一个新任务。</a>
</li>
<li>
<a href="#toc_9">acceptEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它没有返回值。</a>
</li>
<li>
<a href="#toc_10">applyToEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它有返回值。</a>
</li>
<li>
<a href="#toc_11">辅助方法 ：allOf 和 anyOf</a>
</li>
</ul>
</li>
<li>
<a href="#toc_12">更进一步</a>
</li>
</ul>


<h2 id="toc_0">概览</h2>

<p>1、CompletableFuture是java8引入的新类，该类实现了 Future 接口和 CompletionStage 接口，封装了future、forkjoin相关类来执行异步，所以你还是可以像以前一样通过阻塞(get)或者轮询的方式获得结果，尽管这种方式不推荐使用。</p>

<p>2、CompletionStage 接口代表异步计算中的 不同阶段，以及如何 组合 这些计算阶段。</p>

<p>3、CompletableStage 接口中有 50 多个方法，可以对 CompletableStage 进行组合、计算，方法看似很多，但可以按功能对其分类，大多数方法都有 3 种变体：</p>

<ul>
<li>不带 Async 方法：同步方法</li>
<li>带 Async，只有一个参数：异步方法，使用默认的 ForkJoinPool.commonPool() 获取线程池</li>
<li>带 Async，有两个参数：异步方法，且使用第二个参数指定的 ExecutorService 线程池</li>
</ul>

<h2 id="toc_1">创建CompletableFuture对象</h2>

<pre><code class="language-text">//比较特殊，他入参就是返回值，也就是说他可以用来执行需要其他返回值的异步任务。
public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)

//无返回值，使用默认线程池
public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable)

//无返回值，使用自定义线程池
public static CompletableFuture&lt;Void&gt;   runAsync(Runnable runnable, Executor executor)

//有返回值，使用默认线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier)

//有返回值，使用自定义线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt;  supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)

//
public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)
</code></pre>

<p>举例：</p>

<pre><code class="language-text">//supplyAsync方法无入参，但是返回一个String对象。此方法使用了默认的线程池执行异步任务
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    //长时间的计算任务
    return &quot;·00&quot;;
});
</code></pre>

<h2 id="toc_2">CompletableFuture 其它操作</h2>

<p>下面将通过具体例子来展示各个方法的使用。</p>

<h3 id="toc_3">whenComplete* 和 exceptionally 方法</h3>

<p>当原始的CompletableFuture任务执行完后，不管是否成功计算出结果，还是抛出异常，都会会执行 whenComplete* 或 exceptionally 的方法中的任务。<br/>
该操作执行完毕后：</p>

<ul>
<li>会返回一个新的CompletableFuture对象！！！</li>
<li>使用whenComplete*方法时，返回的新的CompletableFuture对象的返回结果和原始的CompletableFuture对象计算结果相同</li>
<li>使用 exceptionally方法时，如果原始计算逻辑抛出异常，那么返回的 新的CompletableFuture对象 的返回结果由该方法的return值决定；如果原始计算逻辑没有抛出异常，那么返回的 新的CompletableFuture对象 的返回结果和原始计算逻辑返回的结果一致。有点绕，先不明白没关系，下面会有四个exceptionally实例解释这段话。</li>
</ul>

<pre><code class="language-text">BiConsumer&lt;T,U&gt; 函数接口有两个参数，无返回值。
Function&lt;T,R&gt; 函数接口有一个输入参数，返回一个结果。

//无Async，同步处理正常计算结果或异常，使用执行任务的那个线程来执行该方法，所以这个方法是同步的。
public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)
//有Async，异步处理正常计算结果或异常，使用执行任务的那个线程池中的线程来执行该方法！所以这个方法是异步的。
public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)
//有Async，异步处理正常计算结果或异常，使用自定义线程池来执行该方法，所以这个方法是异步的。
public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? superThrowable&gt; action, Executor executor)
//处理异常。
public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)
</code></pre>

<p>注意：当没有异常抛出来的时候，上面的Throwable参数为空！举例：</p>

<pre><code class="language-text">    private static Random random = new Random();
    private static long time = System.currentTimeMillis();

    public static int getMoreData(){
        System.out.println(&quot;begin to start compute&quot;);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(&quot;end to compute, passed:&quot; + System.currentTimeMillis());
        return random.nextInt(1000);
    }

    public static int throwException(){
        System.out.println(&quot;准备抛出异常&quot;);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(&quot;抛了&quot;);
        throw new RuntimeException(&quot;主动抛出异常&quot;);
    }
</code></pre>

<p>whenComplete：</p>

<pre><code class="language-text">    //如果使用这段代码，则会是和当前线程同步执行
    public static void main(String[] args) throws Exception{
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; getMoreData());

        CompletableFuture&lt;Integer&gt; future2 = future.whenComplete((result, excetion) -&gt; {
            System.out.println(&quot;执行到whenComplete了，result:&quot; + result);
            System.out.println(&quot;执行到whenComplete了，exception:&quot; + (excetion == null ? &quot;无异常&quot; : excetion.getClass()));
        });
        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    }

&gt; 打印执行结果：  
begin to start compute  
end to compute, passed:1551182552193  
执行到whenComplete了，result:625  
执行到whenComplete了，exception:无异常  
执行到最后一段代码了，future result：625  
执行到最后一段代码了，future2 result：625  

&gt;从打印结果可知，whenComplete使用原始的执行的任务的线程，所以可以看成是同步执行的，并且新的CompletableFuture对象的结果和原始的一致
</code></pre>

<p>whenCompleteAsync：</p>

<pre><code class="language-text">    //如果使用这段代码，则会是和当前线程同步执行
    public static void main(String[] args) throws Exception{
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; getMoreData());

        future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (excetion == null ? &quot;无异常&quot; : excetion.getClass()));
        });
        System.out.println(&quot;执行到最后一段代码了，result：&quot; + future.get());
    }

&gt; 打印执行结果：  
begin to start compute  
end to compute, passed:1551180611064  
执行到最后一段代码了，result：323  
执行到whenComplete了，result:323  
执行到whenComplete了，exception:无异常  

&gt;从打印结果可知，whenCompleteAsync是异步执行的
</code></pre>

<p>exceptionally比较复杂，需要通过4个实例才能真正明白：<br/>
exceptionally实例1：</p>

<pre><code class="language-text">    //这段代码，由于会抛出异常，会先走whenCompleteAsync，然后再走exceptionally，而且是无法获取到返回值的。
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        }).exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            return 0;
        });

       System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: 主动抛出异常
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
    at me.ele.ecs.eapp.service.impl.Main.main(Main.java:69)
Caused by: java.lang.RuntimeException: 主动抛出异常
    at me.ele.ecs.eapp.service.impl.Main.throwException(Main.java:37)
    at me.ele.ecs.eapp.service.impl.Main.lambda$main$0(Main.java:44)
</code></pre>

<p>exceptionally实例2：</p>

<pre><code class="language-text">    //这里的打印结果是和上面类似的，可是为什么这次要获取新的CompletableFuture对象呢？看下面的exceptionally实例3后，再回来对比吧
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        });

        CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            return 0;
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
       //因为上面的执行过程中，已经抛出了异常了，那么下面的这两段代码是无法执行到的，
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
        System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: 主动抛出异常
    at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)
    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1895)
    at me.ele.ecs.eapp.service.impl.Main.main(Main.java:69)
Caused by: java.lang.RuntimeException: 主动抛出异常
    at me.ele.ecs.eapp.service.impl.Main.throwException(Main.java:37)
    at me.ele.ecs.eapp.service.impl.Main.lambda$main$0(Main.java:44)
</code></pre>

<p>exceptionally实例3：</p>

<pre><code class="language-text">    //
    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; throwException());

        CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
        });

        CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
            System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
            //这里的返回值实际其是没有用处的。因为如果抛出了异常，future的get方法是执行不到的；而如果没有抛出异常的话，还是会返回原始的CompletableFuture的值的
            //所以这个exceptionally就是仅仅用来处理异常的。
            return 0;
        });

        //System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        //System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
        //和上面实例2唯一的区别就是注释掉了上面两段代码，但是执行结果却不一样了，而且整个main方法都没有抛出来异常，原因就在于future和future2是异步执行的，所以是在别的线程抛了异常，而main方法是不会抛出来的。而且在获取future3的结果时，可以发现，返回了future3对象自定义的返回值
        System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
    }

&gt; 打印执行结果：  
准备抛出异常
抛了
计算已执行完毕，result:null
计算已执行完毕，exception:class java.util.concurrent.CompletionException
计算执行过程中发生了异常，exception:class java.util.concurrent.CompletionException
执行到最后一段代码了，future3 result：0
</code></pre>

<p>exceptionally实例4：</p>

<pre><code class="language-text">public static void main(String[] args) throws Exception{

    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

    CompletableFuture&lt;Integer&gt; future2 = future.whenCompleteAsync((result, exception) -&gt; {
        System.out.println(&quot;计算已执行完毕，result:&quot; + result);
        System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
    });

    CompletableFuture&lt;Integer&gt; future3 = future2.exceptionally(exception -&gt; {
        System.out.println(&quot;计算执行过程中发生了异常，exception:&quot; + exception.getClass());
        return 0;
    });

    System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
    System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    //原始的计算逻辑不变，exceptionally返回的新的CompletableFuture对象的结果和原始计算逻辑返回的结果一致。
    System.out.println(&quot;执行到最后一段代码了，future3 result：&quot; + future3.get());
}
</code></pre>

<blockquote>
<p>打印执行结果：<br/><br/>
begin to start compute<br/>
end to compute, passed:1551239497158<br/>
getMoreData: 679<br/>
执行到最后一段代码了，future result：679<br/>
计算已执行完毕，result:679<br/>
计算已执行完毕，exception:无异常<br/>
执行到最后一段代码了，future2 result：679<br/>
执行到最后一段代码了，future3 result：679</p>

<pre><code class="language-text"></code></pre>
</blockquote>

<h3 id="toc_4">handle* 方法</h3>

<p>和 whenComplete* 方法一样，都是在任务执行完后，执行该方法的逻辑，但是和 whenComplete* 不同的是：<br/>
该操作执行完毕后，它返回的新CompletableFuture对象的计算结果是handle*方法的返回值，并不是原始计算逻辑的返回值</p>

<pre><code class="language-java">//同步
public &lt;U&gt; CompletableFuture&lt;U&gt;     handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
//异步，使用原始CompletableFuture的线程
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)
//异步，使用自定义线程池的线程
public &lt;U&gt; CompletableFuture&lt;U&gt;     handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)
</code></pre>

<p>代码实例：</p>

<pre><code class="language-java">    public static void main(String[] args) throws Exception{

        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Integer&gt; future2 = future.handleAsync((result, exception) -&gt; {
            System.out.println(&quot;计算已执行完毕，result:&quot; + result);
            System.out.println(&quot;计算已执行完毕，exception:&quot; + (exception == null ? &quot;无异常&quot; : exception.getClass()));
            return result + 1;
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
    }

&gt; 打印执行结果：  
begin to start compute
end to compute, passed:1551243326193
getMoreData: 395
执行到最后一段代码了，future result：395
计算已执行完毕，result:395
计算已执行完毕，exception:无异常
执行到最后一段代码了，future2 result：396
</code></pre>

<h3 id="toc_5">thenApply* 方法：连接</h3>

<p>thenApply* 可以连接多个CompletableFuture对象，相当于将一个一个的CompletableFuture串联起来了，第一个CompletableFuture对象的结果会传递到下一个对象中，并且下一个CompletableFuture对象的结算结果会作为上一个对象的CompletableFuture结果，依次类推，也就是说会改变原始CompletableFuture对象的结果。<br/>
注：它和 handle 方法有点类似，都会拿到上一个CompletableFuture对象的结果进行计算，但是区别就是thenApply 会改变原始对象的计算结果，而 handle* 并不会**。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApply(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)
复制代码public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
        return 100;
        });
       //由于这里同时连接了多个thenApplyAsync，第一个是异步的，第二个是同步的，并且都没有处理异常，所以异常会直接在执行计算的线程上抛出来。
       CompletableFuture&lt;String&gt; f =  future.thenApplyAsync(i -&gt; i * 10).thenApply(i -&gt; i.toString());
       System.out.println(f.get()); //&quot;1000&quot;
}
</code></pre>

<h3 id="toc_6">thenAccept* 方法：纯消费一个CompletableFuture对象的结果</h3>

<p>thenAccept* 返回的新的CompletableFuture对象不返回结果，如果使用get方法，会返回一个null。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  thenAccept(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)
</code></pre>

<pre><code class="language-text">public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Void&gt; future2 = future.thenAccept(result -&gt; {
            System.out.println(&quot;执行到thenAccept了, result：&quot; + result);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result: &quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
end to compute, passed:1551341977684
getMoreData: 171
执行到thenAccept了, result：171
执行到最后一段代码了，future result：171
执行到最后一段代码了，future2 result: null
</code></pre>

<h3 id="toc_7">thenAcceptBoth* 方法：在两个CompletableFuture对象的执行完后执行。</h3>

<p>它和 thenAccept 一样，都是纯消费，但是thenAccept<em>只能消费一个CompletableFuture对象，而thenAcceptBoth</em> 能在两个不同的CompletableFuture对象执行完成后，消费他们两个的计算结果。<br/>
而且他仅仅在原始的两个CompletableFuture对象都计算成功之后，才开始执行。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)
public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)
public &lt;U&gt; CompletableFuture&lt;Void&gt;  thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)

//runAfterBoth和上面三个的区别就是它不消费原始的CompletableFuture结果
public     CompletableFuture&lt;Void&gt;  runAfterBoth(CompletionStage&lt;?&gt; other,  Runnable action)
</code></pre>

<pre><code class="language-java">
public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(Main::getMoreData);

        future.thenAcceptBothAsync(future2, (x, y) -&gt; {
            System.out.println(&quot;future1 和 future都执行完成了，结果分别是：&quot; + x + &quot;,&quot; + y);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result: &quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
begin to start compute
end to compute, passed:1551342475808
getMoreData: 920
执行到最后一段代码了，future result：920
end to compute, passed:1551342475811
getMoreData: 747
执行到最后一段代码了，future2 result: 747
future1 和 future都执行完成了，结果分别是：920,747
</code></pre>

<h3 id="toc_8">thenRun* 方法：不消费CompletableFuture对象的结果，执行一个新任务。</h3>

<p>在原始CompletableFuture执行任务结束后，而且执行指定的任务，不消费，也不产生结果。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  thenRun(Runnable action)
public CompletableFuture&lt;Void&gt;  thenRunAsync(Runnable action)
public CompletableFuture&lt;Void&gt;  thenRunAsync(Runnable action, Executor executor)
复制代码public static void main(String[] args) throws ExecutionException, InterruptedException {
         CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);

        CompletableFuture&lt;Void&gt; future2 = future.thenRunAsync(() -&gt; {
            System.out.println(&quot;future执行完成了&quot;);
        });

        System.out.println(&quot;执行到最后一段代码了，future result：&quot; + future.get());
        System.out.println(&quot;执行到最后一段代码了，future2 result：&quot; + future2.get());
}
&gt; 打印执行结果：
begin to start compute
end to compute, passed:1551344347162
getMoreData: 688
执行到最后一段代码了，future result：688
future执行完成了
执行到最后一段代码了，future2 result：null
</code></pre>

<h3 id="toc_9">acceptEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它没有返回值。</h3>

<p>runAfterBoth是当两个CompletableFuture都计算完成后才执行。</p>

<pre><code class="language-java">public CompletableFuture&lt;Void&gt;  acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)
public CompletableFuture&lt;Void&gt;  acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)
</code></pre>

<h3 id="toc_10">applyToEither* ：当任意一个CompletableFuture计算完成的时候就会执行，它有返回值。</h3>

<p>runAfterBoth是当两个CompletableFuture都计算完成后才执行。而 acceptEither* 没有返回值。</p>

<pre><code class="language-java">public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)
public &lt;U&gt; CompletableFuture&lt;U&gt;     applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)
</code></pre>

<h3 id="toc_11">辅助方法 ：allOf 和 anyOf</h3>

<pre><code class="language-java">// allOf方法是当所有的CompletableFuture都执行完后执行计算。
public static CompletableFuture&lt;Void&gt;       allOf(CompletableFuture&lt;?&gt;... cfs)
//anyOf方法是当任意一个CompletableFuture执行完后就会执行计算，计算的结果相同。
public static CompletableFuture&lt;Object&gt;     anyOf(CompletableFuture&lt;?&gt;... cfs)
</code></pre>

<p>示例：</p>

<pre><code class="language-java">Random rand = new Random();
CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {
    try {
        Thread.sleep(10000 + rand.nextInt(1000));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return 100;
});
CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; {
    try {
        Thread.sleep(10000 + rand.nextInt(1000));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return &quot;abc&quot;;
});
//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);
CompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);
System.out.println(f.get());
</code></pre>

<h2 id="toc_12">更进一步</h2>

<p>如果你用过Guava的Future类，你就会知道它的Futures辅助类提供了很多便利方法，用来处理多个Future，而不像Java的CompletableFuture，只提供了allOf、anyOf两个方法。 比如有这样一个需求，将多个CompletableFuture组合成一个CompletableFuture，这个组合后的CompletableFuture的计算结果是个List,它包含前面所有的CompletableFuture的计算结果，guava的Futures.allAsList可以实现这样的功能，但是对于java CompletableFuture，我们需要一些辅助方法：</p>

<pre><code class="language-java">   public static &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; sequence(List&lt;CompletableFuture&lt;T&gt;&gt; futures) {
       CompletableFuture&lt;Void&gt; allDoneFuture = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));
       return allDoneFuture.thenApply(v -&gt; futures.stream().map(CompletableFuture::join).collect(Collectors.&lt;T&gt;toList()));
   }
public static &lt;T&gt; CompletableFuture&lt;Stream&lt;T&gt;&gt; sequence(Stream&lt;CompletableFuture&lt;T&gt;&gt; futures) {
       List&lt;CompletableFuture&lt;T&gt;&gt; futureList = futures.filter(f -&gt; f != null).collect(Collectors.toList());
       return sequence(futureList);
   }
</code></pre>

<p>Java Future转CompletableFuture:</p>

<pre><code class="language-java">public static &lt;T&gt; CompletableFuture&lt;T&gt; toCompletable(Future&lt;T&gt; future, Executor executor) {
    return CompletableFuture.supplyAsync(() -&gt; {
        try {
            return future.get();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }, executor);
}
</code></pre>

<p>转载掘金文章: <a href="https://juejin.im/post/5c77b3ade51d456a045898c8">java8 CompletableFuture入门 使用教程 详解所有方法 附实例</a></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15882588104882.html" 
          title="Previous Post: Maven内置变量说明：">&laquo; Maven内置变量说明：</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15880844669175.html" 
          title="Next Post: 代理模式">代理模式 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
