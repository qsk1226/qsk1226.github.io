<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  设计模式 - 大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15896081275436.html">
                
                  <h1>适配器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">适配器定义</a>
</li>
<li>
<a href="#toc_1">适配器模式结构</a>
<ul>
<li>
<a href="#toc_2">对象适配器模式</a>
</li>
<li>
<a href="#toc_3">类适配器模式</a>
</li>
<li>
<a href="#toc_4">优点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">代码示例</a>
</li>
<li>
<a href="#toc_7">使用场景</a>
</li>
</ul>


<h2 id="toc_0">适配器定义</h2>

<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>

<h2 id="toc_1">适配器模式结构</h2>

<p>适配器模式角色：</p>

<ul>
<li>Target： 目标角色，客户端期待得到的接口</li>
<li>Adaptee: 适配者角色，被适配的接口</li>
<li>Adapter：适配器角色，将原接口转换成目标接口</li>
</ul>

<h3 id="toc_2">对象适配器模式</h3>

<p><figure><img src="media/15896081275436/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="对象适配器模式"/><figcaption>对象适配器模式</figcaption></figure></p>

<h3 id="toc_3">类适配器模式</h3>

<p><figure><img src="media/15896081275436/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt="类适配器模式"/><figcaption>类适配器模式</figcaption></figure></p>

<h3 id="toc_4">优点</h3>

<ul>
<li><p>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</p></li>
<li><p>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</p></li>
<li><p>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p></li>
<li><p>类适配器模式还具有如下优点：<br/>
由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p></li>
<li><p>对象适配器模式还具有如下优点：<br/>
一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 </p>
<h3 id="toc_5">缺点</h3></li>
<li><p>类适配器模式的缺点如下：<br/>
对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p></li>
<li><p>对象适配器模式的缺点如下：<br/>
与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 </p></li>
</ul>

<h2 id="toc_6">代码示例</h2>

<pre><code class="language-java">
/**
 * 被适配接口--安卓传统方式充电接口
 */
public interface TraditionalCharge {

    /**
     * 传统充电
     */
    void chargeWithTraditional();
}

/**
 * 安卓传统方式充电实现--adaptee
 *
 **/
public class TraditionalChargeImpl implements TraditionalCharge {
    @Override
    public void chargeWithTraditional() {
        System.out.println(&quot;使用传统的安卓充电头进行充电&quot;);
    }
}


/**
 * typeC充电接口 target
 **/
public interface TypeCCharge {
    /**
     * type-C充电
     */
    void chargeWithTypeC();
}

</code></pre>

<p>对象适配器</p>

<pre><code class="language-java">/**
 * 对象适配器  --- adapter
 **/
public class ChargeAdapter implements TypeCCharge {
    /**
     * 被适配对象
     */
    private TraditionalCharge traditionalCharge;

    public ChargeAdapter(TraditionalCharge traditionalCharge) {
        this.traditionalCharge = traditionalCharge;
    }

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        traditionalCharge.chargeWithTraditional();
    }

    public static void main(String[] args) {
        ChargeAdapter chargeAdapter = new ChargeAdapter(new TraditionalChargeImpl());
        chargeAdapter.chargeWithTypeC();
    }
}
</code></pre>

<p>类适配器</p>

<pre><code class="language-java">/**
 * 类适配器  --- adapter
 **/
public class AndroidChargeAdapter extends TraditionalChargeImpl implements TypeCCharge{

    @Override
    public void chargeWithTypeC() {
        System.out.println(&quot;使用Type-C 转接头适配安卓传统充电器&quot;);
        chargeWithTraditional();
    }

    public static void main(String[] args) {
        AndroidChargeAdapter androidChargeAdapter = new AndroidChargeAdapter();
        androidChargeAdapter.chargeWithTypeC();
    }
}

</code></pre>

<h2 id="toc_7">使用场景</h2>

<ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15896032913368.html">
                
                  <h1>单例模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>

<p>单例模式的要点有三个：</p>

<ul>
<li>是某个类只能有一个实例；</li>
<li>是它必须自行创建这个实例；</li>
<li>是它必须自行向整个系统提供这个实例。</li>
</ul>

<p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>

<h2 id="toc_0">单例模式结构</h2>

<p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<p>单例模式包含的角色只有一个，就是单例类——Singleton。</p>

<p>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。</p>

<p>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p>

<p>在单例模式的实现过程中，需要注意如下三点：</p>

<ul>
<li>单例类的构造函数为私有；</li>
<li>提供一个自身的静态私有成员变量；</li>
<li>提供一个公有的静态工厂方法。</li>
</ul>

<p><figure><img src="media/15896032913368/15896221967721.jpg" alt=""/></figure></p>

<h2 id="toc_1">常见的单例实现</h2>

<h3 id="toc_2">饿汉模式</h3>

<pre><code class="language-java">public class Singleton {  
     private static Singleton instance = new Singleton();  
     private Singleton (){
     }
     public static Singleton getInstance() {  
     return instance;  
     }  
 }  
</code></pre>

<h3 id="toc_3">懒汉模式</h3>

<pre><code class="language-java">public class Singleton {

    private Singleton(){} // 私有构造

    private static volatile Singleton instance = null; // 私有单例对象

    // 静态工厂
    public static Singleton getInstance(){
        if (instance == null) { // 双重检测机制
            synchronized (Singleton.class) { // 同步锁
                if (instance == null) { // 双重检测机制
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}

</code></pre>

<h3 id="toc_4">静态内部类实现方式</h3>

<pre><code class="language-java">/**
 * 从外部无法访问静态内部类 LazyHolder，只有当调用 Singleton.getInstance() 方法的时候，才能得到单例对象 INSTANCE。
* INSTANCE 对象初始化的时机并不是在单例类 Singleton 被加载的时候，而是在调用 getInstance 方法，使得静态内部类 LazyHolder 被加载的时候。
* 这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。
 */
public class Singleton {

    private static class LazyHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton (){}

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }

}

</code></pre>

<h3 id="toc_5">使用容器实现</h3>

<pre><code class="language-java">public class SingletonManager { 
　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();
　　private Singleton() { 
　　}
　　public static void registerService(String key, Object instance) {
　　　　if (!objMap.containsKey(key) ) {
　　　　　　objMap.put(key, instance) ;
　　　　}
　　}
　　public static Object getService(String key) {
　　　　return objMap.get(key) ;
　　}
}
</code></pre>

<h3 id="toc_6">枚举实现</h3>

<pre><code class="language-java">public enum Singleton {
    INSTANCE;
    
    public void doSomeThing() {
        //做点什么
    }  
}
</code></pre>

<h2 id="toc_7">使用场景</h2>

<p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>

<p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>

<p>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15894404386842.html">
                
                  <h1>建造者模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于对象创建型模式，建造者模式又可以称为生成器模式。</p>

<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>

<h2 id="toc_0">建造者模式结构</h2>

<p>建造者模式包含如下角色：</p>

<ul>
<li>Builder 抽象建造者</li>
<li>BuilderImpl 具体建造者</li>
<li>Director 指挥者</li>
<li>Product 产品</li>
</ul>

<p><figure><img src="media/15894404386842/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" alt="建造者模式"/><figcaption>建造者模式</figcaption></figure></p>

<p>抽象建造者类中定义了产品的创建方法和返回方法;</p>

<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p>

<p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p>

<h2 id="toc_1">优点</h2>

<ul>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li>
</ul>

<h2 id="toc_2">代码示例（简化版的建造者模式）</h2>

<pre><code class="language-java">public class Race {
    private String name;
    private String feature;

    public Race(String name, String feature) {
        this.name = name;
        this.feature = feature;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getFeature() {
        return feature;
    }

    public void setFeature(String feature) {
        this.feature = feature;
    }

    public static RaceBuilder builder() {
        return new RaceBuilder();
    }

    public static class RaceBuilder {
        private String name;
        private String feature;

        public RaceBuilder name(String name) {
            this.name = name;
            return this;
        }

        public RaceBuilder feature(String feature) {
            this.feature = feature;
            return this;
        }

        public Race build() {
            return new Race(this.name, this.feature);
        }

    }
}
</code></pre>

<h2 id="toc_3">使用场景</h2>

<p>在以下情况下可以使用建造者模式：</p>

<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>

<h3 id="toc_4">注意</h3>

<p>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。<br/>
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15889472727845.html">
                
                  <h1>工厂模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，<br/>
达到提高灵活性的目的。</p>

<p>工厂模式在《Java 与模式》中分为三类:</p>

<ul>
<li>简单工厂模式(Simple Factory)</li>
<li>工厂方法模式(Factory Method)</li>
<li>抽象工厂模式(Abstract Factory) <br/>
这三种模式从上到下逐步抽象，并且更具一般性</li>
</ul>

<h2 id="toc_0">简单工厂模式</h2>

<p>先来看看它的组成:<br/>
1) 工厂类角色:这是本模式的核心，含有一定的商业逻辑和判断逻辑。<br/>
2) 抽象对象角色:它一般是具体产品继承的父类或者实现的接口<br/>
3) 具体产品角色:工厂类所创建的对象就是此角色的实例。</p>

<p><figure><img src="media/15889472727845/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg" alt="简单工厂"/><figcaption>简单工厂</figcaption></figure></p>

<hr/>

<h2 id="toc_1">工厂方法模式</h2>

<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>

<p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>

<h3 id="toc_2">工厂模式优点</h3>

<ul>
<li><p>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p></li>
<li><p>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p></li>
<li><p>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
<h3 id="toc_3">工厂模式缺点</h3></li>
<li><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p></li>
<li><p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p></li>
</ul>

<h3 id="toc_4">模式结构</h3>

<p>工厂方法模式包含如下角色：</p>

<ul>
<li>Product：抽象产品</li>
<li>ConcreteProduct：具体产品</li>
<li>Factory：抽象工厂</li>
<li>ConcreteFactory：具体工厂</li>
</ul>

<p><figure><img src="media/15889472727845/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" alt="工厂模式"/><figcaption>工厂模式</figcaption></figure></p>

<h3 id="toc_5">使用场景</h3>

<ul>
<li><p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p></li>
<li><p>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></li>
<li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p></li>
</ul>

<hr/>

<h2 id="toc_6">抽象工厂</h2>

<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>

<h3 id="toc_7">抽象工厂结构</h3>

<p><figure><img src="media/15889472727845/15916015353768.jpg" alt=""/></figure></p>

<p>抽象工厂模式包含如下角色：</p>

<ul>
<li>AbstractFactory：抽象工厂</li>
</ul>

<pre><code class="language-java">public abstract class AbstractComputerFactory {

    /**
     * cpu
     */
    public abstract Cpu createCpu();

    /**
     * 内存条
     */
    public abstract Memory createMemory();
}
</code></pre>

<ul>
<li>ConcreteFactory：具体工厂</li>
</ul>

<pre><code class="language-java">public class GameComputerFactory extends AbstractComputerFactory {

    @Override
    Cpu createCpu() {
        return new AMDCpu();
    }

    @Override
    Memory createMemory() {
        return new SamsungMemory();
    }
}

public class OfficeComputerFactory extends AbstractComputerFactory{
    @Override
    Cpu createCpu() {
        return new IntelCpu();
    }

    @Override
    Memory createMemory() {
        return new KingstonMemory();
    }
}

</code></pre>

<ul>
<li>AbstractProduct：抽象产品</li>
</ul>

<pre><code class="language-java">public interface Cpu {
    /**
     * 计算
     */
    long calculate();
}

public interface Memory {
    /**
     * 传输
     */
    long transfer();
}

</code></pre>

<ul>
<li>Product：具体产品</li>
</ul>

<pre><code class="language-java">public class AMDCpu implements Cpu {
    @Override
    public long calculate() {
        System.out.println(&quot;飞机以300公里每小时速度前进&quot;);
        return 300;
    }
}
public class IntelCpu implements Cpu {
    @Override
    public long calculate() {
        return 500;
    }
}
public class SamsungMemory implements Memory {
    @Override
    public long transfer() {
        return 0;
    }
}
public class KingstonMemory implements Memory {

    @Override
    public long transfer() {
        return 0;
    }
}
</code></pre>

<ul>
<li>client</li>
</ul>

<pre><code class="language-java">@Test
public void testFactory() {
    AbstractComputerFactory factory = new GameComputerFactory();
    Cpu cpu = factory.createCpu();
    Memory memory = factory.createMemory();
}
</code></pre>

<h3 id="toc_8">使用场景</h3>

<p>在以下情况下可以使用抽象工厂模式：</p>

<ul>
<li><p>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</p></li>
<li><p>系统中有多于一个的产品族，而每次只使用其中某一产品族。</p></li>
<li><p>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</p></li>
<li><p>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/05/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15880844669175.html">
                
                  <h1>代理模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>

<p>在某些情况下，<strong><em>一个客户不想或者不能直接引用一个对象，又或者客户想要增强目标类的功能，但是又不能调整目标类的时候</em></strong>，可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。</p>

<p>通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p>

<p>代理模式可分为静态代理和动态代理，他们都提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>

<p>那么静态代理与动态代理的区别又是什么呢？</p>

<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是使用反射和字节码的技术，在运行期创建指定接口或类的子类以及其实力对象，并加载到JVM中</li>
</ul>

<h2 id="toc_0">静态代理</h2>

<h3 id="toc_1">静态态代理结构</h3>

<ul>
<li>Subject: 抽象主题角色</li>
<li>Proxy: 代理主题角色</li>
<li>RealSubject: 真实主题角色
<figure><img src="media/15880844669175/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式"/><figcaption>代理模式</figcaption></figure></li>
</ul>

<h3 id="toc_2">静态代理示例</h3>

<pre><code class="language-java">/**
 * 接口
 */
public interface IUserDao {

    void save();
}
/**
 * 接口实现
 * 目标对象
 */
public class UserDao implements IUserDao {
    public void save() {
        System.out.println(&quot;----已经保存数据!----&quot;);
    }
}
/**
 * 代理对象,静态代理
 */
public class UserDaoProxy implements IUserDao{
    //接收保存目标对象
    private IUserDao target;
    public UserDaoProxy(IUserDao target){
        this.target=target;
    }

    public void save() {
        System.out.println(&quot;开始事务...&quot;);
        target.save();//执行目标对象的方法
        System.out.println(&quot;提交事务...&quot;);
    }
}

/**
 * 测试类
 */
public class App {
    public static void main(String[] args) {
        //目标对象
        UserDao target = new UserDao();

        //代理对象,把目标对象传给代理对象,建立代理关系
        UserDaoProxy proxy = new UserDaoProxy(target);

        proxy.save();//执行的是代理的方法
    }
}
</code></pre>

<h3 id="toc_3">静态代理总结:</h3>

<ul>
<li>可以做到在不修改目标对象的功能前提下,对目标功能扩展.</li>
<li>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.</li>
</ul>

<p>如何解决静态代理中的缺点呢?答案是可以使用动态代理方式</p>

<h2 id="toc_4">动态代理技术实现主要方式</h2>

<h3 id="toc_5">JDK原生动态代理</h3>

<p>只能基于有接口代理对象进行代理</p>

<ul>
<li>Proxy: Proxy是所有动态代理的父类，它提供了一个静态方法来创建动态代理的class对象和实例。
<code>java
static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )
</code>
<ul>
<li>ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的</li>
<li>Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型</li>
<li>InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入,每个动态代理实例都有一个关联的InvocationHandler。在代理实例上调用方法时，方法调用被转发到InvocationHandler的invoke方法。</li>
</ul></li>
</ul>

<pre><code class="language-java">public class DynamicProxyTest {

    interface IHello{
        void sayHello();
    }

    static class Hello implements IHello {
        @Override
        public void sayHello() {
            System.out.println(&quot;Hello world&quot;);
        }
    }

    static class DynamicProxy implements InvocationHandler {
        Object originalObj;
        Object bind(Object originalObj) {
            this.originalObj = originalObj;
            return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
        }
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(&quot;welcom &quot;);
            return method.invoke(originalObj, args);
        }

    }


    public static void main(String[] args) {
        IHello iHello = (IHello) new DynamicProxy().bind(new Hello());
        iHello.sayHello();
    }
}
</code></pre>

<h3 id="toc_6">CGLIB动态代理</h3>

<p>CGLIB代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</p>

<p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用CGLIB实现.</p>

<p>CGLIB是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)</p>

<p>CGLIB包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</p>

<ul>
<li>Enhancer: 来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor;</li>
<li>MethodInterceptor: 动态代理对象的方法调用都会转发到intercept方法进行增强。</li>
</ul>

<pre><code class="language-java">public class ProxyFactory {
    /**
     * 产生代理对象
     *
     * @param targetClass       目标类
     * @param callbackFilter    回调增强方法的过滤器
     * @param methodInterceptor 回调增强方法
     * @return 代理对象
     */
    public static Object createProxy(Class&lt;?&gt; targetClass, CallbackFilter callbackFilter, MethodInterceptor... methodInterceptor) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(targetClass);
        enhancer.setUseCache(false);
        // 拦截器
        //enhancer.setCallbackFilter(callbackFilter);
        enhancer.setCallbacks(methodInterceptor);
        return enhancer.create();

    }
}

/**
 * 被代理对象
 */
public class HelloService {

    public void sayHello() {
        System.out.println(&quot;hello, Lily&quot;);
    }

    public void saySb(){
        System.out.println(&quot;Sb&quot;);
    }
    public void sayNinHao(){
        System.out.println(&quot;您好&quot;);
    }
}

/**
 * 抽象的增强的回调方法
 **/
public abstract class AbstractAdviceInterceptor implements MethodInterceptor {
    abstract void preExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    abstract void afterExecute(MethodProxy proxy, Object object, Method method, Object[] args);

    public Object execute(MethodProxy proxy, Object object, Method method, Object[] args) {

        preExecute(proxy, object, method, args);
        Object result = null;
        try {
            result = proxy.invokeSuper(object, args);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        afterExecute(proxy, object, method, args);
        return result;
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        return execute(proxy, obj, method, args);
    }
}

/**
 * 代理对象的增强回调接口实现
 * MethodInterceptor可以作为类的回调增强，也能只增强当个方法
 */
public class HelloInterceptor extends AbstractAdviceInterceptor {

    @Override
    void preExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; pre operation:&quot;);
    }

    @Override
    void afterExecute(MethodProxy proxy,Object object, Method method, Object[] args) {
        System.out.println(&quot;----------&gt; class: &quot;+proxy.getSuperName()+&quot;  methodName &quot; + method.getName() + &quot; after operation:&quot;);
        System.out.println(&quot;&quot;);
    }

}

public static void main(String[] args) {
    /*代理整个类*/
    HelloService proxy2 = (HelloService) ProxyFactory.createProxy(HelloService.class, null, new HelloInterceptor());
    proxy2.sayHello();
    proxy2.saySb();
    proxy2.sayNinHao();

}

</code></pre>

<h2 id="toc_7">使用场景</h2>

<p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p>

<ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="设计模式.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="设计模式_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
