<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="vm_fusion.html">
                
                  <h1>mac vmware fusion 设置静态 IP 地址</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">配置静态IP</h2>

<h3 id="toc_1">把网络配置改成nat模式</h3>

<h3 id="toc_2">通过Mac终端进入VMware Fusion的vmnet8目录</h3>

<pre><code class="language-text">cd /Library/Preferences/VMware Fusion/vmnet8
</code></pre>

<ul>
<li>查看nat.conf内容</li>
</ul>

<p><figure><img src="media/15855011797141/15855038592835.jpg" alt=""/></figure></p>

<ul>
<li>查看cat dhcpd.conf</li>
</ul>

<p><figure><img src="media/15855011797141/15855037846968.jpg" alt=""/></figure></p>

<p>注意range 这个是虚拟机允许选择的静态ip地址范围，自定义的静态ip地址必须要在这个范围内</p>

<h3 id="toc_3">登录虚拟机 CentOS7</h3>

<p>进入虚拟机的network-scripts目录</p>

<pre><code class="language-text">cd /etc/sysconfig/network-scripts
</code></pre>

<p>找到ifcfg-en开头的文件,上图中我的是ifcfg-ens33<br/>
修改前：</p>

<pre><code class="language-text">&gt; cd /etc/sysconfig/network-scripts
&gt; vim ifcfg-ens33

TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
</code></pre>

<p>我们将它改成如下配置:</p>

<pre><code class="language-text">TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=no
IPV6_AUTOCONF=no
IPV6_DEFROUTE=no
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f30c4f14-149c-4628-a256-0bd778671148
DEVICE=ens33
ONBOOT=yes
MACADDR=random
IPV6_PRIVACY=no
IPADDR=172.16.65.134
GATEWAY=172.16.65.2
NETMASK=255.255.255.0
DNS1=114.114.114.114
</code></pre>

<p>保存之后，重启服务使修改生效</p>

<p>service network restart<br/>
ping一下百度看看，成功Ping到</p>

<p>接下来我们就可以通过SecureCRT等工具远程连接了，有一点请记住，如果你换了一个地方上网的话，可能会发现你的虚拟机有不通了，那是因为DNS地址发生了变化，此时只需要再次编辑ifcfg-enxxx文件，然后加上你现在网络的DNS地址即可</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="hostnamectl.html">
                
                  <h1>CentOS 7 主机名的修改</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如godson）。</p>

<p>在CentOS 7中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>

<ol>
<li>要查看主机名相关的设置：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl 
   Static hostname: localhost.localdomain
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 50565701419746a08905ba05b882cd40
           Boot ID: a599742730414a448408e1d7a9bbf9d3
    Virtualization: vmware
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-957.el7.x86_64
      Architecture: x86-64
</code></pre>

<ol>
<li>只查看静态、瞬态或灵活主机名，分别使用“--static”，“--transient”或“--pretty”选项。</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ hostnamectl --static
localhost.localdomain
[[godson@localhost ~]$ hostnamectl --transient
localhost.localdomain
[godson@localhost ~]$ hostnamectl --pretty
</code></pre>

<ol>
<li>要同时修改所有三个主机名：静态、瞬态和灵活主机名：</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ se
[godson@localhost ~]$ hostnamectl --pretty
godson
[godson@localhost ~]$ hostnamectl --static
godson
[godson@localhost ~]$ hostnamectl --transient
godson
</code></pre>

<p>就像上面展示的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。一旦修改了静态主机名，/etc/hostname 将被自动更新。然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS 7。否则系统再启动时会很慢。</p>

<ol>
<li>手动更新/etc/hosts</li>
</ol>

<pre><code class="language-text">[godson@localhost ~]$ vim /etc/hosts
127.0.0.1      godson
#127.0.0.1  localhost localhost.localdomain localhost4 localhost4.localdomain
::1        localhost localhost.localdomain localhost6 localhost6.localdomain
</code></pre>

<ol>
<li>重启CentOS 7 之后</li>
</ol>

<pre><code class="language-text">[godson@godson ~]# hostname
godson
[godson@godson ~]# hostnamectl --transient
godson
[godson@godson ~]# hostnamectl --static
godson
[godson@godson ~]# hostnamectl --pretty
godson
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="SSH.html">
                
                  <h1>ssh 免密登录服务器</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>现在有服务器 Server-A,用户名: jetty, ip: 172.16.65.133, 现在希望从本地能够免密访问 Server-A。<br/>
这里我们需要 ssh-keygen 命令来帮我们完成这项任务。</p>

<p>ssh-keygen: 为了让两个linux机器之间使用ssh不需要用户名和密码。<br/>
采用了数字签名RSA或者DSA来完成这个操作。</p>

<h2 id="toc_0">生成本地公钥和私钥</h2>

<pre><code class="language-text">&gt; ssh-keygen -t rsa -C &#39;注释&#39;
</code></pre>

<p>本地机器 .ssh 目录下生成文件 :  id_rsa  id_rsa.pub</p>

<h2 id="toc_1">将本地生成的id_rsa.pub(公钥)追加到 Server-A 的目录~/.ssh/authorized_keys文件中</h2>

<pre><code class="language-text">&gt; ssh-copyid jetty@172.16.65.133
</code></pre>

<p>上传文件方式：</p>

<ul>
<li>cat ~/.ssh/id_rsa.pub | ssh -p 22 jetty@172.16.65.133 &#39;cat &gt;&gt; ~/.ssh/authorized_keys&#39;</li>
<li>ssh-copyid jetty@172.16.65.133</li>
<li>scp -P 22 ~/.ssh/id_rsa.pub jetty@172.16.65.133:~/。<br/>
注意： Server-A 服务器上.ssh 目录的权限为700，其下文件authorized_keys和私钥的权限为600。否则会因为权限问题导致无法免密码登录。</li>
</ul>

<p>上面步骤做完之后我们就可以免密登录 Server-A 了</p>

<pre><code class="language-text">&gt; ssh jetty@172.16.65.133
Last login: Sun Mar 29 12:17:53 2020 from 172.16.65.1
-bash: warning: setlocale: LC_CTYPE: cannot change locale (UTF-8): No such file or directory
&gt; [jetty@jetty ~]$ 
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15854879924872.html">
                
                  <h1>初见 Docker</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Docker官方网址: <a href="https://docs.docker.com/">英文地址</a> <br/>
Docker中文网址: <a href="http://www.docker.org.cn/">中文地址</a></p>

<h2 id="toc_0">docker 架构</h2>

<p>Images </p>

<p>Container</p>

<p>Client</p>

<p>Host</p>

<p>Registry</p>

<p>Machine</p>

<h2 id="toc_1">docker 组件</h2>

<ol>
<li><p>镜像 image<br/>
Docker运行容器之前需要本地存在对应的镜像。镜像是用来创建Docker容器的。一个镜像可以包含一个完整的操作系统环境和用户需要的其他应用程序，在Docker Hub里面有大量现成的镜像提供下载，Docker的镜像是只读的，一个镜像可以创建多个容器。</p></li>
<li><p>容器 Container<br/>
Docker利用容器来进行开发，运行应用。容器是镜像创建的实列，它可以启动，开始，停止，删除，每个容器都是相互隔离的，保证安全的平台。</p></li>
<li><p>仓库 Repository<br/>
仓库是集中存放镜像文件的地方。每个仓库中又包含了多个镜像，每个镜像有不同的标签(TAG)</p></li>
</ol>

<h2 id="toc_2">docker 安装</h2>

<p>1、删除 Linux 机器上已存在的 docker 程序</p>

<pre><code class="language-text">&gt; sudo yum list installed | grep docker
&gt; sudo yum  -y remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
</code></pre>

<p>删除 docker 老的镜像</p>

<pre><code class="language-text">&gt; rm -rf /var/lib/docker
</code></pre>

<p>2、安装 docker 程序</p>

<ul>
<li>安装基本的系统工具<br/>
sudo yum install -y yum-utils device-mapper-persistent-data lvm2</li>
<li><p>配置 yum 源<br/>
yum-config-manager --add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p></li>
<li><p>查看可安装的 docker 版本<br/>
yum list docker-ce --showduplicates | sort -r</p></li>
<li><p>安装 docker</p></li>
</ul>

<pre><code class="language-text">sudo yum install docker-ce(最新版)

sudo yum install -y containerd.io-1.2.13-3.1.el7 docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9-3.el7(指定版本)
</code></pre>

<ul>
<li><p>配置 docker 开机启动<br/>
sudo systemctl start docker<br/>
sudo systemctl enable docker</p></li>
<li><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)<br/>
docker version</p></li>
<li><p>更换 docker 镜像仓库为国内仓库<br/>
修改或创建daemon.json文件：<br/>
vim /etc/docker/daemon.json<br/>
内容如下：<br/>
{<br/>
&quot;registry-mirrors&quot;:[&quot;<a href="https://registry.docker-cn.com%22">https://registry.docker-cn.com&quot;</a>]<br/>
}</p></li>
<li><p>加载 daemon.json 文件<br/>
sudo systemctl daemon-reload</p></li>
<li><p>重启 docker<br/>
systemctl restart docker</p></li>
<li><p>验证 docker 是否完成安装<br/>
执行 sudo docker verxion,完成安装如下图所示</p></li>
</ul>

<pre><code class="language-shell">[godson@godson1 ~]$ sudo docker version
Client:
 Version:           18.09.9
 API version:       1.39
 Go version:        go1.11.13
 Git commit:        039a7df9ba
 Built:             Wed Sep  4 16:51:21 2019
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          18.09.9
  API version:      1.39 (minimum version 1.12)
  Go version:       go1.11.13
  Git commit:       039a7df
  Built:            Wed Sep  4 16:22:32 2019
  OS/Arch:          linux/amd64
  Experimental:     false
</code></pre>

<p>用非 root 账户安装完 docker 之后会,执行 docker 命令会遇到这样一个问题：</p>

<pre><code class="language-text">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json: dial unix /var/run/docker.sock: connect: permission denied
</code></pre>

<p>原因： docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p>

<p>解决方法：</p>

<pre><code class="language-text">&gt; sudo groupadd docker     #添加docker用户组
&gt; sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中
&gt; newgrp docker     #更新用户组
&gt; docker ps    #测试docker命令是否可以使用sudo正常使用
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%AE%B9%E5%99%A8.html'>容器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15586898110083.html">
                
                  <h1>熔断模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一 问题的产生</h2>

<p>在大型的分布式系统中，通常需要调用或操作远程的服务或者资源，这些远程的服务或者资源由于调用者不可以控的原因比如网络连接缓慢，资源被占用或者暂时不可用等原因，导致对这些远程资源的调用失败。这些错误通常在稍后的一段时间内可以恢复正常。</p>

<p>但是，在某些情况下，由于一些无法预知的原因导致结果很难预料，远程的方法或者资源可能需要很长的一段时间才能修复。这种错误严重到系统的部分失去响应甚至导致整个服务的完全不可用。在这种情况下，采用不断地重试可能解决不了问题，相反，应用程序在这个时候应该立即返回并且报告错误。</p>

<p>通常，如果一个服务器非常繁忙，那么系统中的部分失败可能会导致 “连锁失效”（cascading failure）。比如，某个操作可能会调用一个远程的WebService，这个service会设置一个超时的时间，如果响应时间超过了该时间就会抛出一个异常。但是这种策略会导致并发的请求调用同样的操作会阻塞，一直等到超时时间的到期。这种对请求的阻塞可能会占用宝贵的系统资源，如内存，线程，数据库连接等等，最后这些资源就会消耗殆尽，使得其他系统不相关的部分所使用的资源也耗尽从而拖累整个系统。在这种情况下，操作立即返回错误而不是等待超时的发生可能是一种更好的选择。只有当调用服务有可能成功时我们再去尝试。</p>

<h2 id="toc_1">解决之道</h2>

<p>熔断器模式可以防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器模式也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>

<p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定使用允许操作继续，或者立即返回错误。<br/>
<figure><img src="media/15586676190905/15586775537030.jpg" alt=""/></figure><br/>
熔断器可以使用状态机来实现，内部模拟以下几种状态。</p>

<ul>
<li>闭合（closed）状态： 对应用程序的请求能够直接引起方法的调用。代理类维护了最近调用失败的次数，如果某次调用失败，则使失败次数加1。如果最近失败次数超过了在给定时间内允许失败的阈值，则代理类切换到断开(Open)状态。此时代理开启了一个超时时钟，当该时钟超过了该时间，则切换到半断开（Half-Open）状态。该超时时间的设定是给了系统一次机会来修正导致调用失败的错误。</li>
<li>断开(Open)状态：在该状态下，对应用程序的请求会立即返回错误响应。</li>
<li>半断开（Half-Open）状态：允许对应用程序的一定数量的请求可以去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态(并且将错误计数器重置)；如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开方式，然后开始重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。<br/>
各个状态之间的转换如下图：
<figure><img src="media/15586676190905/15586778712353.jpg" alt=""/></figure></li>
</ul>

<p>在Close状态下，错误计数器是基于时间的。在特定的时间间隔内会自动重置。这能够防止由于某次的偶然错误导致熔断器进入断开状态。触发熔断器进入断开状态的失败阈值只有在特定的时间间隔内，错误次数达到指定错误次数的阈值才会产生。在Half-Open状态中使用的连续成功次数计数器记录调用的成功次数。当连续调用成功次数达到某个指定值时，切换到闭合状态，如果某次调用失败，立即切换到断开状态，连续成功调用次数计时器在下次进入半断开状态时归零。</p>

<p>实现熔断器模式使得系统更加稳定和有弹性，在系统从错误中恢复的时候提供稳定性，并且减少了错误对系统性能的影响。它通过快速的拒绝那些试图有可能调用会导致错误的服务，而不会去等待操作超时或者永远不会不返回结果来提高系统的响应事件。如果熔断器设计模式在每次状态切换的时候会发出一个事件，这种信息可以用来监控服务的运行状态，能够通知管理员在熔断器切换到断开状态时进行处理。</p>

<p>可以对熔断器模式进行定制以适应一些可能会导致远程服务失败的特定场景。比如，可以在熔断器中对超时时间使用不断增长的策略。在熔断器开始进入断开状态的时候，可以设置超时时间为几秒钟，然后如果错误没有被解决，然后将该超时时间设置为几分钟，依次类推。在一些情况下，在断开状态下我们可以返回一些错误的默认值，而不是抛出异常。</p>

<h2 id="toc_2">要考虑的因素</h2>

<p>在实现熔断器模式的时候，以下这些因素需可能需要考虑：</p>

<ul>
<li>异常处理：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li>
<li>异常的类型：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li>
<li>日志：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。</li>
<li>测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li>
<li>手动重置：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。</li>
<li>并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。</li>
<li>资源的差异性：使用单个熔断器时，一个资源如果​​有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li>
<li>加快熔断器的熔断操作:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么可以断定出不建议立即重试，而是应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li>
<li>重复失败请求：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li>
</ul>

<h2 id="toc_3">使用场景</h2>

<p>应该使用该模式来：</p>

<ul>
<li>防止应用程序直接调用那些很可能会调用失败的远程服务或共享资源。</li>
</ul>

<p>不适合的场景</p>

<ul>
<li>对于应用程序中的直接访问本地私有资源，比如内存中的数据结构，如果使用熔断器模式只会增加系统额外开销。</li>
<li>不适合作为应用程序中业务逻辑的异常处理替代品</li>
</ul>

<p>根据上面的状态切换图，我们很容易实现一个基本的熔断器，只需要在内部维护一个状态机，并定义好状态转移的规则，可以使用State模式来实现。首先，我们定义一个表示状态转移操作的抽象类CircuitBreakerState：</p>

<pre><code class="language-java">public abstract class CircuitBreakerState
{
    //熔断器
    protected static CircuitBreaker circuitBreaker;
    
    protected CircuitBreakerState(CircuitBreaker circuitBreaker) {
        this.circuitBreaker = circuitBreaker;
    }
    // 调用受保护方法之前处理的操作
    public void protectedCodeIsAboutToBeCalled() {
        //如果是断开状态，直接返回,然后坐等超时转换到半断开状态
        if (circuitBreaker.isOpen) {
            throw new OpenCircuitException();
        }
    }

    // 受熔断器保护的方法调用成功之后的操作
    public virtual void protectedCodeHasBeenCalled() {
        circuitBreaker.IncreaseSuccessCount();
    }

    //受熔断器保护的方法调用发生异常操作后的操作
    public virtual void actUponException(Exception e) {
        //增加失败次数计数器，并且保存错误信息
        circuitBreaker.increaseFailureCount(e);
        //重置连续成功次数
        circuitBreaker.resetConsecutiveSuccessCount();
    }
}
</code></pre>

<p>抽象类中，状态机CircuitBreaker通过构造函数注入；当发生错误时，我们增加错误计数器，并且重置连续成功计数器，在增加错误计数器操作中，同时也记录了出错的异常信息。</p>

<p>然后在分别实现表示熔断器三个状态的类。首先实现闭合状态CloseState：</p>

<pre><code class="language-java">public class ClosedState extends CircuitBreakerState {
    public ClosedState(CircuitBreaker circuitBreaker) {
        super(circuitBreaker)
        //重置失败计数器
        circuitBreaker.resetFailureCount();
    }
    
    @override
    public void actUponException(Exception e) {
        super.actUponException(e);
        //如果失败次数达到阈值，则切换到断开状态
        if (circuitBreaker.failureThresholdReached()){
            circuitBreaker.moveToOpenState();
        }
    }
}
</code></pre>

<p>在闭合状态下，如果发生错误，并且错误次数达到阈值，则状态机切换到断开状态。断开状态OpenState的实现如下：</p>

<pre><code class="language-java">public class OpenState extends CircuitBreakerState {
    private final static Timer timer;

    public OpenState(CircuitBreaker circuitBreaker) {
        timer = new Timer(circuitBreaker.Timeout.TotalMilliseconds);
        timer.Elapsed += TimeoutHasBeenReached;
        timer.AutoReset = false;
        timer.Start();
    }

    // 断开超过设定的阈值，自动切换到半断开状态
    private void timeoutHasBeenReached(object sender, ElapsedEventArgs e) {
        circuitBreaker.moveToHalfOpenState();
    }

    public void protectedCodeIsAboutToBeCalled() {
        super.protectedCodeIsAboutToBeCalled();
        throw new OpenCircuitException();
    }
}
</code></pre>

<p>断开状态内部维护一个计数器，如果断开达到一定的时间，则自动切换到版断开状态，并且，在断开状态下，如果需要执行操作，则直接抛出异常。</p>

<p>最后半断开Half-Open状态实现如下：</p>

<pre><code class="language-java">public class HalfOpenState extends CircuitBreakerState {
    public HalfOpenState(CircuitBreaker circuitBreaker)  {
        // 重置连续成功计数
        circuitBreaker.resetConsecutiveSuccessCount();
    }

    public override void actUponException(Exception e) {
        super.ActUponException(e);
        //只要有失败，立即切换到断开模式
        circuitBreaker.moveToOpenState();
    }
    
    public void protectedCodeHasBeenCalled() {
        super.ProtectedCodeHasBeenCalled();
        //如果连续成功次数达到阈值，切换到闭合状态
        if (circuitBreaker.consecutiveSuccessThresholdReached()) {
            circuitBreaker.moveToClosedState();
        }
    }
}
</code></pre>

<p>切换到半断开状态时，将连续成功调用计数重置为0，当执行成功的时候，自增改字段，当达到连读调用成功次数的阈值时，切换到闭合状态。如果调用失败，立即切换到断开模式。</p>

<p>有了以上三种状态切换之后，我们要实现CircuitBreaker类了:</p>

<pre><code class="language-java">@data
public class CircuitBreaker {
    private final static object monitor = new object();
    private CircuitBreakerState state;
    private int failureCount;
    public int consecutiveSuccessCount;
    public int failureThreshold;
    public int consecutiveSuccessThreshold;
    public TimeSpan Timeout;
    public Exception LastException;

    public CircuitBreaker(int failedThreshold, int consecutiveSuccessThreshold, TimeSpan timeout) {
        if (failedThreshold &lt; 1 || consecutiveSuccessThreshold &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;threshold&quot;, &quot;Threshold should be greater than 0&quot;);
        }

        if (timeout.TotalMilliseconds &lt; 1) {
            throw new ArgumentOutOfRangeException(&quot;timeout&quot;, &quot;Timeout should be greater than 0&quot;);
        }

        failureThreshold = failedthreshold;
        consecutiveSuccessThreshold = consecutiveSuccessThreshold;
        timeout = timeout;
        moveToClosedState();
    }
    
    public bool IsClosed {
        return state is ClosedState; 
    }

    public bool IsOpen {
        return state == OpenState; 
    }

    public bool IsHalfOpen {
       return state is HalfOpenState; }
    }

   public void moveToClosedState() {
        state = new ClosedState(this);
    }

   public void moveToOpenState() {
        state = new OpenState(this);
    }

    public void moveToHalfOpenState() {
        state = new HalfOpenState(this);
    }

    public void increaseFailureCount(Exception ex) {
        LastException = ex;
        failureCount++;
    }

    public void resetFailureCount() {
        failureCount = 0;
    }

    public bool failureThresholdReached() {
        return failureCount &gt;= failureThreshold;
    }

    public void increaseSuccessCount() {
        consecutiveSuccessCount++;
    }

    public void resetConsecutiveSuccessCount() {
        consecutiveSuccessCount = 0;
    }
    
    public bool consecutiveSuccessThresholdReached() {
        return consecutiveSuccessCount &gt;= consecutiveSuccessThreshold;
    }
    
    // 执行代理方法， action 需要执行的代理方法
    public void attemptCall(function protectedCode) {
       synchronized (monitor) {
            state.protectedCodeIsAboutToBeCalled();
        }
    
        try {
            protectedCode();
        } catch (Exception e) {
            synchronized (monitor) {
                state.actUponException(e);
            }
            throw e;
        }
    
        synchronized (monitor) {
            state.protectedCodeHasBeenCalled();
        }
    }
    
    public void Close() {
       synchronized (monitor) {
            moveToClosedState();
        }
    }
    
    public void Open() {
       synchronized (monitor) {
            moveToOpenState();
        }
    }
}
</code></pre>

<p>在该类中</p>

<ul>
<li><p>首先： 定义了一些记录状态的变量，如failureCount，consecutiveSuccessCount 记录失败次数，连续成功次数，以及failureThreshold，consecutiveSuccessThreshold记录最大调用失败次数，连续调用成功次数。这些对象对外部来说是只读的。</p></li>
<li><p>定义了一个 circuitBreakerState类型的state变量，以表示当前系统的状态。</p></li>
<li><p>定义了一些列获取当前状态的方法isOpen, isClose, isHalfOpen,以及表示状态转移的方法moveToOpenState，moveToClosedState等，这些方法比较简单，根据名字即可看出用意。</p></li>
<li><p>然后，可以通过构造函数将在Close状态下最大失败次数，HalfOpen状态下使用的最大连续成功次数，以及Open状态下的超时时间通过构造函数传进来：</p></li>
<li><p>在初始状态下，熔断器切换到闭合状态。</p></li>
<li><p>然后，可以通过attempCall调用，传入期望执行的代理方法，该方法的执行受熔断器保护。这里使用了锁来处理并发问题。</p></li>
<li><p>最后，提供Close和Open两个方法来手动切换当前状态。</p></li>
</ul>

<h2 id="toc_4">测试</h2>

<p>以上的熔断模式，我们可以对其建立单元测试。</p>

<p>首先我们编写几个帮助类以模拟连续执行次数：</p>

<pre><code class="language-java">private static void CallXAmountOfTimes(function codeToCall, int timesToCall) {
    for (int i = 0; i &lt; timesToCall; i++) {
        codeToCall();
    }
}
</code></pre>

<p>以下类用来抛出特定异常：</p>

<pre><code class="language-java">private static void AssertThatExceptionIsThrown&lt;T&gt;(Action code) where T : Exception {
    try {
        code();
    } catch (T) {
        return;
    }

    Assert.Fail(&quot;Expected exception of type {0} was not thrown&quot;, typeof(T).FullName);
}
</code></pre>

<p>然后，使用NUnit，可以建立如下Case：</p>

<pre><code class="language-java">@test
public void ClosesIfProtectedCodeSucceedsInHalfOpenState()
{
    var stub = new Stub(10);
    //定义熔断器，失败10次进入断开状态
    //5秒后进入半断开状态
    //在半断开状态下，连续成功15次，进入闭合状态
    CircuitBreaker circuitBreaker = new CircuitBreaker(10, 15, TimeSpan.FromMilliseconds(5000));
    Assert.That(circuitBreaker.IsClosed);
    //失败10次调用
    CallXAmountOfTimes(() =&gt; AssertThatExceptionIsThrown&lt;ApplicationException&gt;(() =&gt; circuitBreaker.AttemptCall(stub.DoStuff)), 10);

    Assert.AreEqual(10, circuitBreaker.FailureCount);

    Assert.That(circuitBreaker.IsOpen);

    //等待从Open转到HalfOpen
    Thread.Sleep(6000);
    Assert.That(circuitBreaker.IsHalfOpen);
    //成功调用15次
    CallXAmountOfTimes(()=&gt;circuitBreaker.AttemptCall(stub.DoStuff), 15);

    Assert.AreEqual(15, circuitBreaker.ConsecutiveSuccessCount);
    Assert.AreEqual(0, circuitBreaker.FailureCount);
    Assert.That(circuitBreaker.IsClosed);
}
</code></pre>

<p>这个Case模拟了熔断器中状态的转换。首先初始化时，熔断器处于闭合状态，然后连续10次调用抛出异常，这时熔断器进去了断开状态，然后让线程等待6秒，此时在第5秒的时候，状态切换到了半断开状态。然后连续15次成功调用，此时状态又切换到了闭合状态。</p>

<p>七 结论<br/>
在应用系统中，我们通常会去调用远程的服务或者资源(这些服务或资源通常是来自第三方)，对这些远程服务或者资源的调用通常会导致失败，或者挂起没有响应，直到超时的产生。在一些极端情况下，大量的请求会阻塞在对这些异常的远程服务的调用上，会导致一些关键性的系统资源耗尽，从而导致级联的失败，从而拖垮整个系统。熔断器模式在内部采用状态机的形式，使得对这些可能会导致请求失败的远程服务进行了包装，当远程服务发生异常时，可以立即对进来的请求返回错误响应，并告知系统管理员，将错误控制在局部范围内，从而提高系统的稳定性和可靠性。</p>

<p>本文首先介绍了熔断器模式使用的场景，能够解决的问题，以及需要考虑的因素，最后使用代码展示了如何实现一个简单的熔断器，并且给出了测试用例，希望这些对您有帮助，尤其是在当您的系统调用了外部的远程服务或者资源，同时访问量又很大的情况下对提高系统的稳定性和可靠性有所帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/05/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html'>设计模式</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_10.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_12.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
