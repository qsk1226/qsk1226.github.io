<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    AbstractQueuedSynchronizer(AQS) - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            AbstractQueuedSynchronizer(AQS)   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/04/13</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>#并发编程</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <ul>
<li>
<a href="#toc_0">储备知识</a>
<ul>
<li>
<a href="#toc_1">CLH锁、CMS锁算法</a>
</li>
<li>
<a href="#toc_2">LockSupport</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">AQS的整体结构</a>
</li>
<li>
<a href="#toc_4">AQS 流程图</a>
</li>
<li>
<a href="#toc_5">AQS 使用方式</a>
</li>
<li>
<a href="#toc_6">AQS 源码解读</a>
<ul>
<li>
<a href="#toc_7">AQS 中的数据结构</a>
<ul>
<li>
<a href="#toc_8">Node节点</a>
</li>
<li>
<a href="#toc_9">head 和 tail</a>
</li>
<li>
<a href="#toc_10">state</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">节点在同步队列中的增加</a>
</li>
<li>
<a href="#toc_12">独占式同步状态获取与释放</a>
<ul>
<li>
<a href="#toc_13">获取同步状态</a>
</li>
<li>
<a href="#toc_14">释放同步状态</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">共享式同步状态获取与释放</a>
</li>
<li>
<a href="#toc_16">下面实现一个共享锁，代码如下：</a>
</li>
<li>
<a href="#toc_17">ConditionObject</a>
<ul>
<li>
<a href="#toc_18">ConditionObject的数据结构</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>AQS提供一个框架来实现基于先进先出(FIFO)同步队列的阻塞锁和相关同步器(信号量、事件等)。它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p>

<p>AQS同步器是实现锁(也可以是任意同步组件)的关键，在锁的实现中聚合同步器。</p>

<p>锁是面向使用者的，它定义了使用者与锁交互的接口(比如可以允许两个线 程并行访问)，隐藏了实现细节;</p>

<p>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、 线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者 所需关注的领域。</p>

<h2 id="toc_0">储备知识</h2>

<h3 id="toc_1"><a href="16017089858785.html">CLH锁、CMS锁算法</a></h3>

<h3 id="toc_2">LockSupport</h3>

<p>LockSupport 定义了一组的公共静态方法，这些方法提供了最基本的线程阻 塞和唤醒功能，而 LockSupport 也成为构建同步组件的基础工具。</p>

<p>LockSupport 定义了一组以 park 开头的方法用来阻塞当前线程，以及 unpark(Thread thread)方法来唤醒一个被阻塞的线程。</p>

<p>LockSupport 增加了三个方法，用于实现阻塞当前线程的功能</p>

<ul>
<li>park(Object blocker)</li>
<li>parkNanos(Object blocker,long nanos)</li>
<li>parkUntil(Object blocker,long deadline)</li>
</ul>

<p>其中参数 blocker 是用来标识当前线程在等待的对象(以下称为阻塞对象)，该对象主要用于问题排查和系统监控。</p>

<p>关于LockSupport给出一个样例</p>

<pre><code class="language-java">/**
 * 先入先出的不可重入锁
 */
public class FiFOMutex {

    private final AtomicBoolean locked = new AtomicBoolean(false);
    private final Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;&gt;();

    public void lock() {
        boolean wasInterrupted = false;
        Thread current = Thread.currentThread();
        waiters.add(current);

        // Block while not first in queue or cannot acquire lock
        while (waiters.peek() != current ||
                !locked.compareAndSet(false, true)) {
            LockSupport.park(this);
            if (Thread.interrupted()) // ignore interrupts while waiting
                wasInterrupted = true;
        }

        waiters.remove();
        if (wasInterrupted)          // reassert interrupt status on exit
            current.interrupt();
    }

    public void unlock() {
        locked.set(false);
        LockSupport.unpark(waiters.peek());
    }
    
}
</code></pre>

<hr/>

<h2 id="toc_3">AQS的整体结构</h2>

<p><figure><img src="media/15867863097702/16017111534984.jpg" alt=""/></figure></p>

<h2 id="toc_4">AQS 流程图</h2>

<p><figure><img src="media/15867863097702/AQS.jpg" alt="AQS"/><figcaption>AQS</figcaption></figure></p>

<h2 id="toc_5">AQS 使用方式</h2>

<p>AbstractQueuedSynchronizer 又称为队列同步器(后面简称AQS)。</p>

<p>它是用来构建锁或其他同步组件的基础框架，内部通过一个int类型的成员变量state来控制同步状态：</p>

<ul>
<li>当state=0时，则说明没有任何线程占有共享资源的锁</li>
<li>当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待</li>
</ul>

<p>AQS内部通过内部类 Node 构成 FIFO 的同步队列来完成线程获取锁的排队工作，同时利用内部类 ConditionObject 构建等待队列，当Condition 调用 wait() 方法后，线程将会加入等待队列中，而当Condition 调用signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。</p>

<p><strong>注意：</strong>这里涉及到两种队列，一种的同步队列，当线程请求锁而等待的后将加入同步队列等待，而另一种则是等待队列(可有多个)，通过Condition调用await()方法释放锁后，将加入等待队列</p>

<p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管 理同步状态 state，访问或修改同步状态的方法，重写同步器指定的方法时，需要使用同步器提供的如下 3 个方法来访问或修改同步状态：</p>

<p>•getState():获取当前同步状态。</p>

<p>•setState(int newState):设置当前同步状态。</p>

<p>•compareAndSetState(int expect,int update)<br/>
使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<p>AQS支持独占模式(默认)和共享模式来获取同步状态，子类应被定义为自定义同步组件的非公共静态内部类，AQS 自身不实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，这样就可以方便实现不同类型的同步组件(ReentrantLock、 ReentrantReadWriteLock、CountDownLatch、Semaphore、CyclicBarrier 等)。</p>

<p>AQS的设计者采用<strong>模板模式</strong>，提供一系列模板方法供不同类型的同步组件使用，如下所示：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>void acquire(int arg)</td>
<td>以独占木事获取同步状态，忽略中断，如果获取同步状态成功，直接返回true，否则将会进入同步队列中等待，该方法会调用重写的tryAcquire(int arg)方法</td>
</tr>
<tr>
<td>void acquireInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>以共享模式获取同步状态，忽略中断，当前线程未获取到同步状态，则进入同步队列等待，与acquire(int arg)不同的是，同一时刻可以有多个线程获取同步状态</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>同上，但是方法可中断</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>同上，但是如果在给定的超时时间之内没有获取到同步状态，返回false，否则返回true。</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>以独占方式释放同步状态，在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
</tbody>
</table>

<p>AQS提供的支持类型的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>Collection<Thread> getExclusiveQueuedThreads()</td>
<td>返回同步队列中以独占模式获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Thread getFirstQueuedThread()</td>
<td>返回同步队列中第一个（等待时间最长的）线程，或 null如果没有线程正在排队。</td>
</tr>
<tr>
<td>Collection<Thread> getQueuedThreads()</td>
<td>返回同步队列中的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getSharedQueuedThreads()</td>
<td>返回同步队列中以共享模式下获取同步状态的线程集合。</td>
</tr>
<tr>
<td>Collection<Thread> getWaitingThreads(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>返回包含可能正在等待与此同步器关联的给定条件的线程。</td>
</tr>
<tr>
<td>boolean isQueued(Thread thread)</td>
<td>给定的线程当前在排队，则返回true。</td>
</tr>
<tr>
<td>boolean hasQueuedPredecessors()</td>
<td>是否有比当前线程更早排队的线程。该方法被设计为由一个公平的同步器使用</td>
</tr>
<tr>
<td>boolean hasWaiters(AbstractQueuedSynchronizer.ConditionObject condition)</td>
<td>查询任何线程是否等待与此同步器相关联的给定条件。 请注意，由于超时和中断可能随时发生， true返回不能保证未来的signal将唤醒任何线程。 该方法主要用于监视系统状态。</td>
</tr>
<tr>
<td>isQueued(Thread thread)</td>
<td>如果给定的线程当前在排队，则返回true。</td>
</tr>
</tbody>
</table>

<p>需要子类重写的方法：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>boolean tryAcquire(int arg)</td>
<td>以独占模式获取同步状态，需要查询当前状态，并判断同步状态是否符合预期，然后进行CAS设置同步状态</td>
</tr>
<tr>
<td>boolean tryAcquireShared(int arg)</td>
<td>以共享模式获取。 返回大于等于0的值，表示获取成功，否则，获取失败</td>
</tr>
<tr>
<td>boolean tryRelease(int arg)</td>
<td>独占模式下释放同步状态，等待获取同步状态的线程将有机会获取同步状态成功</td>
</tr>
<tr>
<td>boolean tryReleaseShared(int arg)</td>
<td>以共享方式释放同步状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>当前同步器是否被当前线程所独占，此方法仅在AbstractQueuedSynchronizer.ConditionObject方法内部调用，因此如果不使用条件，则不需要定义该方法。</td>
</tr>
</tbody>
</table>

<p>开发者可以自定义同步器，例如：</p>

<pre><code class="language-java">/**
 * 门闩锁
 */
class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() != 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled() ? 1 : -1;
     }

     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
 }
</code></pre>

<hr/>

<h2 id="toc_6">AQS 源码解读</h2>

<h3 id="toc_7">AQS 中的数据结构</h3>

<p><figure><img src="media/15867863097702/15874785413013.jpg" alt=""/></figure></p>

<pre><code class="language-java">/**
 * AQS抽象类
 */
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer{
//指向同步队列队头
private transient volatile Node head;

//指向同步的队尾
private transient volatile Node tail;

//同步状态，0代表锁未被占用，1代表锁已被占用
private volatile int state;

//省略其他代码......
}
</code></pre>

<h4 id="toc_8">Node节点</h4>

<p>Node节点是同步队列节点类。同步队列（由Node实现）是“CLH”(Craig、Landin和Hagersten)锁队列的变体，CLH锁通常用于自旋锁。<br/>
Node节点会存1、储线程信息；2、当前线程&quot;获取锁&quot;请求的状态（取消、通知下一节点）；3、当前节点的前驱和后驱节点等信息。</p>

<p>Node节点数据结构如下所示：</p>

<pre><code class="language-java">static final class Node {
    // 初始 共享模式节点
    static final Node SHARED = new Node();
    // 独占模式节点
    static final Node EXCLUSIVE = null;
    //表示由于超时或中断线程，已取消的等待状态值
    static final int CANCELLED = 1; 
    //表示当前节点在释放或取消的占用状态的时候需要将其后继节点的线程唤醒
    static final int SIGNAL = -1;
    //表示线程正在等待某个条件
    static final int CONDITION = -2;
    //表示一个被释放的节点应该被传播到其他节点。这是在doReleaseShared中设置的(仅针对head节点)，以确保传播能够继续，即使其他操作已经介入。
    static final int PROPAGATE = -3;
    // int 变量表示线程在队列中的状态 0、CANCELLED、SIGNAL、PROPAGATE、CONDITION
    volatile int waitStatus;
    // 表示该节点的前一个 Node 节点(前驱)
    volatile Node prev;
    //表示该节点的后一个 Node 节点(后继)
    volatile Node next;
    // 表示该节点的代表的线程
    volatile Thread thread;
    // 表示等待 condition 条件的 Node 节点
    Node nextWaiter;
    // 是否共享模式
    final boolean isShared() {
        return nextWaiter == SHARED;
    }
    // 当前节点的前驱节点
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }
    //用于建立初始标头或共享标头
    Node() {}
    
    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
</code></pre>

<h4 id="toc_9">head 和 tail</h4>

<p>head是指向Node同步队列的头结点，tail是指向Node同步队列的尾结点。</p>

<h4 id="toc_10">state</h4>

<p>同步器当前的的同步状态，通过下面3个方法进行访问：<br/>
•getState():获取当前同步状态。<br/>
•setState(int newState):设置当前同步状态。<br/>
•compareAndSetState(int expect,int update):使用 CAS 设置当前状态，该方 法能够保证状态设置的原子性。</p>

<hr/>

<h3 id="toc_11">节点在同步队列中的增加</h3>

<p>当一个线程成功地获取了同步状态(或者锁)，其他线程将无法获取到同步状态，也就是获取同步状态失败，AQS 会将这个线程以及等待状态等信息构造成 为一个节点(Node)并将其加入同步队列的尾部。</p>

<p>而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于 CAS 的设置尾节点的方法: compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾 节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。</p>

<p>首节点的变化<br/>
首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设 置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功 获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只需要将 首节点设置成为原首节点的后继节点并断开原首节点的 next 引用即可。</p>

<h3 id="toc_12">独占式同步状态获取与释放</h3>

<p>首先看一下图展示同步状态获取与释放的流程图：<br/>
<figure><img src="media/15867863097702/15874795148241.jpg" alt=""/></figure></p>

<h4 id="toc_13">获取同步状态</h4>

<p>获取同步状态通过调用同步器的 acquire(int arg)方法可以获取同步状态，主要完成了同步 状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是:</p>

<p><strong>首先</strong>调用自定义同步器实现的 tryAcquire(int arg)方法，该方法需要保证线程安全的获取同步状态。<br/>
<strong>其次</strong>如果同步状态获取失败(tryAcquire 返回 false)，则构造同步节点(独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态)并通过 addWaiter(Node node)方法将该节点加入到同步队列的尾部，<br/>
<strong>最后</strong>调用 acquireQueued(Node node,int arg)方法，使得该节点以“死循环” 的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒 主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>

<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>

<p>从源码中可以看到获取同步状态代码只有3行代码，其中最重要的就是下面的三个方法：</p>

<ul>
<li>tryAcquire(int arg)</li>
</ul>

<p>尝试以独占模式获取。该方法应该查询对象的状态是否允许以独占模式获取它，如果允许，则应该获取它。需要我们自定义实现</p>

<pre><code class="language-java">protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
</code></pre>

<ul>
<li>addWaiter(Node node)</li>
</ul>

<p>将当前线程包装成 Node 后，队列不为空的情况下，先尝试把当前节点加入 队列并成为尾节点，如果不成功或者队列为空进入 enq(final Node node)方法</p>

<p>在 enq(final Node node)方法中，同步器通过“死循环”来保证节点的正确添加，这个死循环中，做了两件事，第一件，如果队列为空，初始化队列，new 出一个空节点，并让首节点(head)和尾节点(tail)两个引用都指向这个空节点; 第二件事，把当前节点加入队列。<br/>
在“死循环”中只有通过 CAS 将节点设置成为尾节点之后，当前线程才能从 该方法返回，否则，当前线程不断地尝试设置。</p>

<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 尝试一次快速排队操作，失败的话，enq来补位。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        //保证线程安全的原子操作
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}

// 将节点插入队列，必要时进行初始化.
private Node enq(final Node node) {
    for (; ; ) {
        Node t = tail;
        if (t == null) { 
            // 对head节点进行初始化赋值，并头尾指向同一个节点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // head和tail节点初始化之后，将node加到队列尾部
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>

<ul>
<li>acquireQueued(Node node, arg)</li>
</ul>

<p>其实就是一个自旋的过程，每个节点(或者说每个线程)都在自省地观察， 当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中(并会阻塞节点的线程)。<br/>
在 acquireQueued(final Node node,int arg)方法中，当前线程在“死循环”中 尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么?原因有两个。<br/>
第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。<br/>
第二，维护同步队列的 FIFO 原则。<br/>
当前线程获取到同步状态后，让首节点(head)这个引用指向自己所在节点。 当同步状态获取成功后，当前线程就从 acquire 方法返回了。如果同步器实现的 是锁，那就代表当前线程获得了锁。</p>

<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            //获取节点的前驱结点
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //是否要阻塞线程并判断是否被中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 如果
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h4 id="toc_14">释放同步状态</h4>

<p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的 release(int arg)方法可以释 放同步状态，该方法在释放了同步状态之后，会唤醒其后继节点(进而使后继节 点重新尝试获取同步状态)。</p>

<pre><code class="language-java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>

<p>该方法执行时，会唤醒首节点(head)所指向节点的后继节点线程， unparkSuccessor(Node node)方法使用 LockSupport 来唤醒处于等待状态的线程。</p>

<pre><code class="language-java">private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws &lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus &gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
                if (t.waitStatus &lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
</code></pre>

<p>这段代码的意思，一般情况下，被唤醒的是 head 指向节点的后继节点线程， 如果这个后继节点处于被 cancel 状态， 会转而从尾开始遍历，找到最前面且没有被 cancel 的节点。</p>

<hr/>

<h3 id="toc_15">共享式同步状态获取与释放</h3>

<p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时 获取到同步状态。以读写为例，如果一个程序在进行读操作，那么这一时刻写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。</p>

<p>因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于 等于 0。可以看到，在 doAcquireShared(int arg)方法的自旋过程中，如果当前节<br/>
  点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于 0，表示该次获 取同步状态成功并从自旋过程中退出。</p>

<pre><code class="language-java">public final void acquireShared(int arg) {
    // tryAcquireShared共享方式尝试获取资源。负数表示失败；0表示成功获得同步状态，但没有剩余可用资源；正数表示成功，且有剩余资源。
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>

<p>我们看下doAcquireShared(int arg)方法的实现</p>

<pre><code class="language-java">// 以共享不可中断模式获取。
private void doAcquireShared(int arg) {
    // 构建当前线程的共享节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (; ; ) {
            // 获取当前节点的前驱节点，前驱节点如果是头结点的话，当前线程会尝试获取同步状态
            final Node p = node.predecessor();
            if (p == head) {
                // tryAcquireShared(int arg)方法返回值为 int 类型，当返回值大于等于 0 时，表示能够获取到同步状态
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) {
                    // 此处是与独占同步器的最大不同点
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            // 如果当前线程无法获取到同步状态，则在此处阻塞，等待被唤醒
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

// 设置新的头结点，并将获取的同步状态释放，通知后续节点共享锁资源
private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head;
        // 将node节点设置为头结点
        setHead(node);
        if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||
                (h = head) == null || h.waitStatus &lt; 0) {
            Node s = node.next;
            //下个节点是共享模式的，则释放当前线程的
            if (s == null || s.isShared())
                // 当前线程释放锁，通知下一个节点
                doReleaseShared();
        }
    }
</code></pre>

<p>该方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够 支持多个线程同时访问的并发组件(比如 Semaphore)，它和独占式主要区别在 于 tryReleaseShared(int arg)方法必须确保同步状态(或者资源数)线程安全释放， 一般是通过循环和 CAS 来保证的，因为释放同步状态的操作会同时来自多个线程。</p>

<pre><code class="language-java">private void doReleaseShared() {
        
        for (; ; ) {
            Node h = head;
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    // 释放同步状态不成功的话，继续执行释放
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            
                    // 唤醒后续节点
                    unparkSuccessor(h);
                } else if (ws == 0 &amp;&amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))//确保传播能够继续
                    continue;
            }
            if (h == head) 
                break;
        }
    }
</code></pre>

<hr/>

<h3 id="toc_16">下面实现一个共享锁，代码如下：</h3>

<pre><code class="language-java">/**
 * 共享锁简单实现
 **/
public class SimpleShareLock implements Lock {

    private static final int OFFSET = 1;
    //为n表示允许n个线程同时获得锁
    private final Sync sync = new Sync(4 * OFFSET);

    private static final class Sync extends AbstractQueuedSynchronizer {

        Sync(int count) {
            if (count &lt;= 0) {
                throw new IllegalArgumentException(&quot;允许共享同步状态的线程数不能小于1&quot;);
            }
            setState(count);
        }

        /**
         * @param reduceCount 扣减个数
         * @return 返回小于0，表示当前线程获得同步状态失败，大于0表示当前线程获得同步状态成功
         */
        public int tryAcquireShared(int reduceCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current - reduceCount;
                // 需要保证线程安全使用CAS操作
                if (newCount &lt; 0 || compareAndSetState(current, newCount)) {
                    return newCount;
                }
            }
        }

        /**
         * @param returnCount 归还个数
         * @return
         */
        public boolean tryReleaseShared(int returnCount) {
            for (; ; ) {
                int current = getState();
                int newCount = current + returnCount;
                if (compareAndSetState(current, newCount)) {
                    return true;
                }
            }
        }

        ConditionObject newCondition() {
            return new ConditionObject();
        }
    }

    public void lock() {
        sync.acquireShared(OFFSET);
    }

    public void unlock() {
        sync.releaseShared(OFFSET);
    }

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireSharedInterruptibly(OFFSET);
    }

    public boolean tryLock() {
        return sync.tryAcquireShared(OFFSET) &gt;= 0;
    }

    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(OFFSET, unit.toNanos(time));
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
</code></pre>

<hr/>

<h3 id="toc_17">ConditionObject</h3>

<p><figure><img src="media/15867863097702/15875725837865.jpg" alt=""/></figure></p>

<h4 id="toc_18">ConditionObject的数据结构</h4>

<p>等待队列是一个 FIFO 的队列，在队列中的每个节点都包含了一个线程引用， 该线程就是在 Condition 对象上等待的线程，如果一个线程调用了 Condition.await() 方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。</p>

<p>ConditionObject中的节点定义复用了同步器中节点的定义Node（但是node.waitStatus = Node.CONDITION）</p>

<p>一个 Condition 包含一个等待队列，Condition 拥有首节点(firstWaiter)和尾节点(lastWaiter)。</p>

<p>当前线程调用 Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。Condition 拥有首尾节点的引用，而新增节点只需要将原有的尾节点 nextWaiter 指向它，并且更新尾节点即可。</p>

<p>上述节点引用更新的过程并没有使用 CAS 保证，原因在于调用 await()方法的线程必定是 获取了锁的线程，也就是说该过程是由锁来保证线程安全的。<br/>
<figure><img src="media/15867863097702/15875726221437.jpg" alt=""/></figure></p>

<p>调用 Condition 的 await()方法(或者以 await 开头的方法)，会使当前线程 进入等待队列并释放锁，同时线程状态变为等待状态。当从 await()方法返回时， 当前线程一定获取了 Condition 相关联的锁。</p>

<p>如果从队列(同步队列和等待队列)的角度看 await()方法，当调用 await() 方法时，相当于同步队列的首节点(获取了锁的节点)移动到 Condition 的等待 队列中。调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点， 该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同 步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤 醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用 Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。<br/>
<figure><img src="media/15867863097702/15875726951805.jpg" alt=""/></figure><br/>
如图所示，同步队列的首节点并不会直接加入等待队列，而是通过 addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。<br/>
<figure><img src="media/15867863097702/15875727427827.jpg" alt=""/></figure><br/>
调用 Condition 的 signal()方法，将会唤醒在等待队列中等待时间最长的节点 (首节点)，在唤醒节点之前，会将节点移到同步队列中。</p>

<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到 signal()方法进行了 isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用 LockSupport 唤醒节点中的线程。</p>

<p>通过调用同步器的 enq(Node node)方法，等待队列中的头节点线程安全地移 动到同步队列。当节点移动到同步队列后，当前线程再使用 LockSupport 唤醒该 节点的线程。</p>

<p>被唤醒后的线程，将从 await()方法中的 while 循环中退出 (isOnSyncQueue(Node node)方法返回 true，节点已经在同步队列中)，进而调 用同步器的 acquireQueued()方法加入到获取同步状态的竞争中。</p>

<p>成功获取同步状态(或者说锁)之后，被唤醒的线程将从先前调用的 await() 方法返回，此时该线程已经成功地获取了锁。</p>

<p>Condition 的 signalAll()方法，相当于对等待队列中的每个节点均执行一次 signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每 个节点的线程</p>

<p>ConditionObject 是同步器的条件实现。</p>

<pre><code class="language-java">/**
 * 条件等待
 */
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    // 释放当前线程持有的同步状态，并返回释放之前的同步状态
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // 当前节点是否被移到同步队列, 如果在等待队列，则进行阻塞
    while (!isOnSyncQueue(node)) {
        // 阻塞condition上的当前线程，等待signal信号唤醒
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    //此时进入阻塞队列，自旋获取锁
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}

/**
 * 唤醒条件Condition上的阻塞线程
 */
 public final void signal() {
    // 非当前线程持有同步状态 抛出异常
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

// 删除和传输节点，直到命中不可取消的一个或null。
private void doSignal(Node first) {
    do {
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
            (first = firstWaiter) != null);
}

final boolean transferForSignal(Node node) {
    // 释放当前节点同步状态
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    // 将节点存入同步队列列尾
    Node p = enq(node);
    int ws = p.waitStatus;
    // 同步状态已取消 或 设置同步状态失败，则唤醒节点线程并重新同步。
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
