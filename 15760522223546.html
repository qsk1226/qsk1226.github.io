<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    六、java 虚拟机执行子系统---字节码执行引擎 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            六、java 虚拟机执行子系统---字节码执行引擎   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2019/12/11</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_jvm.html'>#jvm</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>执行引擎是Java虚拟机核心的组成部分之一。</p>

<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>

<p>Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。</p>

<p>这里需要对java虚拟机栈有一个了解 <a href="15865981620428.html">二、JVM自动内存管理--java内存区域与内存溢出异常</a></p>

<h2 id="toc_0">1、方法调用</h2>

<h3 id="toc_1">1.1、解析调用</h3>

<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。</p>

<p>调用不同类型的方法，字节码指令集里面设计了不同的指令。java虚拟机支持一下5条方法调用字节码指令：</p>

<ul>
<li>invokestatic 用于调用静态方法</li>
<li>invokespecial 用于调用实例构造器<init>()方法，私有方法和父类中的方法。</li>
<li>invokevirtual 用于调用所有的虚方法</li>
<li>invokeinterface 用于调用接口方法，会在运行时在确定一个实现该接口的对象</li>
<li>invokedynamic 现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>

<p>些方法统称为“非虚方法”（Non-Virtual Method）： 要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final 修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。</p>

<p>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>

<h3 id="toc_2">1.2、分派</h3>

<p>而另一种主要的方法调用形式：分派（Dispatch）调用则要复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况。</p>

<p>因为Java具备面向对象的3个基本特征：继承、封装和多态。本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，我们关心的依然是虚拟机如何确定正确的目标方法。</p>

<h4 id="toc_3">1.2.1、静态分派</h4>

<p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派解决了方法的重载问题。</p>

<p>从定义中我们需要了解什么事静态类型，首先先看一段如下代码：</p>

<pre><code class="language-java">public class StaticDispatch {

    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    public void sayHello(Human human) {
        System.out.println(&quot;Hello human&quot;);
    }

    public void sayHello(Man man) {
        System.out.println(&quot;Hello man&quot;);
    }

    public void sayHello(Woman woman) {
        System.out.println(&quot;Hello woman&quot;);
    }

    public static void main(String[] args) {
        // 这里Human 被称为静态类型，man被称为实际类型
        Human man = new Man();
        Human woman = new Woman();

        StaticDispatch staticDispatch = new StaticDispatch();
        staticDispatch.sayHello(man);
        staticDispatch.sayHello(woman);
    }
}
</code></pre>

<p>上例中 Human 被称为变量的 ”静态类型“ 后面的Man 被称为变量的“实际类型”。</p>

<p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>

<p>编译期间选择静态分派目标的过程，这个过程也是Java语言实现方法重载的本质。</p>

<h4 id="toc_4">1.2.2、动态分派</h4>

<p>动态分派的实现过程与java语言多态性的另一个重要体现---重写 有着密切关系。</p>

<pre><code class="language-java">public class DynamicDispatch {

    abstract static class Human {
        public abstract void sayHello();
    }

    static class Man extends Human {
        public void sayHello() {
            System.out.println(&quot;Hello man&quot;);
        }
    }

    static class Woman extends Human {
        public void sayHello() {
            System.out.println(&quot;Hello woman&quot;);
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
    }
}

----------------------

Hello man
Hello woman

</code></pre>

<p>关于方法的重写，java虚拟机是怎么判断应该调用哪个方法的呢？</p>

<p>我们看下上面方法的字节码</p>

<pre><code class="language-java">  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class com/goddess/base/classloader/DynamicDispatch$Man
         3: dup
         4: invokespecial #3                  // Method com/goddess/base/classloader/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: new           #4                  // class com/goddess/base/classloader/DynamicDispatch$Woman
        11: dup
        12: invokespecial #5                  // Method com/goddess/base/classloader/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V
        15: astore_2
        16: aload_1
        17: invokevirtual #6                  // Method com/goddess/base/classloader/DynamicDispatch$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #6                  // Method com/goddess/base/classloader/DynamicDispatch$Human.sayHello:()V
        24: return
      LineNumberTable:
        line 29: 0
        line 30: 8
        line 31: 16
        line 32: 20
        line 33: 24
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      25     0  args   [Ljava/lang/String;
            8      17     1   man   Lcom/goddess/base/classloader/DynamicDispatch$Human;
           16       9     2 woman   Lcom/goddess/base/classloader/DynamicDispatch$Human;
}

</code></pre>

<p>0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中。</p>

<p>16～21行是关键部分，16和20行的aload指令分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。</p>

<p>那看来解决问题的关键还必须从invokevirtual指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。</p>

<p>invokevirtual指令的运行时解析过程：</p>

<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做 C</li>
<li>如果在类型 C 中找到与常量 中的描述符和简单名称都有相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方式，则抛出 java.lang.AbstractMethodError异常。</li>
</ul>

<p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接受者的实际类型，所以两次调用中的 invokevirtual 指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接受者的实际类型来选择方法版本，这个过程就是java 语言中方法重写的本质。</p>

<p>我们把这种在运行期根据实际类型确定方法执行版本的过程称为动态分派。</p>

<p>这种多台行的根源在于虚方法调用指令 invokevirtual 的执行逻辑，那自然得出的结论就只对方法有效，对字段无效，因为字段不适用这条指令。</p>

<p>使用如下代码说明动态派生中的虚方法与字段的区别：</p>

<pre><code class="language-java">public class FieldHasNoPolymorphic {
    static class BigBrother {
        public int money = 1;

        public BigBrother() {
            money = 2;
            showMeTheMoney();
        }

        public void showMeTheMoney() {
            System.out.println(&quot;BigBrother had ￥&quot; + money);
        }
    }


    static class LittleBrother extends BigBrother {
        public int money = 3;

        public LittleBrother() {
            money = 4;
            showMeTheMoney();
        }

        public void showMeTheMoney() {
            System.out.println(&quot;LittleBrother had ￥&quot; + money);
        }
    }

    public static void main(String[] args) {
        BigBrother brother = new LittleBrother();
        System.out.println(&quot;brother had ￥&quot; + brother.money);
    }
}

------ 

LittleBrother had ￥0
LittleBrother had ￥4
brother had ￥2
</code></pre>

<p>两句输出都是 “LittleBrother,” 这是因为 LittleBrother 类在创建的时候回隐式的调用 BigBrother 的构造函数，而 BigBrother 构造函数中的对showMetheMoney 的调用是一次虚方法调用，实际执行的版本是 LittleBrother::showMetheModey()方法，而这时虽然父类的money字段别初始化为了2，但是子类 LittleBrother 中的money 还未被程序初始化，因为，子类中的money要等到子类的构造函数执行时才会被初始化，所以此main函数打印出来的结果才会如上例所示。</p>

<h4 id="toc_5">1.2.3、单分派和多分派</h4>

<p>方法的接受者与方法的参数统称为方法的宗量，根据分派给予多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>

<p>如今的Java语言是一门静态多分派、动态单分派的语言。</p>

<h3 id="toc_6">虚拟机的动态分派实现</h3>

<p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。</p>

<p><figure><img src="media/15760522223546/15969817696559.jpg" alt=""/></figure></p>

<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>

<p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的虚方法表也一同初始化完毕。</p>

<p>虚拟机除了使用虚方法表之外，为了进一步提高性能，还会使用类型继承关系分析（Class Hierarchy Analysis，CHA）、守护内联（Guarded Inlining）、内联缓存（Inline Cache）等多种非稳定的激进优化来争取更大的性能空间。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
