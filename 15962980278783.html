<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    七、 JVM 性能调优 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            七、 JVM 性能调优   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/08/02</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <h2 id="toc_0">1、调优需要考虑的内容</h2>

<p>业务场景的设定，计算内存需求，选定cpu，选择合适垃圾回收器，设定新生代大小、分代年龄，设定日志参数</p>

<ul>
<li>Xmn用于设置新生代的大小。过小会增加Minor GC频率，过大会减小老年代的大小。一般设为整个堆空间的1/4或1/3. </li>
<li>XX:SurvivorRatio用于设置新生代中survivor空间(from/to)和eden空间的大小比例；XX:TargetSurvivorRatio表示，当经历Minor GC后，survivor空间占有量(百分比)超过它的时候，就会压缩进入老年代(当然，如果survivor空间不够，则直接进入老年代)。默认值为50%。 </li>
<li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生的大对象直接进入老年代。因为新生对象大部分都是短期的，这就造成了老年代的内存浪费，并且回收代价也高(Full GC发生在老年代和方法区Perm). </li>
<li>当Xms=Xmx，可以使得堆相对稳定，避免不停震荡 一般来说，</li>
<li>MaxPermSize设为64MB可以满足绝大多数的应用了。若依然出现方法区溢出，则可以设为128MB。若128MB还不能满足需求，那么就应该考虑程序优化了，减少动态类的产生</li>
</ul>

<h2 id="toc_1">2、apache bench 压测工具进行接口优化</h2>

<p>ab -c 10 -n 100 url<br/>
其中－n表示请求数，－c表示并发数</p>

<pre><code class="language-shell">&gt; ab -c 10 -n 100 https://www.baidu.com

....

Server Software:        BWS/1.1
Server Hostname:        www.baidu.com
Server Port:            443
SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128
Server Temp Key:        ECDH P-256 256 bits
TLS Server Name:        www.baidu.com

Document Path:          /
Document Length:        227 bytes

# 并发请求数
Concurrency Level:      100
# 整个测试持续的时间
Time taken for tests:   0.849 seconds
# 完成的请求数
Complete requests:      100
# 失败的请求数
Failed requests:        0
# 整个场景中的网络传输量
Total transferred:      108197 bytes
# 整个场景中的HTML内容传输量
HTML transferred:       22700 bytes
# 吞吐率
Requests per second:    117.76 [#/sec] (mean)
# 用户平均请求等待时间
Time per request:       849.153 [ms] (mean)
# 服务器平均请求处理时间
Time per request:       8.492 [ms] (mean, across all concurrent requests)
# 平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题
Transfer rate:          124.43 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       62  541 150.3    662     666
Processing:    15  148 120.4     61     295
Waiting:       11  146 118.8     61     291
Total:         76  689  66.5    704     773

Percentage of the requests served within a certain time (ms)
  50%    704
  66%    710
  75%    714
  80%    716
  90%    723
  95%    725
  98%    731
  99%    773
 100%    773 (longest request)
</code></pre>

<p>性能指标：</p>

<ul>
<li><p>吞吐率（Requests per second）<br/>
概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br/>
计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br/>
Request per second = Complete requests / Time taken for tests</p></li>
<li><p>用户平均请求等待时间（Time per request）<br/>
计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br/>
Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p></li>
<li><p>服务器平均请求等待时间（Time per request: across all concurrent requests）<br/>
计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br/>
Time taken for / testsComplete requests<br/>
可以看到，它是吞吐率的倒数。<br/>
同时，它也=用户平均请求等待时间/并发用户数，即<br/>
Time per request / Concurrency Level</p></li>
</ul>

<h2 id="toc_2">3、gc优化</h2>

<p>首先把优化策略发出来：</p>

<ul>
<li><p>新生代大小选择</p>
<ul>
<li>响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择)。在此种情况下,新生代收集发生的频率也是最小的。同时,减少到达老年代的对象。</li>
<li>吞吐量优先的应用:尽可能的设置大,可能到达 Gbit 的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合 8CPU 以上的应用。</li>
<li>避免设置过小.当新生代设置过小时会导致:1.MinorGC 次数更加频繁 2.可能导致 MinorGC 对象直接进入老年代,如果此时老年代满了,会触发FullGC. </li>
</ul></li>
<li><p>老年代大小选择</p>
<ul>
<li>响应时间优先的应用:老年代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可能会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式; 如果堆大了,则需要较长的收集时间。<br/>
最优化的方案,一般需要参考以下数据获得:并发垃圾收集信息、持久代并发收集次数、传统 GC 信息、花在新生代和老年代回收上的时间比例。</li>
<li>吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的新生代和一个较小的老年代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而 老年代尽存放长期存活对象。</li>
</ul></li>
</ul>

<h3 id="toc_3">3.1、gc性能指标</h3>

<ul>
<li><p>吞吐量:这里的衡量吞吐量是指应用程序所花费的时间和系统总运行时间的比值。<br/>
我们可以按照这个公式来计算 GC 的吞吐量:系统总运行时间 = 应用程序耗时 +GC 耗时。如果系统运行了 100 分钟，GC 耗时 1 分钟，则系统吞吐量为 99%。GC 的吞吐量一般不能低于 95%。</p></li>
<li><p>停顿时间: 指垃圾回收器正在运行时，应用程序的暂停时间。<br/>
对于串行回收器而言，停顿时间可能会比较长;而使用并发回收器，由于垃圾收集器和应用程序交替 运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾收集器，系统的吞吐量也很可能会降低。</p></li>
<li><p>垃圾回收频率: 通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿 时间。所以我们需要适当地增大堆内存空间，保证正常的垃圾回收频率即可。</p></li>
</ul>

<h3 id="toc_4">3.2、GC 调优策略</h3>

<h4 id="toc_5">3.2.1、降低 Minor GC 频率</h4>

<p>由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此我们可以通过增大新生代空间来降低 Minor GC 的频率。 单次 Minor GC 时间是由两部分组成:T1(扫描新生代)和 T2(复制存活对象)。</p>

<p>情况 1: 假设一个对象在 Eden 区的存活时间为 500ms，Minor GC 的时间间隔是 300ms，因为这个对象存活时间 &gt; 间隔时间，那么正常情况下，Minor GC 的时间为 :T1+T2。</p>

<p>情况 2:当我们增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不 存在复制存活对象了，所以再发生 Minor GC 的时间为:即 <code>T1*2(空间大了)+T2*0</code><br/>
可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。</p>

<p>在 JVM 中，复制对象的成本要远高于扫描成本。如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如 果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。</p>

<h4 id="toc_6">3.2.2、降低 Full GC 的频率</h4>

<p>由于堆内存空间不足或老年代对象太多，会触发 Full GC，频繁的 Full GC 会带来上下文切换，增加系统的性能开销。 </p>

<p>减少创建大对象: 在平常的业务场景中，我们一次性从数据库中查询出一个大对象用于 web 端显示。比如，一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代; 即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。</p>

<p>这种大对象很容易产生较多的 Full GC。 增大堆内存空间:在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 Full GC 的频率。</p>

<h2 id="toc_7">4、问题排查</h2>

<h3 id="toc_8">4.1、CPU占用过高排查</h3>

<p>使用top命令查看进程各种运行状况，请参考<a href="15983681960215.html">linux和macOS下top命令区别</a></p>

<p>1、先通过 top 命令找到消耗 cpu 很高的进程 PID<br/>
<figure><img src="media/15962980278783/15983692600595.jpg" alt="" style="width:1008px;"/></figure></p>

<p>2、执行 top -p PID 单独监控该进程<br/>
3、在第 2 步的监控界面输入 H，获取当前进程下的所有线程信息<br/>
4、找到消耗 cpu 特别高的线程编号，假设是 2734(要等待一阵)<br/>
5、执行 jstack PID 对当前的进程做 dump，输出所有的线程信息<br/>
6、将第 4 步得到的线程编号 PID 转成 16 进制是 0x???<br/>
7、根据第 6 步得到的 0x??? 在第 5 步的线程信息里面去找对应线程内容<br/>
8、解读线程信息，定位具体代码位置，此处可能并不是代码问题引起的cpu占用过高，可能由于 GC 引起频繁的垃圾回收，可使用jstat -gc 250 10查看gc统计情况<a href="%5B%E5%9B%9B%E3%80%81JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%5D(15773440983590.html)"></a></p>

<h3 id="toc_9">4.2、内存占用过高</h3>

<p>可以使用jmap命令来查看堆空间信息<br/>
打印出排名前20的对象<br/>
jmap –histo JVM_ID | head -20</p>

<p><figure><img src="media/15962980278783/15983702156050.jpg" alt=""/></figure></p>

<p>从此命令的返回结果中可以看出排名前几的可能就是引发内存占用过高的对象，进而找出那部分代码出了问题</p>

<h3 id="toc_10">4.3、总结</h3>

<p>在 JVM 出现性能问题的时候。(表现上是 CPU100%，内存一直占用)<br/>
1、 如果 CPU 的 100%，要从两个角度出发，一个有可能是业务线程疯狂运行，比如说想很多死循环。还有一种可能性，就是 GC 线程在疯狂的回收，因<br/>
为 JVM 中垃圾回收器主流也是多线程的，所以很容易导致 CPU 的 100%<br/>
2、 在遇到内存溢出的问题的时候，一般情况下我们要查看系统中哪些对象占用得比较多，我的是一个很简单的代码，在实际的业务代码中，找到对应的<br/>
对象，分析对应的类，找到为什么这些对象不能回收的原因，就是我们前面讲过的可达性分析算法，JVM 的内存区域，还有垃圾回收器的基础，当然， 如果遇到更加复杂的情况，你要掌握的理论基础远远不止这些(JVM 很多理论都是排查问题的关键)</p>

<h2 id="toc_11">5、常见问题</h2>

<h3 id="toc_12">5.1、超大对象</h3>

<p>代码中创建了很多大对象 , 且一直因为被引用不能被回收，这些大对象会进入老年代，导致内存一直被占用，很容易引发 GC 甚至是 OOM</p>

<h3 id="toc_13">5.2、内存泄漏</h3>

<p>大量对象引用没有释放，JVM 无法对其自动回收。</p>

<p>内存泄漏和内存溢出辨析：<br/>
内存溢出:实实在在的内存空间不足导致; 内存泄漏:该释放的对象没有释放，常见于使用容器保存元素的情况下。 </p>

<p>如何避免:<br/>
内存溢出:检查代码以及设置足够的空间 内存泄漏:一定是代码有问题 往往很多情况下，内存溢出往往是内存泄漏造成的。</p>

<h3 id="toc_14">5.3、长生命周期的对象持有短生命周期对象的引用</h3>

<p>例如将 HashMap 设置为静态变量，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏</p>

<h3 id="toc_15">5.4、连接未关闭</h3>

<p>如数据库连接、网络连接和 IO 连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象。</p>

<h3 id="toc_16">5.5、变量作用域不合理</h3>

<p>例如，1.一个变量的定义的作用范围大于其使用范围，2.如果没有及时地把对象设置为 null</p>

<h2 id="toc_17">6、MAT Analyzer(TODO)</h2>

<p>MAT(Memory Analyzer Tool)工具是eclipse的一个插件(MAT也可以单独使用)，使用起来非常方便，尤其是在分析大内存的dump文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用OQL对象查询，以及可以很方便的找出对象GC Roots的相关信息，当然最吸引人的还是能够快速为开发人员生成内存泄露报表，方便定位问题和分析问题。</p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
