<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    ElasticSearch - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            ElasticSearch   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2021/05/13</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='ELK.html'>ELK</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFelasticsearch">什么是ElasticSearch</a></li>
<li><a href="#near-realtime%EF%BC%88nrt%E8%BF%91%E5%AE%9E%E6%97%B6%EF%BC%89">Near Realtime（NRT 近实时）</a></li>
<li><a href="#es%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">es基础概念</a>
<ul>
<li><a href="#index%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89">Index（索引）</a></li>
<li><a href="#document%E6%96%87%E6%A1%A3">Document(文档)</a></li>
<li><a href="#%E6%98%A0%E5%B0%84">映射</a></li>
<li><a href="#field%E6%96%87%E6%A1%A3%E5%AD%97%E6%AE%B5">Field(文档字段)</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E5%AD%97%E6%AE%B5%E5%8F%82%E6%95%B0">字段参数</a></li>
</ul>
</li>
<li><a href="#%E5%85%83%E5%AD%97%E6%AE%B5meta-fields">元字段 meta-fields</a>
<ul>
<li><a href="#%E8%BA%AB%E4%BB%BD%E6%A0%87%E8%AF%86%E5%85%83%E6%95%B0%E6%8D%AE">身份标识元数据</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%85%83%E6%95%B0%E6%8D%AE">索引元数据</a></li>
<li><a href="#%E6%96%87%E6%A1%A3%E5%85%83%E6%95%B0%E6%8D%AE">文档元数据</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%85%83%E6%95%B0%E6%8D%AE">路由元数据</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#elasticsearch%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5">ElasticSearch 集群概念</a>
<ul>
<li><a href="#cluster%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89">Cluster（集群）</a></li>
<li><a href="#node%EF%BC%88%E8%8A%82%E7%82%B9%EF%BC%89">Node（节点）</a></li>
<li><a href="#shards-replicas%EF%BC%88%E5%88%86%E7%89%87%E5%89%AF%E6%9C%AC%EF%BC%89">Shards &amp; Replicas（分片 &amp; 副本）</a></li>
</ul>
</li>
</ul>

<h2><a id="%E4%BB%80%E4%B9%88%E6%98%AFelasticsearch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>什么是ElasticSearch</h2>
<p>Elasticsearch 是一个高度可扩展且开源的分布式搜索引擎。它可以让您快速且近实时地存储，检索以及分析海量数据。它通常用作那些具有复杂搜索功能和需求的应用的底层引擎或者技术，提供搜集、分析、存储数据三大功能。它的特点有: 分布式，零配置，自动发现，索引自动分片，索引副本机制， restful 风格接口，多数据源，自动搜索负载等等。</p>
<p>同时 Logstash 和 Beats 有助于收集，聚合和丰富您的数据并将其存储在Elasticsearch中。使用Kibana，您可以交互式地探索，可视化和共享对数据的见解，并管理和监视堆栈。Elasticsearch是建立索引，搜索和分析魔术的地方。</p>
<h2><a id="near-realtime%EF%BC%88nrt%E8%BF%91%E5%AE%9E%E6%97%B6%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Near Realtime（NRT 近实时）</h2>
<p>Elasticsearch 是一个近实时的搜索平台。这意味着从您索引一个文档开始直到它可以被查询时会有轻微的延迟时间（默认为一秒），</p>
<h2><a id="es%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>es基础概念</h2>
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>ElasticSearch</th>
</tr>
</thead>
<tbody>
<tr>
<td>库</td>
<td>index</td>
</tr>
<tr>
<td>表</td>
<td>mapping type</td>
</tr>
<tr>
<td>数据行</td>
<td>document</td>
</tr>
<tr>
<td>字段</td>
<td>field</td>
</tr>
<tr>
<td>表结构</td>
<td>mapping</td>
</tr>
</tbody>
</table>
<h3><a id="index%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Index（索引）</h3>
<p>Elasticsearch 索引是映射类型的容器。一个 Elasticsearch 索引非常像关系型中的数据库，是独立的大量文档集合。</p>
<h3><a id="document%E6%96%87%E6%A1%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Document(文档)</h3>
<p>文档是 es 中所有可搜索数据的最小单位，比如日志文件中的日志项、一个订单等具体信息。</p>
<p>文档会被序列化 JSON 格式保存到 ElasticSearch 中，JSON 对象由字段组成， 每个字段都有对象的字段类型(字符串，数值，布尔，日期，二进制，范围类型)。 同时每个文档都有一个 Unique ID，可以自己指定 ID，或者通过 ElasticSearch 自动生成。</p>
<h3><a id="%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>映射</h3>
<p>映射(mapping)定义了每个字段的类型、字段所使用的分词器等。</p>
<p>映射可以显式映射，由我们在索引映射中进行预先定义;也可以动态映射，在添 加文档的时候，由 es 自动添加到索引，这个过程不需要事先在索引进行字段数 据类型匹配等等，es 会自己推断数据类型。</p>
<h3><a id="field%E6%96%87%E6%A1%A3%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Field(文档字段)</h3>
<p>文档中的一个字段 field 就相当于关系型数据库中的一列 column，它也具有数据类型。</p>
<h4><a id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据类型</h4>
<ul>
<li>字符串类型<br />
字符串类型可以被分为 text和keyword类型，如果我们让es自动映射数据，es会把字符串定义为 text，并且加一个 keyword 类型字段。
<ul>
<li>text 文本数据类型，用于索引全文值的字段。使用 text 的字段，它会被分词，并加入到倒排索引，一般不具备唯一性的字符串都可以设置为 text</li>
<li>keyword 关键字数据类型，用于索引唯一内容的字段(身份证、订单号、手机号等)，keyword 只能用按照其确切值进行搜索，无法进行模糊查询</li>
</ul>
</li>
<li>数字类型 long、integer、short、byte、double、float</li>
<li>日期类型 date</li>
<li>布尔类型 boolean</li>
<li>复杂数据类型
<ul>
<li>数组：无需专门的数据类型</li>
<li>对象数据类型： 单独的劲松</li>
<li>嵌套数据类型： nested，json对象的数组</li>
</ul>
</li>
<li>地理数据类型
<ul>
<li>地理点数据类型</li>
<li>地理形状数据类型</li>
</ul>
</li>
<li>ipv4 数据类型</li>
<li>单词计数数据类型： token_count</li>
</ul>
<h4><a id="%E5%AD%97%E6%AE%B5%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字段参数</h4>
<ul>
<li>analyzer<br />
指定分词器，对于 text 类型的字段，首先会使用分词器进行分词，然后将分词后的词根一个一个存储在 倒排索引中，后续查询主要是针对词根的搜索。<br />
analyzer可以在每个查询、字段、索引中使用，其优先级如下(越靠前越优先)：
<ul>
<li>字段上定义的分词器</li>
<li>索引配置中定义的分词器</li>
<li>默认分词器(stadard)</li>
</ul>
</li>
<li>normalizer<br />
规范化，主要针对 keyword 类型，在索引该字段或查询字段之前，可以先对原始数据进行一些建单的处理，然后再将处理后的结果当成一个词根存入倒排索引中，默认为 null。</li>
</ul>
<pre><code class="language-bash">PUT /my_index
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;normalizer&quot;: {
        &quot;my_normalizer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;filter&quot;: [&quot;lowercase&quot;,&quot;asciifolding&quot;]
        }
      }
    }
  }
}
</code></pre>
<ul>
<li>
<p>coerce<br />
默认true，保证数值不合法的部分被去除掉，例如将字符串强制转为正数、浮点被强制转为整数</p>
</li>
<li>
<p>copy_to<br />
将字段 copy 到 目标字段</p>
</li>
<li>
<p>doc_values<br />
es中倒排索引的优势是查找包含某个词项的文档，而对于从另外一个方向的相反操作并不高效，即确定单个文档里面所有的唯一此项，默认为true，并且只适用于非 text 类型的字段。</p>
</li>
<li>
<p>dynamic<br />
是否允许动态的隐式增加字段，在执行 index api 或 更新文档 API 时，对于 _source 字段中包含一些原先未定义的字段采取的措施，根据 dynamic 的取值， 会进行不同的操作:</p>
<ul>
<li>true，默认值，表示新的字段会加入到类型映射中。</li>
<li>false,新的字段会被忽略，即不会存入_souce 字段中，即不会存储新字段，也无法通过新字段进行查询。</li>
<li>strict，会显示抛出异常，需要新使用 put mapping api 先显示增加字段映射。</li>
</ul>
</li>
<li>
<p>enabled<br />
是否建立索引，默认情况下为 true，但有时候某些类型的字段，无需建立索引，只是用来存储数据即可，enable 设置为 false 的字段，只能从 _source 中获取，不可搜索，只有 映射类型 type 和 object 类型的字段可以设置 enabled 属性。</p>
</li>
<li>
<p>eager_global_ordinals<br />
表示是否提前加载全局顺序号。Global ordinals 是一个建立在 doc_values 和 fielddata 基础上的数据结构, 它为每一个精确词按照字母顺序维护递增的编号，只支持 text 和 keyword 型字段，在 keyword 类型字段中默认是开启的，而在 text 型字段中只有 fielddata 和相关属性开启的状态下才是可用的</p>
</li>
<li>
<p>fielddata<br />
默认false，为了解决排序与聚合，es 为了支持 text 字段高效排序与聚合，引入了一种新的数据结构(fielddata)，使用内存进行存储。<br />
默认构建时机为第一次聚合查询、排序操作时构建，主要存储倒排索引中的词根与文档的映射关系，聚合，排序操作在内存中执行。因此 fielddata 需要消耗大量的 JVM 堆内存。<br />
一旦 fielddata 加载到内存后，它将永久存在。谨慎使用</p>
</li>
<li>
<p>format<br />
在 JSON 文档中，日期表示为字符串。Elasticsearch 使用一组预先配置的格式 来识别和解析这些字符串，并将其解析为 long 类型的数值(毫秒)，支持自定义格式，也有内置格式</p>
</li>
<li>
<p>ignore_above<br />
用于指定字段索引和存储的长度最大值，超过这个最大值会被忽略掉</p>
</li>
<li>
<p>index<br />
默认true，指定字段是否索引，不索引也就不可搜索，取值可以为 true 或 false</p>
</li>
<li>
<p>index_options<br />
index_options 控制索引时存储哪些信息到倒排索引中，，用于搜索和突出显 示目的。</p>
<ul>
<li>docs: 只存储文档编号</li>
<li>freqs: 存储文档编号和词项频率</li>
<li>positions: 存储文档编号、词项频率、词项的位置</li>
<li>offsets: 存储文档编号、词项频率、词项的位置、词项开始和结束字符位置都被存储</li>
</ul>
</li>
<li>
<p>fields<br />
fields 可以让同一文本有多种不同的索引方式</p>
</li>
<li>
<p>norms<br />
norms 参数用于标准化文档，以便查询时计算文档的相关性。norms 虽然对评分有用，但是会消耗较多的磁盘空间，如果不需要对某个字段进行评分，最好不要开启 norms</p>
</li>
<li>
<p>null_value<br />
一般来说值为 null 的字段不索引也不可以搜索，null_value 参数可以让值为 null 的字段显式的可索引、可搜索。</p>
</li>
<li>
<p>position_increment_gap<br />
文本数组元素之间位置信息添加的额外值。<br />
举例，一个字段的值为数组类型:&quot;names&quot;: [ &quot;John Abraham&quot;, &quot;Lincoln Smith&quot;]<br />
为了区别第一个字段和第二个字段，Abraham 和 Lincoln 在索引中有一个间 距，默认是 100。</p>
</li>
</ul>
<pre><code class="language-shell">PUT my_index/groups/1 {&quot;names&quot;: [ &quot;John Abraham&quot;, &quot;Lincoln Smith&quot;] }
# 设置 slop 设置的大于100可查询到 Abraham Lincoln
GET my_index/groups/_search 
{
	&quot;query&quot;: { 
		&quot;match_phrase&quot;: {
			&quot;names&quot;: {
				&quot;query&quot;: &quot;Abraham Lincoln&quot;, 
				&quot;slop&quot;: 101
			}
		}
	}
}
</code></pre>
<ul>
<li>properties<br />
文档属性，可指定 Object 或者 nested 类型</li>
<li>search_analyzer<br />
通常，在索引时和搜索时应用相同的分析器，以确保查询中的术语与反向索 引中的术语具有相同的格式，如果想要在搜索时使用与存储时不同的分词器，则 使用 search_analyzer 属性指定，通常用于 ES 实现即时搜索(edge_ngram)</li>
<li>similarity<br />
指定相似度算法，其可选值:
<ul>
<li>BM25 当前版本的默认相似度算法</li>
<li>classic 使用 TF/IDF算法</li>
<li>boolean 一个简单的布尔相似度，当不需要全文排序时使用，并且分数应该只基于查 询条件是否匹配。</li>
</ul>
</li>
<li>store<br />
默认情况下，字段值被索引以使其可搜索，但它们不存储。<br />
在某些情况下，存储字段是有意义的。例如，如果您有一个包含标题、日期 和非常大的内容字段的文档，您可能只想检索标题和日期，而不需要从大型 _source 字段中提取这些字段，可以将标题和日期字段的 store 定义为 ture。</li>
<li>term_vector</li>
</ul>
<h3><a id="%E5%85%83%E5%AD%97%E6%AE%B5meta-fields" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>元字段 meta-fields</h3>
<p>一个文档存有我们定义的业务字段数据之外，它还包含了元数据字段 (meta-fields)。元字段不需要用户定义，在任一文档中都存在，有点类似于数据库的表结构数据。在名称上有个显著的特征，都是以下划线“_”开头。</p>
<p>大体分为五种类型: 身份(标识)元数据、索引元数据、文档元数据、路由<br />
元数据以及其他类型的元数据，当然不是每个文档都有这些元字段的。</p>
<h4><a id="%E8%BA%AB%E4%BB%BD%E6%A0%87%E8%AF%86%E5%85%83%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>身份标识元数据</h4>
<ul>
<li>_index:文档所属索引 , 自动被索引，可被查询，聚合，排序使用，或者脚本里访问</li>
<li>_type:文档所属类型，自动被索引，可被查询，聚合，排序使用，或者脚本里访问</li>
<li>_id:文档的唯一标识，建索引时候传入 ，不被索引，可通过_uid 被查询， 脚本里使用，不能参与聚合或排序</li>
</ul>
<h4><a id="%E7%B4%A2%E5%BC%95%E5%85%83%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引元数据</h4>
<p>_field_names:索引了每个字段的名字，可以包含 null 值，可以通过 exists 查询或 missing 查询方法来校验特定的字段</p>
<h4><a id="%E6%96%87%E6%A1%A3%E5%85%83%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文档元数据</h4>
<ul>
<li>_source : 一个 doc 的原生的 json 数据，不会被索引，用于获取提取字段 值 ，启动此字段，索引体积会变大，如果既想使用此字段又想兼顾索引体积， 可以开启索引压缩。<br />
_source 是可以被禁用的，不过禁用之后部分功能不再支持，这些功能包括: 部分 update api、运行时高亮搜索结果、索引重建、修改 mapping 以及分词、索引升级、debug 查询或者聚合语句、索引自动修复</li>
<li>_size: 整个_source 字段的字节数大小，需要单独安装一个 mapper-size 插 件才能展示。</li>
</ul>
<h4><a id="%E8%B7%AF%E7%94%B1%E5%85%83%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>路由元数据</h4>
<p>_routing: 一个 doc 可以被路由到指定的 shard 上。</p>
<h4><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h4>
<p>_meta:一般用来存储应用相关的元信息</p>
<h2><a id="elasticsearch%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ElasticSearch 集群概念</h2>
<h3><a id="cluster%EF%BC%88%E9%9B%86%E7%BE%A4%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cluster（集群）</h3>
<p>cluster（集群）是一个或者多个节点的集合，它们一起保存数据并且提供所有节点联合索引以及搜索功能。集群存在一个唯一的名字身份且默认为 “elasticsearch”。这个名字非常重要，因为如果节点安装时通过它自己的名字加入到集群中的话，那么一个节点只能是一个集群中的一部分。</p>
<p>请确保您在不同环境中不要重复使用相同的集群名字，否则您可能最终会将节点加入到了错误的集群中。例如，您可以使用 order-dev，order-stage，以及 order-prod，用于 development（开发），staging（演示）和 production（生产）集群。</p>
<p>注意，一个集群如果只有一个结点也是有效的，并且完全可行的。此外，您还可以有多个独立的集群并且每个集群都有它自己唯一的 cluster name（集群名）。</p>
<h3><a id="node%EF%BC%88%E8%8A%82%E7%82%B9%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Node（节点）</h3>
<p>node（节点）是一个单独的服务器，它是集群的一部分，存储数据，参与集群中的索引和搜索功能。像一个集群一样，一个节点通过一个在它启动时默认分配的一个随机的 UUID（通用唯一标识符）名称来识别。如果您不想使用默认名称您也可自定义任何节点名称。这个名字是要识别网络中的服务器对应这在您的 Elasticsearch 集群节点管理的目的是很重要的。</p>
<p>节点可以通过配置 cluster name 来加入到指定的集群中。默认情况下，每个节点安装时都会加入到名为 elasticsearch 的集群中，这也就意味着如果您在网络中启动许多节点（假设它们可以发现彼此），它们全部将自动的构成并且加入到一个名为 elasticsearch 的单独的集群中。</p>
<h3><a id="shards-replicas%EF%BC%88%E5%88%86%E7%89%87%E5%89%AF%E6%9C%AC%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shards &amp; Replicas（分片 &amp; 副本）</h3>
<p>索引可以存储大量数据，可以超过单个节点的硬件限制。例如，十亿个文档占用了 1TB 的磁盘空间的单个索引可能不适合放在单个节点的磁盘上，并且从单个节点服务请求会变得很慢。</p>
<p>为了解决这个问题，Elasticsearch 提供了把 Index（索引）拆分到多个 Shard（分片）中的能力。在创建索引时，您可以简单的定义 Shard（分片）的数量。每个 Shard 本身就是一个 fully-functional（全功能的）和独立的 “Index（索引）”，（Shard）它可以存储在集群中的任何节点上。</p>
<p>Sharding（分片）非常重要两个理由是 :</p>
<p>水平的拆分/扩展。<br />
分布式和并行跨 Shard 操作（可能在多个节点），从而提高了性能/吞吐量。<br />
Shard 的分布式机制以及它的文档是如何聚合支持搜索请求是完全由 Elasticsearch 管理的，并且是对用户透明的。</p>
<p>在 网络/云 环境中可能随时会故障，无论出于何种原因，在 shard/node 不知何故会离线或者消失的情况下强烈建议设置故障转移是非常有效的。为了达到这个目的，Elasticsearch 可以让您设置一个或多个索引的 Shard 副本到所谓的副本分片，或者副本中去。</p>
<p>副本非常重要的两个理由是 :</p>
<p>在 shard/node 故障的情况下提供了高可用性。为了达到这个目的，需要注意的是在原始的/主 Shard 被复制时副本的 Shard 不会被分配到相同的节点上。<br />
它可以让你水平扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行执行。<br />
总而言之，每个索引可以被拆分成多个分片，一个索引可以设置 0 个（没有副本）或多个副本。开启副本后，每个索引将有主分片（被复制的原始分片）和副本分片（主分片的副本）。分片和副本的数量在索引被创建时都能够被指定。在创建索引后，您也可以在任何时候动态的改变副本的数量，但是不能够改变分片数量。</p>
<p>默认情况下，Elasticsearch 中的每个索引分配了 5 个主分片和 1 个副本，这也就意味着如果您的集群至少有两个节点的话，您的索引将会有 5 个主分片和另外 5 个副本分片（1 个完整的副本），每个索引共计 10 个分片。Shards &amp; Replicas（分片 &amp; 副本）<br />
索引可以存储大量数据，可以超过单个节点的硬件限制。例如，十亿个文档占用了 1TB 的磁盘空间的单个索引可能不适合放在单个节点的磁盘上，并且从单个节点服务请求会变得很慢。</p>
<p>为了解决这个问题，Elasticsearch 提供了把 Index（索引）拆分到多个 Shard（分片）中的能力。在创建索引时，您可以简单的定义 Shard（分片）的数量。每个 Shard 本身就是一个 fully-functional（全功能的）和独立的 “Index（索引）”，（Shard）它可以存储在集群中的任何节点上。</p>
<p>Sharding（分片）非常重要两个理由是 :</p>
<p>水平的拆分/扩展。<br />
分布式和并行跨 Shard 操作（可能在多个节点），从而提高了性能/吞吐量。<br />
Shard 的分布式机制以及它的文档是如何聚合支持搜索请求是完全由 Elasticsearch 管理的，并且是对用户透明的。</p>
<p>在 网络/云 环境中可能随时会故障，无论出于何种原因，在 shard/node 不知何故会离线或者消失的情况下强烈建议设置故障转移是非常有效的。为了达到这个目的，Elasticsearch 可以让您设置一个或多个索引的 Shard 副本到所谓的副本分片，或者副本中去。</p>
<p>副本非常重要的两个理由是 :</p>
<p>在 shard/node 故障的情况下提供了高可用性。为了达到这个目的，需要注意的是在原始的/主 Shard 被复制时副本的 Shard 不会被分配到相同的节点上。<br />
它可以让你水平扩展搜索量/吞吐量，因为搜索可以在所有的副本上并行执行。<br />
总而言之，每个索引可以被拆分成多个分片，一个索引可以设置 0 个（没有副本）或多个副本。开启副本后，每个索引将有主分片（被复制的原始分片）和副本分片（主分片的副本）。分片和副本的数量在索引被创建时都能够被指定。在创建索引后，您也可以在任何时候动态的改变副本的数量，但是不能够改变分片数量。</p>
<p>默认情况下，Elasticsearch 中的每个索引分配了 5 个主分片和 1 个副本，这也就意味着如果您的集群至少有两个节点的话，您的索引将会有 5 个主分片和另外 5 个副本分片（1 个完整的副本），每个索引共计 10 个分片。</p>
<p><a href="https://www.elastic.co/cn/blog/elasticsearch-caching-deep-dive-boosting-query-speed-one-cache-at-a-time">es 缓存</a></p>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
