<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    五、深入理解JVM---垃圾回收机制 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            五、深入理解JVM---垃圾回收机制   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/07/30</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>对java的垃圾回收机制来说，我们需要考虑3个问题</p>

<ol>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>

<p>引用计数算法</p>

<p>给对象添加一个引用计数器，当一个地方引用它，则计数器加1，引用失效，计数器减1，任何时候 计数器为0 的对象就是不可在此使用的对象。<br/>
它很难解决对象直减的相互循环引用的问题。  </p>

<pre><code class="language-text">
/**
 * 这个示例展示两个对象相互引用，程序计数器不会为0的，
 * 如果gc采用引用计数算法，这两个对象将不会得到回收。
 * 但实际情况是，这两个对象得到了回收，hospital jvm采用的不是引用计数垃圾回收算法。
 * -XX:+PrintGCDetails -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
 *
 * @author qinshengke
 * @since 2020/1/9
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }


    public static void main(String[] args) {
        testGC();
    }
}
垃圾回收结果
[GC (System.gc()) [PSYoungGen: 8028K-&gt;624K(76288K)] 8028K-&gt;632K(251392K), 0.0016257 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 624K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;418K(175104K)] 632K-&gt;418K(251392K), [Metaspace: 3153K-&gt;3153K(1056768K)], 0.0134161 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 76288K, used 1966K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)
  eden space 65536K, 3% used [0x000000076ab00000,0x000000076aceb9e0,0x000000076eb00000)
  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)
  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
 ParOldGen       total 175104K, used 418K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)
  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0068b30,0x00000006cab00000)
 Metaspace       used 3173K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 356K, capacity 388K, committed 512K, reserved 1048576K
</code></pre>

<p>根搜索算法 GC Roots Tracing <br/>
可作为GC Roots的对象包括下面几种：</p>

<ul>
<li>虚拟机栈(栈帧中的本地变量表)中的引用对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法中JNI引用的对象</li>
</ul>

<p>方法区主要回收两部分的内容： 废弃常量和无用类。<br/>
类回收需要满足如下3个条件：</p>

<ul>
<li>该类所有的实例都已经别GC,也就是JVM中不存在该Class的任何实例</li>
<li>加载该类的ClassLoader已经被GC</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法。</li>
</ul>

<p>常见的垃圾收集算法(gc)</p>

<ul>
<li>标记-清除算法 mark-sweep</li>
<li>标记整理算法 mark-compact</li>
<li>复制算法 copying</li>
<li>分代算法 generational</li>
</ul>

<p>年轻代</p>

<ul>
<li>新生成的对象都放在新生代，<strong>年轻代用复制算法进行gc</strong>(理论上，年轻代对象的生命周期非常短，是和复制算法)</li>
<li>年轻代分为3个区域，Eden区、from survivor、 to survivor，Eden区满的时候，还存活的对象将被复制到一个from survivor，当from survivor区域满了之后，依然存活的对象被移动到to survivor 区域，to survivor区域满了之后，依然存活的对象会被复制到老年代。</li>
<li>Eden和两个survivor的缺省比例是8:1:1</li>
</ul>

<p>老年代</p>

<ul>
<li>存放了经过一个或多次GC还存活的对象</li>
<li>一般采用Mark-Sweep或者Mark-Compact算法进行GC</li>
<li>有多种垃圾收集器可以选择。每种垃圾收集器可以看做一个GC算法的具体实现。可以根据具体应用的需求选用何时的垃圾收集器(追求吞吐量还是追求最短的湘阴那个时间？)</li>
</ul>

<p>大对象在内存中会直接分配到老年代上<br/>
原子类型的内存分批是分配在java虚拟机栈上</p>

<h2 id="toc_0">垃圾回收</h2>

<p>GC要做的是将那些死亡(没有被引用对象)的对象所占用的内存回收掉。在进行full gc的时候会对Reference类型的应用那个进行特殊处理。<br/>
无论是引用计数算法还是根搜索算法，都和对象的引用有关，那么我们看一下java中的引用概念，java将引用分为强引用、软引用、弱引用、虚引用四种</p>

<ul>
<li>强引用是通过new关键字创建的对象，只要存在强引用，则垃圾回收机制不能对此对象进行回收；</li>
<li>软引用是用来描述非必须对象的，它通过SoftReference类实现的，软引用在JVM将要发生内存溢出时或者长期没有被使用的会将此类引用纳入可回收的范围内进行回收</li>
<li>弱引用 也是藐视非必须对象的，它通过WeekReference类实现，但是它的地位要比软引用还要低，它存活于下一次垃圾回收之前，当下一次垃圾回收发生时，弱引用也会被回收掉。</li>
<li>虚引用，它是最弱的一种引用关系，一个对象是否有序引用的存在，完全不会影响其生存时间，一万五发通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望在这个对象被收集器回收时收到一个系统通知。</li>
</ul>

<p>在根算法中不可达的对象，这个对象至少要经历两次标记过程，算法得出对象不可达后，第一次标记并进行一次筛选(根据对象是否有必要执行finalize()</p>

<ul>
<li>如果对象没有覆写finalize()方法</li>
<li>finalize()方法已经被虚拟机调用过<br/>
以上两种情况被视为没有必要执行回收操作</li>
</ul>

<p>如果对象被判定有必要执行finalize()方法，那么这个对象会被放置在一个名为F-Queue的队列之中，稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。</p>

<p>年轻代的垃圾收集算法有 Serial、ParNew、Parallel Scavenge<br/>
老年代的垃圾收集算法有 CMS、Serial Old(MSC)、Parallel Old</p>

<p>[GC (Allocation Failure) [PSYoungGen: 2615K-&gt;663K(9216K)] 9783K-&gt;7839K(19456K), 0.0017269 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </p>

<p>(Allocation Failure)  gc触发原因<br/>
2615K: 新生代gc时存活的对象<br/>
663K： 新生代gc后存活的对象大小<br/>
9216K: 新生代中总大小</p>

<p>9783K: 堆中存活的对象大小<br/>
7839K:</p>

<h3 id="toc_1">GC的时机</h3>

<ul>
<li>在分代模型的基础上，GC从时机上分为两种: Scavenge GC和Full GC</li>
<li>Scavenge GC(Minor GC)
<ul>
<li>触发时机: 新对象生成时，Eden空间满了</li>
<li>理论上Eden区域大多数对象会在Scavenge GC 回收，复制算法的执行效率会非常高，Scavenge GC时间比较短。</li>
</ul></li>
<li>Full GC 
<ul>
<li>对整个JVM进行整理吗，包括Young、old和Perm/MetaSpace</li>
<li>主要的触发时机: <br/>
a) Old满了 <br/>
b) Perm/MetaSpace满了<br/>
c) System.gc()</li>
<li>效率低，尽量减少Full GC。</li>
</ul></li>
</ul>

<h4 id="toc_2">垃圾回收器</h4>

<h5 id="toc_3">Serial</h5>

<p>单线程收集器，收集时会暂停所有的工作线程</p>

<ul>
<li>最早的收集器，单线程执行</li>
<li>New和Old Generation都可以使用</li>
<li>在新生代采用复式算法；在老年代使用Mark-Compact算法</li>
<li>虚拟机运行在client模式时的默认新生代垃圾收集器。</li>
</ul>

<h5 id="toc_4">ParNew收集器</h5>

<ul>
<li>ParNew收集器是Serial收集器的多线程版本</li>
<li>虚拟机运行在Server模式的默认新生代收集器</li>
<li>通过-XX:ParallelGCThreads来控制GC线程数的多少</li>
</ul>

<h5 id="toc_5">Parallel Scavenge 收集器</h5>

<ul>
<li>多线程收集器</li>
<li>采用复制算法</li>
<li>实现以吞吐量最大化为目标(允许较长时间内的STOP THE WORLD)</li>
</ul>

<h5 id="toc_6">CMS (Concurrent mark sweep)</h5>

<ul>
<li>以最短停顿时间为目标的垃圾收集器</li>
<li>采用 标记-清除算法 mark-sweep</li>
</ul>

<p>缺点：</p>

<ul>
<li>以牺牲CPU资源为代价来提高gc吞吐量</li>
<li>会产生内存碎片，可能导致频繁的Full GC操作<br/>
##### Serial Old(MSC)、</li>
<li>采用Mark-compact算法</li>
</ul>

<h5 id="toc_7">Parallel Old</h5>

<ul>
<li>Parallel Scavenge 在老年代的实现</li>
<li>采用Mark-compact算法</li>
<li>更注重吞吐量</li>
</ul>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
