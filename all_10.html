<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  大爷来玩儿啊~
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.throne4j.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">博客</a></li>
        
        <li id=""><a target="_self" href="archives.html">归档</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 大爷来玩儿啊~</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">博客</a></li>
        
        <li><a target="_self" href="archives.html">归档</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html">JVM深入理解</a></li>
        
            <li><a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html">解决方案</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">数据结构</a></li>
        
            <li><a href="mybatis.html">mybatis</a></li>
        
            <li><a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html">构建工具</a></li>
        
            <li><a href="spring%E6%BA%90%E7%A0%81.html">spring源码</a></li>
        
            <li><a href="redis.html">redis</a></li>
        
            <li><a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">java并发编程</a></li>
        
            <li><a href="other.html">other</a></li>
        
            <li><a href="java.html">java</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="%E5%AE%B9%E5%99%A8.html">容器</a></li>
        
            <li><a href="mysql.html">mysql</a></li>
        
            <li><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15874857577712.html">
                
                  <h1>原子操作CAS 无锁操作</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15874857577712/15879543805684.jpg" alt=""/></figure></p>

<h2 id="toc_0">什么是原子操作?如何实现原子操作?</h2>

<p>假定有两个操作 A 和 B，如果从执行 A 的线程来看，当另一个线程执行 B 时， 要么将 B 全部执行完，要么B完全不执行，那么 A 和 B 对彼此来说是原子的。</p>

<p>实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是 有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制， synchronized 关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候， 访问同一资源的其它线程需要等待，直到该线程释放锁，</p>

<p>这里会有些问题: 首先，如果被阻塞的线程优先级很高很重要怎么办?其次， 如果获得锁的线程一直不释放锁怎么办?(这种情况是非常糟糕的)。还有一种 情况，如果有大量的线程来竞争资源，那 CPU 将会花费大量的时间和资源来处 理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p>

<p>实现原子操作还可以使用当前的处理器基本都支持 CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个 CAS 操作过程都包含三个运算符:一个内 存地址 V，一个期望的值 A 和一个新值 B，操作的时候如果这个地址上存放的值 等于这个期望的值 A，则将地址上的值赋为新值 B，否则不做任何操作。</p>

<p>CAS 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环 CAS 就是在一个循环里不断的做 cas 操作，直到成功为止。</p>

<p>CAS 是怎么实现线程的安全呢?语言层面不做处理，我们将其交给硬件— CPU 和内存，利用 CPU 的多处理能力，实现硬件层面的阻塞，再加上 volatile 变 量的特性即可实现基于原子操作的线程安全。</p>

<hr/>

<h2 id="toc_1">CAS 实现原子操作的三大问题</h2>

<ul>
<li>ABA问题</li>
</ul>

<p>因为 CAS 需要在操作值的时候，检查值有没有发生变化，如果没有发生变化 则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行 检查时会发现它的值没有发生变化，但是实际上却变化了。<br/>
ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量 更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A。举个通俗点的 例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新 倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关 心水还在，这就是 ABA 问题。<br/>
如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的 时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初 始值 0，别人喝水前麻烦先做个累加才能喝水。</p>

<ul>
<li>循环时间长开销大。</li>
</ul>

<p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>

<ul>
<li>只能保证一个共享变量的原子操作。</li>
</ul>

<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操 作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候 就可以用锁。<br/>
还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比 如，有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用 CAS 来操作 ij。从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把 多个变量放在一个对象里来进行 CAS 操作。</p>

<h2 id="toc_2">JDK中 java.util.concurrent.atomic 报下包装有原子操作类。</h2>

<ul>
<li><p>AtomicInteger</p>
<ul>
<li>int addAndGet(int delta):以原子方式将输入的数值与实例中的值(AtomicInteger 里的 value)相加，并返回结果。</li>
<li>boolean compareAndSet(int expect，int update):如果输入的数值等于预 期值，则以原子方式将该值设置为输入的值。</li>
<li>int getAndIncrement():以原子方式将当前值加 1，注意，这里返回的是自 增前的值。</li>
<li>int getAndSet(int newValue):以原子方式设置为 newValue 的值，并返回 旧值。</li>
</ul></li>
<li><p>原子更新基本类型的 AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic 包提供了以下 3 个类。</p>
<ul>
<li>AtomicReference 原子更新引用类型。</li>
<li>AtomicStampedReference <br/>
利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在 ABA 问题了。AtomicStampedReference 是使用 pair 的 int stamp 作为计数器使用。</li>
<li>AtomicMarkableReference<br/>
AtomicMarkableReference 跟 AtomicStampedReference 差不多， AtomicMarkableReference 的 pair 使用的是 boolean mark。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html'>java并发编程</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="java%E5%BA%8F%E5%88%97%E5%8C%96.html">
                
                  <h1>深入理解java序列化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>如果你只知道实现Serializable接口的对象，可以序列化为本地文件。那你最好再阅读该篇文章，文章对序列化进行了更深一步的讨论，用实际的例子代码讲述了序列化的高级认识，包括父类序列化的问题、静态变量问题、transient关键字的影响、序列化ID问题。在笔者实际开发过程中，就多次遇到序列化的问题，在该文章中也会与读者分享。</p>

<h2 id="toc_0">引言</h2>

<p>将Java对象序列化为二进制文件的Java序列化技术是Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现Serializable接口，使用ObjectInputStream和ObjectOutputStream进行对象的读写。然而在有些情况下，光知道这些还远远不够，文章列举了笔者遇到的一些真实情境，它们与Java序列化相关，通过分析情境出现的原因，使读者轻松牢记<br/>
Java 序列化中的一些高级认识。</p>

<h2 id="toc_1">序列化 ID 问题</h2>

<ul>
<li><p><strong>情境</strong>：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C序列化为二进制数据再传给 B，B 反序列化得到 C。</p></li>
<li><p><strong>问题</strong>：C 对象的全类路径假设为 com.inout.Test，在 A 和 B端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable接口，但是反序列化时总是提示不成功。</p></li>
<li><p><strong>解决</strong>：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p></li>
</ul>

<pre><code class="language-text">package com.inout; 
import java.io.Serializable; 
public class A implements Serializable { 

    private static final long serialVersionUID = 1L; 
    private String name; public String getName() { return name; }

    public void setName(String name) {
        this.name = name;
    }
}

package com.inout;
import java.io.Serializable;
public class A implements Serializable {
    private static final long serialVersionUID = 2L;
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
} 
</code></pre>

<p>序列化ID在Eclipse下提供了两种生成策略，一个是固定的1L，一个是随机生成一个不重复的long类型数据（实际上是使用JDK工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的1L就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化ID可以用来限制某些用户的使用。</p>

<h3 id="toc_2">特性使用案例</h3>

<p>　　读者应该听过Façade模式，它是为应用程序提供统一的访问接口，案例程序中的Client客户端使用了该模式，案例程序结构图如图1所示。<br/>
<figure><img src="media/15865876286788/image.png" alt="image"/><figcaption>image</figcaption></figure></p>

<p>　　Client端通过FaçadeObject才可以与业务逻辑对象进行交互。而客户端的FaçadeObject不能直接由Client生成，而是需要Server端生成，然后序列化后通过网络将二进制对象数据传给Client，Client负责反序列化得到Façade对象。该模式可以使得Client端程序的使用需要服务器端的许可,同时Client端和服务器端的FaçadeObject类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的FaçadeObject类的序列化ID再次生成，当Client端反序列化FaçadeObject就会失败，也就是强制Client端从服务器端获取最新程序。</p>

<h2 id="toc_3">静态变量序列化</h2>

<ul>
<li><strong>情境</strong>：查看清单 2 的代码。</li>
</ul>

<p>清单 2. 静态变量序列化问题代码</p>

<pre><code class="language-text">public class Test implements Serializable {
    private static final long serialVersionUID = 1L;
    public static int staticVar = 5;
    public static void main(String[] args) {
        try {
            //初始时staticVar为5
            ObjectOutputStream out = new ObjectOutputStream(
                    new FileOutputStream(&quot;result.obj&quot;));
            out.writeObject(new Test());
            out.close();

            //序列化后修改为10
            Test.staticVar = 10;
 
            ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
            Test t = (Test) oin.readObject();
            oin.close();
             
            //再读取，通过t.staticVar打印新的值
            System.out.println(t.staticVar);
             
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>　　清单2中的main方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单2，这个System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？最后的输出是10，对于无法理解的读者认为，打印的 staticVar是从读取的对象里获得的，应该是保存时的状态才对。之所以打印10的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此序列化并不保存静态变量。</p>

<h2 id="toc_4">父类的序列化与 Transient 关键字</h2>

<ul>
<li><p><strong>情境</strong>：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p></li>
<li><p><strong>解决</strong>：要想将父类对象也序列化，就需要让父类也实现Serializable接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p></li>
</ul>

<p>　　Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int 型的是 0，对象型的是 null。</p>

<h3 id="toc_5">特性使用案例</h3>

<p>　　我们熟悉使用Transient关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现Serializable接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</p>

<p><figure><img src="media/15865876286788/%E6%A1%88%E4%BE%8B%E7%A8%8B%E5%BA%8F%E5%9B%BE.png" alt="案例程序图"/><figcaption>案例程序图</figcaption></figure></p>

<p>　　上图中可以看出，attr1、attr2、attr3、attr5都不会被序列化，放在父类中的好处在于当有另外一个Child类时，attr1、attr2、attr3依然不会被序列化，不用重复抒写transient，代码简洁。</p>

<h2 id="toc_6">对敏感字段加密</h2>

<ul>
<li><strong>情境</strong>：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
<li><strong>解决</strong>：在序列化过程中，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单3展示了这个过程。</li>
</ul>

<pre><code class="language-text">private static final long serialVersionUID = 1L;
private String password = &quot;pass&quot;;
public String getPassword() {
    return password;
}
public void setPassword(String password) {
    this.password = password;
}

private void writeObject(ObjectOutputStream out) {
    try {
        PutField putFields = out.putFields();
        System.out.println(&quot;原密码:&quot; + password);
        password = &quot;encryption&quot;;//模拟加密
        putFields.put(&quot;password&quot;, password);
        System.out.println(&quot;加密后的密码&quot; + password);
        out.writeFields();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void readObject(ObjectInputStream in) {
    try {
        GetField readFields = in.readFields();
        Object object = readFields.get(&quot;password&quot;, &quot;&quot;);
        System.out.println(&quot;要解密的字符串:&quot; + object.toString());
        password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    try {
        ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream(&quot;result.obj&quot;));
        out.writeObject(new Test());
        out.close();

        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                &quot;result.obj&quot;));
        Test t = (Test) oin.readObject();
        System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());
        oin.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}  
</code></pre>

<p>在清单 3 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对<br/>
password进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。执行清单<br/>
3后控制台输出如图 3 所示:</p>

<p><figure><img src="/qsk/java/understand_java_serial/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/><figcaption>数据加密演示</figcaption></figure><figure><img src="media/15865876286788/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%BC%94%E7%A4%BA.png" alt="数据加密演示"/><figcaption>数据加密演示</figcaption></figure></p>

<h3 id="toc_7">特性使用案例</h3>

<p>　　RMI 技术是完全基于 Java序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及RMI的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>

<h3 id="toc_8">序列化存储规则</h3>

<pre><code class="language-text">ObjectOutputStream out = new ObjectOutputStream(
                   new FileOutputStream(&quot;result.obj&quot;));
   Test test = new Test();
   //试图将对象两次写入文件
   out.writeObject(test);
   out.flush();
   System.out.println(new File(&quot;result.obj&quot;).length());
   out.writeObject(test);
   out.close();
   System.out.println(new File(&quot;result.obj&quot;).length());

   ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
           &quot;result.obj&quot;));
   //从文件依次读出两个文件
   Test t1 = (Test) oin.readObject();
   Test t2 = (Test) oin.readObject();
   oin.close();

   //判断两个引用是否指向同一个对象
   System.out.println(t1 == t2);
</code></pre>

<p>　　清单 3中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入false 才对，但是最后结果输出如图 4 所示。</p>

<p><figure><img src="/qsk/java/understand_java_serial/image.png" alt="image"/><figcaption>image</figcaption></figure><figure><img src="media/15865876286788/image.png" alt="image"/><figcaption>image</figcaption></figure></p>

<p>　　我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？</p>

<ul>
<li><strong>解答</strong>：Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</li>
</ul>

<h3 id="toc_9">特性案例分析</h3>

<pre><code class="language-text">
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));
Test test = new Test();
test.i = 1;
out.writeObject(test);
out.flush();
test.i = 2;
out.writeObject(test);
out.close();
ObjectInputStream oin = new ObjectInputStream(new FileInputStream(
                    &quot;result.obj&quot;));
Test t1 = (Test) oin.readObject();
Test t2 = (Test) oin.readObject();
System.out.println(t1.i);
System.out.println(t2.i);
</code></pre>

<p>　　清单 4 的目的是希望将 test 对象两次保存到result.obj文件中，写入一次以后修改对象属性值再次保存第二次，然后从result.obj中再依次读出两个对象，输出这两个对象的i属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。结果两个输出的都是 1，原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次writeObject 需要特别注意这个问题。</p>

<h2 id="toc_10">小结</h2>

<p>本文通过几个具体的情景，介绍了Java序列化的一些高级知识，虽说高级，并不是说读者们都不了解，希望用笔者介绍的情景让读者加深印象，能够更加合理的利用Java序列化技术，在未来开发之路上遇到序列化问题时，可以及时的解决。由于本人知识水平有限，文章中倘若有错误的地方，欢迎联系我批评指正。</p>

<h1 id="toc_11">转载自  <a href="https://www.cnblogs.com/wxgblogs/p/5849951.html">读书使人进步</a></h1>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/04/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='java.html'>java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15855754851859.html">
                
                  <h1>Dockerfile</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">FROM 指定基础镜像</h2>

<h2 id="toc_1">RUN</h2>

<ul>
<li><p>shell 格式：<br/>
RUN &lt;命令行命令&gt;<br/>
&lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</p></li>
<li><p>exec 格式： RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]<br/>
例如： RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</p></li>
</ul>

<h2 id="toc_2">CMD 执行命令</h2>

<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p>

<ul>
<li>CMD 在docker run 时运行。</li>
<li>RUN 是在 docker build。<br/>
作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</li>
</ul>

<p>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p>

<p>格式：</p>

<pre><code class="language-text">CMD &lt;shell 命令&gt; 
CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] 
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供
默认参数
</code></pre>

<p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh</p>

<h2 id="toc_3">ADD 复制指定的文件到容器中（压缩包会自动解压）</h2>

<h2 id="toc_4">COPY 复制</h2>

<p>复制指令，同 ADD 从上下文目录中复制文件或者目录到容器里指定路径。<br/>
格式：</p>

<pre><code class="language-text">COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;
COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]
</code></pre>

<p>[--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>

<p>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p>

<pre><code class="language-text">COPY hom* /mydir/
COPY hom?.txt /mydir/
</code></pre>

<h2 id="toc_5">WORKDIR 指定工作空间</h2>

<p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p>

<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p>

<h2 id="toc_6">VOLUME 为容器创建一个本地主机或其他容器的挂载点</h2>

<h2 id="toc_7">EXPOSE 容器需要暴露的端口</h2>

<h2 id="toc_8">USER 指定运行容器时的用户名，后续的 RUN 也会指定该用户</h2>

<h2 id="toc_9">ENTRYPOINT</h2>

<p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p>

<p>但是, 如果运行 docker run 时使用了 --entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p>

<p>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>

<p>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>

<p>格式：</p>

<p>ENTRYPOINT [&quot;<executeable>&quot;,&quot;<param1>&quot;,&quot;<param2>&quot;,...]<br/>
可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p>

<p>示例：</p>

<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>

<p>FROM nginx</p>

<p>ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参<br/>
CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 <br/>
1、不传参运行</p>

<p>$ docker run  nginx:test<br/>
容器内会默认运行以下命令，启动主进程。</p>

<p>nginx -c /etc/nginx/nginx.conf<br/>
2、传参运行</p>

<p>$ docker run  nginx:test -c /etc/nginx/new.conf<br/>
容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>

<p>nginx -c /etc/nginx/new.conf</p>

<h2 id="toc_10">ENV 环境变量</h2>

<p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>

<p>格式：</p>

<p>ENV <key> <value><br/>
ENV <key1>=<value1> <key2>=<value2>...<br/>
以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>

<p>ENV NODE_VERSION 7.2.0</p>

<p>RUN curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz</a>&quot; \<br/>
  &amp;&amp; curl -SLO &quot;<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc</a>&quot;</p>

<h2 id="toc_11">MAINTAINER 维护者信息</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%AE%B9%E5%99%A8.html'>容器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="sudo%E5%85%8D%E5%AF%86%E6%89%A7%E8%A1%8C.html">
                
                  <h1>linux 普通用户添加 sudo 免密码执行权限</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在使用普通用户登录的时候，会经常使用sudo指令执行一些操作，有时候感觉输入密码比较繁琐，特别是需要设置一些开机启动的时候操作，而这些操作往往就需要sudo指令，如果没有免密的话，在使用普通用户登录的时候就无法执行，这个时候给普通用户添加免密码sudo功能就非常的必要了  </p>

<p>注意：sudo面密码只是在执行sudo指令的时候不需要输入密码，并不是普通用户拥有超级用户的权限，需要root才有的权限不加sudo 一样执行不了 ，所以这一点也保证了使用免密码的安全性 ，只是在使用sudo的时候不需要输入密码</p>

<p>很简单，在命令行输入：</p>

<p>sudo vim /etc/sudoers  </p>

<p>在代码的最后加上：</p>

<p>yourusername   ALL=(ALL)NOPASSWD:ALL      </p>

<p>username是指定的普通用户名称，这样就是保证在指定用户使用sudo的时候不需要输入密码，如果想给执行命令添加免密而已，只需要把最后的ALL替换为命令的绝对路径即可，</p>

<p>如下：</p>

<p>username   ALL=(ALL)NOPASSWD:/bin/hello</p>

<p>这样就为指定用户在执行/bin目录下的hello目录的时候 不需输入密码</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15855064473314.html">
                
                  <h1>docker 命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">容器生命周期管理</h2>

<ul>
<li>run  创建一个新的容器并运行一个命令</li>
</ul>

<p>eg: docker run -d --name nginx -p 80:80 -v /docker/nginx:/etc/nginx/conf.d nginx:latest </p>

<p>说明： 使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/docker/nginx/conf.d 映射到容器的 /etc/nginx/conf.d</p>

<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</p>

<pre><code class="language-text">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-P: 随机端口映射，容器内部端口随机映射到主机的高端口
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h &quot;mars&quot;: 指定容器的hostname；
-e username=&quot;ritchie&quot;: 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；
--volume , -v: 绑定一个卷
</code></pre>

<p>注意： 关于容器的输出以及配置的文件一定要挂载到宿主机上<br/>
配置文件<br/>
日志文件<br/>
业务数据</p>

<p>数据卷容器：<br/>
创建数据卷容器 data<br/>
docker run -d --name data -v /home/godson/docker/nginx/conf.d:/etc/nginx/conf.d -v /home/godson/docker/mysql/conf:/etc/mysql hello-world</p>

<p>创建容器挂载到 data 容器数据卷上 (volumes-from参数)<br/>
docker run -d --name nginx -p 80:80 --volumes-from data nginx</p>

<ul>
<li>start/stop/restart</li>
</ul>

<pre><code class="language-text">start： 启动一个或多个已被停止的容器
stop： 停止一个或多个运行中的容器
restart: 重启一个或多个容器
</code></pre>

<ul>
<li><p>kill 杀掉一个运行中的容器</p></li>
<li><p>rm 删除一个或多个容器</p></li>
</ul>

<pre><code class="language-text">-f :通过SIGKILL信号强制删除一个运行中的容器
-l :移除容器间的网络连接，而非容器本身
-v :-v 删除与容器关联的卷
</code></pre>

<ul>
<li><p>docker rm -fv 删除容器服务</p></li>
<li><p>pause/unpause  暂停/恢复 容器中的所有进程</p></li>
<li><p>create 创建一个新容器，但是不启动它<br/>
语法同 run</p></li>
<li><p>exec</p></li>
</ul>

<pre><code class="language-text">&gt; docker exec -it nginx /bin/bash
-d :分离模式: 在后台运行
-i :即使没有附加也保持STDIN 打开
-t :分配一个伪终端
</code></pre>

<h2 id="toc_1">容器操作</h2>

<ul>
<li>ps  列出容器</li>
</ul>

<pre><code class="language-text">-a :显示所有的容器，包括未运行的。
-f :根据条件过滤显示的内容。
--format :指定返回值的模板文件。
-l :显示最近创建的容器。
-n :列出最近创建的n个容器。
--no-trunc :不截断输出。
-q :静默模式，只显示容器编号。
-s :显示总的文件大小。
</code></pre>

<ul>
<li>inspect 获取容器/镜像的元数据。<br/>
docker inspect -f &#39;{{.NetworkSettings.IPAddress}}&#39; nginx</li>
</ul>

<pre><code class="language-text">-f :指定返回值的模板文件。
-s :显示总的文件大小。
--type :为指定类型返回JSON。
</code></pre>

<ul>
<li>top</li>
<li>attach</li>
<li>events</li>
<li>logs</li>
</ul>

<pre><code class="language-text">-f : 跟踪日志输出
--since :显示某个开始时间的所有日志
-t : 显示时间戳
--tail :仅列出最新N条容器日志
</code></pre>

<ul>
<li>wait</li>
<li>export</li>
<li>port  列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</li>
</ul>

<pre><code class="language-text">&gt; docker port nginx
80/tcp -&gt; 0.0.0.0:8080
</code></pre>

<h2 id="toc_2">容器rootfs命令</h2>

<ul>
<li>commit  从容器创建一个新的镜像。<br/>
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br/>
docker commit -a &quot;作者&quot; -m &quot;描述&quot; nginx  mynginx:v1</li>
<li>cp<br/>
容器和宿主机的文件传输 nginx:表示了容器目录<br/>
docker cp nginx:/etc/nginx/conf.ddefault.conf ./</li>
<li>diff</li>
</ul>

<h2 id="toc_3">镜像仓库</h2>

<ul>
<li>login</li>
<li>pull</li>
<li>push</li>
<li>search</li>
</ul>

<h2 id="toc_4">本地镜像管理</h2>

<ul>
<li>images  列出本地镜像。</li>
</ul>

<pre><code class="language-text">-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；
--digests :显示镜像的摘要信息；
-f :显示满足条件的镜像；
--format :指定返回值的模板文件；
--no-trunc :显示完整的镜像信息；
-q :只显示镜像ID。
</code></pre>

<ul>
<li>rmi</li>
<li>tag  标记本地镜像，将其归入某一仓库。</li>
</ul>

<pre><code class="language-text">docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]

将镜像ubuntu:15.10标记为 w3cschool/ubuntu:v3 镜像

docker tag nginx w3cschool/ubuntu:v3
</code></pre>

<ul>
<li>build   使用Dockerfile创建镜像。</li>
</ul>

<pre><code class="language-text">&gt; docker build -t w3cschool/ubuntu:v1 ./
&gt; docker build -f /home/user/Dockerfile ./

--build-arg=[] :设置镜像创建时的变量；
--cpu-shares :设置 cpu 使用权重；
--cpu-period :限制 CPU CFS周期；
--cpu-quota :限制 CPU CFS配额；
--cpuset-cpus :指定使用的CPU id；
--cpuset-mems :指定使用的内存 id；
--disable-content-trust :忽略校验，默认开启；
-f :指定要使用的Dockerfile路径； -f /path/to/a/Dockerfile .
--force-rm :设置镜像过程中删除中间容器；
--isolation :使用容器隔离技术；
--label=[] :设置镜像使用的元数据；
-m :设置内存最大值；
--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；
--no-cache :创建镜像的过程不使用缓存；
--pull :尝试去更新镜像的新版本；
-q :安静模式，成功后只输出镜像ID；
--rm :设置镜像成功后删除中间容器；
--shm-size :设置/dev/shm的大小，默认值是64M；
--ulimit :Ulimit配置。
--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。
--network: 默认 default。在构建期间设置RUN指令的网络模式
</code></pre>

<p>history<br/>
save<br/>
import</p>

<h2 id="toc_5">info|version</h2>

<p>info<br/>
version</p>

<p>获取 selinux 是否关闭<br/>
getenforce<br/>
暂时关闭<br/>
setenforce 1</p>

<p>vi /etc/sysconfig/selinux</p>

<p><figure><img src="media/15855064473314/15855732599905.jpg" alt="" style="width:620px;"/></figure></p>

<p>SELINUX=disable</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%AE%B9%E5%99%A8.html'>容器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_9.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_11.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/15865826719099/avatar.png" /></div>
            
                <h1>大爷来玩儿啊~</h1>
                <div class="site-des">只要干不死就往死里干</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html"><strong>JVM深入理解</strong></a>
        
            <a href="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"><strong>解决方案</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><strong>数据结构</strong></a>
        
            <a href="mybatis.html"><strong>mybatis</strong></a>
        
            <a href="%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html"><strong>构建工具</strong></a>
        
            <a href="spring%E6%BA%90%E7%A0%81.html"><strong>spring源码</strong></a>
        
            <a href="redis.html"><strong>redis</strong></a>
        
            <a href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"><strong>java并发编程</strong></a>
        
            <a href="other.html"><strong>other</strong></a>
        
            <a href="java.html"><strong>java</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="%E5%AE%B9%E5%99%A8.html"><strong>容器</strong></a>
        
            <a href="mysql.html"><strong>mysql</strong></a>
        
            <a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><strong>设计模式</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15949034079714.html">虚拟机栈</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15948275035029.html">十一、哨兵与集群</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15945438416733.html">十、主从复制</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943917797824.html">九、Redis 持久化--AOF（二）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15943756601312.html">软件设计上的基本知识</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
