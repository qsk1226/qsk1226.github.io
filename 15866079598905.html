<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    三、JVM自动内存管理--垃圾收集 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            三、JVM自动内存管理--垃圾收集   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/04/11</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_jvm.html'>#jvm</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>GC- Garbage Collection 垃圾回收，在 JVM 中是自动化的垃圾回收机制，我们一般不用去关注，在 JVM 中 GC 的重要区域是堆空间。</p>

<p>我们也可以通过一些额外方式主动发起它，比如 System.gc(),主动发起,但是项目中切记不要使用 System.gc()。</p>

<h2 id="toc_0">1、如何识别垃圾对象</h2>

<p>既然是要回收内存中的垃圾，那么怎么判断一个对象变成垃圾了呢？</p>

<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>

<h3 id="toc_1">1.1、引用计数算法</h3>

<p>给对象添加一个引用计数器，当一个地方引用它，则计数器加1，引用失效，计数器减1，任何时候 计数器为0 的对象就是不可在此使用的对象。<br/>
它很难解决对象直减的相互循环引用的问题。  </p>

<pre><code class="language-java">/**
 * 这个示例展示两个对象相互引用，程序计数器不会为0的，
 * 如果gc采用引用计数算法，这两个对象将不会得到回收。
 * 但实际情况是，这两个对象得到了回收，hospital jvm采用的不是引用计数垃圾回收算法。
 * -XX:+PrintGCDetails -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
 *
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }

    public static void main(String[] args) {
        testGC();
    }
}
垃圾回收结果
[GC (System.gc()) [PSYoungGen: 8028K-&gt;624K(76288K)] 8028K-&gt;632K(251392K), 0.0016257 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 624K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;418K(175104K)] 632K-&gt;418K(251392K), [Metaspace: 3153K-&gt;3153K(1056768K)], 0.0134161 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 76288K, used 1966K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)
  eden space 65536K, 3% used [0x000000076ab00000,0x000000076aceb9e0,0x000000076eb00000)
  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)
  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)
 ParOldGen       total 175104K, used 418K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)
  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0068b30,0x00000006cab00000)
 Metaspace       used 3173K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 356K, capacity 388K, committed 512K, reserved 1048576K
</code></pre>

<h3 id="toc_2">1.2、可达性算法</h3>

<p>可达性算法是通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>

<p>可作为GC Roots的对象包括下面几种：</p>

<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>

<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p>

<h2 id="toc_3">2、JVM 对象的四大引用</h2>

<p>java引用分为强引用、软引用、弱引用，虚引用四种。</p>

<ul>
<li>强引用是程序代码中最普遍一种引用，只要强引用关系存在，垃圾收集器永远不会回收调被引用的对象。</li>
<li>软引用（SoftReference）描述的是一些还有用，但非必须的对象，只被软引用关联着的对象，在系统发生内存溢出异常前，会把这些对象列进回收范围进行回收。 <a href="15866239860150.html">软引用（SoftReference）实现内存敏感的高速缓存</a></li>
<li>弱引用（WeakReference）描述非必须对象，对象的重要性比软引用更加低，被弱引用关联的对象，下一次垃圾收集发生的时候，就会被回收掉。</li>
<li>虚引用（PhantomReference）基本没什么用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>

<h2 id="toc_4">3、方法区的回收</h2>

<p>方法区并不是垃圾回收的主要区域，但是方法区也可以回收以下两部分的内容： 废弃常量和无用类。</p>

<p>类回收需要满足如下3个条件：</p>

<ul>
<li>该类所有的实例都已经被GC,也就是JVM中不存在该Class的任何实例</li>
<li>加载该类的ClassLoader已经被GC</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，不能在任何地方通过反射访问该类的方法。</li>
</ul>

<h2 id="toc_5">4、垃圾收集算法</h2>

<p>常见的垃圾收集算法有</p>

<ul>
<li>标记-清除算法 mark-sweep</li>
<li>标记整理算法 mark-compact</li>
<li>复制算法 copying</li>
<li>分代算法 generational</li>
</ul>

<h3 id="toc_6">4.1、 标记清除算法</h3>

<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>

<p>过程:</p>

<ul>
<li>首先标记所有需要回收的对象</li>
<li>统一回收被标记的对象<br/>
缺点:<br/>
1.效率问题，标记和清除效率都不高 2.标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不 提前触发另一次垃圾收集动作。</li>
</ul>

<p><figure><img src="media/15866079598905/15961870545090.jpg" alt="标记清除算法示意图"/><figcaption>标记清除算法示意图</figcaption></figure></p>

<h3 id="toc_7">4.2、标记整理算法</h3>

<p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端<br/>
边界以外的内存</p>

<p><figure><img src="media/15866079598905/15961895612170.jpg" alt=""/></figure></p>

<h3 id="toc_8">4.3、复制算法</h3>

<p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>

<p>在大部分对象需要回收的情况下这种方式的效率非常高，但是对于大部分对象存活的情况，效率就大打折扣了，另外内存空间浪费严重。</p>

<p><figure><img src="media/15866079598905/15961872702735.jpg" alt="复制算法示意图"/><figcaption>复制算法示意图</figcaption></figure></p>

<h3 id="toc_9">4.4、堆内存采用的垃圾收集算法</h3>

<h4 id="toc_10">4.4.1、新生代采用算法</h4>

<ul>
<li>新生成的对象都放在新生代，<strong>新生代用复制算法进行gc</strong>(理论上，年轻代对象的生命周期非常短，是复制算法)</li>
<li>年轻代分为3个区域，Eden区、from survivor、 to survivor，Eden区满的时候，还存活的对象将被复制到一个from survivor，当from survivor区域满了之后，依然存活的对象被移动到to survivor 区域，to survivor区域满了之后，依然存活的对象会被复制到老年代。</li>
<li>Eden和两个survivor的缺省比例是8:1:1</li>
</ul>

<p>新生代的垃圾回收被称为 minor gc 或者 young gc ，发生的频率高、执行速度快。</p>

<p>新生代中的对象 90% 是“朝生夕死”的，所以一般来说回收占据 10%的空间够用了，所以并不需要按照 1:1 的比例来划分内存空间，而是 将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor[1]。当回收时，将 Eden 和 Survivor 中还存活着的对象一 次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。</p>

<h4 id="toc_11">4.4.2、老年代采用算法</h4>

<ul>
<li>一般采用Mark-Sweep或者Mark-Compact算法进行GC</li>
<li>存放了经过一个或多次GC还存活的对象</li>
<li>有多种垃圾收集器可以选择。每种垃圾收集器可以看做一个GC算法的具体实现。</li>
</ul>

<p>可以根据具体应用的需求选用何时的垃圾收集器(追求吞吐量还是追求最短的湘阴那个时间？)</p>

<h2 id="toc_12">5、垃圾收集器</h2>

<h3 id="toc_13">5.1、GC的时机</h3>

<ul>
<li>在分代模型的基础上，GC从时机上分为两种: Scavenge GC 和 Full GC</li>
<li>Scavenge GC(Minor GC)
<ul>
<li>触发时机: 新对象生成时，Eden空间满了</li>
<li>理论上Eden区域大多数对象会在Scavenge GC 回收，复制算法的执行效率会非常高，Scavenge GC时间比较短。</li>
</ul></li>
<li>Full GC 
<ul>
<li>对整个JVM进行整理吗，包括Young、old和Perm/MetaSpace</li>
<li>主要的触发时机: <br/>
a) Old满了 <br/>
b) Perm/MetaSpace满了<br/>
c) System.gc()</li>
<li>效率低，尽量减少Full GC。</li>
</ul></li>
</ul>

<h4 id="toc_14">安全点</h4>

<p>程序的代码指令流并不是在任意位置都能停顿下来开始垃圾收集，而是强制要求必须执行到达指定的位置才能够暂停下来进行垃圾回收，这个指定位置被称为 安全点。</p>

<p>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>

<p>另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。</p>

<p>这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（V oluntary Suspension），抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</p>

<p>而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p>

<h4 id="toc_15">安全区域</h4>

<h3 id="toc_16">5.2、垃圾回收器</h3>

<p><figure><img src="media/15866079598905/15961903062948.jpg" alt="" style="width:727px;"/></figure></p>

<p>年轻代的垃圾收集算法有 Serial、ParNew、Parallel Scavenge<br/>
老年代的垃圾收集算法有 CMS、Serial Old(MSC)、Parallel Old</p>

<h5 id="toc_17">Serial</h5>

<p>单线程收集器，收集时会暂停所有的工作线程</p>

<ul>
<li>最早的收集器，单线程执行</li>
<li>New和Old Generation都可以使用</li>
<li>在新生代采用复式算法；在老年代使用Mark-Compact算法</li>
<li>虚拟机运行在client模式时的默认新生代垃圾收集器。</li>
</ul>

<h5 id="toc_18">ParNew收集器</h5>

<ul>
<li>ParNew收集器是Serial收集器的多线程版本</li>
<li>虚拟机运行在Server模式的默认新生代收集器</li>
<li>通过-XX:ParallelGCThreads来控制GC线程数的多少</li>
</ul>

<h5 id="toc_19">Parallel Scavenge 收集器</h5>

<ul>
<li>多线程收集器</li>
<li>采用复制算法</li>
<li>实现以吞吐量最大化为目标(允许较长时间内的STOP THE WORLD)</li>
</ul>

<h5 id="toc_20">CMS (Concurrent mark sweep)</h5>

<ul>
<li>以最短停顿时间为目标的垃圾收集器</li>
<li>采用 标记-清除算法 mark-sweep</li>
</ul>

<p>缺点：</p>

<ul>
<li>以牺牲CPU资源为代价来提高gc吞吐量</li>
<li>会产生内存碎片，可能导致频繁的Full GC操作<br/>
##### Serial Old(MSC)、</li>
<li>采用Mark-compact算法</li>
</ul>

<h5 id="toc_21">Parallel Old</h5>

<ul>
<li>Parallel Scavenge 在老年代的实现</li>
<li>采用Mark-compact算法</li>
<li>更注重吞吐量</li>
</ul>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
