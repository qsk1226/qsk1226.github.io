<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
    三、JVM自动内存管理 - 大爷来玩儿啊~
    
    </title>
    <link rel="shortcut icon" href="media/15865826719099/icon.png" type="image/png" />

    
    
    <link href="atom.xml" rel="alternate" title="大爷来玩儿啊~" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <script src="asset/app.js"></script>
</head>
  <body>
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="_self" class="navbar-item " href="index.html">博客</a>
                
                <a target="_self" class="navbar-item " href="archives.html">归档</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                        
                        
                        
                        
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                          <span class="icon is-large has-text-black-bis">
                              <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                          </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
    </section>
    <section class="ct-body">
      <div class="container">
          <div class="columns is-variable bd-klmn-columns is-4 is-centered">
              <div class="column is-four-fifths">
                  <div class="post-body single-content">
                    
                    <h1 class="title">
                            三、JVM自动内存管理   
                      </h1>
                     
                    
                      <div class="media">
                            
                            <figure class="media-left">
                              <p class="image is-48x48">
                                
                                  <img class="is-rounded" src="media/15865826719099/avatar.png">
                                
                              </p>
                            </figure>
                            
                            <div class="media-content">
                              <div class="content">
                                <p>
                                 <span class="date">2020/04/11</span>
                                  <span class="tran-posted-in">posted in</span>&nbsp; 
                                  
                                      <span class="posted-in"><a href='JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html'>JVM深入理解</a></span>
                                         
                                  

                                   
                                      
                                  <br />
                                  <span class="tran-tags">Tags:</span>&nbsp;
                                  
                                    <a class="tag is-link is-light" href='tag_jvm.html'>#jvm</a>
                                     

                                </p>
                              </div>
                            </div>
                         
                    </div>
                </div>
                  <article class="markdown-body single-content">
                    <p>java 技术体系的自动内存管理的最根本的目标就是要自动化的解决两个问题：</p>

<ul>
<li>自动给对象分配内存</li>
<li>自动回收分配给对象的内存</li>
</ul>

<p>我们在进行java开发的过程中，我们根本不用去为每一个对象申请以及释放内存空间，这是是由于JVM帮我们完成了对象的内存管理，如果我们不了解JVM是怎么使用内存的，一旦发生内存泄漏或者溢出方面的问题，那只能火急火燎的找大牛过来帮忙处理了。</p>

<h2 id="toc_0">运行时数据区域</h2>

<p>JVM在运行过程中，会把内存分为多个不同的数据区，他们各有各的用途，我们通过下图看下JVM是如何对内存结构进行划分的：<br/>
<figure><img src="media/15866079598905/15866802670837.jpg" alt="" style="width:1082px;"/></figure></p>

<h2 id="toc_1">程序计数器</h2>

<p>字节码解释器工作室就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，他是程序控制流的指示器(分支、循环、跳转、异常处理、线程回复等基础功能都需要程序计数器)。<br/>
由于jvm多线程是通过线程轮流切、分配处理器执行时间(cpu时间片轮转机制)来实现，因此为了线程在切换后能恢复到正确的执行位置，每条线程需要一个独立的程序计数器，各条线程的程序计数器互不影响，独立存储，因此<strong>程序计数器是线程私有的</strong>。此块区域也是唯一一个没有OOM的内存区。</p>

<h2 id="toc_2">java虚拟机栈</h2>

<ul>
<li><p>栈分为3个部分：基本数据类型的变量区、执行环境上下文、操作指令区(存放操作指令)。</p></li>
<li><p>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</p></li>
<li><p>每个线程包含一个栈区，栈中只保存基本数据类型的数据和自定义对象的引用(不是对象的实例)，对象实例都存放在堆区中</p></li>
</ul>

<p>JVM栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，JVM都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>

<ul>
<li>栈帧<br/>
一个线程中，每调用一个方法就创建一个栈帧（stack frame），方法结束栈帧销毁
<ul>
<li>局部变量表 <br/>
存放了编译期可知的各种java虚拟机基本数据类型、对象引用(方法参数、局部变量等)和returnAddress类型(指向了一条字节码指令的地址)，这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，局部变量表的容量以变量槽（Variable Slot）为最小单位。<br/>
其中64位的double和long类型的数据会占用2个局部变量空间(slot),其他基本数据类型只占用1个。局部变量空间所需的内存空间在编译期间完成分配。</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法出口</li>
</ul></li>
</ul>

<p>java虚拟机规范允许虚拟机自行选择是否支持栈的动态扩容，但Hotspot选择不支持扩容。所以除非在创建线程申请内存时，因无法获取足够内存而出现OOM异常。<br/>
OutOfMemoryError：</p>

<pre><code class="language-java">/**
 * jvm栈OOM(此操作可能拖垮cpu，请谨慎执行)
 * -Xss256k
 **/
public class StackOOMErrorMock {
    public static void main(String[] args) {
        for (int i = 0; ; i++) {
            new Thread(()-&gt;{
                while (true) {

                }
            }).start();
        }
    }
}
</code></pre>

<p>StackOverFlowError：</p>

<pre><code class="language-java">/**
 * StackOverFlowError
 * -Xss256k 栈大小
 */
public class StackOverFlowMock {
    private static int index = 1;

    public void call() {
        index++;
        call();
    }

    public static void main(String[] args) {
        StackOverFlowMock mock = new StackOverFlowMock();
        try {
            mock.call();
        } catch (Throwable e) {
            System.out.println(&quot;Stack deep : &quot; + index);
            e.printStackTrace();
        }
    }
}
</code></pre>

<h2 id="toc_3">本地方法栈</h2>

<p>与java虚拟机栈的作用相似，不同的是此块区域是为本地方(native)法服务的。<br/>
可引起OutOfMemoryError、StackOverFlowError</p>

<h2 id="toc_4">java堆内存</h2>

<p>java堆内存是所有线程共享的一块内存区域，用于存储对象的实例数据。在JVM启动的时候创建。Java堆空间只是在逻辑上是连续的，在物理上并不一定是连续的内存空间。堆所占内存的大小由-Xmx指令和-Xms指令来调节。</p>

<ul>
<li>线程共享区域</li>
<li>用于存放对象实例和数组</li>
<li>堆是java虚拟机管理的内存中最大的一块。</li>
<li>垃圾收集器的管理的主要区域,为了现在垃圾收集收集器都是采用分代收集算法，所以把堆细分为多个子区域：
<ul>
<li>新生代 <br/>
默认情况下，新生代中Eden空间与Survivor空间的比例是8:1,可以使用参数-XX:SurvivorRatio进行设置
<ul>
<li>伊甸区(eden)</li>
<li>from survivor</li>
<li>to survivor</li>
</ul></li>
<li>老年代  主要存放应用程序中生命周期长的内存对象</li>
</ul></li>
</ul>

<p>从分配内存的角度看的话，所有线程共享的java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）,可以提升对象分配时的效率。</p>

<p>可引起OutOfMemoryError异常</p>

<pre><code class="language-java">
/**
 * OOM 异常 -Xms5m -Xmx5m
 */
public class HeapOomMock {
    public static void main(String[] args) {
        List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;();
        int i = 0;
        boolean flag = true;
        while (flag) {
            try {
                i++;
                list.add(new byte[1024 * 1024]);//每次增加一个1M大小的数组对象
            } catch (Throwable e) {
                e.printStackTrace();
                flag = false;
                System.out.println(&quot;count=&quot; + i);//记录运行的次数
            }
        }
    }
}
</code></pre>

<h2 id="toc_5">方法区</h2>

<p>方法区是所有线程共享的一块内存区域，用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>

<p>jdk7之前采用永久代来实现，占用jvm的堆内存不说，还可能会OOM: PermGen space,<br/>
jdk8之后移除永久代而采用了元数据区（本地内存）来实现方法区，理论上来说，只要物理条件允许，这个区域要多大有多大。</p>

<h3 id="toc_6">元数据区</h3>

<p>元数据区是自jdk8才出现的一个新的内存区域用来取代之前的永久区，用本地内存来存储类元数据信息</p>

<p>可引起OutOfMemoryError异常：</p>

<pre><code class="language-java">import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;

/**
 * jdk8之前： -XX:PermSize=10M -XX:MaxPermSize=10M
 * jdk8及之后： -XX:MaxMetaspaceSize=20m
 *
 */
public class MetaSpaceMemory {
    public static void main(String[] args) {
        for (; ; ) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(MetaSpaceMemory.class);
            enhancer.setUseCache(false);
            enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));
            System.out.println(&quot;metaspace oom&quot;);
            enhancer.create();
        }
    }

    private Object person;

    public Object getPerson() {
        return person;
    }

    public void setPerson(Object person) {
        this.person = person;
    }

}
</code></pre>

<h2 id="toc_7">运行时常量池</h2>

<p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到运行时常量池中。</p>

<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。java语言并不要求常量一定只在编译器产生。</p>

<p>例如 String类的intern()方法就是在JVM运行期间将新的常量放入到常量池中。</p>

<p><strong>注意：</strong> jdk6之前字符串常量池是放在永久区中的，第一次创建字符串实例的时候讲字符串复制到常量池中，intern()返回常量池中的引用地址，而jdk6之后字符串常量池被移动到了java堆内存中,所以直接将字符串首次出现的引用地址记录到常量池就可以了，这是intern()方法返回的和堆中字符串实例是同一个引用地址。</p>

<p>可引起OutOfMemoryError异常：</p>

<pre><code class="language-java">/**
 * jdk1.6之前 -XX:PermSize=6M -XX:MaxPermSize=6M
 * jdk1.6之后 -Xmx6M
 **/
public class ConstantPoolOOMMock {

    public static void main(String[] args) {
        Set&lt;String&gt; stringSet = new HashSet&lt;&gt;();
        int i = 0;
        while (true) {
            stringSet.add(String.valueOf(i++).intern());
        }
    }
}
</code></pre>

<h2 id="toc_8">直接内存</h2>

<p><strong>直接内存不是虚拟机运行时数据区的一部分</strong><br/>
NIO 使用区域，基于管道(channel)与缓冲区(buffer)的IO方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在java堆里面的 DirectByteBuffer 作为这块直接内存的引用进行操作。使用直接内存避免了java堆与Native堆来回复制数据，一些场景下，能显著提高运行性能。</p>

<p>jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。见 sun.misc.Cleaner类</p>

<p>OOM异常：</p>

<pre><code class="language-java">/**
 * -XX:MaxDirectMemorySize=5M -Xmx20M
 **/
public class DirectMemoryOOMMock {
    private static final int _1MB = 1024*1024*10;
    public static void main(String[] args) throws IllegalAccessException {
        Field declaredField = Unsafe.class.getDeclaredFields()[0];
        declaredField.setAccessible(true);
        Unsafe unsafe = (Unsafe)declaredField.get(null);
        while (true)
            unsafe.allocateMemory(_1MB);
    }
}
</code></pre>

                  </article>
                  <div class="comments-wrap">
                    <div class="share-comments">
                      

                      

                      
                    </div>
                  </div><!-- end comments wrap -->
              </div>
            </div><!-- end columns -->
      </div><!-- end container -->
    </section>



    <footer class="footer">
        <div class="content has-text-centered">
          <p>
              Copyright &copy; 2019
              Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
              Theme used <a target="_blank" href="https://bulma.io/">Bulma CSS</a>.
          </p>
        </div>
      </footer>



  













<script src="asset/prism.js"></script>



  
    




  </body>
</html>
